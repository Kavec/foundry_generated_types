import fs from 'node:fs';
import { exec } from 'node:child_process';

import decompress from 'decompress';
import prompts from 'prompts';
import { glob } from 'glob';

async function runStep(message, op) {
    process.stdout.write(`${message}... `);
    const result = op();
    if (result instanceof Promise) {
        await result;
    }
    console.log('done!');
}

const localCacheDir = './.foundryvtt';
async function copyFoundryToCache() {
    if (fs.existsSync(localCacheDir)) {
        const { doBlast } = await prompts({
            type: 'confirm',
            name: 'doBlast',
            message: 'Cached files detected; blast \'em?'
        });

        if (!doBlast) return;

        await runStep(
            `Cleaning old cache files in ${localCacheDir}`,
            () => fs.rmSync(localCacheDir, { recursive: true, force: true }),
        );
    }

    const { linuxBuild } = await prompts({
        type: 'text',
        name: 'linuxBuild',
        message: 'Enter path to linux version build downloaded from FoundryVTT'
    });

    if (!fs.existsSync(linuxBuild)) {
        throw Exception(`Linux build not found at: ${linuxBuild}`);
    }

    if (fs.lstatSync(linuxBuild).isDirectory()) {
        // Has already been extracted, just need to copy
        await runStep(
            `Copying foundry VTT build to ${localCacheDir}`,
            () => {
                fs.cpSync(linuxBuild, localCacheDir, { recursive: true });
            }
        )
    } else {
        // Probably a zip file. Could stand to do more validation
        await runStep(
            `Extracting Foundry VTT build to ${localCacheDir}`,
            async () => {
                fs.mkdirSync(localCacheDir);
                await decompress(linuxBuildZip, localCacheDir);
            }
        );
    }
}


await copyFoundryToCache();

// The vendored Pixi code doesn't typecheck well, so to avoid type
// generation errors we nuke out the javascript code here and include
// type definitions via tsconfig.json & the usual package.json dependencies
const pixiPath = `${localCacheDir}/resources/app/client/pixi`;
if (fs.existsSync(pixiPath)) {
    await runStep(
        `Removing problematic vendored pixi code`,
        () => fs.rmSync(pixiPath, { recursive: true, force: true }),
    );
}

await runStep(
    `Generating type definitions via tsc`,
    async () => await new Promise((r) => exec(`pnpm tsc`, r)),
);


await runStep(
    `Wiring up reference types declarations into index.d.ts`,
    async () => {
        const typedefFiles = await glob('./types/**/*.d.ts');
        const refLines = typedefFiles.map(filename => `/// <reference path='./${filename}' />`);
        refLines.sort();

        fs.writeFileSync(`index.d.ts`, [
            '// WARNING: AUTOGENERATED FILE',
            '// Changes should be made to index.mjs rather than by hand',
            '',
            '// Apply fixup patches for things that are wonky-typed first',
            '/// <reference path=\'./fixups.d.ts\' />',
            '',
            ...refLines
        ].join('\n'));


    }
)

console.log(`\nHave a nice day!`);
