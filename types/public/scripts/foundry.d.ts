/** @module client */
/**
 * The string prefix used to prepend console logging
 * @type {string}
 */
declare function ClientPackageMixin(BasePackage: any): any;
/**
 * @typedef {Object} PackageCompatibilityBadge
 * @property {string} type        A type in "safe", "unsafe", "warning", "neutral" applied as a CSS class
 * @property {string} tooltip     A tooltip string displayed when hovering over the badge
 * @property {string} [label]     An optional text label displayed in the badge
 * @property {string} [icon]      An optional icon displayed in the badge
 */
/**
 * A client-side mixin used for all Package types.
 * @param {typeof BasePackage} BasePackage    The parent BasePackage class being mixed
 * @returns {typeof ClientPackage}            A BasePackage subclass mixed with ClientPackage features
 * @category - Mixins
 */
declare function ClientPackageMixin(BasePackage: any): any;
/** @module client */
/**
 * The string prefix used to prepend console logging
 * @type {string}
 */
declare function saveDataToFile(data: string, type: string, filename: string): void;
/**
 * Export data content to be saved to a local file
 * @param {string} data       Data content converted to a string
 * @param {string} type       The type of
 * @param {string} filename   The filename of the resulting download
 */
declare function saveDataToFile(data: string, type: string, filename: string): void;
declare function readTextFromFile(file: File): Promise<string>;
/**
 * Read text data from a user provided File object
 * @param {File} file           A File object
 * @return {Promise.<String>}   A Promise which resolves to the loaded text data
 */
declare function readTextFromFile(file: File): Promise<string>;
declare function fromUuid(uuid: string, options?: {
    relative?: Document;
    invalid?: boolean;
}): Promise<Document>;
/**
 * Retrieve a Document by its Universally Unique Identifier (uuid).
 * @param {string} uuid                      The uuid of the Document to retrieve.
 * @param {object} [options]                 Options to configure how a UUID is resolved.
 * @param {Document} [options.relative]      A Document to resolve relative UUIDs against.
 * @param {boolean} [options.invalid=false]  Allow retrieving an invalid Document.
 * @returns {Promise<Document|null>}         Returns the Document if it could be found, otherwise null.
 */
declare function fromUuid(uuid: string, options?: {
    relative?: Document;
    invalid?: boolean;
}): Promise<Document | null>;
declare function fromUuidSync(uuid: string, options?: {
    relative?: Document;
    invalid?: boolean;
    strict?: boolean;
}): any;
/**
 * Retrieve a Document by its Universally Unique Identifier (uuid) synchronously. If the uuid resolves to a compendium
 * document, that document's index entry will be returned instead.
 * @param {string} uuid                      The uuid of the Document to retrieve.
 * @param {object} [options]                 Options to configure how a UUID is resolved.
 * @param {Document} [options.relative]      A Document to resolve relative UUIDs against.
 * @param {boolean} [options.invalid=false]  Allow retrieving an invalid Document.
 * @param {boolean} [options.strict=true]    Throw an error if the UUID cannot be resolved synchronously.
 * @returns {Document|object|null}           The Document or its index entry if it resides in a Compendium, otherwise
 *                                           null.
 * @throws If the uuid resolves to a Document that cannot be retrieved synchronously, and the strict option is true.
 */
declare function fromUuidSync(uuid: string, options?: {
    relative?: Document;
    invalid?: boolean;
    strict?: boolean;
}): Document | object | null;
declare function _resolveEmbedded(parent: Document, parts: string[], { invalid }?: {
    invalid?: boolean;
}): Document;
/**
 * Resolve a series of embedded document UUID parts against a parent Document.
 * @param {Document} parent                  The parent Document.
 * @param {string[]} parts                   A series of Embedded Document UUID parts.
 * @param {object} [options]                 Additional options to configure Embedded Document resolution.
 * @param {boolean} [options.invalid=false]  Allow retrieving an invalid Embedded Document.
 * @returns {Document}                       The resolved Embedded Document.
 * @private
 */
declare function _resolveEmbedded(parent: Document, parts: string[], { invalid }?: {
    invalid?: boolean;
}): Document;
declare function getDocumentClass(documentName: string): {
    new (): Document;
    prototype: Document;
};
/**
 * Return a reference to the Document class implementation which is configured for use.
 * @param {string} documentName     The canonical Document name, for example "Actor"
 * @returns {typeof Document}       The configured Document class implementation
 */
declare function getDocumentClass(documentName: string): typeof Document;
declare function getTemplate(path: string, id?: string): Promise<Function>;
/**
 * Get a template from the server by fetch request and caching the retrieved result
 * @param {string} path           The web-accessible HTML template URL
 * @param {string} [id]           An ID to register the partial with.
 * @returns {Promise<Function>}   A Promise which resolves to the compiled Handlebars template
 */
declare function getTemplate(path: string, id?: string): Promise<Function>;
declare function loadTemplates(paths: any): Promise<Function[]>;
/**
 * Load and cache a set of templates by providing an Array of paths
 * @param {string[]|Object<string>} paths  An array of template file paths to load, or an object of Handlebars partial
 *                                         IDs to paths.
 * @returns {Promise<Function[]>}
 *
 * @example Loading a list of templates.
 * ```js
 * await loadTemplates(["templates/apps/foo.html", "templates/apps/bar.html"]);
 * ```
 * ```hbs
 * <!-- Include a pre-loaded template as a partial -->
 * {{> "templates/apps/foo.html" }}
 * ```
 *
 * @example Loading an object of templates.
 * ```js
 * await loadTemplates({
 *   foo: "templates/apps/foo.html",
 *   bar: "templates/apps/bar.html"
 * });
 * ```
 * ```hbs
 * <!-- Include a pre-loaded template as a partial -->
 * {{> foo }}
 * ```
 */
declare function loadTemplates(paths: string[] | any): Promise<Function[]>;
declare function renderTemplate(path: string, data: any): Promise<string>;
/**
 * Get and render a template using provided data and handle the returned HTML
 * Support asynchronous file template file loading with a client-side caching layer
 *
 * Allow resolution of prototype methods and properties since this all occurs within the safety of the client.
 * @see {@link https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access}
 *
 * @param {string} path             The file path to the target HTML template
 * @param {Object} data             A data object against which to compile the template
 *
 * @returns {Promise<string>}        Returns the compiled and rendered template as a string
 */
declare function renderTemplate(path: string, data: any): Promise<string>;
/** @module client */
/**
 * The string prefix used to prepend console logging
 * @type {string}
 */
declare function CanvasDocumentMixin(Base: any): any;
/**
 * A specialized subclass of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 * @param {typeof abstract.Document} Base     The base document class mixed with client and canvas features
 * @returns {typeof CanvasDocument}           The mixed CanvasDocument class definition
 */
declare function CanvasDocumentMixin(Base: any): any;
/** @module client */
/**
 * The string prefix used to prepend console logging
 * @type {string}
 */
declare function ClientDocumentMixin(Base: any): any;
/**
 * A mixin which extends each Document definition with specialized client-side behaviors.
 * This mixin defines the client-side interface for database operations and common document behaviors.
 * @param {typeof abstract.Document} Base     The base Document class to be mixed
 * @returns {typeof ClientDocument}           The mixed client-side document class definition
 * @category - Mixins
 * @mixin
 */
declare function ClientDocumentMixin(Base: any): any;
/** @module client */
/**
 * The string prefix used to prepend console logging
 * @type {string}
 */
declare function DirectoryCollectionMixin(BaseCollection: any): any;
/**
 * A mixin which adds directory functionality to a DocumentCollection, such as folders, tree structures, and sorting.
 * @param {typeof Collection} BaseCollection      The base collection class to extend
 * @returns {typeof DirectoryCollection}          A Collection mixed with DirectoryCollection functionality
 * @category - Mixins
 * @mixin
 */
declare function DirectoryCollectionMixin(BaseCollection: any): any;
/**
 * Test whether a file source exists by performing a HEAD request against it
 * @param {string} src          The source URL or path to test
 * @returns {Promise<boolean>}   Does the file exist at the provided url?
 */
declare function srcExists(src: string): Promise<boolean>;
/**
 * Get a single texture or sprite sheet from the cache.
 * @param {string} src                            The texture path to load.
 * @returns {PIXI.Texture|PIXI.Spritesheet|null}  A texture, a sprite sheet or null if not found in cache.
 */
declare function getTexture(src: string): PIXI.Texture | PIXI.Spritesheet | null;
/**
 * Load a single asset and return a Promise which resolves once the asset is ready to use
 * @param {string} src                           The requested asset source
 * @param {object} [options]                     Additional options which modify asset loading
 * @param {string} [options.fallback]            A fallback texture URL to use if the requested source is unavailable
 * @returns {PIXI.Texture|PIXI.Spritesheet|null} The loaded Texture or sprite sheet,
 *                                               or null if loading failed with no fallback
 */
declare function loadTexture(src: string, { fallback }?: {
    fallback?: string;
}): PIXI.Texture | PIXI.Spritesheet | null;
/**
 * Augment any PIXI.DisplayObject to assume bounds that are always aligned with the full visible screen.
 * The bounds of this container do not depend on its children but always fill the entire canvas.
 * @param {typeof PIXI.DisplayObject} Base    Any PIXI DisplayObject subclass
 * @returns {typeof FullCanvasObject}         The decorated subclass with full canvas bounds
 */
declare function FullCanvasObjectMixin(Base: any): any;
/**
 * Add RenderFlags functionality to some other object.
 * This mixin standardizes the interface for such functionality.
 * @param {typeof PIXI.DisplayObject} Base      The base class being mixed
 * @returns {typeof RenderFlagObject}           The mixed class definition
 */
declare function RenderFlagsMixin(Base: any): any;
/**
 * A mixin which decorates a DisplayObject with depth and/or occlusion properties.
 * @category - Mixins
 * @param {typeof PIXI.DisplayObject} DisplayObject   The parent DisplayObject class being mixed
 * @returns {typeof OccludableObject}                 A DisplayObject subclass mixed with OccludableObject features
 */
declare function OccludableObjectMixin(DisplayObject: any): any;
/**
 * A mixin which decorates a DisplayObject with additional properties expected for rendering in the PrimaryCanvasGroup.
 * @category - Mixins
 * @param {typeof PIXI.DisplayObject} DisplayObject   The parent DisplayObject class being mixed
 * @returns {typeof PrimaryCanvasObject}              A DisplayObject subclass mixed with PrimaryCanvasObject features
 */
declare function PrimaryCanvasObjectMixin(DisplayObject: any): any;
/** @module client */
/**
 * The string prefix used to prepend console logging
 * @type {string}
 */
declare function DirectoryApplicationMixin(Base: typeof Application): any;
/**
 * @typedef {Object} DirectoryMixinEntry
 * @property {string} id                The unique id of the entry
 * @property {Folder|string} folder     The folder id or folder object to which this entry belongs
 * @property {string} [img]             An image path to display for the entry
 * @property {string} [sort]            A numeric sort value which orders this entry relative to others
 * @interface
 */
/**
 * Augment an Application instance with functionality that supports rendering as a directory of foldered entries.
 * @param {typeof Application} Base           The base Application class definition
 * @returns {typeof DirectoryApplication}     The decorated DirectoryApplication class definition
 */
declare function DirectoryApplicationMixin(Base: typeof Application): any;
/** @module client */
/**
 * The string prefix used to prepend console logging
 * @type {string}
 */
declare const vtt: string;
/**
 * The singleton Game instance
 * @type {Game}
 */
declare let game: Game;
/**
 * A helper class to manage requesting clipboard permissions and provide common functionality for working with the
 * clipboard.
 */
declare class ClipboardHelper {
    /**
     * Copies plain text to the clipboard in a cross-browser compatible way.
     * @param {string} text  The text to copy.
     * @returns {Promise<void>}
     */
    copyPlainText(text: string): Promise<void>;
}
/**
 * A data structure for quickly retrieving objects by a string prefix.
 * Note that this works well for languages with alphabets (latin, cyrillic, korean, etc.), but may need more nuanced
 * handling for languages that compose characters and letters.
 */
declare class WordTree {
    /**
     * Create a new node.
     * @returns {WordTreeNode}
     */
    get node(): {
        /**
         * Any leaves at this node.
         */
        leaves: {
            /**
             * An object that this entry represents.
             */
            entry: any;
            /**
             * The document type.
             */
            documentName: string;
            /**
             * The document's UUID.
             */
            uuid: string;
            /**
             * The pack ID.
             */
            pack?: string;
        }[];
    };
    /**
     * Insert an entry into the tree.
     * @param {string} string        The string key for the entry.
     * @param {WordTreeEntry} entry  The entry to store.
     * @returns {WordTreeNode}       The node the entry was added to.
     */
    addLeaf(string: string, entry: {
        /**
         * An object that this entry represents.
         */
        entry: any;
        /**
         * The document type.
         */
        documentName: string;
        /**
         * The document's UUID.
         */
        uuid: string;
        /**
         * The pack ID.
         */
        pack?: string;
    }): {
        /**
         * Any leaves at this node.
         */
        leaves: {
            /**
             * An object that this entry represents.
             */
            entry: any;
            /**
             * The document type.
             */
            documentName: string;
            /**
             * The document's UUID.
             */
            uuid: string;
            /**
             * The pack ID.
             */
            pack?: string;
        }[];
    };
    /**
     * Return entries that match the given string prefix.
     * @param {string} prefix              The prefix.
     * @param {object} [options]           Additional options to configure behaviour.
     * @param {number} [options.limit=10]  The maximum number of items to retrieve. It is important to set this value as
     *                                     very short prefixes will naturally match large numbers of entries.
     * @returns {WordTreeEntry[]}          A number of entries that have the given prefix.
     */
    lookup(prefix: string, { limit }?: {
        limit?: number;
    }): {
        /**
         * An object that this entry represents.
         */
        entry: any;
        /**
         * The document type.
         */
        documentName: string;
        /**
         * The document's UUID.
         */
        uuid: string;
        /**
         * The pack ID.
         */
        pack?: string;
    }[];
    /**
     * Returns the node at the given prefix.
     * @param {string} prefix  The prefix.
     * @returns {WordTreeNode}
     */
    nodeAtPrefix(prefix: string): {
        /**
         * Any leaves at this node.
         */
        leaves: {
            /**
             * An object that this entry represents.
             */
            entry: any;
            /**
             * The document type.
             */
            documentName: string;
            /**
             * The document's UUID.
             */
            uuid: string;
            /**
             * The pack ID.
             */
            pack?: string;
        }[];
    };
    /**
     * Perform a breadth-first search starting from the given node and retrieving any entries along the way, until we
     * reach the limit.
     * @param {WordTreeNode} node          The starting node.
     * @param {WordTreeEntry[]} entries    The accumulated entries.
     * @param {WordTreeNode[]} queue       The working queue of nodes to search.
     * @param {object} [options]           Additional options for the search.
     * @param {number} [options.limit=10]  The maximum number of entries to retrieve before stopping.
     * @protected
     */
    protected _breadthFirstSearch(node: {
        /**
         * Any leaves at this node.
         */
        leaves: {
            /**
             * An object that this entry represents.
             */
            entry: any;
            /**
             * The document type.
             */
            documentName: string;
            /**
             * The document's UUID.
             */
            uuid: string;
            /**
             * The pack ID.
             */
            pack?: string;
        }[];
    }, entries: {
        /**
         * An object that this entry represents.
         */
        entry: any;
        /**
         * The document type.
         */
        documentName: string;
        /**
         * The document's UUID.
         */
        uuid: string;
        /**
         * The pack ID.
         */
        pack?: string;
    }[], queue: {
        /**
         * Any leaves at this node.
         */
        leaves: {
            /**
             * An object that this entry represents.
             */
            entry: any;
            /**
             * The document type.
             */
            documentName: string;
            /**
             * The document's UUID.
             */
            uuid: string;
            /**
             * The pack ID.
             */
            pack?: string;
        }[];
    }[], { limit }?: {
        limit?: number;
    }): void;
    #private;
}
/**
 * This class is responsible for indexing all documents available in the world and storing them in a word tree structure
 * that allows for fast searching.
 */
declare class DocumentIndex {
    /**
     * Returns a Promise that resolves when the indexing process is complete.
     * @returns {Promise<void>|null}
     */
    get ready(): Promise<void>;
    /**
     * Index all available documents in the world and store them in a word tree.
     * @returns {Promise<void>}
     */
    index(): Promise<void>;
    /**
     * Return entries that match the given string prefix.
     * @param {string} prefix                     The prefix.
     * @param {object} [options]                  Additional options to configure behaviour.
     * @param {string[]} [options.documentTypes]  Optionally provide an array of document types. Only entries of that type
     *                                            will be searched for.
     * @param {number} [options.limit=10]         The maximum number of items per document type to retrieve. It is
     *                                            important to set this value as very short prefixes will naturally match
     *                                            large numbers of entries.
     * @returns {Object<WordTreeEntry[]>}         A number of entries that have the given prefix, grouped by document
     *                                            type.
     */
    lookup(prefix: string, { limit, documentTypes }?: {
        documentTypes?: string[];
        limit?: number;
    }): any;
    /**
     * Add an entry to the index.
     * @param {Document} doc  The document entry.
     */
    addDocument(doc: Document): void;
    /**
     * Remove an entry from the index.
     * @param {Document} doc  The document entry.
     */
    removeDocument(doc: Document): void;
    /**
     * Replace an entry in the index with an updated one.
     * @param {Document} doc  The document entry.
     */
    replaceDocument(doc: Document): void;
    /**
     * Add a leaf node to the word tree index.
     * @param {Document|object} doc                  The document or compendium index entry to add.
     * @param {object} [options]                     Additional information for indexing.
     * @param {CompendiumCollection} [options.pack]  The compendium that the index belongs to.
     * @protected
     */
    protected _addLeaf(doc: Document | object, { pack }?: {
        pack?: CompendiumCollection;
    }): void;
    /**
     * Aggregate the compendium index and add it to the word tree index.
     * @param {CompendiumCollection} pack  The compendium pack.
     * @protected
     */
    protected _indexCompendium(pack: CompendiumCollection): void;
    /**
     * Add all of a parent document's embedded documents to the index.
     * @param {Document} parent  The parent document.
     * @protected
     */
    protected _indexEmbeddedDocuments(parent: Document): void;
    /**
     * Aggregate all documents and embedded documents in a world collection and add them to the index.
     * @param {string} documentName  The name of the documents to index.
     * @protected
     */
    protected _indexWorldCollection(documentName: string): void;
    #private;
}
/**
 * Management class for Gamepad events
 */
declare class GamepadManager {
    /**
     * How often Gamepad polling should check for button presses
     * @type {number}
     */
    static GAMEPAD_POLLER_INTERVAL_MS: number;
    _gamepadPoller: NodeJS.Timeout;
    /**
     * The connected Gamepads
     * @type {Map<string, ConnectedGamepad>}
     * @private
     */
    private _connectedGamepads;
    /**
     * Begin listening to gamepad events.
     * @internal
     */
    _activateListeners(): void;
    /**
     * Handles a Gamepad Connection event, adding its info to the poll list
     * @param {GamepadEvent} event The originating Event
     * @private
     */
    private _onGamepadConnect;
    /**
     * Handles a Gamepad Disconnect event, removing it from consideration for polling
     * @param {GamepadEvent} event The originating Event
     * @private
     */
    private _onGamepadDisconnect;
    /**
     * Polls all Connected Gamepads for updates. If they have been updated, checks status of Axis and Buttons,
     * firing off Keybinding Contexts as appropriate
     * @private
     */
    private _pollGamepads;
    /**
     * Converts a Gamepad Input event into a KeyboardEvent, then fires it
     * @param {string} gamepadId  The string representation of the Gamepad Input
     * @param {boolean} up        True if the Input is pressed or active
     * @param {boolean} repeat    True if the Input is being held
     * @private
     */
    private _handleGamepadInput;
}
/**
 * @typedef {object} HookedFunction
 * @property {string} hook
 * @property {number} id
 * @property {Function} fn
 * @property {boolean} once
 */
/**
 * A simple event framework used throughout Foundry Virtual Tabletop.
 * When key actions or events occur, a "hook" is defined where user-defined callback functions can execute.
 * This class manages the registration and execution of hooked callback functions.
 */
declare class Hooks {
    static get events(): any;
    private static "__#49@#events";
    static "__#49@#ids": Map<number, HookedFunction>;
    static "__#49@#id": number;
    static on(hook: string, fn: Function, { once }?: {
        once: boolean;
    }): number;
    /**
     * Register a callback handler which should be triggered when a hook is triggered.
     * @param {string} hook     The unique name of the hooked event
     * @param {Function} fn     The callback function which should be triggered when the hook event occurs
     * @param {object} options  Options which customize hook registration
     * @param {boolean} options.once  Only trigger the hooked function once
     * @returns {number}      An ID number of the hooked function which can be used to turn off the hook later
     */
    static on(hook: string, fn: Function, { once }?: {
        once: boolean;
    }): number;
    static once(hook: string, fn: Function): number;
    /**
     * Register a callback handler for an event which is only triggered once the first time the event occurs.
     * An alias for Hooks.on with {once: true}
     * @param {string} hook   The unique name of the hooked event
     * @param {Function} fn   The callback function which should be triggered when the hook event occurs
     * @returns {number}      An ID number of the hooked function which can be used to turn off the hook later
     */
    static once(hook: string, fn: Function): number;
    static off(hook: string, fn: number | Function): void;
    /**
     * Unregister a callback handler for a particular hook event
     * @param {string} hook           The unique name of the hooked event
     * @param {Function|number} fn    The function, or ID number for the function, that should be turned off
     */
    static off(hook: string, fn: Function | number): void;
    static callAll(hook: string, ...args: any[]): boolean;
    /**
     * Call all hook listeners in the order in which they were registered
     * Hooks called this way can not be handled by returning false and will always trigger every hook callback.
     *
     * @param {string} hook   The hook being triggered
     * @param {...*} args     Arguments passed to the hook callback functions
     * @returns {boolean}     Were all hooks called without execution being prevented?
     */
    static callAll(hook: string, ...args: any[]): boolean;
    static call(hook: string, ...args: any[]): boolean;
    /**
     * Call hook listeners in the order in which they were registered.
     * Continue calling hooks until either all have been called or one returns false.
     *
     * Hook listeners which return false denote that the original event has been adequately handled and no further
     * hooks should be called.
     *
     * @param {string} hook   The hook being triggered
     * @param {...*} args     Arguments passed to the hook callback functions
     * @returns {boolean}     Were all hooks called without execution being prevented?
     */
    static call(hook: string, ...args: any[]): boolean;
    private static "__#49@#call";
    static onError(location: string, error: Error, { msg, notify, log, ...data }?: {
        msg?: string;
        log?: string;
        notify?: string;
        data?: any;
    }): void;
    /**
     * Notify subscribers that an error has occurred within foundry.
     * @param {string} location                The method where the error was caught.
     * @param {Error} error                    The error.
     * @param {object} [options={}]            Additional options to configure behaviour.
     * @param {string} [options.msg=""]        A message which should prefix the resulting error or notification.
     * @param {?string} [options.log=null]     The level at which to log the error to console (if at all).
     * @param {?string} [options.notify=null]  The level at which to spawn a notification in the UI (if at all).
     * @param {object} [options.data={}]       Additional data to pass to the hook subscribers.
     */
    static onError(location: string, error: Error, { msg, notify, log, ...data }?: {
        msg?: string;
        log?: string | null;
        notify?: string | null;
        data?: object;
    }): void;
    /**
     * @type {Object<HookedFunction[]>}
     * @private
     * @ignore
     */
    private static "__#109@#events";
    /**
     * A mapping of hooked functions by their assigned ID
     * @type {Map<number, HookedFunction>}
     */
    static "__#109@#ids": Map<number, HookedFunction>;
    /**
     * An incrementing counter for assigned hooked function IDs
     * @type {number}
     */
    static "__#109@#id": number;
    /**
     * Call a hooked function using provided arguments and perhaps unregister it.
     * @param {HookedFunction} entry    The hooked function entry
     * @param {any[]} args              Arguments to be passed
     * @private
     */
    private static "__#109@#call";
}
/**
 * A helper class to provide common functionality for working with Image objects
 */
declare class ImageHelper {
    /**
     * Create thumbnail preview for a provided image path.
     * @param {string|PIXI.DisplayObject} src   The URL or display object of the texture to render to a thumbnail
     * @param {object} options    Additional named options passed to the compositeCanvasTexture function
     * @param {number} [options.width]        The desired width of the resulting thumbnail
     * @param {number} [options.height]       The desired height of the resulting thumbnail
     * @param {number} [options.tx]           A horizontal transformation to apply to the provided source
     * @param {number} [options.ty]           A vertical transformation to apply to the provided source
     * @param {boolean} [options.center]      Whether to center the object within the thumbnail
     * @param {string} [options.format]       The desired output image format
     * @param {number} [options.quality]      The desired output image quality
     * @returns {Promise<object>}  The parsed and converted thumbnail data
     */
    static createThumbnail(src: string | PIXI.DisplayObject, { width, height, tx, ty, center, format, quality }: {
        width?: number;
        height?: number;
        tx?: number;
        ty?: number;
        center?: boolean;
        format?: string;
        quality?: number;
    }): Promise<object>;
    /**
     * Test whether a source file has a supported image extension type
     * @param {string} src      A requested image source path
     * @returns {boolean}       Does the filename end with a valid image extension?
     */
    static hasImageExtension(src: string): boolean;
    /**
     * Composite a canvas object by rendering it to a single texture
     *
     * @param {PIXI.DisplayObject} object   The object to render to a texture
     * @param {object} [options]            Options which configure the resulting texture
     * @param {number} [options.width]        The desired width of the output texture
     * @param {number} [options.height]       The desired height of the output texture
     * @param {number} [options.tx]           A horizontal translation to apply to the object
     * @param {number} [options.ty]           A vertical translation to apply to the object
     * @param {boolean} [options.center]      Center the texture in the rendered frame?
     *
     * @returns {PIXI.Texture}              The composite Texture object
     */
    static compositeCanvasTexture(object: PIXI.DisplayObject, { width, height, tx, ty, center }?: {
        width?: number;
        height?: number;
        tx?: number;
        ty?: number;
        center?: boolean;
    }): PIXI.Texture;
    /**
     * Extract a texture to a base64 PNG string
     * @param {PIXI.Texture} texture      The texture object to extract
     * @param {object} options
     * @param {string} [options.format]   Image format, e.g. "image/jpeg" or "image/webp".
     * @param {number} [options.quality]  JPEG or WEBP compression from 0 to 1. Default is 0.92.
     * @returns {Promise<string>}         A base64 png string of the texture
     */
    static textureToImage(texture: PIXI.Texture, { format, quality }?: {
        format?: string;
        quality?: number;
    }): Promise<string>;
    /**
     * Asynchronously convert a DisplayObject container to base64 using Canvas#toBlob and FileReader
     * @param {PIXI.DisplayObject} target     A PIXI display object to convert
     * @param {string} type                   The requested mime type of the output, default is image/png
     * @param {number} quality                A number between 0 and 1 for image quality if image/jpeg or image/webp
     * @returns {Promise<string>}             A processed base64 string
     */
    static pixiToBase64(target: PIXI.DisplayObject, type: string, quality: number): Promise<string>;
    /**
     * Asynchronously convert a canvas element to base64.
     * @param {HTMLCanvasElement} canvas
     * @param {string} [type="image/png"]
     * @param {number} [quality]
     * @returns {Promise<string>} The base64 string of the canvas.
     */
    static canvasToBase64(canvas: HTMLCanvasElement, type?: string, quality?: number): Promise<string>;
    /**
     * Upload a base64 image string to a persisted data storage location
     * @param {string} base64       The base64 string
     * @param {string} fileName     The file name to upload
     * @param {string} filePath     The file path where the file should be uploaded
     * @param {object} [options]    Additional options which affect uploading
     * @param {string} [options.storage=data]   The data storage location to which the file should be uploaded
     * @param {string} [options.type]           The MIME type of the file being uploaded
     * @param {boolean} [options.notify=true]   Display a UI notification when the upload is processed.
     * @returns {Promise<object>}   A promise which resolves to the FilePicker upload response
     */
    static uploadBase64(base64: string, fileName: string, filePath: string, { storage, type, notify }?: {
        storage?: string;
        type?: string;
        notify?: boolean;
    }): Promise<object>;
    /**
     * Create a canvas element containing the pixel data.
     * @param {Uint8ClampedArray} pixels              Buffer used to create the image data.
     * @param {number} width                          Buffered image width.
     * @param {number} height                         Buffered image height.
     * @param {object} options
     * @param {HTMLCanvasElement} [options.element]   The element to use.
     * @param {number} [options.ew]                   Specified width for the element (default to buffer image width).
     * @param {number} [options.eh]                   Specified height for the element (default to buffer image height).
     * @returns {HTMLCanvasElement}
     */
    static pixelsToCanvas(pixels: Uint8ClampedArray, width: number, height: number, { element, ew, eh }?: {
        element?: HTMLCanvasElement;
        ew?: number;
        eh?: number;
    }): HTMLCanvasElement;
}
/**
 * An object structure of document types at the top level, with a count of different sub-types for that document type.
 * @typedef {Object<Object<number>>} ModuleSubTypeCounts
 */
/**
 * A class responsible for tracking issues in the current world.
 */
declare class ClientIssues {
    /**
     * The minimum supported resolution.
     * @type {{WIDTH: number, HEIGHT: number}}
     */
    static "__#110@#MIN_RESOLUTION": {
        WIDTH: number;
        HEIGHT: number;
    };
    /**
     * @typedef {object} BrowserTest
     * @property {number} minimum  The minimum supported version for this browser.
     * @property {RegExp} match    A regular expression to match the browser against the user agent string.
     * @property {string} message  A message to display if the user's browser version does not meet the minimum.
     */
    /**
     * The minimum supported client versions.
     * @type {Object<BrowserTest>}
     */
    static "__#110@#BROWSER_TESTS": any;
    /**
     * Detect and display warnings for known performance issues which may occur due to the user's hardware or browser
     * configuration.
     * @internal
     */
    _detectWebGLIssues(): void;
    /**
     * Add an invalid Document to the module-provided sub-type counts.
     * @param {string} documentName                The Document name.
     * @param {object} source                      The Document's source data.
     * @param {object} [options]
     * @param {boolean} [options.decrement=false]  Decrement the counter rather than incrementing it.
     * @internal
     */
    _countDocumentSubType(documentName: string, source: object, options?: {
        decrement?: boolean;
    }): void;
    /**
     * Track a validation failure that occurred in a WorldCollection.
     * @param {WorldCollection} collection      The parent collection.
     * @param {object} source                   The Document's source data.
     * @param {DataModelValidationError} error  The validation error.
     * @internal
     */
    _trackValidationFailure(collection: WorldCollection, source: object, error: DataModelValidationError): void;
    /**
     * Detect and record certain usability error messages which are likely to result in the user having a bad experience.
     * @internal
     */
    _detectUsabilityIssues(): void;
    /**
     * Get the Document sub-type counts for a given module.
     * @param {Module|string} module  The module or its ID.
     * @returns {ModuleSubTypeCounts}
     */
    getSubTypeCountsFor(module: Module | string): ModuleSubTypeCounts;
    /**
     * Retrieve all sub-type counts in the world.
     * @returns {Iterator<string, ModuleSubTypeCounts>}
     */
    getAllSubTypeCounts(): Iterator<string, ModuleSubTypeCounts>;
    /**
     * Retrieve the tracked validation failures.
     * @returns {object}
     */
    get validationFailures(): any;
    /**
     * Retrieve the tracked usability issues.
     * @returns {Object<UsabilityIssue>}
     */
    get usabilityIssues(): any;
    /**
     * @typedef {object} PackageCompatibilityIssue
     * @property {string[]} error    Error messages.
     * @property {string[]} warning  Warning messages.
     */
    /**
     * Retrieve package compatibility issues.
     * @returns {Object<PackageCompatibilityIssue>}
     */
    get packageCompatibilityIssues(): any;
    #private;
}
/**
 * A class responsible for managing defined game keybinding.
 * Each keybinding is a string key/value pair belonging to a certain namespace and a certain store scope.
 *
 * When Foundry Virtual Tabletop is initialized, a singleton instance of this class is constructed within the global
 * Game object as as game.keybindings.
 *
 * @see {@link Game#keybindings}
 * @see {@link SettingKeybindingConfig}
 * @see {@link KeybindingsConfig}
 */
declare class ClientKeybindings {
    static MOVEMENT_DIRECTIONS: {
        UP: string;
        LEFT: string;
        DOWN: string;
        RIGHT: string;
    };
    static ZOOM_DIRECTIONS: {
        IN: string;
        OUT: string;
    };
    /**
     * A helper method that, when given a value, ensures that the returned value is a standardized Binding array
     * @param {KeybindingActionBinding[]} values  An array of keybinding assignments to be validated
     * @returns {KeybindingActionBinding[]}       An array of keybinding assignments confirmed as valid
     * @private
     */
    private static _validateBindings;
    /**
     * Validate that assigned modifiers are allowed
     * @param {string[]} keys           An array of modifiers which may be valid
     * @returns {string[]}              An array of modifiers which are confirmed as valid
     * @private
     */
    private static _validateModifiers;
    /**
     * Compares two Keybinding Actions based on their Order
     * @param {KeybindingAction} a   The first Keybinding Action
     * @param {KeybindingAction} b   the second Keybinding Action
     * @returns {number}
     * @internal
     */
    static _compareActions(a: KeybindingAction, b: KeybindingAction): number;
    /**
     * Handle Select all action
     * @param {KeyboardEvent} event             The originating keyboard event
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onSelectAllObjects;
    /**
     * Handle Cycle View actions
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onCycleView;
    /**
     * Handle Dismiss actions
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onDismiss;
    /**
     * Open Character sheet for current token or controlled actor
     * @param {KeyboardEvent} event             The initiating keyboard event
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onToggleCharacterSheet;
    /**
     * Handle action to target the currently hovered token.
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onTarget;
    /**
     * Handle DELETE Keypress Events
     * @param {KeyboardEvent} event             The originating keyboard event
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onDelete;
    /**
     * Handle Measured Ruler Movement Action
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onMeasuredRulerMovement;
    /**
     * Handle Pause Action
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onPause;
    /**
     * Handle Highlight action
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onHighlight;
    /**
     * Handle Macro executions
     * @param {KeyboardEventContext} context  The context data of the event
     * @param {number} number                 The numbered macro slot to execute
     * @private
     */
    private static _onMacroExecute;
    /**
     * Handle Macro page swaps
     * @param {KeyboardEventContext} context    The context data of the event
     * @param {number} page                     The numbered macro page to activate
     * @private
     */
    private static _onMacroPageSwap;
    /**
     * Handle action to copy data to clipboard
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onCopy;
    /**
     * Handle Paste action
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onPaste;
    /**
     * Handle Undo action
     * @param {KeyboardEventContext} context    The context data of the event
     * @private
     */
    private static _onUndo;
    /**
     * Handle presses to keyboard zoom keys
     * @param {KeyboardEventContext} context                    The context data of the event
     * @param {ClientKeybindings.ZOOM_DIRECTIONS} zoomDirection The direction to zoom
     * @private
     */
    private static _onZoom;
    /**
     * Bring the chat window into view and focus the input
     * @param {KeyboardEventContext} context    The context data of the event
     * @returns {boolean}
     * @private
     */
    private static _onFocusChat;
    /**
     * Registered Keybinding actions
     * @type {Map<string, KeybindingActionConfig>}
     */
    actions: Map<string, KeybindingActionConfig>;
    /**
     * A mapping of a string key to possible Actions that might execute off it
     * @type {Map<string, KeybindingAction[]>}
     */
    activeKeys: Map<string, KeybindingAction[]>;
    /**
     * A stored cache of Keybind Actions Ids to Bindings
     * @type {Map<string, KeybindingActionBinding[]>}
     */
    bindings: Map<string, KeybindingActionBinding[]>;
    /**
     * A count of how many registered keybindings there are
     * @type {number}
     * @private
     */
    private _registered;
    /**
     * A timestamp which tracks the last time a pan operation was performed
     * @type {number}
     * @private
     */
    private _moveTime;
    /**
     * An alias of the movement key set tracked by the keyboard
     * @returns {Set<string>}>
     */
    get moveKeys(): Set<string>;
    /**
     * Initializes the keybinding values for all registered actions
     */
    initialize(): void;
    /**
     * Register a new keybinding
     *
     * @param {string} namespace                  The namespace the Keybinding Action belongs to
     * @param {string} action                     A unique machine-readable id for the Keybinding Action
     * @param {KeybindingActionConfig} data       Configuration for keybinding data
     *
     * @example Define a keybinding which shows a notification
     * ```js
     * game.keybindings.register("myModule", "showNotification", {
     *   name: "My Settings Keybinding",
     *   hint: "A description of what will occur when the Keybinding is executed.",
     *   uneditable: [
     *     {
     *       key: "Digit1",
     *       modifiers: ["Control"]
     *     }
     *   ],
     *   editable: [
     *     {
     *       key: "F1"
     *     }
     *   ],
     *   onDown: () => { ui.notifications.info("Pressed!") },
     *   onUp: () => {},
     *   restricted: true,             // Restrict this Keybinding to gamemaster only?
     *   reservedModifiers: ["Alt""],  // On ALT, the notification is permanent instead of temporary
     *   precedence: CONST.KEYBINDING_PRECEDENCE.NORMAL
     * }
     * ```
     */
    register(namespace: string, action: string, data: KeybindingActionConfig): void;
    /**
     * Get the current Bindings of a given namespace's Keybinding Action
     *
     * @param {string} namespace   The namespace under which the setting is registered
     * @param {string} action      The keybind action to retrieve
     * @returns {KeybindingActionBinding[]}
     *
     * @example Retrieve the current Keybinding Action Bindings
     * ```js
     * game.keybindings.get("myModule", "showNotification");
     * ```
     */
    get(namespace: string, action: string): KeybindingActionBinding[];
    /**
     * Set the editable Bindings of a Keybinding Action for a certain namespace and Action
     *
     * @param {string} namespace                    The namespace under which the Keybinding is registered
     * @param {string} action                       The Keybinding action to set
     * @param {KeybindingActionBinding[]} bindings  The Bindings to assign to the Keybinding
     *
     * @example Update the current value of a keybinding
     * ```js
     * game.keybindings.set("myModule", "showNotification", [
     *     {
     *       key: "F2",
     *       modifiers: [ "CONTROL" ]
     *     }
     * ]);
     * ```
     */
    set(namespace: string, action: string, bindings: KeybindingActionBinding[]): Promise<any>;
    /**
     * Reset all client keybindings back to their default configuration.
     */
    resetDefaults(): Promise<any>;
    /**
     * Register core keybindings
     */
    _registerCoreKeybindings(): void;
    /**
     * Handle keyboard movement once a small delay has elapsed to allow for multiple simultaneous key-presses.
     * @param {KeyboardEventContext} context        The context data of the event
     * @param {InteractionLayer} layer              The active InteractionLayer instance
     * @private
     */
    private _handleMovement;
    /**
     * Handle panning the canvas using CTRL + directional keys
     */
    _handleCanvasPan(): any;
    /**
     * Handle Pan action
     * @param {KeyboardEventContext} context          The context data of the event
     * @param {string[]} movementDirections           The Directions being panned in
     * @private
     */
    private _onPan;
}
/**
 * A set of helpers and management functions for dealing with user input from keyboard events.
 * {@link https://keycode.info/}
 */
declare class KeyboardManager {
    /**
     * Allowed modifier keys
     * @enum {string}
     */
    static MODIFIER_KEYS: {
        CONTROL: string;
        SHIFT: string;
        ALT: string;
    };
    /**
     * Track which KeyboardEvent#code presses associate with each modifier
     * @enum {string[]}
     */
    static MODIFIER_CODES: {
        [x: string]: string[];
    };
    /**
     * Key codes which are "protected" and should not be used because they are reserved for browser-level actions.
     * @type {string[]}
     */
    static PROTECTED_KEYS: string[];
    /**
     * The OS-specific string display for what their Command key is
     * @type {string}
     */
    static CONTROL_KEY_STRING: string;
    /**
     * An special mapping of how special KeyboardEvent#code values should map to displayed strings or symbols.
     * Values in this configuration object override any other display formatting rules which may be applied.
     * @type {Object<string, string>}
     */
    static KEYCODE_DISPLAY_MAPPING: {
        [x: string]: string;
    };
    /**
     * Emulates a key being pressed, triggering the Keyboard event workflow.
     * @param {boolean} up                        If True, emulates the `keyup` Event. Else, the `keydown` event
     * @param {string} code                       The KeyboardEvent#code which is being pressed
     * @param {object} [options]                  Additional options to configure behavior.
     * @param {boolean} [options.altKey=false]    Emulate the ALT modifier as pressed
     * @param {boolean} [options.ctrlKey=false]   Emulate the CONTROL modifier as pressed
     * @param {boolean} [options.shiftKey=false]  Emulate the SHIFT modifier as pressed
     * @param {boolean} [options.repeat=false]    Emulate this as a repeat event
     * @param {boolean} [options.force=false]     Force the event to be handled.
     * @returns {KeyboardEventContext}
     */
    static emulateKeypress(up: boolean, code: string, { altKey, ctrlKey, shiftKey, repeat, force }?: {
        altKey?: boolean;
        ctrlKey?: boolean;
        shiftKey?: boolean;
        repeat?: boolean;
        force?: boolean;
    }): KeyboardEventContext;
    /**
     * Format a KeyboardEvent#code into a displayed string.
     * @param {string} code       The input code
     * @returns {string}          The displayed string for this code
     */
    static getKeycodeDisplayString(code: string): string;
    /**
     * Get a standardized keyboard context for a given event.
     * Every individual keypress is uniquely identified using the KeyboardEvent#code property.
     * A list of possible key codes is documented here: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values
     *
     * @param {KeyboardEvent} event   The originating keypress event
     * @param {boolean} up            A flag for whether the key is down or up
     * @return {KeyboardEventContext} The standardized context of the event
     */
    static getKeyboardEventContext(event: KeyboardEvent, up?: boolean): KeyboardEventContext;
    /**
     * Converts a Keyboard Context event into a string representation, such as "C" or "Control+C"
     * @param {KeyboardEventContext} context  The standardized context of the event
     * @param {boolean} includeModifiers      If True, includes modifiers in the string representation
     * @return {string}
     * @private
     */
    private static _getContextDisplayString;
    /**
     * Given a standardized pressed key, find all matching registered Keybind Actions.
     * @param {KeyboardEventContext} context  A standardized keyboard event context
     * @return {KeybindingAction[]}           The matched Keybind Actions. May be empty.
     * @internal
     */
    static _getMatchingActions(context: KeyboardEventContext): KeybindingAction[];
    /**
     * Test whether a keypress context matches the registration for a keybinding action
     * @param {KeybindingAction} action             The keybinding action
     * @param {KeyboardEventContext} context        The keyboard event context
     * @returns {boolean}                           Does the context match the action requirements?
     * @private
     */
    private static _testContext;
    /**
     * Given a registered Keybinding Action, executes the action with a given event and context
     *
     * @param {KeybindingAction} keybind         The registered Keybinding action to execute
     * @param {KeyboardEventContext} context     The gathered context of the event
     * @return {boolean}                         Returns true if the keybind was consumed
     * @private
     */
    private static _executeKeybind;
    /**
     * Begin listening to keyboard events.
     * @internal
     */
    _activateListeners(): void;
    /**
     * The set of key codes which are currently depressed (down)
     * @type {Set<string>}
     */
    downKeys: Set<string>;
    /**
     * The set of movement keys which were recently pressed
     * @type {Set<string>}
     */
    moveKeys: Set<string>;
    /**
     * Test whether an HTMLElement currently has focus.
     * If so we normally don't want to process keybinding actions.
     * @type {boolean}
     */
    get hasFocus(): boolean;
    /**
     * Report whether a modifier in KeyboardManager.MODIFIER_KEYS is currently actively depressed.
     * @param {string} modifier     A modifier in MODIFIER_KEYS
     * @returns {boolean}           Is this modifier key currently down (active)?
     */
    isModifierActive(modifier: string): boolean;
    /**
     * Processes a keyboard event context, checking it against registered keybinding actions
     * @param {KeyboardEventContext} context   The keyboard event context
     * @param {object} [options]               Additional options to configure behavior.
     * @param {boolean} [options.force=false]  Force the event to be handled.
     * @protected
     */
    protected _processKeyboardContext(context: KeyboardEventContext, { force }?: {
        force?: boolean;
    }): void;
    /**
     * Reset tracking for which keys are in the down and released states
     * @private
     */
    private _reset;
    /**
     * Emulate a key-up event for any currently down keys. When emulating, we go backwards such that combinations such as
     * "CONTROL + S" emulate the "S" first in order to capture modifiers.
     * @param {object} [options]              Options to configure behavior.
     * @param {boolean} [options.force=true]  Force the keyup events to be handled.
     */
    releaseKeys({ force }?: {
        force?: boolean;
    }): void;
    /**
     * Handle a key press into the down position
     * @param {KeyboardEvent} event   The originating keyboard event
     * @param {boolean} up            A flag for whether the key is down or up
     * @private
     */
    private _handleKeyboardEvent;
    /**
     * Input events do not fire with isComposing = false at the end of a composition event in Chrome
     * See: https://github.com/w3c/uievents/issues/202
     * @param {CompositionEvent} event
     */
    _onCompositionEnd(event: CompositionEvent): void;
    /**
     * Release any down keys when focusing a form element.
     * @param {FocusEvent} event  The focus event.
     * @protected
     */
    protected _onFocusIn(event: FocusEvent): void;
}
/**
 * Management class for Mouse events
 */
declare class MouseManager {
    /**
     * Specify a rate limit for mouse wheel to gate repeated scrolling.
     * This is especially important for continuous scrolling mice which emit hundreds of events per second.
     * This designates a minimum number of milliseconds which must pass before another wheel event is handled
     * @type {number}
     */
    static MOUSE_WHEEL_RATE_LIMIT: number;
    _wheelTime: number;
    /**
     * Begin listening to mouse events.
     * @internal
     */
    _activateListeners(): void;
    /**
     * Master mouse-wheel event handler
     * @param {WheelEvent} event    The mouse wheel event
     * @private
     */
    private _onWheel;
}
/**
 * Responsible for managing the New User Experience workflows.
 */
declare class NewUserExperience {
    /**
     * Initialize the new user experience.
     * Currently, this generates some chat messages with hints for getting started if we detect this is a new world.
     */
    initialize(): void;
    /**
     * Show chat tips for first launch.
     * @private
     */
    private _createInitialChatMessages;
    /**
     * Create a default scene for the new world.
     * @private
     */
    private _createDefaultScene;
    /**
     * Automatically show uncompleted Tours related to new worlds.
     * @private
     */
    private _showNewWorldTour;
    /**
     * Add event listeners to the chat card links.
     * @param {ChatMessage} msg  The ChatMessage being rendered.
     * @param {jQuery} html      The HTML content of the message.
     * @private
     */
    private _activateListeners;
    /**
     * Perform some special action triggered by clicking on a link in a NUE chat card.
     * @param {TriggeredEvent} event  The click event.
     * @private
     */
    private _onActionLink;
    /**
     * Switch to the appropriate tab when a user clicks on a link in the chat message.
     * @param {TriggeredEvent} event  The click event.
     * @private
     */
    private _onTabLink;
}
declare const Module_base: typeof import("../../common/packages/base-module.mjs").default;
/**
 * @extends foundry.packages.BaseModule
 * @mixes ClientPackageMixin
 * @category - Packages
 */
declare class Module extends Module_base {
    constructor(data: any, options?: {});
}
declare const System_base: typeof import("../../common/packages/base-system.mjs").default;
/**
 * @extends foundry.packages.BaseSystem
 * @mixes ClientPackageMixin
 * @category - Packages
 */
declare class System extends System_base {
}
declare const World_base: typeof import("../../common/packages/base-world.mjs").default;
/**
 * @extends foundry.packages.BaseWorld
 * @mixes ClientPackageMixin
 * @category - Packages
 */
declare class World extends World_base {
    /** @inheritDoc */
    getVersionBadge(): any;
    /**
     * Provide data for a system badge displayed for the world which reflects the system ID and its availability
     * @returns {PackageCompatibilityBadge|null}
     */
    getSystemBadge(): PackageCompatibilityBadge | null;
    /** @inheritdoc */
    _formatBadDependenciesTooltip(deps: any): any;
}
/**
 * A mapping of allowed package types and the classes which implement them.
 * @type {{world: World, system: System, module: Module}}
 */
declare const PACKAGE_TYPES: {
    world: World;
    system: System;
    module: Module;
};
/**
 * A class responsible for managing defined game settings or settings menus.
 * Each setting is a string key/value pair belonging to a certain namespace and a certain store scope.
 *
 * When Foundry Virtual Tabletop is initialized, a singleton instance of this class is constructed within the global
 * Game object as game.settings.
 *
 * @see {@link Game#settings}
 * @see {@link Settings}
 * @see {@link SettingsConfig}
 */
declare class ClientSettings {
    constructor(worldSettings: any);
    /**
     * A object of registered game settings for this scope
     * @type {Map<string, SettingsConfig>}
     */
    settings: Map<string, SettingsConfig>;
    /**
     * Registered settings menus which trigger secondary applications
     * @type {Map}
     */
    menus: Map<any, any>;
    /**
     * The storage interfaces used for persisting settings
     * Each storage interface shares the same API as window.localStorage
     */
    storage: Map<any, any>;
    /**
     * Return a singleton instance of the Game Settings Configuration app
     * @returns {SettingsConfig}
     */
    get sheet(): SettingsConfig;
    _sheet: SettingsConfig;
    /**
     * Register a new game setting under this setting scope
     *
     * @param {string} namespace    The namespace under which the setting is registered
     * @param {string} key          The key name for the setting under the namespace
     * @param {SettingConfig} data  Configuration for setting data
     *
     * @example Register a client setting
     * ```js
     * game.settings.register("myModule", "myClientSetting", {
     *   name: "Register a Module Setting with Choices",
     *   hint: "A description of the registered setting and its behavior.",
     *   scope: "client",     // This specifies a client-stored setting
     *   config: true,        // This specifies that the setting appears in the configuration view
     *   requiresReload: true // This will prompt the user to reload the application for the setting to take effect.
     *   type: String,
     *   choices: {           // If choices are defined, the resulting setting will be a select menu
     *     "a": "Option A",
     *     "b": "Option B"
     *   },
     *   default: "a",        // The default value for the setting
     *   onChange: value => { // A callback function which triggers when the setting is changed
     *     console.log(value)
     *   }
     * });
     * ```
     *
     * @example Register a world setting
     * ```js
     * game.settings.register("myModule", "myWorldSetting", {
     *   name: "Register a Module Setting with a Range slider",
     *   hint: "A description of the registered setting and its behavior.",
     *   scope: "world",      // This specifies a world-level setting
     *   config: true,        // This specifies that the setting appears in the configuration view
     *   requiresReload: true // This will prompt the GM to have all clients reload the application for the setting to
     *                        // take effect.
     *   type: Number,
     *   range: {             // If range is specified, the resulting setting will be a range slider
     *     min: 0,
     *     max: 100,
     *     step: 10
     *   }
     *   default: 50,         // The default value for the setting
     *   onChange: value => { // A callback function which triggers when the setting is changed
     *     console.log(value)
     *   }
     * });
     * ```
     */
    register(namespace: string, key: string, data: SettingConfig): void;
    /**
     * Register a new sub-settings menu
     *
     * @param {string} namespace           The namespace under which the menu is registered
     * @param {string} key                 The key name for the setting under the namespace
     * @param {SettingSubmenuConfig} data  Configuration for setting data
     *
     * @example Define a settings submenu which handles advanced configuration needs
     * ```js
     * game.settings.registerMenu("myModule", "mySettingsMenu", {
     *   name: "My Settings Submenu",
     *   label: "Settings Menu Label",      // The text label used in the button
     *   hint: "A description of what will occur in the submenu dialog.",
     *   icon: "fas fa-bars",               // A Font Awesome icon used in the submenu button
     *   type: MySubmenuApplicationClass,   // A FormApplication subclass which should be created
     *   restricted: true                   // Restrict this submenu to gamemaster only?
     * });
     * ```
     */
    registerMenu(namespace: string, key: string, data: SettingSubmenuConfig): void;
    /**
     * Get the value of a game setting for a certain namespace and setting key
     *
     * @param {string} namespace   The namespace under which the setting is registered
     * @param {string} key         The setting key to retrieve
     *
     * @example Retrieve the current setting value
     * ```js
     * game.settings.get("myModule", "myClientSetting");
     * ```
     */
    get(namespace: string, key: string): any;
    /**
     * Set the value of a game setting for a certain namespace and setting key
     *
     * @param {string} namespace    The namespace under which the setting is registered
     * @param {string} key          The setting key to retrieve
     * @param {*} value             The data to assign to the setting key
     * @param {object} [options]    Additional options passed to the server when updating world-scope settings
     * @returns {*}                 The assigned setting value
     *
     * @example Update the current value of a setting
     * ```js
     * game.settings.set("myModule", "myClientSetting", "b");
     * ```
     */
    set(namespace: string, key: string, value: any, options?: object): any;
    #private;
}
declare class SocketInterface {
    /**
     * Standardize the way that socket messages are dispatched and their results are handled
     * @param {string} eventName          The socket event name being handled
     * @param {SocketRequest} request     Data provided to the Socket event
     * @returns {Promise<SocketResponse>} A Promise which resolves to the SocketResponse
     */
    static dispatch(eventName: string, request: SocketRequest): Promise<SocketResponse>;
    /**
     * Handle an error returned from the database, displaying it on screen and in the console
     * @param {Error} err   The provided Error message
     * @private
     */
    private static _handleError;
}
/**
 * A collection of functions related to sorting objects within a parent container.
 */
declare class SortingHelpers {
    static performIntegerSort(source: any, { target, siblings, sortKey, sortBefore }?: {
        target?: any;
        siblings?: any[];
        sortKey?: string;
        sortBefore?: boolean;
    }): any[];
    /**
     * Given a source object to sort, a target to sort relative to, and an Array of siblings in the container:
     * Determine the updated sort keys for the source object, or all siblings if a reindex is required.
     * Return an Array of updates to perform, it is up to the caller to dispatch these updates.
     * Each update is structured as:
     * {
     *   target: object,
     *   update: {sortKey: sortValue}
     * }
     *
     * @param {object} source       The source object being sorted
     * @param {object} [options]    Options which modify the sort behavior
     * @param {object|null} [options.target]  The target object relative which to sort
     * @param {object[]} [options.siblings]   The Array of siblings which the source should be sorted within
     * @param {string} [options.sortKey=sort] The property name within the source object which defines the sort key
     * @param {boolean} [options.sortBefore]  Explicitly sort before (true) or sort after( false).
     *                                        If undefined the sort order will be automatically determined.
     * @returns {object[]}          An Array of updates for the caller of the helper function to perform
     */
    static performIntegerSort(source: object, { target, siblings, sortKey, sortBefore }?: {
        target?: object | null;
        siblings?: object[];
        sortKey?: string;
        sortBefore?: boolean;
    }): object[];
    private static _sortBefore;
    private static _sortAfter;
}
/**
 * A singleton class {@link game#time} which keeps the official Server and World time stamps.
 * Uses a basic implementation of https://www.geeksforgeeks.org/cristians-algorithm/ for synchronization.
 */
declare class GameTime {
    /**
     * The amount of time to delay before re-syncing the official server time.
     * @type {number}
     */
    static SYNC_INTERVAL_MS: number;
    constructor(socket: any);
    /**
     * The most recently synchronized timestamps retrieved from the server.
     * @type {{clientTime: number, serverTime: number, worldTime: number}}
     */
    _time: {
        clientTime: number;
        serverTime: number;
        worldTime: number;
    };
    /**
     * The average one-way latency across the most recent 5 trips
     * @type {number}
     */
    _dt: number;
    /**
     * The most recent five synchronization durations
     * @type {number[]}
     */
    _dts: number[];
    /**
     * The current server time based on the last synchronization point and the approximated one-way latency.
     * @type {number}
     */
    get serverTime(): number;
    /**
     * The current World time based on the last recorded value of the core.time setting
     * @type {number}
     */
    get worldTime(): number;
    /**
     * Advance the game time by a certain number of seconds
     * @param {number} seconds        The number of seconds to advance (or rewind if negative) by
     * @param {object} [options]      Additional options passed to game.settings.set
     * @returns {Promise<number>}     The new game time
     */
    advance(seconds: number, options?: object): Promise<number>;
    /**
     * Synchronize the local client game time with the official time kept by the server
     * @param {Socket} socket         The connected server Socket instance
     * @returns {Promise<GameTime>}
     */
    sync(socket: Socket): Promise<GameTime>;
    /**
     * Handle follow-up actions when the official World time is changed
     * @param {number} worldTime      The new canonical World time.
     * @param {object} options        Options passed from the requesting client where the change was made
     * @param {string} userId         The ID of the User who advanced the time
     */
    onUpdateWorldTime(worldTime: number, options: object, userId: string): void;
}
/**
 * A singleton Tooltip Manager class responsible for rendering and positioning a dynamic tooltip element which is
 * accessible as `game.tooltip`.
 *
 * @see {@link Game.tooltip}
 *
 * @example API Usage
 * ```js
 * game.tooltip.activate(htmlElement, {text: "Some tooltip text", direction: "UP"});
 * game.tooltip.deactivate();
 * ```
 *
 * @example HTML Usage
 * ```html
 * <span data-tooltip="Some Tooltip" data-tooltip-direction="LEFT">I have a tooltip</span>
 * <ol data-tooltip-direction="RIGHT">
 *   <li data-tooltip="The First One">One</li>
 *   <li data-tooltip="The Second One">Two</li>
 *   <li data-tooltip="The Third One">Three</li>
 * </ol>
 * ```
 */
declare class TooltipManager {
    /**
     * An amount of margin which is used to offset tooltips from their anchored element.
     * @type {number}
     */
    static TOOLTIP_MARGIN_PX: number;
    /**
     * The number of milliseconds delay which activates a tooltip on a "long hover".
     * @type {number}
     */
    static TOOLTIP_ACTIVATION_MS: number;
    /**
     * The directions in which a tooltip can extend, relative to its tool-tipped element.
     * @enum {string}
     */
    static TOOLTIP_DIRECTIONS: {
        UP: string;
        DOWN: string;
        LEFT: string;
        RIGHT: string;
        CENTER: string;
    };
    /**
     * The number of pixels buffer around a locked tooltip zone before they should be dismissed.
     * @type {number}
     */
    static LOCKED_TOOLTIP_BUFFER_PX: number;
    /**
     * A cached reference to the global tooltip element
     * @type {HTMLElement}
     */
    tooltip: HTMLElement;
    /**
     * A reference to the HTML element which is currently tool-tipped, if any.
     * @type {HTMLElement|null}
     */
    element: HTMLElement | null;
    /**
     * Activate interactivity by listening for hover events on HTML elements which have a data-tooltip defined.
     */
    activateEventListeners(): void;
    /**
     * Activate the tooltip for a hovered HTML element which defines a tooltip localization key.
     * @param {HTMLElement} element         The HTML element being hovered.
     * @param {object} [options={}]         Additional options which can override tooltip behavior.
     * @param {string} [options.text]       Explicit tooltip text to display. If this is not provided the tooltip text is
     *                                      acquired from the elements data-tooltip attribute. This text will be
     *                                      automatically localized
     * @param {TooltipManager.TOOLTIP_DIRECTIONS} [options.direction]  An explicit tooltip expansion direction. If this
     *                                      is not provided the direction is acquired from the data-tooltip-direction
     *                                      attribute of the element or one of its parents.
     * @param {string} [options.cssClass]   An optional, space-separated list of CSS classes to apply to the activated
     *                                      tooltip. If this is not provided, the CSS classes are acquired from the
     *                                      data-tooltip-class attribute of the element or one of its parents.
     * @param {boolean} [options.locked]    An optional boolean to lock the tooltip after creation. Defaults to false.
     * @param {HTMLElement} [options.content]  Explicit HTML content to inject into the tooltip rather than using tooltip
     *                                         text.
     */
    activate(element: HTMLElement, { text, direction, cssClass, locked, content }?: {
        text?: string;
        direction?: {
            UP: string;
            DOWN: string;
            LEFT: string;
            RIGHT: string;
            CENTER: string;
        };
        cssClass?: string;
        locked?: boolean;
        content?: HTMLElement;
    }): void;
    /**
     * Deactivate the tooltip from a previously hovered HTML element.
     */
    deactivate(): void;
    /**
     * Clear any pending activation workflow.
     * @internal
     */
    clearPending(): void;
    /**
     * Lock the current tooltip.
     * @returns {HTMLElement}
     */
    lockTooltip(): HTMLElement;
    /**
     * Handle a request to lock the current tooltip.
     * @param {MouseEvent} event  The click event.
     * @protected
     */
    protected _onLockTooltip(event: MouseEvent): void;
    /**
     * Handle dismissing a locked tooltip.
     * @param {MouseEvent} event  The click event.
     * @protected
     */
    protected _onLockedTooltipDismiss(event: MouseEvent): void;
    /**
     * Dismiss a given locked tooltip.
     * @param {HTMLElement} element  The locked tooltip to dismiss.
     */
    dismissLockedTooltip(element: HTMLElement): void;
    /**
     * Dismiss the set of active locked tooltips.
     */
    dismissLockedTooltips(): void;
    /**
     * Create a locked tooltip at the given position.
     * @param {object} position             A position object with coordinates for where the tooltip should be placed
     * @param {string} position.top         Explicit top position for the tooltip
     * @param {string} position.right       Explicit right position for the tooltip
     * @param {string} position.bottom      Explicit bottom position for the tooltip
     * @param {string} position.left        Explicit left position for the tooltip
     * @param {string} text                 Explicit tooltip text or HTML to display.
     * @param {object} [options={}]         Additional options which can override tooltip behavior.
     * @param {array} [options.cssClass]    An optional, space-separated list of CSS classes to apply to the activated
     *                                      tooltip.
     * @returns {HTMLElement}
     */
    createLockedTooltip(position: {
        top: string;
        right: string;
        bottom: string;
        left: string;
    }, text: string, { cssClass }?: {
        cssClass?: any[];
    }): HTMLElement;
    /**
     * If an explicit tooltip expansion direction was not specified, figure out a valid direction based on the bounds
     * of the target element and the screen.
     * @protected
     */
    protected _determineDirection(): any;
    /**
     * Set tooltip position relative to an HTML element using an explicitly provided data-tooltip-direction.
     * @param {TooltipManager.TOOLTIP_DIRECTIONS} direction  The tooltip expansion direction specified by the element
     *                                                        or a parent element.
     * @protected
     */
    protected _setAnchor(direction: {
        UP: string;
        DOWN: string;
        LEFT: string;
        RIGHT: string;
        CENTER: string;
    }): void;
    /**
     * Apply inline styling rules to the tooltip for positioning and text alignment.
     * @param {object} [position={}]  An object of positioning data, supporting top, right, bottom, left, and textAlign
     * @protected
     */
    protected _setStyle(position?: object): void;
    #private;
}
/**
 * @typedef {Object} TourStep               A step in a Tour
 * @property {string} id                    A machine-friendly id of the Tour Step
 * @property {string} title                 The title of the step, displayed in the tooltip header
 * @property {string} content               Raw HTML content displayed during the step
 * @property {string} [selector]            A DOM selector which denotes an element to highlight during this step.
 *                                          If omitted, the step is displayed in the center of the screen.
 * @property {TooltipManager.TOOLTIP_DIRECTIONS} [tooltipDirection]  How the tooltip for the step should be displayed
 *                                          relative to the target element. If omitted, the best direction will be attempted to be auto-selected.
 * @property {boolean} [restricted]         Whether the Step is restricted to the GM only. Defaults to false.
 */
/**
 * @typedef {Object} TourConfig               Tour configuration data
 * @property {string} namespace               The namespace this Tour belongs to. Typically, the name of the package which
 *                                            implements the tour should be used
 * @property {string} id                      A machine-friendly id of the Tour, must be unique within the provided namespace
 * @property {string} title                   A human-readable name for this Tour. Localized.
 * @property {TourStep[]} steps               The list of Tour Steps
 * @property {string} [description]           A human-readable description of this Tour. Localized.
 * @property {object} [localization]          A map of localizations for the Tour that should be merged into the default localizations
 * @property {boolean} [restricted]           Whether the Tour is restricted to the GM only. Defaults to false.
 * @property {boolean} [display]              Whether the Tour should be displayed in the Manage Tours UI. Defaults to false.
 * @property {boolean} [canBeResumed]         Whether the Tour can be resumed or if it always needs to start from the beginning. Defaults to false.
 * @property {string[]} [suggestedNextTours]  A list of namespaced Tours that might be suggested to the user when this Tour is completed.
 *                                            The first non-completed Tour in the array will be recommended.
 */
/**
 * A Tour that shows a series of guided steps.
 * @param {TourConfig} config           The configuration of the Tour
 * @tutorial tours
 */
declare class Tour {
    /**
     * A singleton reference which tracks the currently active Tour.
     * @type {Tour|null}
     */
    static "__#113@#activeTour": Tour | null;
    /**
     * @enum {string}
     */
    static STATUS: {
        UNSTARTED: string;
        IN_PROGRESS: string;
        COMPLETED: string;
    };
    /**
     * Indicates if a Tour is currently in progress.
     * @returns {boolean}
     */
    static get tourInProgress(): boolean;
    /**
     * Returns the active Tour, if any
     * @returns {Tour|null}
     */
    static get activeTour(): Tour;
    /**
     * Handle a movement action to either progress or regress the Tour.
     * @param @param {string[]} movementDirections           The Directions being moved in
     * @returns {boolean}
     */
    static onMovementAction(movementDirections: string[]): boolean;
    /**
     * Padding around a Highlighted Element
     * @type {number}
     */
    static HIGHLIGHT_PADDING: number;
    /**
     * Creates and returns a Tour by loading a JSON file
     * @param {string} filepath   The path to the JSON file
     * @returns {Promise<Tour>}
     */
    static fromJSON(filepath: string): Promise<Tour>;
    constructor(config: any, { id, namespace }?: {
        id: any;
        namespace: any;
    });
    /**
     * Configuration of the tour. This object is cloned to avoid mutating the original configuration.
     * @type {TourConfig}
     */
    config: TourConfig;
    /**
     * The HTMLElement which is the focus of the current tour step.
     * @type {HTMLElement}
     */
    targetElement: HTMLElement;
    /**
     * The HTMLElement that fades out the rest of the screen
     * @type {HTMLElement}
     */
    fadeElement: HTMLElement;
    /**
     * The HTMLElement that blocks input while a Tour is active
     */
    overlayElement: any;
    set id(arg: string);
    /**
     * The unique identifier of the tour.
     * @type {string}
     */
    get id(): string;
    /**
     * The human-readable title for the tour.
     * @type {string}
     */
    get title(): string;
    /**
     * The human-readable description of the tour.
     * @type {string}
     */
    get description(): string;
    set namespace(arg: string);
    /**
     * The package namespace for the tour.
     * @type {string}
     */
    get namespace(): string;
    /**
     * The key the Tour is stored under in game.tours, of the form `${namespace}.${id}`
     * @returns {string}
     */
    get key(): string;
    /**
     * The configuration of tour steps
     * @type {TourStep[]}
     */
    get steps(): TourStep[];
    /**
     * Return the current Step, or null if the tour has not yet started.
     * @type {TourStep|null}
     */
    get currentStep(): TourStep;
    /**
     * The index of the current step; -1 if the tour has not yet started, or null if the tour is finished.
     * @type {number|null}
     */
    get stepIndex(): number;
    /**
     * Returns True if there is a next TourStep
     * @type {boolean}
     */
    get hasNext(): boolean;
    /**
     * Returns True if there is a previous TourStep
     * @type {boolean}
     */
    get hasPrevious(): boolean;
    /**
     * Return whether this Tour is currently eligible to be started?
     * This is useful for tours which can only be used in certain circumstances, like if the canvas is active.
     * @type {boolean}
     */
    get canStart(): boolean;
    /**
     * The current status of the Tour
     * @returns {STATUS}
     */
    get status(): string;
    /**
     * Advance the tour to a completed state.
     */
    complete(): Promise<any>;
    /**
     * Exit the tour at the current step.
     */
    exit(): void;
    /**
     * Reset the Tour to an un-started state.
     */
    reset(): Promise<any>;
    /**
     * Start the Tour at its current step, or at the beginning if the tour has not yet been started.
     */
    start(): Promise<any>;
    /**
     * Progress the Tour to the next step.
     */
    next(): Promise<any>;
    /**
     * Rewind the Tour to the previous step.
     */
    previous(): Promise<any>;
    /**
     * Progresses to a given Step
     * @param {number} stepIndex  The step to progress to
     */
    progress(stepIndex: number): Promise<any>;
    /**
     * Query the DOM for the target element using the provided selector
     * @param {string} selector     A CSS selector
     * @returns {Element|null}      The target element, or null if not found
     * @protected
     */
    protected _getTargetElement(selector: string): Element | null;
    /**
     * Set-up operations performed before a step is shown.
     * @abstract
     * @protected
     */
    protected _preStep(): Promise<void>;
    /**
     * Clean-up operations performed after a step is completed.
     * @abstract
     * @protected
     */
    protected _postStep(): Promise<void>;
    /**
     * Renders the current Step of the Tour
     * @protected
     */
    protected _renderStep(): Promise<void>;
    /**
     * Handle Tour Button clicks
     * @param {Event} event   A click event
     * @param {HTMLElement[]} buttons   The step buttons
     * @private
     */
    private _onButtonClick;
    /**
     * Saves the current progress of the Tour to a world setting
     * @private
     */
    private _saveProgress;
    /**
     * Returns the User's current progress of this Tour
     * @returns {null|number}
     * @private
     */
    private _loadProgress;
    /**
     * Reloads the Tour's current step from the saved progress
     * @internal
     */
    _reloadProgress(): void;
    #private;
}
/**
 * A singleton Tour Collection class responsible for registering and activating Tours, accessible as game.tours
 * @see {Game#tours}
 * @extends Map
 */
declare class Tours extends Map<any, any> {
    constructor();
    /**
     * Register a new Tour
     * @param {string} namespace          The namespace of the Tour
     * @param {string} id                 The machine-readable id of the Tour
     * @param {Tour} tour                 The constructed Tour
     * @returns {void}
     */
    register(namespace: string, id: string, tour: Tour): void;
    /**
     * @inheritDoc
     * @override
     */
    override set(key: any, tour: any): this;
}
/**
 * A helper class to provide common functionality for working with HTML5 video objects
 * A singleton instance of this class is available as ``game.video``
 */
declare class VideoHelper {
    /**
     * Check if a source has a video extension.
     * @param {string} src          The source.
     * @returns {boolean}           If the source has a video extension or not.
     */
    static hasVideoExtension(src: string): boolean;
    /**
     * A user gesture must be registered before video playback can begin.
     * This Set records the video elements which await such a gesture.
     * @type {Set}
     */
    pending: Set<any>;
    /**
     * A mapping of base64 video thumbnail images
     * @type {Map<string,string>}
     */
    thumbs: Map<string, string>;
    /**
     * A flag for whether video playback is currently locked by awaiting a user gesture
     * @type {boolean}
     */
    locked: boolean;
    /**
     * Return the HTML element which provides the source for a loaded texture.
     * @param {PIXI.Sprite|SpriteMesh} mesh                       The rendered mesh
     * @returns {HTMLImageElement|HTMLVideoElement|null}          The source HTML element
     */
    getSourceElement(mesh: PIXI.Sprite | SpriteMesh): HTMLImageElement | HTMLVideoElement | null;
    /**
     * Get the video element source corresponding to a Sprite or SpriteMesh.
     * @param {PIXI.Sprite|SpriteMesh|PIXI.Texture} object        The PIXI source
     * @returns {HTMLVideoElement|null}                           The source video element or null
     */
    getVideoSource(object: PIXI.Sprite | SpriteMesh | PIXI.Texture): HTMLVideoElement | null;
    /**
     * Clone a video texture so that it can be played independently of the original base texture.
     * @param {HTMLVideoElement} source     The video element source
     * @returns {Promise<PIXI.Texture>}     An unlinked PIXI.Texture which can be played independently
     */
    cloneTexture(source: HTMLVideoElement): Promise<PIXI.Texture>;
    /**
     * Play a single video source
     * If playback is not yet enabled, add the video to the pending queue
     * @param {HTMLElement} video     The VIDEO element to play
     * @param {object} [options={}]   Additional options for modifying video playback
     * @param {boolean} [options.playing] Should the video be playing? Otherwise, it will be paused
     * @param {boolean} [options.loop]    Should the video loop?
     * @param {number} [options.offset]   A specific timestamp between 0 and the video duration to begin playback
     * @param {number} [options.volume]   Desired volume level of the video's audio channel (if any)
     */
    play(video: HTMLElement, { playing, loop, offset, volume }?: {
        playing?: boolean;
        loop?: boolean;
        offset?: number;
        volume?: number;
    }): Promise<any>;
    /**
     * Stop a single video source
     * @param {HTMLElement} video   The VIDEO element to stop
     */
    stop(video: HTMLElement): void;
    /**
     * Register an event listener to await the first mousemove gesture and begin playback once observed
     * A user interaction must involve a mouse click or keypress.
     * Listen for any of these events, and handle the first observed gesture.
     */
    awaitFirstGesture(): void;
    /**
     * Handle the first observed user gesture
     * We need a slight delay because unfortunately Chrome is stupid and doesn't always acknowledge the gesture fast enough.
     * @param {Event} event   The mouse-move event which enables playback
     */
    _onFirstGesture(event: Event): void;
    /**
     * Create and cache a static thumbnail to use for the video.
     * The thumbnail is cached using the video file path or URL.
     * @param {string} src        The source video URL
     * @param {object} options    Thumbnail creation options, including width and height
     * @returns {Promise<string>}  The created and cached base64 thumbnail image, or a placeholder image if the canvas is
     *                            disabled and no thumbnail can be generated.
     */
    createThumbnail(src: string, options: object): Promise<string>;
    /**
     * Lazily-load the YouTube API and retrieve a Player instance for a given iframe.
     * @param {string} id      The iframe ID.
     * @param {object} config  A player config object. See {@link https://developers.google.com/youtube/iframe_api_reference} for reference.
     * @returns {Promise<YT.Player>}
     */
    getYouTubePlayer(id: string, config?: object): Promise<YT.Player>;
    /**
     * Retrieve a YouTube video ID from a URL.
     * @param {string} url  The URL.
     * @returns {string}
     */
    getYouTubeId(url: string): string;
    /**
     * Take a URL to a YouTube video and convert it into a URL suitable for embedding in a YouTube iframe.
     * @param {string} url   The URL to convert.
     * @param {object} vars  YouTube player parameters.
     * @returns {string}     The YouTube embed URL.
     */
    getYouTubeEmbedURL(url: string, vars?: object): string;
    /**
     * Test a URL to see if it points to a YouTube video.
     * @param {string} url  The URL to test.
     * @returns {boolean}
     */
    isYouTubeURL(url?: string): boolean;
    #private;
}
/**
 * @typedef {Object<string, *>} WorkerTask
 * @property {number} [taskId]          An incrementing task ID used to reference task progress
 * @property {WorkerManager.WORKER_TASK_ACTIONS} action  The task action being performed, from WorkerManager.WORKER_TASK_ACTIONS
 * @property {function} [resolve]       A Promise resolution handler
 * @property {function} [reject]        A Promise rejection handler
 */
/**
 * An asynchronous web Worker which can load user-defined functions and await execution using Promises.
 * @param {string} name                 The worker name to be initialized
 * @param {object} [options={}]         Worker initialization options
 * @param {boolean} [options.debug=false]           Should the worker run in debug mode?
 * @param {boolean} [options.loadPrimitives=false]  Should the worker automatically load the primitives library?
 * @param {string[]} [options.scripts]              Should the worker operates in script modes? Optional scripts.
 */
declare class AsyncWorker extends Worker {
    /**
     * A path reference to the JavaScript file which provides companion worker-side functionality.
     * @type {string}
     */
    static WORKER_HARNESS_JS: string;
    constructor(name: any, { debug, loadPrimitives, scripts }?: {
        debug?: boolean;
        loadPrimitives?: boolean;
        scripts: any;
    });
    name: any;
    /**
     * A Promise which resolves once the Worker is ready to accept tasks
     * @type {Promise}
     */
    ready: Promise<any>;
    /**
     * A queue of active tasks that this Worker is executing.
     * @type {Map<number, WorkerTask>}
     */
    tasks: Map<number, WorkerTask>;
    /**
     * Load a function onto a given Worker.
     * The function must be a pure function with no external dependencies or requirements on global scope.
     * @param {string} functionName   The name of the function to load
     * @param {Function} functionRef  A reference to the function that should be loaded
     * @returns {Promise<unknown>}    A Promise which resolves once the Worker has loaded the function.
     */
    loadFunction(functionName: string, functionRef: Function): Promise<unknown>;
    /**
     * Execute a task on a specific Worker.
     * @param {string} functionName   The named function to execute on the worker. This function must first have been
     *                                loaded.
     * @param {Array<*>} args         An array of parameters with which to call the requested function
     * @param {Array<*>} transfer     An array of transferable objects which are transferred to the worker thread.
     *                                See https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects
     * @returns {Promise<unknown>}    A Promise which resolves with the returned result of the function once complete.
     */
    executeFunction(functionName: string, args?: Array<any>, transfer?: Array<any>): Promise<unknown>;
    /**
     * Dispatch a task to a named Worker, awaiting confirmation of the result.
     * @param {WorkerTask} taskData   Data to dispatch to the Worker as part of the task.
     * @param {Array<*>} transfer     An array of transferable objects which are transferred to the worker thread.
     * @returns {Promise}             A Promise which wraps the task transaction.
     * @private
     */
    private _dispatchTask;
    #private;
}
/**
 * A client-side class responsible for managing a set of web workers.
 * This interface is accessed as a singleton instance via game.workers.
 * @see Game#workers
 */
declare class WorkerManager extends Map<any, any> {
    /**
     * Supported worker task actions
     * @enum {string}
     */
    static WORKER_TASK_ACTIONS: Readonly<{
        INIT: "init";
        LOAD: "load";
        EXECUTE: "execute";
    }>;
    constructor();
    /**
     * Create a new named Worker.
     * @param {string} name                 The named Worker to create
     * @param {object} [config={}]          Worker configuration parameters passed to the AsyncWorker constructor
     * @returns {Promise<AsyncWorker>}      The created AsyncWorker which is ready to accept tasks
     */
    createWorker(name: string, config?: object): Promise<AsyncWorker>;
    /**
     * Retire a current Worker, terminating it immediately.
     * @see Worker#terminate
     * @param {string} name           The named worker to terminate
     */
    retireWorker(name: string): void;
    /**
     * @deprecated since 11
     * @ignore
     */
    getWorker(name: any): any;
}
/**
 * A namespace containing the user interface applications which are defined throughout the Foundry VTT ecosystem.
 * @namespace applications
 */
declare let _appId: number;
declare let _maxZ: number;
declare const MIN_WINDOW_WIDTH: 200;
declare const MIN_WINDOW_HEIGHT: 50;
/**
 * @typedef {object} ApplicationOptions
 * @property {string|null} [baseApplication]  A named "base application" which generates an additional hook
 * @property {number|null} [width]         The default pixel width for the rendered HTML
 * @property {number|string|null} [height]  The default pixel height for the rendered HTML
 * @property {number|null} [top]           The default offset-top position for the rendered HTML
 * @property {number|null} [left]          The default offset-left position for the rendered HTML
 * @property {number|null} [scale]         A transformation scale for the rendered HTML
 * @property {boolean} [popOut]            Whether to display the application as a pop-out container
 * @property {boolean} [minimizable]       Whether the rendered application can be minimized (popOut only)
 * @property {boolean} [resizable]         Whether the rendered application can be drag-resized (popOut only)
 * @property {string} [id]                 The default CSS id to assign to the rendered HTML
 * @property {string[]} [classes]          An array of CSS string classes to apply to the rendered HTML
 * @property {string} [title]              A default window title string (popOut only)
 * @property {string|null} [template]      The default HTML template path to render for this Application
 * @property {string[]} [scrollY]          A list of unique CSS selectors which target containers that should have their
 *                                         vertical scroll positions preserved during a re-render.
 * @property {TabsConfiguration[]} [tabs]  An array of tabbed container configurations which should be enabled for the
 *                                         application.
 * @property {DragDropConfiguration[]} dragDrop  An array of CSS selectors for configuring the application's
 *                                               {@link DragDrop} behaviour.
 * @property {SearchFilterConfiguration[]} filters An array of {@link SearchFilter} configuration objects.
 */
/**
 * The standard application window that is rendered for a large variety of UI elements in Foundry VTT.
 * @abstract
 * @param {ApplicationOptions} [options]  Configuration options which control how the application is rendered.
 *                                        Application subclasses may add additional supported options, but these base
 *                                        configurations are supported for all Applications. The values passed to the
 *                                        constructor are combined with the defaultOptions defined at the class level.
 */
declare class Application {
    /**
     * The sequence of rendering states that track the Application life-cycle.
     * @enum {number}
     */
    static RENDER_STATES: Readonly<{
        CLOSING: -2;
        CLOSED: -1;
        NONE: 0;
        RENDERING: 1;
        RENDERED: 2;
        ERROR: 3;
    }>;
    /**
     * Assign the default options configuration which is used by this Application class. The options and values defined
     * in this object are merged with any provided option values which are passed to the constructor upon initialization.
     * Application subclasses may include additional options which are specific to their usage.
     * @returns {ApplicationOptions}
     */
    static get defaultOptions(): ApplicationOptions;
    /**
     * Return the inheritance chain for this Application class up to (and including) it's base Application class.
     * @returns {Function[]}
     * @private
     */
    private static _getInheritanceChain;
    constructor(options?: {});
    /**
     * The options provided to this application upon initialization
     * @type {object}
     */
    options: object;
    /**
     * The application ID is a unique incrementing integer which is used to identify every application window
     * drawn by the VTT
     * @type {number}
     */
    appId: number;
    /**
     * An internal reference to the HTML element this application renders
     * @type {jQuery}
     */
    _element: JQueryStatic;
    /**
     * Track the current position and dimensions of the Application UI
     * @type {object}
     */
    position: object;
    /**
     * DragDrop workflow handlers which are active for this Application
     * @type {DragDrop[]}
     */
    _dragDrop: DragDrop[];
    /**
     * Tab navigation handlers which are active for this Application
     * @type {Tabs[]}
     */
    _tabs: Tabs[];
    /**
     * SearchFilter handlers which are active for this Application
     * @type {SearchFilter[]}
     */
    _searchFilters: SearchFilter[];
    /**
     * Track whether the Application is currently minimized
     * @type {boolean|null}
     */
    _minimized: boolean | null;
    /**
     * The current render state of the Application
     * @see {Application.RENDER_STATES}
     * @type {number}
     * @protected
     */
    protected _state: number;
    /**
     * The prior render state of this Application.
     * This allows for rendering logic to understand if the application is being rendered for the first time.
     * @see {Application.RENDER_STATES}
     * @type {number}
     * @protected
     */
    protected _priorState: number;
    /**
     * Track the most recent scroll positions for any vertically scrolling containers
     * @type {object | null}
     */
    _scrollPositions: object | null;
    /**
     * Create drag-and-drop workflow handlers for this Application
     * @returns {DragDrop[]}     An array of DragDrop handlers
     * @private
     */
    private _createDragDropHandlers;
    /**
     * Create tabbed navigation handlers for this Application
     * @returns {Tabs[]}     An array of Tabs handlers
     * @private
     */
    private _createTabHandlers;
    /**
     * Create search filter handlers for this Application
     * @returns {SearchFilter[]}  An array of SearchFilter handlers
     * @private
     */
    private _createSearchFilters;
    /**
     * Return the CSS application ID which uniquely references this UI element
     * @type {string}
     */
    get id(): string;
    /**
     * Return the active application element, if it currently exists in the DOM
     * @type {jQuery}
     */
    get element(): JQueryStatic;
    /**
     * The path to the HTML template file which should be used to render the inner content of the app
     * @type {string}
     */
    get template(): string;
    /**
     * Control the rendering style of the application. If popOut is true, the application is rendered in its own
     * wrapper window, otherwise only the inner app content is rendered
     * @type {boolean}
     */
    get popOut(): boolean;
    /**
     * Return a flag for whether the Application instance is currently rendered
     * @type {boolean}
     */
    get rendered(): boolean;
    /**
     * Whether the Application is currently closing.
     * @type {boolean}
     */
    get closing(): boolean;
    /**
     * An Application window should define its own title definition logic which may be dynamic depending on its data
     * @type {string}
     */
    get title(): string;
    /**
     * An application should define the data object used to render its template.
     * This function may either return an Object directly, or a Promise which resolves to an Object
     * If undefined, the default implementation will return an empty object allowing only for rendering of static HTML
     * @param {object} options
     * @returns {object|Promise<object>}
     */
    getData(options?: object): object | Promise<object>;
    /**
     * Render the Application by evaluating it's HTML template against the object of data provided by the getData method
     * If the Application is rendered as a pop-out window, wrap the contained HTML in an outer frame with window controls
     *
     * @param {boolean} force   Add the rendered application to the DOM if it is not already present. If false, the
     *                          Application will only be re-rendered if it is already present.
     * @param {object} options  Additional rendering options which are applied to customize the way that the Application
     *                          is rendered in the DOM.
     *
     * @param {number} [options.left]           The left positioning attribute
     * @param {number} [options.top]            The top positioning attribute
     * @param {number} [options.width]          The rendered width
     * @param {number} [options.height]         The rendered height
     * @param {number} [options.scale]          The rendered transformation scale
     * @param {boolean} [options.focus=false]   Apply focus to the application, maximizing it and bringing it to the top
     *                                          of the vertical stack.
     * @param {string} [options.renderContext]  A context-providing string which suggests what event triggered the render
     * @param {object} [options.renderData]     The data change which motivated the render request
     *
     * @returns {Application}                 The rendered Application instance
     *
     */
    render(force?: boolean, options?: {
        left?: number;
        top?: number;
        width?: number;
        height?: number;
        scale?: number;
        focus?: boolean;
        renderContext?: string;
        renderData?: object;
    }): Application;
    /**
     * An asynchronous inner function which handles the rendering of the Application
     * @fires renderApplication
     * @param {boolean} force     Render and display the application even if it is not currently displayed.
     * @param {object} options    Additional options which update the current values of the Application#options object
     * @returns {Promise<void>}   A Promise that resolves to the Application once rendering is complete
     * @protected
     */
    protected _render(force?: boolean, options?: object): Promise<void>;
    /**
     * Persist the scroll positions of containers within the app before re-rendering the content
     * @param {jQuery} html           The HTML object being traversed
     * @protected
     */
    protected _saveScrollPositions(html: JQueryStatic): void;
    /**
     * Restore the scroll positions of containers within the app after re-rendering the content
     * @param {jQuery} html           The HTML object being traversed
     * @protected
     */
    protected _restoreScrollPositions(html: JQueryStatic): void;
    /**
     * Render the outer application wrapper
     * @returns {Promise<jQuery>}   A promise resolving to the constructed jQuery object
     * @protected
     */
    protected _renderOuter(): Promise<JQueryStatic>;
    /**
     * Render the inner application content
     * @param {object} data         The data used to render the inner template
     * @returns {Promise<jQuery>}   A promise resolving to the constructed jQuery object
     * @private
     */
    private _renderInner;
    /**
     * Customize how inner HTML is replaced when the application is refreshed
     * @param {jQuery} element      The original HTML processed as a jQuery object
     * @param {jQuery} html         New updated HTML as a jQuery object
     * @private
     */
    private _replaceHTML;
    /**
     * Customize how a new HTML Application is added and first appears in the DOM
     * @param {jQuery} html       The HTML element which is ready to be added to the DOM
     * @private
     */
    private _injectHTML;
    /**
     * Specify the set of config buttons which should appear in the Application header.
     * Buttons should be returned as an Array of objects.
     * The header buttons which are added to the application can be modified by the getApplicationHeaderButtons hook.
     * @fires getApplicationHeaderButtons
     * @returns {ApplicationHeaderButton[]}
     * @private
     */
    private _getHeaderButtons;
    /**
     * Create a {@link ContextMenu} for this Application.
     * @param {jQuery} html  The Application's HTML.
     * @private
     */
    private _contextMenu;
    /**
     * Activate required listeners which must be enabled on every Application.
     * These are internal interactions which should not be overridden by downstream subclasses.
     * @param {jQuery} html
     * @protected
     */
    protected _activateCoreListeners(html: JQueryStatic): void;
    /**
     * After rendering, activate event listeners which provide interactivity for the Application.
     * This is where user-defined Application subclasses should attach their event-handling logic.
     * @param {JQuery} html
     */
    activateListeners(html: JQuery): void;
    /**
     * Change the currently active tab
     * @param {string} tabName      The target tab name to switch to
     * @param {object} options      Options which configure changing the tab
     * @param {string} options.group    A specific named tab group, useful if multiple sets of tabs are present
     * @param {boolean} options.triggerCallback  Whether to trigger tab-change callback functions
     */
    activateTab(tabName: string, { group, triggerCallback }?: {
        group: string;
        triggerCallback: boolean;
    }): void;
    /**
     * Handle changes to the active tab in a configured Tabs controller
     * @param {MouseEvent|null} event   A left click event
     * @param {Tabs} tabs               The Tabs controller
     * @param {string} active           The new active tab name
     * @protected
     */
    protected _onChangeTab(event: MouseEvent | null, tabs: Tabs, active: string): void;
    /**
     * Handle changes to search filtering controllers which are bound to the Application
     * @param {KeyboardEvent} event   The key-up event from keyboard input
     * @param {string} query          The raw string input to the search field
     * @param {RegExp} rgx            The regular expression to test against
     * @param {HTMLElement} html      The HTML element which should be filtered
     * @protected
     */
    protected _onSearchFilter(event: KeyboardEvent, query: string, rgx: RegExp, html: HTMLElement): void;
    /**
     * Define whether a user is able to begin a dragstart workflow for a given drag selector
     * @param {string} selector       The candidate HTML selector for dragging
     * @returns {boolean}             Can the current user drag this selector?
     * @protected
     */
    protected _canDragStart(selector: string): boolean;
    /**
     * Define whether a user is able to conclude a drag-and-drop workflow for a given drop selector
     * @param {string} selector       The candidate HTML selector for the drop target
     * @returns {boolean}             Can the current user drop on this selector?
     * @protected
     */
    protected _canDragDrop(selector: string): boolean;
    /**
     * Callback actions which occur at the beginning of a drag start workflow.
     * @param {DragEvent} event       The originating DragEvent
     * @protected
     */
    protected _onDragStart(event: DragEvent): void;
    /**
     * Callback actions which occur when a dragged element is over a drop target.
     * @param {DragEvent} event       The originating DragEvent
     * @protected
     */
    protected _onDragOver(event: DragEvent): void;
    /**
     * Callback actions which occur when a dragged element is dropped on a target.
     * @param {DragEvent} event       The originating DragEvent
     * @protected
     */
    protected _onDrop(event: DragEvent): void;
    /**
     * Bring the application to the top of the rendering stack
     */
    bringToTop(): void;
    /**
     * Close the application and un-register references to it within UI mappings
     * This function returns a Promise which resolves once the window closing animation concludes
     * @fires closeApplication
     * @param {object} [options={}] Options which affect how the Application is closed
     * @returns {Promise<void>}     A Promise which resolves once the application is closed
     */
    close(options?: object): Promise<void>;
    /**
     * Minimize the pop-out window, collapsing it to a small tab
     * Take no action for applications which are not of the pop-out variety or apps which are already minimized
     * @returns {Promise<void>}  A Promise which resolves once the minimization action has completed
     */
    minimize(): Promise<void>;
    /**
     * Maximize the pop-out window, expanding it to its original size
     * Take no action for applications which are not of the pop-out variety or are already maximized
     * @returns {Promise<void>}    A Promise which resolves once the maximization action has completed
     */
    maximize(): Promise<void>;
    /**
     * Set the application position and store its new location.
     * Returns the updated position object for the application containing the new values.
     * @param {object} position                   Positional data
     * @param {number|null} position.left            The left offset position in pixels
     * @param {number|null} position.top             The top offset position in pixels
     * @param {number|null} position.width           The application width in pixels
     * @param {number|string|null} position.height   The application height in pixels
     * @param {number|null} position.scale           The application scale as a numeric factor where 1.0 is default
     * @returns {{left: number, top: number, width: number, height: number, scale:number}|void}
     */
    setPosition({ left, top, width, height, scale }?: {
        left: number | null;
        top: number | null;
        width: number | null;
        height: number | string | null;
        scale: number | null;
    }): {
        left: number;
        top: number;
        width: number;
        height: number;
        scale: number;
    } | void;
    /**
     * Handle application minimization behavior - collapsing content and reducing the size of the header
     * @param {Event} ev
     * @private
     */
    private _onToggleMinimize;
    /**
     * Additional actions to take when the application window is resized
     * @param {Event} event
     * @private
     */
    private _onResize;
    /**
     * Wait for any images present in the Application to load.
     * @returns {Promise<void>}  A Promise that resolves when all images have loaded.
     * @protected
     */
    protected _waitForImages(): Promise<void>;
}
/**
 * @typedef {ApplicationOptions} FormApplicationOptions
 * @property {boolean} [closeOnSubmit=true]     Whether to automatically close the application when it's contained
 *                                              form is submitted.
 * @property {boolean} [submitOnChange=false]   Whether to automatically submit the contained HTML form when an input
 *                                              or select element is changed.
 * @property {boolean} [submitOnClose=false]    Whether to automatically submit the contained HTML form when the
 *                                              application window is manually closed.
 * @property {boolean} [editable=true]          Whether the application form is editable - if true, it's fields will
 *                                              be unlocked and the form can be submitted. If false, all form fields
 *                                              will be disabled and the form cannot be submitted.
 * @property {boolean} [sheetConfig=false]      Support configuration of the sheet type used for this application.
 */
/**
 * An abstract pattern for defining an Application responsible for updating some object using an HTML form
 *
 * A few critical assumptions:
 * 1) This application is used to only edit one object at a time
 * 2) The template used contains one (and only one) HTML form as it's outer-most element
 * 3) This abstract layer has no knowledge of what is being updated, so the implementation must define _updateObject
 *
 * @extends {Application}
 * @abstract
 * @interface
 *
 * @param {object} object                     Some object which is the target data structure to be updated by the form.
 * @param {FormApplicationOptions} [options]  Additional options which modify the rendering of the sheet.
 */
declare class FormApplication extends Application {
    constructor(object?: {}, options?: {});
    /**
     * The object target which we are using this form to modify
     * @type {*}
     */
    object: any;
    /**
     * A convenience reference to the form HTMLElement
     * @type {HTMLElement}
     */
    form: HTMLElement;
    /**
     * Keep track of any FilePicker instances which are associated with this form
     * The values of this Array are inner-objects with references to the FilePicker instances and other metadata
     * @type {FilePicker[]}
     */
    filepickers: FilePicker[];
    /**
     * Keep track of any mce editors which may be active as part of this form
     * The values of this object are inner-objects with references to the MCE editor and other metadata
     * @type {Object<string, object>}
     */
    editors: {
        [x: string]: object;
    };
    /**
     * Is the Form Application currently editable?
     * @type {boolean}
     */
    get isEditable(): boolean;
    /**
     * @inheritdoc
     * @returns {object|Promise<object>}
     */
    getData(options?: {}): object | Promise<object>;
    /** @inheritdoc */
    _render(force: any, options: any): Promise<void>;
    /** @inheritdoc */
    _renderInner(...args: any[]): Promise<JQueryStatic>;
    /** @inheritdoc */
    _activateCoreListeners(html: any): void;
    /** @inheritdoc */
    activateListeners(html: any): void;
    /**
     * If the form is not editable, disable its input fields
     * @param {HTMLElement} form    The form HTML
     * @protected
     */
    protected _disableFields(form: HTMLElement): void;
    /**
     * Handle standard form submission steps
     * @param {Event} event               The submit event which triggered this handler
     * @param {object | null} [updateData]  Additional specific data keys/values which override or extend the contents of
     *                                    the parsed form. This can be used to update other flags or data fields at the
     *                                    same time as processing a form submission to avoid multiple database operations.
     * @param {boolean} [preventClose]    Override the standard behavior of whether to close the form on submit
     * @param {boolean} [preventRender]   Prevent the application from re-rendering as a result of form submission
     * @returns {Promise}                 A promise which resolves to the validated update data
     * @protected
     */
    protected _onSubmit(event: Event, { updateData, preventClose, preventRender }?: object | null): Promise<any>;
    _submitting: boolean;
    /**
     * Get an object of update data used to update the form's target object
     * @param {object} updateData     Additional data that should be merged with the form data
     * @returns {object}               The prepared update data
     * @protected
     */
    protected _getSubmitData(updateData?: object): object;
    /**
     * Handle changes to an input element, submitting the form if options.submitOnChange is true.
     * Do not preventDefault in this handler as other interactions on the form may also be occurring.
     * @param {Event} event  The initial change event
     * @protected
     */
    protected _onChangeInput(event: Event): Promise<any>;
    /**
     * Handle the change of a color picker input which enters it's chosen value into a related input field
     * @param {Event} event   The color picker change event
     * @protected
     */
    protected _onChangeColorPicker(event: Event): void;
    /**
     * Handle changes to a range type input by propagating those changes to the sibling range-value element
     * @param {Event} event  The initial change event
     * @protected
     */
    protected _onChangeRange(event: Event): void;
    /**
     * Additional handling which should trigger when a FilePicker contained within this FormApplication is submitted.
     * @param {string} selection          The target path which was selected
     * @param {FilePicker} filePicker     The FilePicker instance which was submitted
     * @protected
     */
    protected _onSelectFile(selection: string, filePicker: FilePicker): void;
    /**
     * This method is called upon form submission after form data is validated
     * @param {Event} event       The initial triggering submission event
     * @param {object} formData   The object of validated form data with which to update the object
     * @returns {Promise}         A Promise which resolves once the update operation has completed
     * @abstract
     */
    _updateObject(event: Event, formData: object): Promise<any>;
    /**
     * Activate a named TinyMCE text editor
     * @param {string} name             The named data field which the editor modifies.
     * @param {object} options          Editor initialization options passed to {@link TextEditor.create}.
     * @param {string} initialContent   Initial text content for the editor area.
     * @returns {Promise<TinyMCE.Editor|ProseMirror.EditorView>}
     */
    activateEditor(name: string, options?: object, initialContent?: string): Promise<TinyMCE.Editor | ProseMirror.EditorView>;
    /**
     * Handle saving the content of a specific editor by name
     * @param {string} name           The named editor to save
     * @param {boolean} [remove]      Remove the editor after saving its content
     * @returns {Promise<void>}
     */
    saveEditor(name: string, { remove }?: boolean): Promise<void>;
    /**
     * Activate an editor instance present within the form
     * @param {HTMLElement} div  The element which contains the editor
     * @protected
     */
    protected _activateEditor(div: HTMLElement): void;
    /**
     * Configure ProseMirror plugins for this sheet.
     * @param {string} name                    The name of the editor.
     * @param {object} [options]               Additional options to configure the plugins.
     * @param {boolean} [options.remove=true]  Whether the editor should destroy itself on save.
     * @returns {object}
     * @protected
     */
    protected _configureProseMirrorPlugins(name: string, { remove }?: {
        remove?: boolean;
    }): object;
    /**
     * Activate a FilePicker instance present within the form
     * @param {PointerEvent} event    The mouse click event on a file picker activation button
     * @protected
     */
    protected _activateFilePicker(event: PointerEvent): Promise<any>;
    /**
     * Determine the configuration options used to initialize a FilePicker instance within this FormApplication.
     * Subclasses can extend this method to customize the behavior of pickers within their form.
     * @param {PointerEvent} event        The initiating mouse click event which opens the picker
     * @returns {object}                  Options passed to the FilePicker constructor
     * @protected
     */
    protected _getFilePickerOptions(event: PointerEvent): object;
    /** @inheritdoc */
    close(options?: {}): Promise<void>;
    /**
     * Submit the contents of a Form Application, processing its content as defined by the Application
     * @param {object} [options]        Options passed to the _onSubmit event handler
     * @returns {FormApplication}       Return a self-reference for convenient method chaining
     */
    submit(options?: object): FormApplication;
}
/**
 * @typedef {FormApplicationOptions} DocumentSheetOptions
 * @property {number} viewPermission                The default permissions required to view this Document sheet.
 * @property {HTMLSecretConfiguration[]} [secrets]  An array of {@link HTMLSecret} configuration objects.
 */
/**
 * Extend the FormApplication pattern to incorporate specific logic for viewing or editing Document instances.
 * See the FormApplication documentation for more complete description of this interface.
 *
 * @extends {FormApplication}
 * @abstract
 * @interface
 */
declare class DocumentSheet extends FormApplication {
    /**
     * @param {Document} object                    A Document instance which should be managed by this form.
     * @param {DocumentSheetOptions} [options={}]  Optional configuration parameters for how the form behaves.
     */
    constructor(object: Document, options?: DocumentSheetOptions);
    /**
     * The list of handlers for secret block functionality.
     * @type {HTMLSecret[]}
     * @protected
     */
    protected _secrets: HTMLSecret[];
    /**
     * A semantic convenience reference to the Document instance which is the target object for this form.
     * @type {ClientDocument}
     */
    get document(): ClientDocument;
    /** @inheritdoc */
    get isEditable(): any;
    /** @inheritdoc */
    getData(options?: {}): {
        cssClass: string;
        editable: any;
        document: ClientDocument;
        data: any;
        limited: any;
        options: any;
        owner: any;
        title: string;
    };
    /** @inheritdoc */
    activateEditor(name: any, options?: {}, initialContent?: string): Promise<any>;
    /** @inheritdoc */
    render(force?: boolean, options?: {}): any;
    /**
     * Create an ID link button in the document sheet header which displays the document ID and copies to clipboard
     * @param {jQuery} html
     * @protected
     */
    protected _createDocumentIdLink(html: JQueryStatic): void;
    /**
     * Test whether a certain User has permission to view this Document Sheet.
     * @param {User} user     The user requesting to render the sheet
     * @returns {boolean}     Does the User have permission to view this sheet?
     * @protected
     */
    protected _canUserView(user: User): boolean;
    /**
     * Create objects for managing the functionality of secret blocks within this Document's content.
     * @returns {HTMLSecret[]}
     * @protected
     */
    protected _createSecretHandlers(): HTMLSecret[];
    /**
     * Get the HTML content that a given secret block is embedded in.
     * @param {HTMLElement} secret  The secret block.
     * @returns {string}
     * @protected
     */
    protected _getSecretContent(secret: HTMLElement): string;
    /**
     * Update the HTML content that a given secret block is embedded in.
     * @param {HTMLElement} secret         The secret block.
     * @param {string} content             The new content.
     * @returns {Promise<ClientDocument>}  The updated Document.
     * @protected
     */
    protected _updateSecret(secret: HTMLElement, content: string): Promise<ClientDocument>;
    /**
     * Handle requests to configure the default sheet used by this Document
     * @param event
     * @private
     */
    private _onConfigureSheet;
    /**
     * Handle changing a Document's image.
     * @param {MouseEvent} event  The click event.
     * @returns {Promise}
     * @protected
     */
    protected _onEditImage(event: MouseEvent): Promise<any>;
    /** @inheritdoc */
    _updateObject(event: any, formData: any): Promise<any>;
}
/**
 * A helper class which assists with localization and string translation
 * @param {string} serverLanguage       The default language configuration setting for the server
 */
declare class Localization {
    constructor(serverLanguage: any);
    /**
     * The target language for localization
     * @type {string}
     */
    lang: string;
    /**
     * The package authorized to provide default language configurations
     * @type {string}
     */
    defaultModule: string;
    /**
     * The translation dictionary for the target language
     * @type {Object}
     */
    translations: any;
    /**
     * Fallback translations if the target keys are not found
     * @type {Object}
     */
    _fallback: any;
    /**
     * Initialize the Localization module
     * Discover available language translations and apply the current language setting
     * @returns {Promise<void>}      A Promise which resolves once languages are initialized
     */
    initialize(): Promise<void>;
    /**
     * Set a language as the active translation source for the session
     * @param {string} lang       A language string in CONFIG.supportedLanguages
     * @returns {Promise<void>}   A Promise which resolves once the translations for the requested language are ready
     */
    setLanguage(lang: string): Promise<void>;
    /**
     * Discover the available supported languages from the set of packages which are provided
     * @returns {object}         The resulting configuration of supported languages
     * @private
     */
    private _discoverSupportedLanguages;
    /**
     * Prepare the dictionary of translation strings for the requested language
     * @param {string} lang         The language for which to load translations
     * @returns {Promise<object>}   The retrieved translations object
     * @private
     */
    private _getTranslations;
    /**
     * Reduce the languages array provided by a package to an array of file paths of translations to load
     * @param {object} pkg          The package data
     * @param {string} lang         The target language to filter on
     * @returns {string[]}           An array of translation file paths
     * @private
     */
    private _filterLanguagePaths;
    /**
     * Load a single translation file and return its contents as processed JSON
     * @param {string} src        The translation file path to load
     * @returns {Promise<object>} The loaded translation dictionary
     * @private
     */
    private _loadTranslationFile;
    /**
     * Return whether a certain string has a known translation defined.
     * @param {string} stringId     The string key being translated
     * @param {boolean} [fallback]  Allow fallback translations to count?
     * @returns {boolean}
     */
    has(stringId: string, fallback?: boolean): boolean;
    /**
     * Localize a string by drawing a translation from the available translations dictionary, if available
     * If a translation is not available, the original string is returned
     * @param {string} stringId     The string ID to translate
     * @returns {string}             The translated string
     *
     * @example Localizing a simple string in JavaScript
     * ```js
     * {
     *   "MYMODULE.MYSTRING": "Hello, this is my module!"
     * }
     * game.i18n.localize("MYMODULE.MYSTRING"); // Hello, this is my module!
     * ```
     *
     * @example Localizing a simple string in Handlebars
     * ```hbs
     * {{localize "MYMODULE.MYSTRING"}} <!-- Hello, this is my module! -->
     * ```
     */
    localize(stringId: string): string;
    /**
     * Localize a string including variable formatting for input arguments.
     * Provide a string ID which defines the localized template.
     * Variables can be included in the template enclosed in braces and will be substituted using those named keys.
     *
     * @param {string} stringId     The string ID to translate
     * @param {object} data         Provided input data
     * @returns {string}             The translated and formatted string
     *
     * @example Localizing a formatted string in JavaScript
     * ```js
     * {
     *   "MYMODULE.GREETING": "Hello {name}, this is my module!"
     * }
     * game.i18n.format("MYMODULE.GREETING" {name: "Andrew"}); // Hello Andrew, this is my module!
     * ```
     *
     * @example Localizing a formatted string in Handlebars
     * ```hbs
     * {{localize "MYMODULE.GREETING" name="Andrew"}} <!-- Hello, this is my module! -->
     * ```
     */
    format(stringId: string, data?: object): string;
    /**
     * Retrieve list formatter configured to the world's language setting.
     * @see [Intl.ListFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/ListFormat)
     * @param {object} [options]
     * @param {ListFormatStyle} [options.style=long]       The list formatter style, either "long", "short", or "narrow".
     * @param {ListFormatType} [options.type=conjunction]  The list formatter type, either "conjunction", "disjunction",
     *                                                     or "unit".
     * @returns {Intl.ListFormat}
     */
    getListFormatter({ style, type }?: {
        style?: ListFormatStyle;
        type?: ListFormatType;
    }): Intl.ListFormat;
    /**
     * Sort an array of objects by a given key in a localization-aware manner.
     * @param {object[]} objects  The objects to sort, this array will be mutated.
     * @param {string} key        The key to sort the objects by. This can be provided in dot-notation.
     * @returns {object[]}
     */
    sortObjects(objects: object[], key: string): object[];
    #private;
}
/**
 * A collection of Handlebars template helpers which can be used within HTML templates.
 */
declare class HandlebarsHelpers {
    /**
     * For checkboxes, if the value of the checkbox is true, add the "checked" property, otherwise add nothing.
     * @returns {string}
     *
     * @example
     * ```hbs
     * <label>My Checkbox</label>
     * <input type="checkbox" name="myCheckbox" {{checked myCheckbox}}>
     * ```
     */
    static checked(value: any): string;
    /**
     * For use in form inputs. If the supplied value is truthy, add the "disabled" property, otherwise add nothing.
     * @returns {string}
     *
     * @example
     * ```hbs
     * <button type="submit" {{disabled myValue}}>Submit</button>
     * ```
     */
    static disabled(value: any): string;
    /**
     * Concatenate a number of string terms into a single string.
     * This is useful for passing arguments with variable names.
     * @param {string[]} values             The values to concatenate
     * @returns {Handlebars.SafeString}
     *
     * @example Concatenate several string parts to create a dynamic variable
     * ```hbs
     * {{filePicker target=(concat "faces." i ".img") type="image"}}
     * ```
     */
    static concat(...values: string[]): Handlebars.SafeString;
    /**
     * Render a pair of inputs for selecting a color.
     * @param {object} options              Helper options
     * @param {string} [options.name]       The name of the field to create
     * @param {string} [options.value]      The current color value
     * @param {string} [options.default]    A default color string if a value is not provided
     * @returns {Handlebars.SafeString}
     *
     * @example
     * ```hbs
     * {{colorPicker name="myColor" value=myColor default="#000000"}}
     * ```
     */
    static colorPicker(options: {
        name?: string;
        value?: string;
        default?: string;
    }): Handlebars.SafeString;
    /**
     * @typedef {object} TextEditorOptions
     * @property {string} [target]             The named target data element
     * @property {boolean} [button]            Include a button used to activate the editor later?
     * @property {string} [class]              A specific CSS class to add to the editor container
     * @property {boolean} [editable=true]     Is the text editor area currently editable?
     * @property {string} [engine=tinymce]     The editor engine to use, see {@link TextEditor.create}.
     * @property {boolean} [collaborate=false] Whether to turn on collaborative editing features for ProseMirror.
     *
     * The below options are deprecated since v10 and should be avoided.
     * @property {boolean} [owner]             Is the current user an owner of the data?
     * @property {boolean} [documents=true]    Replace dynamic document links?
     * @property {Object|Function} [rollData]  The data object providing context for inline rolls
     * @property {string} [content=""]         The original HTML content as a string
     */
    /**
     * Construct an editor element for rich text editing with TinyMCE or ProseMirror.
     * @param {[string, TextEditorOptions]} args  The content to display and edit, followed by handlebars options.
     * @returns {Handlebars.SafeString}
     *
     * @example
     * ```hbs
     * {{editor world.description target="description" button=false engine="prosemirror" collaborate=false}}
     * ```
     */
    static editor(args_0: string, args_1: {
        /**
         * The named target data element
         */
        target?: string;
        /**
         * Include a button used to activate the editor later?
         */
        button?: boolean;
        /**
         * A specific CSS class to add to the editor container
         */
        class?: string;
        /**
         * Is the text editor area currently editable?
         */
        editable?: boolean;
        /**
         * The editor engine to use, see {@link TextEditor.create }.
         */
        engine?: string;
        /**
         * Whether to turn on collaborative editing features for ProseMirror.
         *
         * The below options are deprecated since v10 and should be avoided.
         */
        collaborate?: boolean;
        /**
         * Is the current user an owner of the data?
         */
        owner?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * The data object providing context for inline rolls
         */
        rollData?: any;
        /**
         * The original HTML content as a string
         */
        content?: string;
    }): Handlebars.SafeString;
    /**
     * Render a file-picker button linked to an `<input>` field
     * @param {object} options              Helper options
     * @param {string} [options.type]       The type of FilePicker instance to display
     * @param {string} [options.target]     The field name in the target data
     * @returns {Handlebars.SafeString|string}
     *
     * @example
     * ```hbs
     * {{filePicker type="image" target="img"}}
     * ```
     */
    static filePicker(options: {
        type?: string;
        target?: string;
    }): Handlebars.SafeString | string;
    /**
     * A ternary expression that allows inserting A or B depending on the value of C.
     * @param {boolean} criteria    The test criteria
     * @param {string} ifTrue       The string to output if true
     * @param {string} ifFalse      The string to output if false
     * @returns {string}            The ternary result
     *
     * @example Ternary if-then template usage
     * ```hbs
     * {{ifThen true "It is true" "It is false"}}
     * ```
     */
    static ifThen(criteria: boolean, ifTrue: string, ifFalse: string): string;
    /**
     * Translate a provided string key by using the loaded dictionary of localization strings.
     * @returns {string}
     *
     * @example Translate a provided localization string, optionally including formatting parameters
     * ```hbs
     * <label>{{localize "ACTOR.Create"}}</label> <!-- "Create Actor" -->
     * <label>{{localize "CHAT.InvalidCommand" command=foo}}</label> <!-- "foo is not a valid chat message command." -->
     * ```
     */
    static localize(value: any, options: any): string;
    /**
     * A string formatting helper to display a number with a certain fixed number of decimals and an explicit sign.
     * @param {number} value              A numeric value to format
     * @param {object} options            Additional options which customize the resulting format
     * @param {number} [options.decimals=0]   The number of decimal places to include in the resulting string
     * @param {boolean} [options.sign=false]  Whether to include an explicit "+" sign for positive numbers   *
     * @returns {Handlebars.SafeString}   The formatted string to be included in a template
     *
     * @example
     * ```hbs
     * {{formatNumber 5.5}} <!-- 5.5 -->
     * {{formatNumber 5.5 decimals=2}} <!-- 5.50 -->
     * {{formatNumber 5.5 decimals=2 sign=true}} <!-- +5.50 -->
    *  ```
     */
    static numberFormat(value: number, options: {
        decimals?: number;
        sign?: boolean;
    }): Handlebars.SafeString;
    /**
     * Render a form input field of type number with value appropriately rounded to step size.
     * @returns {Handlebars.SafeString}
     *
     * @example
     * ```hbs
     * {{numberInput value name="numberField" step=1 min=0 max=10}}
     * ```
     */
    static numberInput(value: any, options: any): Handlebars.SafeString;
    /**
     * A helper to create a set of radio checkbox input elements in a named set.
     * The provided keys are the possible radio values while the provided values are human readable labels.
     *
     * @param {string} name         The radio checkbox field name
     * @param {object} choices      A mapping of radio checkbox values to human readable labels
     * @param {object} options      Options which customize the radio boxes creation
     * @param {string} options.checked    Which key is currently checked?
     * @param {boolean} options.localize  Pass each label through string localization?
     * @returns {Handlebars.SafeString}
     *
     * @example The provided input data
     * ```js
     * let groupName = "importantChoice";
     * let choices = {a: "Choice A", b: "Choice B"};
     * let chosen = "a";
     * ```
     *
     * @example The template HTML structure
     * ```hbs
     * <div class="form-group">
     *   <label>Radio Group Label</label>
     *   <div class="form-fields">
     *     {{radioBoxes groupName choices checked=chosen localize=true}}
     *   </div>
     * </div>
     * ```
     */
    static radioBoxes(name: string, choices: object, options: {
        checked: string;
        localize: boolean;
    }): Handlebars.SafeString;
    /**
     * Render a pair of inputs for selecting a value in a range.
     * @param {object} options            Helper options
     * @param {string} [options.name]     The name of the field to create
     * @param {number} [options.value]    The current range value
     * @param {number} [options.min]      The minimum allowed value
     * @param {number} [options.max]      The maximum allowed value
     * @param {number} [options.step]     The allowed step size
     * @returns {Handlebars.SafeString}
     *
     * @example
     * ```hbs
     * {{rangePicker name="foo" value=bar min=0 max=10 step=1}}
     * ```
     */
    static rangePicker(options: {
        name?: string;
        value?: number;
        min?: number;
        max?: number;
        step?: number;
    }): Handlebars.SafeString;
    /**
    * A helper to assign an `<option>` within a `<select>` block as selected based on its value
    * Escape the string as handlebars would, then escape any regexp characters in it
    * @param {string} value    The value of the option
    * @returns {Handlebars.SafeString}
     *
     * @example
     * ```hbs
     * <select>
     * {{#select selected}}
     *   <option value="a">Choice A</option>
     *   <option value="b">Choice B</option>
     * {{/select}}
     * </select>
    */
    static select(selected: any, options: any): Handlebars.SafeString;
    /**
     * A helper to create a set of &lt;option> elements in a &lt;select> block based on a provided dictionary.
     * The provided keys are the option values while the provided values are human readable labels.
     * This helper supports both single-select as well as multi-select input fields.
     *
     * @param {object|Array<object>>} choices      A mapping of radio checkbox values to human-readable labels
     * @param {object} options                     Helper options
     * @param {string|string[]} [options.selected] Which key or array of keys that are currently selected?
     * @param {boolean} [options.localize=false]   Pass each label through string localization?
     * @param {string} [options.blank]             Add a blank option as the first option with this label
     * @param {boolean} [options.sort]             Sort the options by their label after localization
     * @param {string} [options.nameAttr]          Look up a property in the choice object values to use as the option value
     * @param {string} [options.labelAttr]         Look up a property in the choice object values to use as the option label
     * @param {boolean} [options.inverted=false]   Use the choice object value as the option value, and the key as the label
     *                                             instead of vice-versa
     * @returns {Handlebars.SafeString}
     *
     * @example The provided input data
     * ```js
     * let choices = {a: "Choice A", b: "Choice B"};
     * let value = "a";
     * ```
     * The template HTML structure
     * ```hbs
     * <select name="importantChoice">
     *   {{selectOptions choices selected=value localize=true}}
     * </select>
     * ```
     * The resulting HTML
     * ```html
     * <select name="importantChoice">
     *   <option value="a" selected>Choice A</option>
     *   <option value="b">Choice B</option>
     * </select>
     * ```
     *
     * @example Using inverted choices
     * ```js
     * let choices = {"Choice A": "a", "Choice B": "b"};
     * let value = "a";
     * ```
     *  The template HTML structure
     *  ```hbs
     * <select name="importantChoice">
     *   {{selectOptions choices selected=value inverted=true}}
     * </select>
     * ```
     *
     * @example Using nameAttr and labelAttr with objects
     * ```js
     * let choices = {foo: {key: "a", label: "Choice A"}, bar: {key: "b", label: "Choice B"}};
     * let value = "b";
     * ```
     * The template HTML structure
     * ```hbs
     * <select name="importantChoice">
     *   {{selectOptions choices selected=value nameAttr="key" labelAttr="label"}}
     * </select>
     * ```
     *
     * @example Using nameAttr and labelAttr with arrays
     * ```js
     * let choices = [{key: "a", label: "Choice A"}, {key: "b", label: "Choice B"}];
     * let value = "b";
     * ```
     * The template HTML structure
     * ```hbs
     * <select name="importantChoice">
     *   {{selectOptions choices selected=value nameAttr="key" labelAttr="label"}}
     * </select>
     * ```
     */
    static selectOptions(choices: any, options: {
        selected?: string | string[];
        localize?: boolean;
        blank?: string;
        sort?: boolean;
        nameAttr?: string;
        labelAttr?: string;
        inverted?: boolean;
    }): Handlebars.SafeString;
}
/**
 * The core Game instance which encapsulates the data, settings, and states relevant for managing the game experience.
 * The singleton instance of the Game class is available as the global variable game.
 */
declare class Game {
    /**
     * Fetch World data and return a Game instance
     * @param {string} view             The named view being created
     * @param {string|null} sessionId   The current sessionId of the connecting client
     * @returns {Promise<Game>}         A Promise which resolves to the created Game instance
     */
    static create(view: string, sessionId: string | null): Promise<Game>;
    /**
     * Establish a live connection to the game server through the socket.io URL
     * @param {string} sessionId  The client session ID with which to establish the connection
     * @returns {Promise<object>}  A promise which resolves to the connected socket, if successful
     */
    static connect(sessionId: string): Promise<object>;
    /**
     * Retrieve the cookies which are attached to the client session
     * @returns {object}   The session cookies
     */
    static getCookies(): object;
    /**
     * Request World data from server and return it
     * @param {Socket} socket     The active socket connection
     * @param {string} view       The view for which data is being requested
     * @returns {Promise<object>}
     */
    static getData(socket: Socket, view: string): Promise<object>;
    /**
     * Get the current World status upon initial connection.
     * @param {Socket} socket  The active client socket connection
     * @returns {Promise<boolean>}
     */
    static getWorldStatus(socket: Socket): Promise<boolean>;
    /**
     * Support mousewheel control for range type input elements
     * @param {WheelEvent} event    A Mouse Wheel scroll event
     * @private
     */
    private static _handleMouseWheelInputChange;
    /**
     * @param {string} view         The named view which is active for this game instance.
     * @param {object} data         An object of all the World data vended by the server when the client first connects
     * @param {string} sessionId    The ID of the currently active client session retrieved from the browser cookie
     * @param {Socket} socket       The open web-socket which should be used to transact game-state data
     */
    constructor(view: string, data: object, sessionId: string, socket: Socket);
    /**
     * The user role permissions setting
     * @type {object}
     */
    permissions: object;
    /**
     * Whether the Game is running in debug mode
     * @type {boolean}
     */
    debug: boolean;
    /**
     * A flag for whether texture assets for the game canvas are currently loading
     * @type {boolean}
     */
    loading: boolean;
    /**
     * A flag for whether the Game has successfully reached the "ready" hook
     * @type {boolean}
     */
    ready: boolean;
    /**
     * The game World which is currently active.
     * @type {World}
     */
    world: World;
    /**
     * The System which is used to power this game World.
     * @type {System}
     */
    system: System;
    /**
     * A Map of active Modules which are currently eligible to be enabled in this World.
     * The subset of Modules which are designated as active are currently enabled.
     * @type {Map<string, Module>}
     */
    modules: Map<string, Module>;
    /**
     * Returns the current version of the Release, usable for comparisons using isNewerVersion
     * @type {string}
     */
    get version(): string;
    /**
     * Configure package data that is currently enabled for this world
     * @param {object} data  Game data provided by the server socket
     */
    setupPackages(data: object): void;
    documentTypes: any;
    template: any;
    model: any;
    /**
     * Return the named scopes which can exist for packages.
     * Scopes are returned in the prioritization order that their content is loaded.
     * @returns {string[]}    An array of string package scopes
     */
    getPackageScopes(): string[];
    /**
     * Initialize the Game for the current window location
     */
    initialize(): Promise<void>;
    /**
     * Shut down the currently active Game. Requires GameMaster user permission.
     * @returns {Promise<void>}
     */
    shutDown(): Promise<void>;
    /**
     * Fully set up the game state, initializing Documents, UI applications, and the Canvas
     * @returns {Promise<void>}
     */
    setupGame(): Promise<void>;
    /**
     * Initialize game state data by creating WorldCollection instances for every primary Document type
     */
    initializeDocuments(): void;
    _documentsReady: boolean;
    /**
     * Initialize the Compendium packs which are present within this Game
     * Create a Collection which maps each Compendium pack using it's collection ID
     * @returns {Collection<string,CompendiumCollection>}
     */
    initializePacks(): Collection<string, CompendiumCollection>;
    /**
     * Initialize the WebRTC implementation
     */
    initializeRTC(): Promise<boolean>;
    webrtc: AVMaster;
    /**
     * Initialize core UI elements
     */
    initializeUI(): void;
    /**
     * Initialize the game Canvas
     * @returns {Promise<void>}
     */
    initializeCanvas(): Promise<void>;
    /**
     * Initialize Keyboard controls
     */
    initializeKeyboard(): void;
    /**
     * Initialize Mouse controls
     */
    initializeMouse(): void;
    /**
     * Initialize Gamepad controls
     */
    initializeGamepads(): void;
    /**
     * Register core game settings
     */
    registerSettings(): void;
    /**
     * Register core Tours
     * @returns {Promise<void>}
     */
    registerTours(): Promise<void>;
    /**
     * Is the current session user authenticated as an application administrator?
     * @type {boolean}
     */
    get isAdmin(): boolean;
    /**
     * The currently connected User document, or null if Users is not yet initialized
     * @type {User|null}
     */
    get user(): User;
    /**
     * A convenience accessor for the currently viewed Combat encounter
     * @type {Combat}
     */
    get combat(): Combat;
    /**
     * A state variable which tracks whether the game session is currently paused
     * @type {boolean}
     */
    get paused(): boolean;
    /**
     * A convenient reference to the currently active canvas tool
     * @type {string}
     */
    get activeTool(): string;
    /**
     * Toggle the pause state of the game
     * Trigger the `pauseGame` Hook when the paused state changes
     * @param {boolean} pause         The desired pause state; true for paused, false for un-paused
     * @param {boolean} [push=false]  Push the pause state change to other connected clients? Requires an GM user.
     * @returns {boolean}             The new paused state
     */
    togglePause(pause: boolean, push?: boolean): boolean;
    /**
     * Open Character sheet for current token or controlled actor
     * @returns {ActorSheet|null}  The ActorSheet which was toggled, or null if the User has no character
     */
    toggleCharacterSheet(): ActorSheet | null;
    /**
     * Log out of the game session by returning to the Join screen
     */
    logOut(): void;
    /**
     * Scale the base font size according to the user's settings.
     * @param {number} [index]  Optionally supply a font size index to use, otherwise use the user's setting.
     *                          Available font sizes, starting at index 1, are: 8, 10, 12, 14, 16, 18, 20, 24, 28, and 32.
     */
    scaleFonts(index?: number): void;
    /**
     * Activate Socket event listeners which are used to transact game state data with the server
     */
    activateSocketListeners(): void;
    /**
     * Activate Event Listeners which apply to every Game View
     */
    activateListeners(): void;
    /**
     * On left mouse clicks, check if the element is contained in a valid hyperlink and open it in a new tab.
     * @param {MouseEvent} event
     * @private
     */
    private _onClickHyperlink;
    /**
     * Prevent starting a drag and drop workflow on elements within the document unless the element has the draggable
     * attribute explicitly defined or overrides the dragstart handler.
     * @param {DragEvent} event   The initiating drag start event
     * @private
     */
    private _onPreventDragstart;
    /**
     * Disallow dragging of external content onto anything but a file input element
     * @param {DragEvent} event   The requested drag event
     * @private
     */
    private _onPreventDragover;
    /**
     * Disallow dropping of external content onto anything but a file input element
     * @param {DragEvent} event   The requested drag event
     * @private
     */
    private _onPreventDrop;
    /**
     * On a left-click event, remove any currently displayed inline roll tooltip
     * @param {PointerEvent} event    The mousedown pointer event
     * @private
     */
    private _onPointerDown;
    /**
     * Fallback handling for mouse-up events which aren't handled further upstream.
     * @param {PointerEvent} event    The mouseup pointer event
     * @private
     */
    private _onPointerUp;
    /**
     * Handle resizing of the game window by adjusting the canvas and repositioning active interface applications.
     * @param {Event} event     The window resize event which has occurred
     * @private
     */
    private _onWindowResize;
    /**
     * Handle window unload operations to clean up any data which may be pending a final save
     * @param {Event} event     The window unload event which is about to occur
     * @private
     */
    private _onWindowBeforeUnload;
    /**
     * Handle cases where the browser window loses focus to reset detection of currently pressed keys
     * @param {Event} event   The originating window.blur event
     * @private
     */
    private _onWindowBlur;
    _onWindowPopState(event: any): void;
    /**
     * Initialize elements required for the current view
     * @private
     */
    private _initializeView;
    /**
     * Initialization steps for the primary Game view
     * @private
     */
    private _initializeGameView;
    /**
     * Initialization steps for the Stream helper view
     * @private
     */
    private _initializeStreamView;
    #private;
}
/**
 * An interface and API for constructing and evaluating dice rolls.
 * The basic structure for a dice roll is a string formula and an object of data against which to parse it.
 *
 * @param {string} formula    The string formula to parse
 * @param {object} data       The data object against which to parse attributes within the formula
 *
 * @example Attack with advantage
 * ```js
 * // Construct the Roll instance
 * let r = new Roll("2d20kh + @prof + @strMod", {prof: 2, strMod: 4});
 *
 * // The parsed terms of the roll formula
 * console.log(r.terms);    // [Die, OperatorTerm, NumericTerm, OperatorTerm, NumericTerm]
 *
 * // Execute the roll
 * await r.evaluate();
 *
 * // The resulting equation after it was rolled
 * console.log(r.result);   // 16 + 2 + 4
 *
 * // The total resulting from the roll
 * console.log(r.total);    // 22
 * ```
 */
declare class Roll {
    /**
     * A Proxy environment for safely evaluating a string using only available Math functions
     * @type {Math}
     */
    static MATH_PROXY: Math;
    /**
     * The HTML template path used to render a complete Roll object to the chat log
     * @type {string}
     */
    static CHAT_TEMPLATE: string;
    /**
     * The HTML template used to render an expanded Roll tooltip to the chat log
     * @type {string}
     */
    static TOOLTIP_TEMPLATE: string;
    /**
     * A factory method which constructs a Roll instance using the default configured Roll class.
     * @param {string} formula        The formula used to create the Roll instance
     * @param {object} [data={}]      The data object which provides component data for the formula
     * @param {object} [options={}]   Additional options which modify or describe this Roll
     * @returns {Roll}                The constructed Roll instance
     */
    static create(formula: string, data?: object, options?: object): Roll;
    /**
     * Get the default configured Roll class.
     * @returns {typeof Roll}
     */
    static get defaultImplementation(): typeof Roll;
    /**
     * Transform an array of RollTerm objects into a cleaned string formula representation.
     * @param {RollTerm[]} terms      An array of terms to represent as a formula
     * @returns {string}              The string representation of the formula
     */
    static getFormula(terms: RollTerm[]): string;
    /**
     * A sandbox-safe evaluation function to execute user-input code with access to scoped Math methods.
     * @param {string} expression   The input string expression
     * @returns {number}            The numeric evaluated result
     */
    static safeEval(expression: string): number;
    /**
     * After parenthetical and arithmetic terms have been resolved, we need to simplify the remaining expression.
     * Any remaining string terms need to be combined with adjacent non-operators in order to construct parsable terms.
     * @param {RollTerm[]} terms      An array of terms which is eligible for simplification
     * @returns {RollTerm[]}          An array of simplified terms
     */
    static simplifyTerms(terms: RollTerm[]): RollTerm[];
    /**
     * Simulate a roll and evaluate the distribution of returned results
     * @param {string} formula      The Roll expression to simulate
     * @param {number} n            The number of simulations
     * @returns {Promise<number[]>} The rolled totals
     */
    static simulate(formula: string, n?: number): Promise<number[]>;
    /**
     * Parse a formula by following an order of operations:
     *
     * Step 1: Replace formula data
     * Step 2: Split outer-most parenthetical groups
     * Step 3: Further split outer-most dice pool groups
     * Step 4: Further split string terms on arithmetic operators
     * Step 5: Classify all remaining strings
     *
     * @param {string} formula      The original string expression to parse
     * @param {object} data         A data object used to substitute for attributes in the formula
     * @returns {RollTerm[]}        A parsed array of RollTerm instances
     */
    static parse(formula: string, data: object): RollTerm[];
    /**
     * Replace referenced data attributes in the roll formula with values from the provided data.
     * Data references in the formula use the @attr syntax and would reference the corresponding attr key.
     *
     * @param {string} formula          The original formula within which to replace
     * @param {object} data             The data object which provides replacements
     * @param {object} [options]        Options which modify formula replacement
     * @param {string} [options.missing]      The value that should be assigned to any unmatched keys.
     *                                        If null, the unmatched key is left as-is.
     * @param {boolean} [options.warn=false]  Display a warning notification when encountering an un-matched key.
     * @static
     */
    static replaceFormulaData(formula: string, data: object, { missing, warn }?: {
        missing?: string;
        warn?: boolean;
    }): string;
    /**
     * Validate that a provided roll formula can represent a valid
     * @param {string} formula    A candidate formula to validate
     * @returns {boolean}         Is the provided input a valid dice formula?
     */
    static validate(formula: string): boolean;
    /**
     * Split a formula by identifying its outer-most parenthetical and math terms
     * @param {string} _formula      The raw formula to split
     * @returns {string[]}          An array of terms, split on parenthetical terms
     * @private
     */
    private static _splitParentheses;
    /**
     * Handle closing of a parenthetical term to create a MathTerm expression with a function and arguments
     * @param {string} expression   The expression to split
     * @returns {MathTerm[]}        An array of evaluated MathTerm instances
     * @private
     */
    private static _splitMathArgs;
    /**
     * Split a formula by identifying its outermost dice pool terms.
     * @param {string} _formula      The raw formula to split
     * @returns {string[]}          An array of terms, split on parenthetical terms
     * @private
     */
    private static _splitPools;
    /**
     * Split a formula by identifying its outermost groups using a certain group symbol like parentheses or brackets.
     * @param {string} _formula     The raw formula to split
     * @param {object} options      Options that configure how groups are split
     * @param {RegExp} [options.openRegexp]   A regular expression that identifies opening groups
     * @param {RegExp} [options.closeRegexp]  A regular expression that identifies closing groups
     * @param {string} [options.openSymbol]   The string symbol that opens a group
     * @param {string} [options.closeSymbol]  The string symbol that closes a group
     * @param {Function} [options.onClose]    A callback function invoked when a group is closed
     * @returns {string[]}          An array of terms, split on dice pool terms
     * @private
     */
    private static _splitGroup;
    /**
     * Split a formula by identifying arithmetic terms
     * @param {string} _formula                 The raw formula to split
     * @returns {Array<(string|OperatorTerm)>}  An array of terms, split on arithmetic operators
     * @private
     */
    private static _splitOperators;
    /**
     * Temporarily remove flavor text from a string formula allowing it to be accurately parsed.
     * @param {string} formula                        The formula to extract
     * @returns {{formula: string, flavors: object}}  The cleaned formula and extracted flavor mapping
     * @private
     */
    private static _extractFlavors;
    /**
     * Restore flavor text to a string term
     * @param {string} term             The string term possibly containing flavor symbols
     * @param {Object<string>} flavors  The extracted flavors object
     * @returns {string}                The restored term containing flavor text
     * @private
     */
    private static _restoreFlavor;
    /**
     * Classify a remaining string term into a recognized RollTerm class
     * @param {string} term         A remaining un-classified string
     * @param {object} [options={}] Options which customize classification
     * @param {boolean} [options.intermediate=true]  Allow intermediate terms
     * @param {RollTerm|string} [options.prior]       The prior classified term
     * @param {RollTerm|string} [options.next]        The next term to classify
     * @returns {RollTerm}          A classified RollTerm instance
     * @internal
     */
    static _classifyStringTerm(term: string, { intermediate, prior, next }?: {
        intermediate?: boolean;
        prior?: RollTerm | string;
        next?: RollTerm | string;
    }): RollTerm;
    /**
     * Expand an inline roll element to display its contained dice result as a tooltip.
     * @param {HTMLAnchorElement} a     The inline-roll button
     * @returns {Promise<void>}
     */
    static expandInlineResult(a: HTMLAnchorElement): Promise<void>;
    /**
     * Collapse an expanded inline roll to conceal its tooltip.
     * @param {HTMLAnchorElement} a     The inline-roll button
     */
    static collapseInlineResult(a: HTMLAnchorElement): void;
    /**
     * Recreate a Roll instance using a provided data object
     * @param {object} data   Unpacked data representing the Roll
     * @returns {Roll}         A reconstructed Roll instance
     */
    static fromData(data: object): Roll;
    /**
     * Recreate a Roll instance using a provided JSON string
     * @param {string} json   Serialized JSON data representing the Roll
     * @returns {Roll}        A reconstructed Roll instance
     */
    static fromJSON(json: string): Roll;
    /**
     * Manually construct a Roll object by providing an explicit set of input terms
     * @param {RollTerm[]} terms      The array of terms to use as the basis for the Roll
     * @param {object} [options={}]   Additional options passed to the Roll constructor
     * @returns {Roll}                The constructed Roll instance
     *
     * @example Construct a Roll instance from an array of component terms
     * ```js
     * const t1 = new Die({number: 4, faces: 8};
     * const plus = new OperatorTerm({operator: "+"});
     * const t2 = new NumericTerm({number: 8});
     * const roll = Roll.fromTerms([t1, plus, t2]);
     * roll.formula; // 4d8 + 8
     * ```
     */
    static fromTerms(terms: RollTerm[], options?: object): Roll;
    constructor(formula: any, data?: {}, options?: {});
    /**
     * The original provided data object which substitutes into attributes of the roll formula
     * @type {Object}
     */
    data: any;
    /**
     * Options which modify or describe the Roll
     * @type {object}
     */
    options: object;
    /**
     * The identified terms of the Roll
     * @type {RollTerm[]}
     */
    terms: RollTerm[];
    /**
     * An array of inner DiceTerms which were evaluated as part of the Roll evaluation
     * @type {DiceTerm[]}
     */
    _dice: DiceTerm[];
    /**
     * Store the original cleaned formula for the Roll, prior to any internal evaluation or simplification
     * @type {string}
     */
    _formula: string;
    /**
     * Track whether this Roll instance has been evaluated or not. Once evaluated the Roll is immutable.
     * @type {boolean}
     */
    _evaluated: boolean;
    /**
     * Cache the numeric total generated through evaluation of the Roll.
     * @type {number}
     * @private
     */
    private _total;
    /**
     * Prepare the data structure used for the Roll.
     * This is factored out to allow for custom Roll classes to do special data preparation using provided input.
     * @param {object} data   Provided roll data
     * @returns {object}      The prepared data object
     * @protected
     */
    protected _prepareData(data: object): object;
    /**
     * Return an Array of the individual DiceTerm instances contained within this Roll.
     * @type {DiceTerm[]}
     */
    get dice(): DiceTerm[];
    /**
     * Return a standardized representation for the displayed formula associated with this Roll.
     * @type {string}
     */
    get formula(): string;
    /**
     * The resulting arithmetic expression after rolls have been evaluated
     * @type {string}
     */
    get result(): string;
    /**
     * Return the total result of the Roll expression if it has been evaluated.
     * @type {number}
     */
    get total(): number;
    /**
     * Whether this Roll contains entirely deterministic terms or whether there is some randomness.
     * @type {boolean}
     */
    get isDeterministic(): boolean;
    /**
     * Alter the Roll expression by adding or multiplying the number of dice which are rolled
     * @param {number} multiply   A factor to multiply. Dice are multiplied before any additions.
     * @param {number} add        A number of dice to add. Dice are added after multiplication.
     * @param {boolean} [multiplyNumeric]  Apply multiplication factor to numeric scalar terms
     * @returns {Roll}            The altered Roll expression
     */
    alter(multiply: number, add: number, { multiplyNumeric }?: boolean): Roll;
    /**
     * Clone the Roll instance, returning a new Roll instance that has not yet been evaluated.
     * @returns {Roll}
     */
    clone(): Roll;
    /**
     * Execute the Roll, replacing dice and evaluating the total result
     * @param {object} [options={}]     Options which inform how the Roll is evaluated
     * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
     * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
     * @param {boolean} [options.async=true]        Evaluate the roll asynchronously. false is deprecated
     * @returns {Roll|Promise<Roll>}    The evaluated Roll instance
     *
     * @example Evaluate a Roll expression
     * ```js
     * let r = new Roll("2d6 + 4 + 1d4");
     * await r.evaluate();
     * console.log(r.result); // 5 + 4 + 2
     * console.log(r.total);  // 11
     * ```
     */
    evaluate({ minimize, maximize, async }?: {
        minimize?: boolean;
        maximize?: boolean;
        async?: boolean;
    }): Roll | Promise<Roll>;
    /**
     * Evaluate the roll asynchronously.
     * A temporary helper method used to migrate behavior from 0.7.x (sync by default) to 0.9.x (async by default).
     * @param {object} [options]      Options which inform how evaluation is performed
     * @param {boolean} [options.minimize]    Force the result to be minimized
     * @param {boolean} [options.maximize]    Force the result to be maximized
     * @returns {Promise<Roll>}
     * @private
     */
    private _evaluate;
    /**
     * Evaluate the roll synchronously.
     * A temporary helper method used to migrate behavior from 0.7.x (sync by default) to 0.9.x (async by default).
     * @param {object} [options]      Options which inform how evaluation is performed
     * @param {boolean} [options.minimize]    Force the result to be minimized
     * @param {boolean} [options.maximize]    Force the result to be maximized
     * @returns {Roll}
     * @private
     */
    private _evaluateSync;
    /**
     * Safely evaluate the final total result for the Roll using its component terms.
     * @returns {number}    The evaluated total
     * @private
     */
    private _evaluateTotal;
    /**
     * Alias for evaluate.
     * @param {object} options    Options passed to Roll#evaluate
     * @see {Roll#evaluate}
     */
    roll(options?: object): Roll | Promise<Roll>;
    /**
     * Create a new Roll object using the original provided formula and data.
     * Each roll is immutable, so this method returns a new Roll instance using the same data.
     * @param {object} [options={}]     Evaluation options passed to Roll#evaluate
     * @returns {Roll}                  A new Roll object, rolled using the same formula and data
     */
    reroll(options?: object): Roll;
    /**
     * Recompile the formula string that represents this Roll instance from its component terms.
     * @returns {string}                The re-compiled formula
     */
    resetFormula(): string;
    /**
     * Render the tooltip HTML for a Roll instance
     * @returns {Promise<string>}     The rendered HTML tooltip as a string
     */
    getTooltip(): Promise<string>;
    /**
     * Render a Roll instance to HTML
     * @param {object} [options={}]               Options which affect how the Roll is rendered
     * @param {string} [options.flavor]             Flavor text to include
     * @param {string} [options.template]           A custom HTML template path
     * @param {boolean} [options.isPrivate=false]   Is the Roll displayed privately?
     * @returns {Promise<string>}                 The rendered HTML template as a string
     */
    render({ flavor, template, isPrivate }?: {
        flavor?: string;
        template?: string;
        isPrivate?: boolean;
    }): Promise<string>;
    /**
     * Transform a Roll instance into a ChatMessage, displaying the roll result.
     * This function can either create the ChatMessage directly, or return the data object that will be used to create.
     *
     * @param {object} messageData          The data object to use when creating the message
     * @param {options} [options]           Additional options which modify the created message.
     * @param {string} [options.rollMode]   The template roll mode to use for the message from CONFIG.Dice.rollModes
     * @param {boolean} [options.create=true]   Whether to automatically create the chat message, or only return the
     *                                          prepared chatData object.
     * @returns {Promise<ChatMessage|object>} A promise which resolves to the created ChatMessage document if create is
     *                                        true, or the Object of prepared chatData otherwise.
     */
    toMessage(messageData?: object, { rollMode, create }?: options): Promise<ChatMessage | object>;
    /**
     * Construct an inline roll link for this Roll.
     * @param {object} [options]                  Additional options to configure how the link is constructed.
     * @param {string} [options.label]            A custom label for the total.
     * @param {object<string>} [options.attrs]    Attributes to set on the link.
     * @param {object<string>} [options.dataset]  Custom data attributes to set on the link.
     * @param {string[]} [options.classes]        Additional classes to add to the link. The classes `inline-roll`
     *                                            and `inline-result` are added by default.
     * @param {string} [options.icon]             A font-awesome icon class to use as the icon instead of a d20.
     * @returns {HTMLAnchorElement}
     */
    toAnchor({ attrs, dataset, classes, label, icon }?: {
        label?: string;
    }): HTMLAnchorElement;
    /**
     * Represent the data of the Roll as an object suitable for JSON serialization.
     * @returns {object}     Structured data which can be serialized into JSON
     */
    toJSON(): object;
}
/**
 * An abstract class which represents a single token that can be used as part of a Roll formula.
 * Every portion of a Roll formula is parsed into a subclass of RollTerm in order for the Roll to be fully evaluated.
 */
declare class RollTerm {
    /**
     * A regular expression pattern which identifies optional term-level flavor text
     * @type {string}
     */
    static FLAVOR_REGEXP_STRING: string;
    /**
     * A regular expression which identifies term-level flavor text
     * @type {RegExp}
     */
    static FLAVOR_REGEXP: RegExp;
    /**
     * A regular expression used to match a term of this type
     * @type {RegExp}
     */
    static REGEXP: RegExp;
    /**
     * An array of additional attributes which should be retained when the term is serialized
     * @type {string[]}
     */
    static SERIALIZE_ATTRIBUTES: string[];
    /**
     * Construct a RollTerm from a provided data object
     * @param {object} data         Provided data from an un-serialized term
     * @return {RollTerm}           The constructed RollTerm
     */
    static fromData(data: object): RollTerm;
    /**
     * Define term-specific logic for how a de-serialized data object is restored as a functional RollTerm
     * @param {object} data         The de-serialized term data
     * @returns {RollTerm}          The re-constructed RollTerm object
     * @protected
     */
    protected static _fromData(data: object): RollTerm;
    /**
     * Reconstruct a RollTerm instance from a provided JSON string
     * @param {string} json   A serialized JSON representation of a DiceTerm
     * @return {RollTerm}     A reconstructed RollTerm from the provided JSON
     */
    static fromJSON(json: string): RollTerm;
    constructor({ options }?: {
        options?: {};
    });
    /**
     * An object of additional options which describes and modifies the term.
     * @type {object}
     */
    options: object;
    /**
     * An internal flag for whether the term has been evaluated
     * @type {boolean}
     */
    _evaluated: boolean;
    /**
     * Is this term intermediate, and should be evaluated first as part of the simplification process?
     * @type {boolean}
     */
    isIntermediate: boolean;
    /**
     * A string representation of the formula expression for this RollTerm, prior to evaluation.
     * @type {string}
     */
    get expression(): string;
    /**
     * A string representation of the formula, including optional flavor text.
     * @type {string}
     */
    get formula(): string;
    /**
     * A string or numeric representation of the final output for this term, after evaluation.
     * @type {number|string}
     */
    get total(): string | number;
    /**
     * Optional flavor text which modifies and describes this term.
     * @type {string}
     */
    get flavor(): string;
    /**
     * Whether this term is entirely deterministic or contains some randomness.
     * @type {boolean}
     */
    get isDeterministic(): boolean;
    /**
     * Evaluate the term, processing its inputs and finalizing its total.
     * @param {object} [options={}]           Options which modify how the RollTerm is evaluated
     * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
     * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
     * @param {boolean} [options.async=false]       Evaluate the term asynchronously, receiving a Promise as the returned value.
     *                                              This will become the default behavior in version 10.x
     * @returns {RollTerm}                     The evaluated RollTerm
     */
    evaluate({ minimize, maximize, async }?: {
        minimize?: boolean;
        maximize?: boolean;
        async?: boolean;
    }): RollTerm;
    /**
     * Evaluate the term.
     * @param {object} [options={}]           Options which modify how the RollTerm is evaluated, see RollTerm#evaluate
     * @returns {Promise<RollTerm>}
     * @private
     */
    private _evaluate;
    /**
     * This method is temporarily factored out in order to provide different behaviors synchronous evaluation.
     * This will be removed in 0.10.x
     * @private
     */
    private _evaluateSync;
    /**
     * Serialize the RollTerm to a JSON string which allows it to be saved in the database or embedded in text.
     * This method should return an object suitable for passing to the JSON.stringify function.
     * @return {object}
     */
    toJSON(): object;
}
/**
 * A standalone, pure JavaScript implementation of the Mersenne Twister pseudo random number generator.
 *
 * @author Raphael Pigulla <pigulla@four66.com>
 * @version 0.2.3
 * @license
 * Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. The names of its contributors may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
declare class MersenneTwister {
    /**
     * A factory method for generating random uniform rolls
     * @returns {number}
     */
    static random(): number;
    /**
     * A factory method for generating random normal rolls
     * @return {number}
     */
    static normal(...args: any[]): number;
    /**
     * Instantiates a new Mersenne Twister.
     * @param {number} [seed]   The initial seed value, if not provided the current timestamp will be used.
     * @constructor
     */
    constructor(seed?: number);
    MAX_INT: number;
    N: number;
    M: number;
    UPPER_MASK: number;
    LOWER_MASK: number;
    MATRIX_A: number;
    mt: any[];
    mti: number;
    SEED: number;
    /**
     * Initializes the state vector by using one unsigned 32-bit integer "seed", which may be zero.
     *
     * @since 0.1.0
     * @param {number} seed The seed value.
     */
    seed(seed: number): number;
    /**
     * Initializes the state vector by using an array key[] of unsigned 32-bit integers of the specified length. If
     * length is smaller than 624, then each array of 32-bit integers gives distinct initial state vector. This is
     * useful if you want a larger seed space than 32-bit word.
     *
     * @since 0.1.0
     * @param {array} vector The seed vector.
     */
    seedArray(vector: any[]): void;
    /**
     * Generates a random unsigned 32-bit integer.
     *
     * @since 0.1.0
     * @returns {number}
     */
    int(): number;
    /**
     * Generates a random unsigned 31-bit integer.
     *
     * @since 0.1.0
     * @returns {number}
     */
    int31(): number;
    /**
     * Generates a random real in the interval [0;1] with 32-bit resolution.
     *
     * @since 0.1.0
     * @returns {number}
     */
    real(): number;
    /**
     * Generates a random real in the interval ]0;1[ with 32-bit resolution.
     *
     * @since 0.1.0
     * @returns {number}
     */
    realx(): number;
    /**
     * Generates a random real in the interval [0;1[ with 32-bit resolution.
     *
     * @since 0.1.0
     * @returns {number}
     */
    rnd(): number;
    /**
     * Generates a random real in the interval [0;1[ with 32-bit resolution.
     *
     * Same as .rnd() method - for consistency with Math.random() interface.
     *
     * @since 0.2.0
     * @returns {number}
     */
    random(): number;
    /**
     * Generates a random real in the interval [0;1[ with 53-bit resolution.
     *
     * @since 0.1.0
     * @returns {number}
     */
    rndHiRes(): number;
    /**
     * A pseudo-normal distribution using the Box-Muller transform.
     * @param {number} mu     The normal distribution mean
     * @param {number} sigma  The normal distribution standard deviation
     * @returns {number}
     */
    normal(mu: number, sigma: number): number;
}
declare const twist: MersenneTwister;
/**
 * @typedef {Object} DiceTermResult
 * @property {number} result        The numeric result
 * @property {boolean} [active]     Is this result active, contributing to the total?
 * @property {number} [count]       A value that the result counts as, otherwise the result is not used directly as
 * @property {boolean} [success]    Does this result denote a success?
 * @property {boolean} [failure]    Does this result denote a failure?
 * @property {boolean} [discarded]  Was this result discarded?
 * @property {boolean} [rerolled]   Was this result rerolled?
 * @property {boolean} [exploded]   Was this result exploded?
 */
/**
 * An abstract base class for any type of RollTerm which involves randomized input from dice, coins, or other devices.
 * @extends RollTerm
 *
 * @param {object} termData                 Data used to create the Dice Term, including the following:
 * @param {number} [termData.number=1]      The number of dice of this term to roll, before modifiers are applied
 * @param {number} termData.faces           The number of faces on each die of this type
 * @param {string[]} [termData.modifiers]   An array of modifiers applied to the results
 * @param {object[]} [termData.results]     An optional array of pre-cast results for the term
 * @param {object} [termData.options]       Additional options that modify the term
 */
declare class DiceTerm extends RollTerm {
    /**
     * Define the denomination string used to register this DiceTerm type in CONFIG.Dice.terms
     * @type {string}
     */
    static DENOMINATION: string;
    /**
     * Define the named modifiers that can be applied for this particular DiceTerm type.
     * @type {{string: (string|Function)}}
     */
    static MODIFIERS: {
        string: (string | Function);
    };
    /**
     * A regular expression pattern which captures the full set of term modifiers
     * Anything until a space, group symbol, or arithmetic operator
     * @type {string}
     */
    static MODIFIERS_REGEXP_STRING: string;
    /**
     * A regular expression used to separate individual modifiers
     * @type {RegExp}
     */
    static MODIFIER_REGEXP: RegExp;
    /**
     * A helper comparison function.
     * Returns a boolean depending on whether the result compares favorably against the target.
     * @param {number} result         The result being compared
     * @param {string} comparison     The comparison operator in [=,&lt;,&lt;=,>,>=]
     * @param {number} target         The target value
     * @return {boolean}              Is the comparison true?
     */
    static compareResult(result: number, comparison: string, target: number): boolean;
    /**
     * A helper method to modify the results array of a dice term by flagging certain results are kept or dropped.
     * @param {object[]} results      The results array
     * @param {number} number         The number to keep or drop
     * @param {boolean} [keep]        Keep results?
     * @param {boolean} [highest]     Keep the highest?
     * @return {object[]}             The modified results array
     */
    static _keepOrDrop(results: object[], number: number, { keep, highest }?: boolean): object[];
    /**
     * A reusable helper function to handle the identification and deduction of failures
     */
    static _applyCount(results: any, comparison: any, target: any, { flagSuccess, flagFailure }?: {
        flagSuccess?: boolean;
        flagFailure?: boolean;
    }): void;
    /**
     * A reusable helper function to handle the identification and deduction of failures
     */
    static _applyDeduct(results: any, comparison: any, target: any, { deductFailure, invertFailure }?: {
        deductFailure?: boolean;
        invertFailure?: boolean;
    }): void;
    /**
     * Determine whether a string expression matches this type of term
     * @param {string} expression               The expression to parse
     * @param {object} [options={}]             Additional options which customize the match
     * @param {boolean} [options.imputeNumber=true]  Allow the number of dice to be optional, i.e. "d6"
     * @return {RegExpMatchArray|null}
     */
    static matchTerm(expression: string, { imputeNumber }?: {
        imputeNumber?: boolean;
    }): RegExpMatchArray | null;
    /**
     * Construct a term of this type given a matched regular expression array.
     * @param {RegExpMatchArray} match          The matched regular expression array
     * @return {DiceTerm}                      The constructed term
     */
    static fromMatch(match: RegExpMatchArray): DiceTerm;
    constructor({ number, faces, modifiers, results, options }: {
        number?: number;
        faces?: number;
        modifiers?: any[];
        results?: any[];
        options?: {};
    });
    /**
     * The number of dice of this term to roll, before modifiers are applied
     * @type {number}
     */
    number: number;
    /**
     * The number of faces on the die
     * @type {number}
     */
    faces: number;
    /**
     * An Array of dice term modifiers which are applied
     * @type {string[]}
     */
    modifiers: string[];
    /**
     * The array of dice term results which have been rolled
     * @type {DiceTermResult[]}
     */
    results: DiceTermResult[];
    /** @inheritdoc */
    get total(): number;
    /**
     * Return an array of rolled values which are still active within this term
     * @type {number[]}
     */
    get values(): number[];
    /**
     * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
     * @param {number} multiply   A factor to multiply. Dice are multiplied before any additions.
     * @param {number} add        A number of dice to add. Dice are added after multiplication.
     * @return {DiceTerm}         The altered term
     */
    alter(multiply: number, add: number): DiceTerm;
    /** @inheritdoc */
    _evaluateSync({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): this;
    /**
     * Roll the DiceTerm by mapping a random uniform draw against the faces of the dice term.
     * @param {object} [options={}]           Options which modify how a random result is produced
     * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
     * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
     * @return {DiceTermResult}               The produced result
     */
    roll({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): DiceTermResult;
    /**
     * Return a string used as the label for each rolled result
     * @param {DiceTermResult} result     The rolled result
     * @return {string}                   The result label
     */
    getResultLabel(result: DiceTermResult): string;
    /**
     * Get the CSS classes that should be used to display each rolled result
     * @param {DiceTermResult} result     The rolled result
     * @return {string[]}                 The desired classes
     */
    getResultCSS(result: DiceTermResult): string[];
    /**
     * Render the tooltip HTML for a Roll instance
     * @return {object}      The data object used to render the default tooltip template for this DiceTerm
     */
    getTooltipData(): object;
    /**
     * Sequentially evaluate each dice roll modifier by passing the term to its evaluation function
     * Augment or modify the results array.
     * @private
     */
    private _evaluateModifiers;
    /**
     * Evaluate a single modifier command, recording it in the array of evaluated modifiers
     * @param {string} command        The parsed modifier command
     * @param {string} modifier       The full modifier request
     * @private
     */
    private _evaluateModifier;
}
/**
 * A type of RollTerm used to apply a function from the Math library.
 * @extends {RollTerm}
 */
declare class MathTerm extends RollTerm {
    constructor({ fn, terms, options }?: {
        fn: any;
        terms?: any[];
        options: any;
    });
    /**
     * The named function in the Math environment which should be applied to the term
     * @type {string}
     */
    fn: string;
    /**
     * An array of string argument terms for the function
     * @type {string[]}
     */
    terms: string[];
    /**
     * The cached Roll instances for each function argument
     * @type {Roll[]}
     */
    rolls: Roll[];
    /**
     * The cached result of evaluating the method arguments
     * @type {number}
     */
    result: number;
    /**
     * An array of evaluated DiceTerm instances that should be bubbled up to the parent Roll
     * @type {DiceTerm[]}
     */
    get dice(): DiceTerm[];
    /** @inheritdoc */
    get total(): number;
    /** @inheritdoc */
    _evaluateSync({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): this;
    /** @inheritdoc */
    _evaluate({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): Promise<this>;
}
/**
 * A type of RollTerm used to represent static numbers.
 * @extends {RollTerm}
 */
declare class NumericTerm extends RollTerm {
    /**
     * Determine whether a string expression matches a NumericTerm
     * @param {string} expression               The expression to parse
     * @return {RegExpMatchArray|null}
     */
    static matchTerm(expression: string): RegExpMatchArray | null;
    /**
     * Construct a term of this type given a matched regular expression array.
     * @param {RegExpMatchArray} match          The matched regular expression array
     * @return {NumericTerm}                    The constructed term
     */
    static fromMatch(match: RegExpMatchArray): NumericTerm;
    constructor({ number, options }?: {
        number: any;
        options: any;
    });
    number: number;
    /** @inheritdoc */
    get total(): number;
}
/**
 * A type of RollTerm used to denote and perform an arithmetic operation.
 * @extends {RollTerm}
 */
declare class OperatorTerm extends RollTerm {
    /**
     * An array of operators which represent arithmetic operations
     * @type {string[]}
     */
    static OPERATORS: string[];
    constructor({ operator, options }?: {
        operator: any;
        options: any;
    });
    operator: any;
    /** @inheritdoc */
    get total(): string;
}
/**
 * A type of RollTerm used to enclose a parenthetical expression to be recursively evaluated.
 * @extends {RollTerm}
 */
declare class ParentheticalTerm extends RollTerm {
    /**
     * The regular expression pattern used to identify the opening of a parenthetical expression.
     * This could also identify the opening of a math function.
     * @type {RegExp}
     */
    static OPEN_REGEXP: RegExp;
    /**
     * A regular expression pattern used to identify the closing of a parenthetical expression.
     * @type {RegExp}
     */
    static CLOSE_REGEXP: RegExp;
    /**
     * Construct a ParentheticalTerm from an Array of component terms which should be wrapped inside the parentheses.
     * @param {RollTerm[]} terms      The array of terms to use as internal parts of the parenthetical
     * @param {object} [options={}]   Additional options passed to the ParentheticalTerm constructor
     * @returns {ParentheticalTerm}   The constructed ParentheticalTerm instance
     *
     * @example Create a Parenthetical Term from an array of component RollTerm instances
     * ```js
     * const d6 = new Die({number: 4, faces: 6});
     * const plus = new OperatorTerm({operator: "+"});
     * const bonus = new NumericTerm({number: 4});
     * t = ParentheticalTerm.fromTerms([d6, plus, bonus]);
     * t.formula; // (4d6 + 4)
     * ```
     */
    static fromTerms(terms: RollTerm[], options?: object): ParentheticalTerm;
    constructor({ term, roll, options }: {
        term: any;
        roll: any;
        options: any;
    });
    /**
     * The original provided string term used to construct the parenthetical
     * @type {string}
     */
    term: string;
    /**
     * Alternatively, an already-evaluated Roll instance may be passed directly
     * @type {Roll}
     */
    roll: Roll;
    /**
     * An array of evaluated DiceTerm instances that should be bubbled up to the parent Roll
     * @type {DiceTerm[]}
     */
    get dice(): DiceTerm[];
    /** @inheritdoc */
    get total(): number;
    /** @inheritdoc */
    _evaluateSync({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): this;
    /** @inheritdoc */
    _evaluate({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): Promise<this>;
}
/**
 * A type of RollTerm which encloses a pool of multiple inner Rolls which are evaluated jointly.
 *
 * A dice pool represents a set of Roll expressions which are collectively modified to compute an effective total
 * across all Rolls in the pool. The final total for the pool is defined as the sum over kept rolls, relative to any
 * success count or margin.
 *
 * @example Keep the highest of the 3 roll expressions
 * ```js
 * let pool = new PoolTerm({
 *   terms: ["4d6", "3d8 - 1", "2d10 + 3"],
 *   modifiers: ["kh"]
 * });
 * pool.evaluate();
 * ```
 */
declare class PoolTerm extends RollTerm {
    /**
     * Define the modifiers that can be used for this particular DiceTerm type.
     * @type {Object<string, Function>}
     */
    static MODIFIERS: {
        [x: string]: Function;
    };
    /**
     * The regular expression pattern used to identify the opening of a dice pool expression.
     * @type {RegExp}
     */
    static OPEN_REGEXP: RegExp;
    /**
     * A regular expression pattern used to identify the closing of a dice pool expression.
     * @type {RegExp}
     */
    static CLOSE_REGEXP: RegExp;
    /** @inheritdoc */
    static _fromData(data: any): RollTerm;
    /**
     * Given a string formula, create and return an evaluated PoolTerm object
     * @param {string} formula    The string formula to parse
     * @param {object} [options]  Additional options applied to the PoolTerm
     * @return {PoolTerm|null}    The evaluated PoolTerm object or null if the formula is invalid
     */
    static fromExpression(formula: string, options?: object): PoolTerm | null;
    /**
     * Create a PoolTerm by providing an array of existing Roll objects
     * @param {Roll[]} rolls      An array of Roll objects from which to create the pool
     * @returns {RollTerm}        The constructed PoolTerm comprised of the provided rolls
     */
    static fromRolls(rolls?: Roll[]): RollTerm;
    constructor({ terms, modifiers, rolls, results, options }?: {
        terms?: any[];
        modifiers?: any[];
        rolls?: any[];
        results?: any[];
        options?: {};
    });
    /**
     * The original provided terms to the Dice Pool
     * @type {string[]}
     */
    terms: string[];
    /**
     * The string modifiers applied to resolve the pool
     * @type {string[]}
     */
    modifiers: string[];
    /**
     * Each component term of a dice pool is evaluated as a Roll instance
     * @type {Roll[]}
     */
    rolls: Roll[];
    /**
     * The array of dice pool results which have been rolled
     * @type {DiceTermResult[]}
     */
    results: DiceTermResult[];
    /**
     * Return an Array of each individual DiceTerm instances contained within the PoolTerm.
     * @return {DiceTerm[]}
     */
    get dice(): DiceTerm[];
    /** @inheritdoc */
    get total(): number;
    /**
     * Return an array of rolled values which are still active within the PoolTerm
     * @type {number[]}
     */
    get values(): number[];
    /**
     * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
     * @param {any[]} args        Arguments passed to each contained Roll#alter method.
     * @return {PoolTerm}         The altered pool
     */
    alter(...args: any[]): PoolTerm;
    /** @inheritdoc */
    _evaluateSync({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): this;
    /** @inheritdoc */
    _evaluate({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): Promise<this>;
    /**
     * Use the same logic as for the DiceTerm to avoid duplication
     * @see DiceTerm#_evaluateModifiers
     */
    _evaluateModifiers(): any;
    /**
     * Use the same logic as for the DiceTerm to avoid duplication
     * @see DiceTerm#_evaluateModifier
     */
    _evaluateModifier(command: any, modifier: any): any;
    /**
     * Keep a certain number of highest or lowest dice rolls from the result set.
     *
     * {1d6,1d8,1d10,1d12}kh2       Keep the 2 best rolls from the pool
     * {1d12,6}kl                   Keep the lowest result in the pool
     *
     * @param {string} modifier     The matched modifier query
     */
    keep(modifier: string): any;
    /**
     * Keep a certain number of highest or lowest dice rolls from the result set.
     *
     * {1d6,1d8,1d10,1d12}dl3       Drop the 3 worst results in the pool
     * {1d12,6}dh                   Drop the highest result in the pool
     *
     * @param {string} modifier     The matched modifier query
     */
    drop(modifier: string): any;
    /**
     * Count the number of successful results which occurred in the pool.
     * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
     * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
     *
     * 20d20cs      Count the number of dice which rolled a 20
     * 20d20cs>10   Count the number of dice which rolled higher than 10
     * 20d20cs<10   Count the number of dice which rolled less than 10
     *
     * @param {string} modifier     The matched modifier query
     */
    countSuccess(modifier: string): any;
    /**
     * Count the number of failed results which occurred in a given result set.
     * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
     * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
     *
     * 6d6cf      Count the number of dice which rolled a 1 as failures
     * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
     * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
     *
     * @param {string} modifier     The matched modifier query
     */
    countFailures(modifier: string): any;
}
/**
 * A type of RollTerm used to represent strings which have not yet been matched.
 * @extends {RollTerm}
 */
declare class StringTerm extends RollTerm {
    constructor({ term, options }?: {
        term: any;
        options: any;
    });
    term: any;
    /** @inheritdoc */
    get expression(): any;
    /** @inheritdoc */
    get total(): any;
    /** @inheritdoc */
    evaluate(options?: {}): void;
}
/**
 * A type of DiceTerm used to represent flipping a two-sided coin.
 * @implements {DiceTerm}
 */
declare class Coin extends DiceTerm implements DiceTerm {
    /** @inheritdoc */
    static MODIFIERS: {
        c: string;
    };
    constructor(termData: any);
    /** @inheritdoc */
    roll({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): {
        result: any;
        active: boolean;
    };
    /** @inheritdoc */
    getResultLabel(result: any): any;
    /** @inheritdoc */
    getResultCSS(result: any): string[];
    /**
     * Call the result of the coin flip, marking any coins that matched the called target as a success
     * 3dcc1      Flip 3 coins and treat "heads" as successes
     * 2dcc0      Flip 2 coins and treat "tails" as successes
     * @param {string} modifier     The matched modifier query
     */
    call(modifier: string): boolean;
}
/**
 * A type of DiceTerm used to represent rolling a fair n-sided die.
 * @implements {DiceTerm}
 *
 * @example Roll four six-sided dice
 * ```js
 * let die = new Die({faces: 6, number: 4}).evaluate();
 * ```
 */
declare class Die extends DiceTerm implements DiceTerm {
    /** @inheritdoc */
    static MODIFIERS: {
        r: string;
        rr: string;
        x: string;
        xo: string;
        k: string;
        kh: string;
        kl: string;
        d: string;
        dh: string;
        dl: string;
        min: string;
        max: string;
        even: string;
        odd: string;
        cs: string;
        cf: string;
        df: string;
        sf: string;
        ms: string;
    };
    constructor(termData?: {});
    /**
     * Re-roll the Die, rolling additional results for any values which fall within a target set.
     * If no target number is specified, re-roll the lowest possible result.
     *
     * 20d20r         reroll all 1s
     * 20d20r1        reroll all 1s
     * 20d20r=1       reroll all 1s
     * 20d20r1=1      reroll a single 1
     *
     * @param {string} modifier     The matched modifier query
     * @param {boolean} recursive   Reroll recursively, continuing to reroll until the condition is no longer met
     * @returns {boolean|void}      False if the modifier was unmatched
     */
    reroll(modifier: string, { recursive }?: boolean): boolean | void;
    /**
     * @see {@link Die#reroll}
     */
    rerollRecursive(modifier: any): boolean | void;
    /**
     * Explode the Die, rolling additional results for any values which match the target set.
     * If no target number is specified, explode the highest possible result.
     * Explosion can be a "small explode" using a lower-case x or a "big explode" using an upper-case "X"
     *
     * @param {string} modifier     The matched modifier query
     * @param {boolean} recursive   Explode recursively, such that new rolls can also explode?
     */
    explode(modifier: string, { recursive }?: boolean): boolean;
    /**
     * @see {@link Die#explode}
     */
    explodeOnce(modifier: any): boolean;
    /**
     * Keep a certain number of highest or lowest dice rolls from the result set.
     *
     * 20d20k       Keep the 1 highest die
     * 20d20kh      Keep the 1 highest die
     * 20d20kh10    Keep the 10 highest die
     * 20d20kl      Keep the 1 lowest die
     * 20d20kl10    Keep the 10 lowest die
     *
     * @param {string} modifier     The matched modifier query
     */
    keep(modifier: string): boolean;
    /**
     * Drop a certain number of highest or lowest dice rolls from the result set.
     *
     * 20d20d       Drop the 1 lowest die
     * 20d20dh      Drop the 1 highest die
     * 20d20dl      Drop the 1 lowest die
     * 20d20dh10    Drop the 10 highest die
     * 20d20dl10    Drop the 10 lowest die
     *
     * @param {string} modifier     The matched modifier query
     */
    drop(modifier: string): boolean;
    /**
     * Count the number of successful results which occurred in a given result set.
     * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
     * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
     *
     * 20d20cs      Count the number of dice which rolled a 20
     * 20d20cs>10   Count the number of dice which rolled higher than 10
     * 20d20cs<10   Count the number of dice which rolled less than 10
     *
     * @param {string} modifier     The matched modifier query
     */
    countSuccess(modifier: string): boolean;
    /**
     * Count the number of failed results which occurred in a given result set.
     * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
     * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
     *
     * 6d6cf      Count the number of dice which rolled a 1 as failures
     * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
     * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
     *
     * @param {string} modifier     The matched modifier query
     */
    countFailures(modifier: string): boolean;
    /**
     * Count the number of even results which occurred in a given result set.
     * Even numbers are marked as a success and counted as 1
     * Odd numbers are marked as a non-success and counted as 0.
     *
     * 6d6even    Count the number of even numbers rolled
     *
     * @param {string} modifier     The matched modifier query
     */
    countEven(modifier: string): void;
    /**
     * Count the number of odd results which occurred in a given result set.
     * Odd numbers are marked as a success and counted as 1
     * Even numbers are marked as a non-success and counted as 0.
     *
     * 6d6odd    Count the number of odd numbers rolled
     *
     * @param {string} modifier     The matched modifier query
     */
    countOdd(modifier: string): void;
    /**
     * Deduct the number of failures from the dice result, counting each failure as -1
     * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
     * Applying a deduct-failures modifier to the results counts all failed results as -1.
     *
     * 6d6df      Subtract the number of dice which rolled a 1 from the non-failed total.
     * 6d6cs>3df  Subtract the number of dice which rolled a 3 or less from the non-failed count.
     * 6d6cf<3df  Subtract the number of dice which rolled less than 3 from the non-failed count.
     *
     * @param {string} modifier     The matched modifier query
     */
    deductFailures(modifier: string): boolean;
    /**
     * Subtract the value of failed dice from the non-failed total, where each failure counts as its negative value.
     * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
     * Applying a deduct-failures modifier to the results counts all failed results as -1.
     *
     * 6d6df<3    Subtract the value of results which rolled less than 3 from the non-failed total.
     *
     * @param {string} modifier     The matched modifier query
     */
    subtractFailures(modifier: string): boolean;
    /**
     * Subtract the total value of the DiceTerm from a target value, treating the difference as the final total.
     * Example: 6d6ms>12    Roll 6d6 and subtract 12 from the resulting total.
     * @param {string} modifier     The matched modifier query
     */
    marginSuccess(modifier: string): boolean;
    /**
     * Constrain each rolled result to be at least some minimum value.
     * Example: 6d6min2    Roll 6d6, each result must be at least 2
     * @param {string} modifier     The matched modifier query
     */
    minimum(modifier: string): boolean;
    /**
     * Constrain each rolled result to be at most some maximum value.
     * Example: 6d6max5    Roll 6d6, each result must be at most 5
     * @param {string} modifier     The matched modifier query
     */
    maximum(modifier: string): boolean;
}
/**
 * A type of DiceTerm used to represent a three-sided Fate/Fudge die.
 * Mathematically behaves like 1d3-2
 * @extends {DiceTerm}
 */
declare class FateDie extends DiceTerm {
    /** @inheritdoc */
    static MODIFIERS: {
        r: (modifier: string, { recursive }?: boolean) => boolean | void;
        rr: (modifier: any) => boolean | void;
        k: (modifier: string) => boolean;
        kh: (modifier: string) => boolean;
        kl: (modifier: string) => boolean;
        d: (modifier: string) => boolean;
        dh: (modifier: string) => boolean;
        dl: (modifier: string) => boolean;
    };
    constructor(termData: any);
    /** @inheritdoc */
    roll({ minimize, maximize }?: {
        minimize?: boolean;
        maximize?: boolean;
    }): {
        result: any;
        active: boolean;
    };
    /** @inheritdoc */
    getResultLabel(result: any): any;
}
declare const ClientDatabaseBackend_base: typeof import("../../common/abstract/backend.mjs").default;
/**
 * The client-side database backend implementation which handles Document modification operations.
 */
declare class ClientDatabaseBackend extends ClientDatabaseBackend_base {
    /**
     * Perform a standardized pre-creation workflow for all Document types. For internal use only.
     * @param {typeof Document} documentClass
     * @param {SocketRequest} request
     * @param {User} user
     */
    static "__#118@#preCreateDocumentArray"(documentClass: typeof Document, request: SocketRequest, user: User): Promise<Document[]>;
    /**
     * Perform a standardized post-creation workflow for all Document types. For internal use only.
     * @param {DocumentCollection} collection
     * @param {object[]} result
     * @param {ClientDocument} parent
     * @param {string} pack
     * @param {object} options
     * @param {string} userId
     * @returns {Array<function():Document>} An array of callback operations performed after every Document is created
     */
    static "__#118@#postCreateDocumentCallbacks"(collection: DocumentCollection, result: object[], parent: ClientDocument, pack: string, options: object, userId: string): Array<() => Document>;
    /**
     * Perform a standardized pre-update workflow for all Document types.
     * @param {DocumentCollection} collection
     * @param {SocketRequest} request
     * @param {User} user
     */
    static "__#118@#preUpdateDocumentArray"(collection: DocumentCollection, request: SocketRequest, user: User): Promise<any[]>;
    /**
     * Perform a standardized post-update workflow for all Document types.
     * @param {DocumentCollection} collection
     * @param {object[]} result
     * @param {object} options
     * @param {string} userId
     * @returns {Array<function():Document>} An array of callback operations performed after every Document is updated
     */
    static "__#118@#postUpdateDocumentCallbacks"(collection: DocumentCollection, result: object[], options: object, userId: string): Array<() => Document>;
    /**
     * Perform a standardized pre-delete workflow for all Document types.
     * @param {DocumentCollection} collection
     * @param {string[]} ids
     * @param {object} options
     * @param {User} user
     */
    static "__#118@#preDeleteDocumentArray"(collection: DocumentCollection, ids: string[], options: object, user: User): Promise<string[]>;
    /**
     * Perform a standardized post-deletion workflow for all Document types.
     * @param {DocumentCollection} collection
     * @param {string[]} ids
     * @param {object} options
     * @param {string} userId
     * @returns {Array<function():Document>} An array of callback operations performed after every Document is deleted
     */
    static "__#118@#postDeleteDocumentCallbacks"(collection: DocumentCollection, ids: string[], options: object, userId: string): Array<() => Document>;
    /**
     * Get the parent document for given request from its provided UUID, if any.
     * @param {string|null} uuid          The parent document UUID, or null
     * @param {object} [options]          Options which customize how the parent document is retrieved by UUID
     * @returns {Promise<ClientDocument>} The parent document for the transaction
     */
    static "__#118@#getParent"(uuid: string | null, options?: object): Promise<ClientDocument>;
    /**
     * Obtain the document collection for a given Document type, parent, and compendium pack.
     * @param {string} documentName           The Document name
     * @param {ClientDocument|null} parent    A parent Document, if applicable
     * @param {string} pack                   A compendium pack identifier, if applicable
     * @returns {DocumentCollection|CompendiumCollection}  The relevant collection instance for this request
     */
    static "__#118@#getCollection"(documentName: string, parent: ClientDocument | null, pack: string): DocumentCollection | CompendiumCollection;
    /**
     * Build a CRUD request.
     * @param {SocketRequest} request  The initial request data.
     * @returns {SocketRequest}
     */
    static "__#118@#buildRequest"({ documentClass, action, data, updates, ids, options, pack, parent }: SocketRequest): SocketRequest;
    /**
     * Build a CRUD response.
     * @param {object} response                      The response data.
     * @param {string} response.action               The type of response.
     * @param {ClientDocument[]} response.documents  The initial response result.
     * @param {object} response.options              The response options.
     * @returns {ClientDocument[]}
     */
    static "__#118@#buildResponse"({ action, documents, options }: {
        action: string;
        documents: ClientDocument[];
        options: object;
    }): ClientDocument[];
    /**
     * Retrieve a Document's Token ancestor, if it exists.
     * @param {ClientDocument} parent   The parent Document
     * @returns {TokenDocument|null}    The Token ancestor, or null
     */
    static "__#118@#getTokenAncestor"(parent: ClientDocument): TokenDocument | null;
    /** @inheritdoc */
    _getDocuments(documentClass: any, { query, options, pack }: {
        query: any;
        options: any;
        pack: any;
    }, user: any): Promise<any>;
    /** @inheritdoc */
    _createDocuments(documentClass: any, context: any, user: any): Promise<any>;
    /** @inheritdoc */
    _updateDocuments(documentClass: any, context: any, user: any): Promise<Document[]>;
    /** @inheritdoc */
    _deleteDocuments(documentClass: any, context: any, user: any): Promise<Document[]>;
    /**
     * Activate the Socket event listeners used to receive responses from events which modify database documents
     * @param {Socket} socket   The active game socket
     */
    activateSocketListeners(socket: Socket): void;
    /** @inheritdoc */
    getFlagScopes(): any[];
    /** @inheritdoc */
    getCompendiumScopes(): any[];
    #private;
}
/**
 * An abstract subclass of the Collection container which defines a collection of Document instances.
 * @extends {Collection}
 * @abstract
 *
 * @param {object[]} data      An array of data objects from which to create document instances
 */
declare class DocumentCollection {
    /**
     * The base Document type which is contained within this DocumentCollection
     * @type {string}
     */
    static documentName: string;
    /**
     * The cache of search fields for each data model
     * @type {Map<string, Set<string>>}
     */
    static "__#119@#dataModelSearchFieldsCache": Map<string, Set<string>>;
    /**
     * Get the searchable fields for a given document or index, based on its data model
     * @param {string} documentName         The document type name
     * @param {string} [documentSubtype=""] The document subtype name
     * @param {boolean} [isEmbedded=false]  Whether the document is an embedded object
     * @returns {Set<string>}               The dot-delimited property paths of searchable fields
     */
    static getSearchableFields(documentName: string, documentSubtype?: string, isEmbedded?: boolean): Set<string>;
    constructor(data?: any[]);
    /**
     * An Array of application references which will be automatically updated when the collection content changes
     * @type {Application[]}
     */
    apps: Application[];
    /**
     * Initialize the DocumentCollection by constructing any initially provided Document instances
     * @private
     */
    private _initialize;
    /**
     * A reference to the Document class definition which is contained within this DocumentCollection.
     * @type {Function}
     */
    get documentClass(): Function;
    /** @inheritdoc */
    get documentName(): any;
    /**
     * Record the set of document ids where the Document was not initialized because of invalid source data
     * @type {Set<string>}
     */
    invalidDocumentIds: Set<string>;
    /**
     * The Collection class name
     * @type {string}
     */
    get name(): string;
    /**
     * Instantiate a Document for inclusion in the Collection.
     * @param {object} data       The Document data.
     * @param {object} [context]  Document creation context.
     * @returns {Document}
     */
    createDocument(data: object, context?: object): Document;
    /**
     * Obtain a temporary Document instance for a document id which currently has invalid source data.
     * @param {string} id                      A document ID with invalid source data.
     * @param {object} [options]               Additional options to configure retrieval.
     * @param {boolean} [options.strict=true]  Throw an Error if the requested ID is not in the set of invalid IDs for
     *                                         this collection.
     * @returns {Document}                     An in-memory instance for the invalid Document
     * @throws If strict is true and the requested ID is not in the set of invalid IDs for this collection.
     */
    getInvalid(id: string, { strict }?: {
        strict?: boolean;
    }): Document;
    /**
     * Get an element from the DocumentCollection by its ID.
     * @param {string} id                        The ID of the Document to retrieve.
     * @param {object} [options]                 Additional options to configure retrieval.
     * @param {boolean} [options.strict=false]   Throw an Error if the requested Document does not exist.
     * @param {boolean} [options.invalid=false]  Allow retrieving an invalid Document.
     * @returns {Document}
     * @throws If strict is true and the Document cannot be found.
     */
    get(id: string, { invalid, strict }?: {
        strict?: boolean;
        invalid?: boolean;
    }): Document;
    /** @inheritdoc */
    set(id: any, document: any): void;
    /** @inheritdoc */
    delete(id: any): void;
    /**
     * Render any Applications associated with this DocumentCollection.
     */
    render(force: any, options: any): void;
    /**
     * Find all Documents which match a given search term using a full-text search against their indexed HTML fields and their name.
     * If filters are provided, results are filtered to only those that match the provided values.
     * @param {object} search                      An object configuring the search
     * @param {string} [search.query]              A case-insensitive search string
     * @param {FieldFilter[]} [search.filters]     An array of filters to apply
     * @param {string[]} [search.exclude]          An array of document IDs to exclude from search results
     * @returns {string[]}
     */
    search({ query, filters, exclude }: {
        query?: string;
        filters?: FieldFilter[];
        exclude?: string[];
    }): string[];
    /**
     * Update all objects in this DocumentCollection with a provided transformation.
     * Conditionally filter to only apply to Entities which match a certain condition.
     * @param {Function|object} transformation    An object of data or function to apply to all matched objects
     * @param {Function|null}  condition          A function which tests whether to target each object
     * @param {object} [options]                  Additional options passed to Document.update
     * @return {Promise<Document[]>}              An array of updated data once the operation is complete
     */
    updateAll(transformation: Function | object, condition?: Function | null, options?: object): Promise<Document[]>;
    /**
     * Preliminary actions taken before a set of Documents in this Collection are created.
     * @param {object[]} result       An Array of created data objects
     * @param {object} options        Options which modified the creation operation
     * @param {string} userId         The ID of the User who triggered the operation
     * @internal
     */
    _preCreateDocuments(result: object[], options: object, userId: string): void;
    /**
     * Follow-up actions taken after a set of Documents in this Collection are created.
     * @param {Document[]} documents  An Array of created Documents
     * @param {object[]} result       An Array of created data objects
     * @param {object} options        Options which modified the creation operation
     * @param {string} userId         The ID of the User who triggered the operation
     * @internal
     */
    _onCreateDocuments(documents: Document[], result: object[], options: object, userId: string): void;
    /**
     * Preliminary actions taken before a set of Documents in this Collection are updated.
     * @param {object[]} result       An Array of incremental data objects
     * @param {object} options        Options which modified the update operation
     * @param {string} userId         The ID of the User who triggered the operation
     * @internal
     */
    _preUpdateDocuments(result: object[], options: object, userId: string): void;
    /**
     * Follow-up actions taken after a set of Documents in this Collection are updated.
     * @param {Document[]} documents  An Array of updated Documents
     * @param {object[]} result       An Array of incremental data objects
     * @param {object} options        Options which modified the update operation
     * @param {string} userId         The ID of the User who triggered the operation
     * @internal
     */
    _onUpdateDocuments(documents: Document[], result: object[], options: object, userId: string): void;
    /**
     * Preliminary actions taken before a set of Documents in this Collection are deleted.
     * @param {string[]} result       An Array of document IDs being deleted
     * @param {object} options        Options which modified the deletion operation
     * @param {string} userId         The ID of the User who triggered the operation
     * @internal
     */
    _preDeleteDocuments(result: string[], options: object, userId: string): void;
    /**
     * Follow-up actions taken after a set of Documents in this Collection are deleted.
     * @param {Document[]} documents  An Array of deleted Documents
     * @param {string[]} result       An Array of document IDs being deleted
     * @param {object} options        Options which modified the deletion operation
     * @param {string} userId         The ID of the User who triggered the operation
     * @internal
     */
    _onDeleteDocuments(documents: Document[], result: string[], options: object, userId: string): void;
    /**
     * Handle shifting documents in a deleted folder to a new parent folder.
     * @param {Folder} parentFolder     The parent folder to which documents should be shifted
     * @param {string} deleteFolderId   The ID of the folder being deleted
     * @param {boolean} deleteContents  Whether to delete the contents of the folder
     * @returns {string[]}              An array of document IDs to deleted
     * @internal
     */
    _onDeleteFolder(parentFolder: Folder, deleteFolderId: string, deleteContents: boolean): string[];
    /**
     * Generate the render context information provided for CRUD operations.
     * @param {string} action           The CRUD operation.
     * @param {Document[]} documents    The documents being operated on.
     * @param {object[]|string[]} data  An array of creation or update objects, or an array of document IDs, depending on
     *                                  the operation.
     * @returns {{action: string, documentType: string, documents: Document[], data: object[]|string[]}}
     * @private
     */
    private _getRenderContext;
}
/**
 * A collection of world-level Document objects with a singleton instance per primary Document type.
 * Each primary Document type has an associated subclass of WorldCollection which contains them.
 * @extends {DocumentCollection}
 * @abstract
 * @see {Game#collections}
 *
 * @param {object[]} data      An array of data objects from which to create Document instances
 */
declare class WorldCollection extends DocumentCollection {
    /**
     * Return a reference to the singleton instance of this WorldCollection, or null if it has not yet been created.
     * @type {WorldCollection}
     */
    static get instance(): WorldCollection;
    /**
     * Register a Document sheet class as a candidate which can be used to display Documents of a given type.
     * See {@link DocumentSheetConfig.registerSheet} for details.
     * @static
     * @param {Array<*>} args      Arguments forwarded to the DocumentSheetConfig.registerSheet method
     *
     * @example Register a new ActorSheet subclass for use with certain Actor types.
     * ```js
     * Actors.registerSheet("dnd5e", ActorSheet5eCharacter, { types: ["character], makeDefault: true });
     * ```
     */
    static registerSheet(...args: Array<any>): void;
    /**
     * Unregister a Document sheet class, removing it from the list of available sheet Applications to use.
     * See {@link DocumentSheetConfig.unregisterSheet} for detauls.
     * @static
     * @param {Array<*>} args      Arguments forwarded to the DocumentSheetConfig.unregisterSheet method
     *
     * @example Deregister the default ActorSheet subclass to replace it with others.
     * ```js
     * Actors.unregisterSheet("core", ActorSheet);
     * ```
     */
    static unregisterSheet(...args: Array<any>): void;
    /**
     * Return an array of currently registered sheet classes for this Document type.
     * @static
     * @type {DocumentSheet[]}
     */
    static get registeredSheets(): DocumentSheet[];
    /**
     * Reference the set of Folders which contain documents in this collection
     * @type {Collection<string, Folder>}
     */
    get folders(): Collection<string, Folder>;
    /**
     * Return a reference to the SidebarDirectory application for this WorldCollection.
     * @type {DocumentDirectory}
     */
    get directory(): DocumentDirectory;
    /** @override */
    override _getVisibleTreeContents(entry: any): any;
    /**
     * Import a Document from a Compendium collection, adding it to the current World.
     * @param {CompendiumCollection} pack The CompendiumCollection instance from which to import
     * @param {string} id             The ID of the compendium entry to import
     * @param {object} [updateData]   Optional additional data used to modify the imported Document before it is created
     * @param {object} [options]      Optional arguments passed to the {@link WorldCollection#fromCompendium} and
     *                                {@link Document.create} methods
     * @returns {Promise<Document>}   The imported Document instance
     */
    importFromCompendium(pack: CompendiumCollection, id: string, updateData?: object, options?: object): Promise<Document>;
    /**
     * Apply data transformations when importing a Document from a Compendium pack
     * @param {Document|object} document    The source Document, or a plain data object
     * @param {object} [options]            Additional options which modify how the document is imported
     * @param {boolean} [options.addFlags=true]         Add flags which track the import source
     * @param {boolean} [options.clearFolder=false]     Clear the currently assigned folder
     * @param {boolean} [options.clearSort=true]        Clear the currently assigned folder and sort order
     * @param {boolean} [options.clearOwnership=true]   Clear document ownership
     * @param {boolean} [options.keepId=false]          Retain the Document id from the source Compendium
     * @returns {object}                    The processed data ready for world Document creation
     */
    fromCompendium(document: Document | object, { addFlags, clearFolder, clearSort, clearOwnership, keepId }?: {
        addFlags?: boolean;
        clearFolder?: boolean;
        clearSort?: boolean;
        clearOwnership?: boolean;
        keepId?: boolean;
    }): object;
}
/**
 * The singleton collection of Actor documents which exist within the active World.
 * This Collection is accessible within the Game object as game.actors.
 * @extends {WorldCollection}
 * @category - Collections
 *
 * @see {@link Actor} The Actor document
 * @see {@link ActorDirectory} The ActorDirectory sidebar directory
 *
 * @example Retrieve an existing Actor by its id
 * ```js
 * let actor = game.actors.get(actorId);
 * ```
 */
declare class Actors extends WorldCollection {
    /**
     * A mapping of synthetic Token Actors which are currently active within the viewed Scene.
     * Each Actor is referenced by the Token.id.
     * @type {Object<string, Actor>}
     */
    get tokens(): {
        [x: string]: Actor;
    };
    /** @inheritdoc */
    fromCompendium(document: any, options?: {}): any;
}
/**
 * The collection of Cards documents which exist within the active World.
 * This Collection is accessible within the Game object as game.cards.
 * @extends {WorldCollection}
 * @see {@link Cards} The Cards document
 */
declare class CardStacks extends WorldCollection {
}
/**
 * The singleton collection of Combat documents which exist within the active World.
 * This Collection is accessible within the Game object as game.combats.
 * @extends {WorldCollection}
 *
 * @see {@link Combat} The Combat document
 * @see {@link CombatTracker} The CombatTracker sidebar directory
 */
declare class CombatEncounters extends WorldCollection {
    /**
     * Provide the settings object which configures the Combat document
     * @type {object}
     */
    static get settings(): any;
    /** @inheritdoc */
    get directory(): any;
    /**
     * Get an Array of Combat instances which apply to the current canvas scene
     * @type {Combat[]}
     */
    get combats(): Combat[];
    /**
     * The currently active Combat instance
     * @type {Combat}
     */
    get active(): Combat;
    /**
     * The currently viewed Combat encounter
     * @type {Combat|null}
     */
    get viewed(): Combat;
    /**
     * When a Token is deleted, remove it as a combatant from any combat encounters which included the Token
     * @param {string} sceneId      The Scene id within which a Token is being deleted
     * @param {string} tokenId      The Token id being deleted
     * @protected
     */
    protected _onDeleteToken(sceneId: string, tokenId: string): Promise<void>;
}
/**
 * @typedef {SocketRequest} ManageCompendiumRequest
 * @property {string} action                      The request action.
 * @property {PackageCompendiumData|string} data  The compendium creation data, or the ID of the compendium to delete.
 * @property {object} [options]                   Additional options.
 */
/**
 * @typedef {SocketResponse} ManageCompendiumResponse
 * @property {ManageCompendiumRequest} request      The original request.
 * @property {PackageCompendiumData|string} result  The compendium creation data, or the collection name of the
 *                                                  deleted compendium.
 */
/**
 * A collection of Document objects contained within a specific compendium pack.
 * Each Compendium pack has its own associated instance of the CompendiumCollection class which contains its contents.
 * @extends {DocumentCollection}
 * @abstract
 * @see {Game#packs}
 *
 * @param {object} metadata   The compendium metadata, an object provided by game.data
 */
declare class CompendiumCollection extends DocumentCollection {
    /**
     * The amount of time that Document instances within this CompendiumCollection are held in memory.
     * Accessing the contents of the Compendium pack extends the duration of this lifetime.
     * @type {number}
     */
    static CACHE_LIFETIME_SECONDS: number;
    /**
     * The named game setting which contains Compendium configurations.
     * @type {string}
     */
    static CONFIG_SETTING: string;
    /** @override */
    static override _sortStandard(a: any, b: any): number;
    /**
     * Activate the Socket event listeners used to receive responses to compendium management events.
     * @param {Socket} socket  The active game socket.
     * @internal
     */
    static _activateSocketListeners(socket: Socket): void;
    /**
     * Create a new Compendium Collection using provided metadata.
     * @param {object} metadata   The compendium metadata used to create the new pack
     * @param {object} options   Additional options which modify the Compendium creation request
     * @returns {Promise<CompendiumCollection>}
     */
    static createCompendium(metadata: object, options?: object): Promise<CompendiumCollection>;
    /**
     * Handle a response from the server where a compendium was created.
     * @param {ManageCompendiumResponse} response  The server response.
     * @returns {CompendiumCollection}
     */
    static "__#120@#handleCreateCompendium"({ result }: SocketResponse): CompendiumCollection;
    /**
     * Handle a response from the server where a compendium was deleted.
     * @param {ManageCompendiumResponse} response  The server response.
     * @returns {CompendiumCollection}
     */
    static "__#120@#handleDeleteCompendium"({ result }: SocketResponse): CompendiumCollection;
    constructor(metadata: any);
    /**
     * The compendium metadata which defines the compendium content and location
     * @type {object}
     */
    metadata: object;
    /**
     * A subsidiary collection which contains the more minimal index of the pack
     * @type {Collection<string, object>}
     */
    index: Collection<string, any>;
    /**
     * A debounced function which will clear the contents of the Compendium pack if it is not accessed frequently.
     * @type {Function}
     * @private
     */
    private _flush;
    /**
     * The canonical Compendium name - comprised of the originating package and the pack name
     * @type {string}
     */
    get collection(): string;
    /**
     * The banner image for this Compendium pack, or the default image for the pack type if no image is set.
     * @returns {string}
     */
    get banner(): string;
    /**
     * A reference to the Application class which provides an interface to interact with this compendium content.
     * @type {typeof Application}
     */
    applicationClass: typeof Application;
    get folders(): CompendiumFolderCollection;
    /** @override */
    override get maxFolderDepth(): number;
    /**
     * Get the Folder that this Compendium is displayed within
     * @returns {Folder|null}
     */
    get folder(): Folder;
    /**
     * Assign this CompendiumCollection to be organized within a specific Folder.
     * @param {Folder|string|null} folder     The desired Folder within the World or null to clear the folder
     * @returns {Promise<void>}               A promise which resolves once the transaction is complete
     */
    setFolder(folder: Folder | string | null): Promise<void>;
    /**
     * Get the sort order for this Compendium
     * @returns {number}
     */
    get sort(): number;
    /** @override */
    override _getVisibleTreeContents(): any;
    /**
     * Access the compendium configuration data for this pack
     * @type {object}
     */
    get config(): any;
    /**
     * Track whether the Compendium Collection is locked for editing
     * @type {boolean}
     */
    get locked(): boolean;
    /**
     * The visibility configuration of this compendium pack.
     * A value in CONST.USER_ROLES
     * @type {number}
     */
    get ownership(): number;
    /**
     * Is this Compendium pack visible to the current game User?
     * @type {boolean}
     */
    get visible(): boolean;
    /**
     * A convenience reference to the label which should be used as the title for the Compendium pack.
     * @type {string}
     */
    get title(): string;
    /**
     * The index fields which should be loaded for this compendium pack
     * @type {Set<string>}
     */
    get indexFields(): Set<string>;
    /**
     * Has this compendium pack been fully indexed?
     * @type {boolean}
     */
    get indexed(): boolean;
    /** @inheritdoc */
    get(key: any, options: any): Document;
    /**
     * Load the Compendium index and cache it as the keys and values of the Collection.
     * @param {object} [options]    Options which customize how the index is created
     * @param {string[]} [options.fields]  An array of fields to return as part of the index
     * @returns {Promise<Collection>}
     */
    getIndex({ fields }?: {
        fields?: string[];
    }): Promise<Collection>;
    /**
     * Get a single Document from this Compendium by ID.
     * The document may already be locally cached, otherwise it is retrieved from the server.
     * @param {string} id               The requested Document id
     * @returns {Promise<Document>|undefined}     The retrieved Document instance
     */
    getDocument(id: string): Promise<Document> | undefined;
    /**
     * Load multiple documents from the Compendium pack using a provided query object.
     * @param {object} query            A database query used to retrieve documents from the underlying database
     * @returns {Promise<Document[]>}   The retrieved Document instances
     */
    getDocuments(query?: object): Promise<Document[]>;
    /**
     * Get the ownership level that a User has for this Compendium pack.
     * @param {documents.User} user     The user being tested
     * @returns {number}                The ownership level in CONST.DOCUMENT_OWNERSHIP_LEVELS
     */
    getUserLevel(user?: documents.User): number;
    /**
     * Test whether a certain User has a requested permission level (or greater) over the Compendium pack
     * @param {documents.BaseUser} user       The User being tested
     * @param {string|number} permission      The permission level from DOCUMENT_OWNERSHIP_LEVELS to test
     * @param {object} options                Additional options involved in the permission test
     * @param {boolean} [options.exact=false]     Require the exact permission level requested?
     * @returns {boolean}                      Does the user have this permission level over the Compendium pack?
     */
    testUserPermission(user: documents.BaseUser, permission: string | number, { exact }?: {
        exact?: boolean;
    }): boolean;
    /**
     * Import a Document into this Compendium Collection.
     * @param {Document} document     The existing Document you wish to import
     * @param {object} [options]      Additional options which modify how the data is imported.
     *                                See {@link ClientDocumentMixin#toCompendium}
     * @returns {Promise<Document>}   The imported Document instance
     */
    importDocument(document: Document, options?: object): Promise<Document>;
    /**
     * Import a Folder into this Compendium Collection.
     * @param {Folder} folder                         The existing Folder you wish to import
     * @param {object} [options]                      Additional options which modify how the data is imported.
     * @param {boolean} [options.importParents=true]  Import any parent folders which are not already present in the Compendium
     * @returns {Promise<void>}
     */
    importFolder(folder: Folder, { importParents, ...options }?: {
        importParents?: boolean;
    }): Promise<void>;
    /**
     * Import an array of Folders into this Compendium Collection.
     * @param {Folder[]} folders                      The existing Folders you wish to import
     * @param {object} [options]                      Additional options which modify how the data is imported.
     * @param {boolean} [options.importParents=true]  Import any parent folders which are not already present in the Compendium
     * @returns {Promise<void>}
     */
    importFolders(folders: Folder[], { importParents, ...options }?: {
        importParents?: boolean;
    }): Promise<void>;
    /**
     * Fully import the contents of a Compendium pack into a World folder.
     * @param {object} [options={}]     Options which modify the import operation. Additional options are forwarded to
     *                                  {@link WorldCollection#fromCompendium} and {@link Document.createDocuments}
     * @param {string|null} [options.folderId]  An existing Folder _id to use.
     * @param {string} [options.folderName]     A new Folder name to create.
     * @returns {Promise<Document[]>}   The imported Documents, now existing within the World
     */
    importAll({ folderId, folderName, ...options }?: {
        folderId?: string | null;
        folderName?: string;
    }): Promise<Document[]>;
    /**
     * Provide a dialog form that prompts the user to import the full contents of a Compendium pack into the World.
     * @param {object} [options={}] Additional options passed to the Dialog.confirm method
     * @returns {Promise<Document[]|boolean|null>} A promise which resolves in the following ways: an array of imported
     *                            Documents if the "yes" button was pressed, false if the "no" button was pressed, or
     *                            null if the dialog was closed without making a choice.
     */
    importDialog(options?: object): Promise<Document[] | boolean | null>;
    /**
     * Add a Document to the index, capturing its relevant index attributes
     * @param {Document} document       The document to index
     */
    indexDocument(document: Document): void;
    /**
     * Prompt the gamemaster with a dialog to configure ownership of this Compendium pack.
     * @returns {Promise<Object<string>>}   The configured ownership for the pack
     */
    configureOwnershipDialog(): Promise<any>;
    /**
     * Generate a UUID for a given primary document ID within this Compendium pack
     * @param {string} id     The document ID to generate a UUID for
     * @returns {string}      The generated UUID, in the form of "Compendium.<collection>.<documentName>.<id>"
     */
    getUuid(id: string): string;
    /**
     * Assign configuration metadata settings to the compendium pack
     * @param {object} configuration  The object of compendium settings to define
     * @returns {Promise}             A Promise which resolves once the setting is updated
     */
    configure(configuration?: object): Promise<any>;
    /**
     * Delete an existing world-level Compendium Collection.
     * This action may only be performed for world-level packs by a Gamemaster User.
     * @returns {Promise<CompendiumCollection>}
     */
    deleteCompendium(): Promise<CompendiumCollection>;
    /**
     * Duplicate a compendium pack to the current World.
     * @param {string} label    A new Compendium label
     * @returns {Promise<CompendiumCollection>}
     */
    duplicateCompendium({ label }?: string): Promise<CompendiumCollection>;
    /**
     * Migrate a compendium pack.
     * This operation re-saves all documents within the compendium pack to disk, applying the current data model.
     * If the document type has system data, the latest system data template will also be applied to all documents.
     * @returns {Promise<CompendiumCollection>}
     */
    migrate(): Promise<CompendiumCollection>;
    /** @inheritdoc */
    updateAll(transformation: any, condition?: any, options?: {}): Promise<Document[]>;
    /** @inheritdoc */
    _onCreateDocuments(documents: any, result: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onUpdateDocuments(documents: any, result: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDeleteDocuments(documents: any, result: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDeleteFolder(parentFolder: any, deleteFolderId: any, deleteContents: any): any[];
    /**
     * Follow-up actions taken when Documents within this Compendium pack are modified
     * @private
     */
    private _onModifyContents;
    /**
     * @deprecated since v11
     * @ignore
     */
    get private(): boolean;
    /**
     * @deprecated since v11
     * @ignore
     */
    get isOpen(): boolean;
    #private;
}
/**
 * A Collection of Compendium Folders
 * @extends {DocumentCollection}
 * @type {DocumentCollection}
 */
declare class CompendiumFolderCollection extends DocumentCollection {
    constructor(pack: any, data?: any[]);
    /**
     * The CompendiumPack instance which contains this CompendiumFolderCollection
     * @type {CompendiumPack}
     */
    pack: CompendiumPack;
    /** @inheritdoc */
    get documentName(): string;
}
declare class CompendiumPacks {
    /** @override */
    static override _sortAlphabetical(a: any, b: any): any;
    /**
     * Get a Collection of Folders which contain Compendium Packs
     * @returns {Collection<Folder>}
     */
    get folders(): Collection<Folder>;
    /** @override */
    override _getVisibleTreeContents(): any;
}
/**
 * The singleton collection of FogExploration documents which exist within the active World.
 * @extends {WorldCollection}
 * @see {@link FogExploration} The FogExploration document
 */
declare class FogExplorations extends WorldCollection {
    /**
     * Activate Socket event listeners to handle for fog resets
     * @param {Socket} socket     The active web socket connection
     * @internal
     */
    static _activateSocketListeners(socket: Socket): void;
}
/**
 * The singleton collection of Folder documents which exist within the active World.
 * This Collection is accessible within the Game object as game.folders.
 * @extends {WorldCollection}
 *
 * @see {@link Folder} The Folder document
 */
declare class Folders extends WorldCollection {
    constructor(...args: any[]);
    /**
     * Track which Folders are currently expanded in the UI
     */
    _expanded: {};
    /** @override */
    override render(force: any, context: any): any;
    /**
     * Refresh the display of any active JournalSheet instances where the folder list will change.
     * @private
     */
    private _refreshJournalEntrySheets;
}
/**
 * The singleton collection of Item documents which exist within the active World.
 * This Collection is accessible within the Game object as game.items.
 * @extends {WorldCollection}
 *
 * @see {@link Item} The Item document
 * @see {@link ItemDirectory} The ItemDirectory sidebar directory
 */
declare class Items extends WorldCollection {
}
/**
 * The singleton collection of JournalEntry documents which exist within the active World.
 * This Collection is accessible within the Game object as game.journal.
 * @extends {WorldCollection}
 *
 * @see {@link JournalEntry} The JournalEntry document
 * @see {@link JournalDirectory} The JournalDirectory sidebar directory
 */
declare class Journal extends WorldCollection {
    /**
     * Display a dialog which prompts the user to show a JournalEntry or JournalEntryPage to other players.
     * @param {JournalEntry|JournalEntryPage} doc  The JournalEntry or JournalEntryPage to show.
     * @returns {Promise<JournalEntry|JournalEntryPage|void>}
     */
    static showDialog(doc: JournalEntry | JournalEntryPage): Promise<JournalEntry | JournalEntryPage | void>;
    /**
     * Show the JournalEntry or JournalEntryPage to connected players.
     * By default, the document will only be shown to players who have permission to observe it.
     * If the force parameter is passed, the document will be shown to all players regardless of normal permission.
     * @param {JournalEntry|JournalEntryPage} doc  The JournalEntry or JournalEntryPage to show.
     * @param {object} [options]                   Additional options to configure behaviour.
     * @param {boolean} [options.force=false]      Display the entry to all players regardless of normal permissions.
     * @param {string[]} [options.users]           An optional list of user IDs to show the document to. Otherwise it will
     *                                             be shown to all connected clients.
     * @returns {Promise<JournalEntry|JournalEntryPage>}  A Promise that resolves back to the shown document once the
     *                                                    request is processed.
     * @throws If the user does not own the document they are trying to show.
     */
    static show(doc: JournalEntry | JournalEntryPage, { force, users }?: {
        force?: boolean;
        users?: string[];
    }): Promise<JournalEntry | JournalEntryPage>;
    /**
     * Share an image with connected players.
     * @param {string} src                 The image URL to share.
     * @param {ShareImageConfig} [config]  Image sharing configuration.
     */
    static showImage(src: string, { users, ...options }?: {
        /**
         * The image URL to share.
         */
        image: string;
        /**
         * The image title.
         */
        title: string;
        /**
         * The UUID of a Document related to the image, used to determine permission to see
         *         the image title.
         */
        uuid?: string;
        /**
         * If this is provided, the permissions of the related Document will be ignored and
         *   the title will be shown based on this parameter.
         */
        showTitle?: boolean;
        /**
         * A list of user IDs to show the image to.
         */
        users?: string[];
    }): void;
    /**
     * Open Socket listeners which transact JournalEntry data
     * @param {Socket} socket       The open websocket
     */
    static _activateSocketListeners(socket: Socket): void;
    /**
     * Handle a received request to show a JournalEntry or JournalEntryPage to the current client
     * @param {string} uuid            The UUID of the document to display for other players
     * @param {boolean} [force=false]  Display the document regardless of normal permissions
     * @internal
     */
    static _showEntry(uuid: string, force?: boolean): Promise<void>;
}
/**
 * The singleton collection of Macro documents which exist within the active World.
 * This Collection is accessible within the Game object as game.macros.
 * @extends {WorldCollection}
 *
 * @see {@link Macro} The Macro document
 * @see {@link MacroDirectory} The MacroDirectory sidebar directory
 */
declare class Macros extends WorldCollection {
    /** @override */
    override get directory(): any;
    /** @inheritdoc */
    fromCompendium(document: any, options?: {}): any;
}
/**
 * The singleton collection of ChatMessage documents which exist within the active World.
 * This Collection is accessible within the Game object as game.messages.
 * @extends {WorldCollection}
 *
 * @see {@link ChatMessage} The ChatMessage document
 * @see {@link ChatLog} The ChatLog sidebar directory
 */
declare class Messages extends WorldCollection {
    /**
     * @override
     * @returns {SidebarTab}
     * */
    override get directory(): SidebarTab;
    /** @override */
    override render(force?: boolean): void;
    /**
     * If requested, dispatch a Chat Bubble UI for the newly created message
     * @param {ChatMessage} message     The ChatMessage document to say
     * @private
     */
    private sayBubble;
    /**
     * Handle export of the chat log to a text file
     * @private
     */
    private export;
    /**
     * Allow for bulk deletion of all chat messages, confirm first with a yes/no dialog.
     * @see {@link Dialog.confirm}
     */
    flush(): Promise<any>;
}
/**
 * The singleton collection of Playlist documents which exist within the active World.
 * This Collection is accessible within the Game object as game.playlists.
 * @extends {WorldCollection}
 *
 * @see {@link Playlist} The Playlist document
 * @see {@link PlaylistDirectory} The PlaylistDirectory sidebar directory
 */
declare class Playlists extends WorldCollection {
    constructor(...args: any[]);
    /**
     * Return the subset of Playlist documents which are currently playing
     * @type {Playlist[]}
     */
    get playing(): Playlist[];
    /**
     * Perform one-time initialization to begin playback of audio
     */
    initialize(): void;
    /**
     * Handle changes to a Scene to determine whether to trigger changes to Playlist documents.
     * @param {Scene} scene       The Scene document being updated
     * @param {Object} data       The incremental update data
     */
    _onChangeScene(scene: Scene, data: any): Promise<void>;
}
/**
 * The singleton collection of Scene documents which exist within the active World.
 * This Collection is accessible within the Game object as game.scenes.
 * @extends {WorldCollection}
 *
 * @see {@link Scene} The Scene document
 * @see {@link SceneDirectory} The SceneDirectory sidebar directory
 */
declare class Scenes extends WorldCollection {
    /** @override */
    static override _activateSocketListeners(socket: any): void;
    /**
     * Handle requests pulling the current User to a specific Scene
     * @param {string} sceneId
     * @private
     */
    private static _pullToScene;
    /**
     * Return a reference to the Scene which is currently active
     * @type {Scene}
     */
    get active(): Scene;
    /**
     * Return the current Scene target.
     * This is the viewed scene if the canvas is active, otherwise it is the currently active scene.
     * @type {Scene}
     */
    get current(): Scene;
    /**
     * Return a reference to the Scene which is currently viewed
     * @type {Scene}
     */
    get viewed(): Scene;
    /**
     * Handle preloading the art assets for a Scene
     * @param {string} sceneId    The Scene id to begin loading
     * @param {boolean} push      Trigger other connected clients to also preload Scene resources
     */
    preload(sceneId: string, push?: boolean): Promise<any>;
    /** @inheritdoc */
    fromCompendium(document: any, options?: {}): any;
}
/**
 * The Collection of Setting documents which exist within the active World.
 * This collection is accessible as game.settings.storage.get("world")
 * @extends {WorldCollection}
 *
 * @see {@link Setting} The Setting document
 */
declare class WorldSettings extends WorldCollection {
    /** @override */
    override get directory(): any;
    /**
     * Return the Setting document with the given key.
     * @param {string} key        The setting key
     * @returns {Setting}         The Setting
     */
    getSetting(key: string): Setting;
    /**
     * Return the serialized value of the world setting as a string
     * @param {string} key    The setting key
     * @returns {string|null}  The serialized setting string
     */
    getItem(key: string): string | null;
}
/**
 * The singleton collection of RollTable documents which exist within the active World.
 * This Collection is accessible within the Game object as game.tables.
 * @extends {WorldCollection}
 *
 * @see {@link RollTable} The RollTable document
 * @see {@link RollTableDirectory} The RollTableDirectory sidebar directory
 */
declare class RollTables extends WorldCollection {
    /**
     * Register world settings related to RollTable documents
     */
    static registerSettings(): void;
    /** @override */
    override get directory(): any;
}
/**
 * The singleton collection of User documents which exist within the active World.
 * This Collection is accessible within the Game object as game.users.
 * @extends {WorldCollection}
 *
 * @see {@link User} The User document
 */
declare class Users extends WorldCollection {
    static _activateSocketListeners(socket: any): void;
    /**
     * Handle receipt of activity data from another User connected to the Game session
     * @param {string} userId               The User id who generated the activity data
     * @param {ActivityData} activityData   The object of activity data
     * @private
     */
    private static _handleUserActivity;
    constructor(...args: any[]);
    /**
     * The User document of the currently connected user
     * @type {User|null}
     */
    current: User | null;
    /**
     * Get the users with player roles
     * @returns {User[]}
     */
    get players(): User[];
    /**
     * Get one User who is an active Gamemaster, or null if no active GM is available.
     * This can be useful for workflows which occur on all clients, but where only one user should take action.
     * @type {User|null}
     */
    get activeGM(): User;
}
/**
 * @typedef {EffectDurationData} ActiveEffectDuration
 * @property {string} type            The duration type, either "seconds", "turns", or "none"
 * @property {number|null} duration   The total effect duration, in seconds of world time or as a decimal
 *                                    number with the format {rounds}.{turns}
 * @property {number|null} remaining  The remaining effect duration, in seconds of world time or as a decimal
 *                                    number with the format {rounds}.{turns}
 * @property {string} label           A formatted string label that represents the remaining duration
 * @property {number} [_worldTime]    An internal flag used determine when to recompute seconds-based duration
 * @property {number} [_combatTime]   An internal flag used determine when to recompute turns-based duration
 */
/**
 * The client-side ActiveEffect document which extends the common BaseActiveEffect model.
 * Each ActiveEffect belongs to the effects collection of its parent Document.
 * Each ActiveEffect contains a ActiveEffectData object which provides its source data.
 *
 * @extends documents.BaseActiveEffect
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Actor}                     The Actor document which contains ActiveEffect embedded documents
 * @see {@link documents.Item}                      The Item document which contains ActiveEffect embedded documents
 *
 * @property {ActiveEffectDuration} duration        Expanded effect duration data.
 */
declare class ActiveEffect {
    /**
     * Retrieve the initial duration configuration.
     * @returns {{duration: {startTime: number, [startRound]: number, [startTurn]: number}}}
     */
    static getInitialDuration(): {
        duration: {
            startTime: number;
            [startRound]: number;
            [startTurn]: number;
        };
    };
    /**
     * Is there some system logic that makes this active effect ineligible for application?
     * @type {boolean}
     */
    get isSuppressed(): boolean;
    /**
     * Provide forward-compatibility with other Document types which use img as their primary image or icon.
     * We are likely to formally migrate this in the future, but for now this getter provides compatible read access.
     * @type {string}
     */
    get img(): string;
    /**
     * Retrieve the Document that this ActiveEffect targets for modification.
     * @type {Document|null}
     */
    get target(): Document;
    /**
     * Whether the Active Effect currently applying its changes to the target.
     * @type {boolean}
     */
    get active(): boolean;
    /**
     * Does this Active Effect currently modify an Actor?
     * @type {boolean}
     */
    get modifiesActor(): boolean;
    /** @inheritdoc */
    prepareBaseData(): void;
    /** @inheritdoc */
    prepareDerivedData(): void;
    /**
     * Update derived Active Effect duration data.
     * Configure the remaining and label properties to be getters which lazily recompute only when necessary.
     * @returns {ActiveEffectDuration}
     */
    updateDuration(): EffectDurationData;
    /**
     * Determine whether the ActiveEffect requires a duration update.
     * True if the worldTime has changed for an effect whose duration is tracked in seconds.
     * True if the combat turn has changed for an effect tracked in turns where the effect target is a combatant.
     * @returns {boolean}
     * @protected
     */
    protected _requiresDurationUpdate(): boolean;
    /**
     * Compute derived data related to active effect duration.
     * @returns {{
     *   type: string,
     *   duration: number|null,
     *   remaining: number|null,
     *   label: string,
     *   [_worldTime]: number,
     *   [_combatTime]: number}
     * }
     * @internal
     */
    _prepareDuration(): {
        type: string;
        duration: number | null;
        remaining: number | null;
        label: string;
        [_worldTime]: number;
        [_combatTime]: number;
    };
    /**
     * Format a round+turn combination as a decimal
     * @param {number} round    The round number
     * @param {number} turn     The turn number
     * @param {number} [nTurns] The maximum number of turns in the encounter
     * @returns {number}        The decimal representation
     * @private
     */
    private _getCombatTime;
    /**
     * Format a number of rounds and turns into a human-readable duration label
     * @param {number} rounds   The number of rounds
     * @param {number} turns    The number of turns
     * @returns {string}        The formatted label
     * @private
     */
    private _getDurationLabel;
    /**
     * Describe whether the ActiveEffect has a temporary duration based on combat turns or rounds.
     * @type {boolean}
     */
    get isTemporary(): boolean;
    /**
     * The source name of the Active Effect. The source is retrieved synchronously.
     * Therefore "Unknown" (localized) is returned if the origin points to a document inside a compendium.
     * Returns "None" (localized) if it has no origin, and "Unknown" (localized) if the origin cannot be resolved.
     * @type {string}
     */
    get sourceName(): string;
    /**
     * Apply this ActiveEffect to a provided Actor.
     * TODO: This method is poorly conceived. Its functionality is static, applying a provided change to an Actor
     * TODO: When we revisit this in Active Effects V2 this should become an Actor method, or a static method
     * @param {Actor} actor                   The Actor to whom this effect should be applied
     * @param {EffectChangeData} change       The change data being applied
     * @returns {*}                           The resulting applied value
     */
    apply(actor: Actor, change: EffectChangeData): any;
    /**
     * Cast a raw EffectChangeData change string to the desired data type.
     * @param {string} raw      The raw string value
     * @param {string} type     The target data type that the raw value should be cast to match
     * @returns {*}             The parsed delta cast to the target data type
     * @private
     */
    private _castDelta;
    /**
     * Cast a raw EffectChangeData change string to an Array of an inner type.
     * @param {string} raw      The raw string value
     * @param {string} type     The target data type of inner array elements
     * @returns {Array<*>}      The parsed delta cast as a typed array
     * @private
     */
    private _castArray;
    /**
     * Parse serialized JSON, or retain the raw string.
     * @param {string} raw      A raw serialized string
     * @returns {*}             The parsed value, or the original value if parsing failed
     * @private
     */
    private _parseOrString;
    /**
     * Apply an ActiveEffect that uses an ADD application mode.
     * The way that effects are added depends on the data type of the current value.
     *
     * If the current value is null, the change value is assigned directly.
     * If the current type is a string, the change value is concatenated.
     * If the current type is a number, the change value is cast to numeric and added.
     * If the current type is an array, the change value is appended to the existing array if it matches in type.
     *
     * @param {Actor} actor                   The Actor to whom this effect should be applied
     * @param {EffectChangeData} change       The change data being applied
     * @param {*} current                     The current value being modified
     * @param {*} delta                       The parsed value of the change object
     * @param {object} changes                An object which accumulates changes to be applied
     * @private
     */
    private _applyAdd;
    /**
     * Apply an ActiveEffect that uses a MULTIPLY application mode.
     * Changes which MULTIPLY must be numeric to allow for multiplication.
     * @param {Actor} actor                   The Actor to whom this effect should be applied
     * @param {EffectChangeData} change       The change data being applied
     * @param {*} current                     The current value being modified
     * @param {*} delta                       The parsed value of the change object
     * @param {object} changes                An object which accumulates changes to be applied
     * @private
     */
    private _applyMultiply;
    /**
     * Apply an ActiveEffect that uses an OVERRIDE application mode.
     * Numeric data is overridden by numbers, while other data types are overridden by any value
     * @param {Actor} actor                   The Actor to whom this effect should be applied
     * @param {EffectChangeData} change       The change data being applied
     * @param {*} current                     The current value being modified
     * @param {*} delta                       The parsed value of the change object
     * @param {object} changes                An object which accumulates changes to be applied
     * @private
     */
    private _applyOverride;
    /**
     * Apply an ActiveEffect that uses an UPGRADE, or DOWNGRADE application mode.
     * Changes which UPGRADE or DOWNGRADE must be numeric to allow for comparison.
     * @param {Actor} actor                   The Actor to whom this effect should be applied
     * @param {EffectChangeData} change       The change data being applied
     * @param {*} current                     The current value being modified
     * @param {*} delta                       The parsed value of the change object
     * @param {object} changes                An object which accumulates changes to be applied
     * @private
     */
    private _applyUpgrade;
    /**
     * Apply an ActiveEffect that uses a CUSTOM application mode.
     * @param {Actor} actor                   The Actor to whom this effect should be applied
     * @param {EffectChangeData} change       The change data being applied
     * @param {*} current                     The current value being modified
     * @param {*} delta                       The parsed value of the change object
     * @param {object} changes                An object which accumulates changes to be applied
     * @private
     */
    private _applyCustom;
    /** @inheritdoc */
    getFlag(scope: any, key: any): any;
    /** @inheritdoc */
    _preCreate(data: any, options: any, user: any): Promise<void>;
    /** @inheritdoc */
    _onCreate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _preUpdate(data: any, options: any, userId: any): Promise<any>;
    /** @inheritdoc */
    _onUpdate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDelete(options: any, userId: any): void;
    /**
     * Display changes to active effects as scrolling Token status text.
     * @param {boolean} enabled     Is the active effect currently enabled?
     * @protected
     */
    protected _displayScrollingStatus(enabled: boolean): void;
    /**
     * Get the name of the source of the Active Effect
     * @type {string}
     * @deprecated since v11
     * @ignore
     */
    _getSourceName(): Promise<any>;
}
/**
 * The client-side ActorDelta embedded document which extends the common BaseActorDelta document model.
 * @extends documents.BaseActorDelta
 * @mixes ClientDocumentMixin
 * @see {@link TokenDocument}  The TokenDocument document type which contains ActorDelta embedded documents.
 */
declare class ActorDelta {
    /** @inheritdoc */
    _configure(options?: {}): void;
    /** @inheritdoc */
    _initialize({ sceneReset, ...options }?: {
        sceneReset?: boolean;
    }): void;
    /**
     * Apply this ActorDelta to the base Actor and return a synthetic Actor.
     * @param {object} [context]  Context to supply to synthetic Actor instantiation.
     * @returns {Actor|null}
     */
    apply(context?: object): Actor | null;
    /** @override */
    override prepareEmbeddedDocuments(): void;
    /** @inheritdoc */
    updateSource(changes?: {}, options?: {}): any;
    /** @inheritdoc */
    reset(): void;
    /**
     * Generate a synthetic Actor instance when constructed, or when the represented Actor, or actorLink status changes.
     * @param {object} [options]
     * @param {boolean} [options.reinitializeCollections]  Whether to fully re-initialize this ActorDelta's collections in
     *                                                     order to re-retrieve embedded Documents from the synthetic
     *                                                     Actor.
     * @internal
     */
    _createSyntheticActor({ reinitializeCollections }?: {
        reinitializeCollections?: boolean;
    }): void;
    /**
     * Update the synthetic Actor instance with changes from the delta or the base Actor.
     */
    updateSyntheticActor(): void;
    /**
     * Restore this delta to empty, inheriting all its properties from the base actor.
     * @returns {Promise<Actor>}  The restored synthetic Actor.
     */
    restore(): Promise<Actor>;
    /**
     * Ensure that the embedded collection delta is managing any entries that have had their descendants updated.
     * @param {Document} doc  The parent whose immediate children have been modified.
     * @internal
     */
    _handleDeltaCollectionUpdates(doc: Document): any;
    _preDelete(options: any, user: any): Promise<any>;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDelete(options: any, userId: any): void;
    /** @inheritdoc */
    _dispatchDescendantDocumentEvents(event: any, collection: any, args: any, _parent: any): void;
}
declare const Actor_base: typeof import("../../common/documents/actor.mjs").default;
/**
 * The client-side Actor document which extends the common BaseActor model.
 *
 * @extends foundry.documents.BaseActor
 * @mixes ClientDocumentMixin
 * @category - Documents
 *
 * @see {@link documents.Actors}            The world-level collection of Actor documents
 * @see {@link applications.ActorSheet}     The Actor configuration application
 *
 * @example Create a new Actor
 * ```js
 * let actor = await Actor.create({
 *   name: "New Test Actor",
 *   type: "character",
 *   img: "artwork/character-profile.jpg"
 * });
 * ```
 *
 * @example Retrieve an existing Actor
 * ```js
 * let actor = game.actors.get(actorId);
 * ```
 */
declare class Actor extends Actor_base {
    /**
     * Request wildcard token images from the server and return them.
     * @param {string} actorId         The actor whose prototype token contains the wildcard image path.
     * @param {object} [options]
     * @param {string} [options.pack]  The name of the compendium the actor is in.
     * @returns {Promise<string[]>}    The list of filenames to token images that match the wildcard search.
     * @private
     */
    private static _requestTokenImages;
    /** @inheritdoc */
    _configure(options?: {}): void;
    /**
     * An object that tracks which tracks the changes to the data model which were applied by active effects
     * @type {object}
     */
    overrides: object;
    /**
     * The statuses that are applied to this actor by active effects
     * @type {Set<string>}
     */
    statuses: Set<string>;
    /**
     * A cached array of image paths which can be used for this Actor's token.
     * Null if the list has not yet been populated.
     * @type {string[]|null}
     * @private
     */
    private _tokenImages;
    /**
     * Cache the last drawn wildcard token to avoid repeat draws
     * @type {string|null}
     */
    _lastWildcard: string | null;
    /**
     * Provide a thumbnail image path used to represent this document.
     * @type {string}
     */
    get thumbnail(): string;
    /**
     * Provide an object which organizes all embedded Item instances by their type
     * @type {Object<Item[]>}
     */
    get itemTypes(): any;
    /**
     * Test whether an Actor document is a synthetic representation of a Token (if true) or a full Document (if false)
     * @type {boolean}
     */
    get isToken(): boolean;
    /**
     * Retrieve the list of ActiveEffects that are currently applied to this Actor.
     * @type {ActiveEffect[]}
     */
    get appliedEffects(): ActiveEffect[];
    /**
     * An array of ActiveEffect instances which are present on the Actor which have a limited duration.
     * @type {ActiveEffect[]}
     */
    get temporaryEffects(): ActiveEffect[];
    /**
     * Return a reference to the TokenDocument which owns this Actor as a synthetic override
     * @type {TokenDocument|null}
     */
    get token(): TokenDocument;
    /**
     * Whether the Actor has at least one Combatant in the active Combat that represents it.
     * @returns {boolean}
     */
    get inCombat(): boolean;
    /**
     * Apply any transformations to the Actor data which are caused by ActiveEffects.
     */
    applyActiveEffects(): void;
    /**
     * Retrieve an Array of active tokens which represent this Actor in the current canvas Scene.
     * If the canvas is not currently active, or there are no linked actors, the returned Array will be empty.
     * If the Actor is a synthetic token actor, only the exact Token which it represents will be returned.
     *
     * @param {boolean} [linked=false]    Limit results to Tokens which are linked to the Actor. Otherwise, return all
     *                                    Tokens even those which are not linked.
     * @param {boolean} [document=false]  Return the Document instance rather than the PlaceableObject
     * @returns {Array<TokenDocument|Token>} An array of Token instances in the current Scene which reference this Actor.
     */
    getActiveTokens(linked?: boolean, document?: boolean): (Function | TokenDocument)[];
    /**
     * Get all ActiveEffects that may apply to this Actor.
     * If CONFIG.ActiveEffect.legacyTransferral is true, this is equivalent to actor.effects.contents.
     * If CONFIG.ActiveEffect.legacyTransferral is false, this will also return all the transferred ActiveEffects on any
     * of the Actor's owned Items.
     * @yields {ActiveEffect}
     * @returns {Generator<ActiveEffect, void, void>}
     */
    allApplicableEffects(): Generator<ActiveEffect, void, void>;
    /**
     * Prepare a data object which defines the data schema used by dice roll commands against this Actor
     * @returns {object}
     */
    getRollData(): object;
    /**
     * Create a new Token document, not yet saved to the database, which represents the Actor.
     * @param {object} [data={}]            Additional data, such as x, y, rotation, etc. for the created token data
     * @returns {Promise<TokenDocument>}    The created TokenDocument instance
     */
    getTokenDocument(data?: object): Promise<TokenDocument>;
    /**
     * Get an Array of Token images which could represent this Actor
     * @returns {Promise<string[]>}
     */
    getTokenImages(): Promise<string[]>;
    /**
     * Handle how changes to a Token attribute bar are applied to the Actor.
     * This allows for game systems to override this behavior and deploy special logic.
     * @param {string} attribute    The attribute path
     * @param {number} value        The target attribute value
     * @param {boolean} isDelta     Whether the number represents a relative change (true) or an absolute change (false)
     * @param {boolean} isBar       Whether the new value is part of an attribute bar, or just a direct value
     * @returns {Promise<documents.Actor>}  The updated Actor document
     */
    modifyTokenAttribute(attribute: string, value: number, isDelta?: boolean, isBar?: boolean): Promise<documents.Actor>;
    /** @inheritdoc */
    prepareEmbeddedDocuments(): void;
    /**
     * Roll initiative for all Combatants in the currently active Combat encounter which are associated with this Actor.
     * If viewing a full Actor document, all Tokens which map to that actor will be targeted for initiative rolls.
     * If viewing a synthetic Token actor, only that particular Token will be targeted for an initiative roll.
     *
     * @param {object} options                          Configuration for how initiative for this Actor is rolled.
     * @param {boolean} [options.createCombatants=false]    Create new Combatant entries for Tokens associated with
     *                                                      this actor.
     * @param {boolean} [options.rerollInitiative=false]    Re-roll the initiative for this Actor if it has already
     *                                                      been rolled.
     * @param {object} [options.initiativeOptions={}]       Additional options passed to the Combat#rollInitiative method.
     * @returns {Promise<documents.Combat|null>}        A promise which resolves to the Combat document once rolls
     *                                                  are complete.
     */
    rollInitiative({ createCombatants, rerollInitiative, initiativeOptions }?: {
        createCombatants?: boolean;
        rerollInitiative?: boolean;
        initiativeOptions?: object;
    }): Promise<documents.Combat | null>;
    /**
     * Get this actor's dependent tokens.
     * If the actor is a synthetic token actor, only the exact Token which it represents will be returned.
     * @param {object} [options]
     * @param {Scene|Scene[]} [options.scenes]  A single Scene, or list of Scenes to filter by.
     * @param {boolean} [options.linked]        Limit the results to tokens that are linked to the actor.
     * @returns {TokenDocument[]}
     */
    getDependentTokens({ scenes, linked }?: {
        scenes?: Scene | Scene[];
        linked?: boolean;
    }): TokenDocument[];
    /**
     * Register a token as a dependent of this actor.
     * @param {TokenDocument} token  The token.
     * @internal
     */
    _registerDependentToken(token: TokenDocument): void;
    /**
     * Remove a token from this actor's dependents.
     * @param {TokenDocument} token  The token.
     * @internal
     */
    _unregisterDependentToken(token: TokenDocument): void;
    /**
     * Prune a whole scene from this actor's dependent tokens.
     * @param {Scene} scene  The scene.
     * @internal
     */
    _unregisterDependentScene(scene: Scene): void;
    /**
     * When an Actor is being created, apply default token configuration settings to its prototype token.
     * @param {object} data         Data explicitly provided to the creation workflow
     * @param {object} options      Options which configure creation
     * @param {boolean} [options.fromCompendium]  Does this creation workflow originate via compendium import?
     * @protected
     */
    protected _applyDefaultTokenSettings(data: object, { fromCompendium }?: {
        fromCompendium?: boolean;
    }): any;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onCreateDescendantDocuments(parent: any, collection: any, documents: any, data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onUpdateDescendantDocuments(parent: any, collection: any, documents: any, changes: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDeleteDescendantDocuments(parent: any, collection: any, documents: any, ids: any, options: any, userId: any): void;
    /**
     * Additional workflows to perform when any descendant document within this Actor changes.
     * @protected
     */
    protected _onEmbeddedDocumentChange(): void;
    /**
     * Update the active TokenDocument instances which represent this Actor.
     * @param {object} [update]                        The update delta.
     * @param {DocumentModificationContext} [options]  The update context.
     * @protected
     */
    protected _updateDependentTokens(update?: object, options?: DocumentModificationContext): void;
    /**
     * @deprecated since v10
     * @ignore
     */
    getTokenData(data: any): Promise<TokenDocument>;
}
/**
 * @typedef {Object} AdventureImportData
 * @property {Object<object[]>} toCreate    Arrays of document data to create, organized by document name
 * @property {Object<object[]>} toUpdate    Arrays of document data to update, organized by document name
 * @property {number} documentCount         The total count of documents to import
 */
/**
 * @typedef {Object} AdventureImportResult
 * @property {Object<Document[]>} created   Documents created as a result of the import, organized by document name
 * @property {Object<Document[]>} updated   Documents updated as a result of the import, organized by document name
 */
/**
 * The client-side Adventure document which extends the common {@link foundry.documents.BaseAdventure} model.
 * @extends documents.BaseAdventure
 * @mixes ClientDocumentMixin
 *
 * ### Hook Events
 * {@link hookEvents.preImportAdventure} emitted by Adventure#import
 * {@link hookEvents.importAdventure} emitted by Adventure#import
 */
declare class Adventure {
    /**
     * Perform a full import workflow of this Adventure.
     * Create new and update existing documents within the World.
     * @param {object} [options]                  Options which configure and customize the import process
     * @param {boolean} [options.dialog=true]       Display a warning dialog if existing documents would be overwritten
     * @returns {Promise<AdventureImportResult>}  The import result
     */
    import({ dialog, ...importOptions }?: {
        dialog?: boolean;
    }): Promise<AdventureImportResult>;
    /**
     * Prepare Adventure data for import into the World.
     * @param {object} [options]                 Options passed in from the import dialog to configure the import
     *                                           behavior.
     * @param {string[]} [options.importFields]  A subset of adventure fields to import.
     * @returns {Promise<AdventureImportData>}
     */
    prepareImport({ importFields }?: {
        importFields?: string[];
    }): Promise<AdventureImportData>;
    /**
     * Execute an Adventure import workflow, creating and updating documents in the World.
     * @param {AdventureImportData} data          Prepared adventure data to import
     * @returns {Promise<AdventureImportResult>}  The import result
     */
    importContent({ toCreate, toUpdate, documentCount }?: AdventureImportData): Promise<AdventureImportResult>;
}
/**
 * The client-side AmbientLight document which extends the common BaseAmbientLight document model.
 * @extends documents.BaseAmbientLight
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains AmbientLight documents
 * @see {@link AmbientLightConfig}        The AmbientLight configuration application
 */
declare class AmbientLightDocument {
    /** @inheritdoc */
    _onUpdate(data: any, options: any, userId: any): void;
    /**
     * Is this ambient light source global in nature?
     * @type {boolean}
     */
    get isGlobal(): boolean;
}
/**
 * The client-side AmbientSound document which extends the common BaseAmbientSound document model.
 * @extends abstract.BaseAmbientSound
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                   The Scene document type which contains AmbientSound documents
 * @see {@link AmbientSoundConfig}      The AmbientSound configuration application
 */
declare class AmbientSoundDocument {
}
/**
 * The client-side Card document which extends the common BaseCard document model.
 * @extends documents.BaseCard
 * @mixes ClientDocumentMixin
 *
 * @see {@link Cards}                    The Cards document type which contains Card embedded documents
 * @see {@link CardConfig}               The Card configuration application
 */
declare class Card {
    /**
     * The current card face
     * @type {CardFaceData|null}
     */
    get currentFace(): any;
    /**
     * The image of the currently displayed card face or back
     * @type {string}
     */
    get img(): string;
    /**
     * A reference to the source Cards document which defines this Card.
     * @type {Cards|null}
     */
    get source(): Cards;
    /**
     * A convenience property for whether the Card is within its source Cards stack. Cards in decks are always
     * considered home.
     * @type {boolean}
     */
    get isHome(): boolean;
    /**
     * Whether to display the face of this card?
     * @type {boolean}
     */
    get showFace(): boolean;
    /**
     * Does this Card have a next face available to flip to?
     * @type {boolean}
     */
    get hasNextFace(): boolean;
    /**
     * Does this Card have a previous face available to flip to?
     * @type {boolean}
     */
    get hasPreviousFace(): boolean;
    /** @override */
    override prepareDerivedData(): void;
    name: any;
    /**
     * Flip this card to some other face. A specific face may be requested, otherwise:
     * If the card currently displays a face the card is flipped to the back.
     * If the card currently displays the back it is flipped to the first face.
     * @param {number|null} [face]      A specific face to flip the card to
     * @returns {Promise<Card>}         A reference to this card after the flip operation is complete
     */
    flip(face?: number | null): Promise<Card>;
    /**
     * Pass this Card to some other Cards document.
     * @param {Cards} to                A new Cards document this card should be passed to
     * @param {object} [options={}]     Options which modify the pass operation
     * @param {object} [options.updateData={}]  Modifications to make to the Card as part of the pass operation,
     *                                  for example the displayed face
     * @returns {Promise<Card>}         A reference to this card after it has been passed to another parent document
     */
    pass(to: Cards, { updateData, ...options }?: {
        updateData?: object;
    }): Promise<Card>;
    /**
     * @alias Card#pass
     * @see Card#pass
     * @inheritdoc
     */
    play(to: any, { updateData, ...options }?: {
        updateData?: {};
    }): Promise<any>;
    /**
     * @alias Card#pass
     * @see Card#pass
     * @inheritdoc
     */
    discard(to: any, { updateData, ...options }?: {
        updateData?: {};
    }): Promise<any>;
    /**
     * Recall this Card to its original Cards parent.
     * @param {object} [options={}]   Options which modify the recall operation
     * @returns {Promise<Card>}       A reference to the recalled card belonging to its original parent
     */
    recall(options?: object): Promise<Card>;
    /**
     * Create a chat message which displays this Card.
     * @param {object} [messageData={}] Additional data which becomes part of the created ChatMessageData
     * @param {object} [options={}]     Options which modify the message creation operation
     * @returns {Promise<ChatMessage>}  The created chat message
     */
    toMessage(messageData?: object, options?: object): Promise<ChatMessage>;
}
/**
 * The client-side Cards document which extends the common BaseCards model.
 * Each Cards document contains CardsData which defines its data schema.
 * @extends documents.BaseCards
 * @mixes ClientDocumentMixin
 *
 * @see {@link CardStacks}                        The world-level collection of Cards documents
 * @see {@link CardsConfig}                       The Cards configuration application
 */
declare class Cards {
    /** @inheritdoc */
    static createDocuments(data?: any[], context?: {}): Promise<any>;
    /** @override */
    static override createDialog(data?: {}, { parent, pack, ...options }?: {
        parent?: any;
        pack?: any;
    }): Promise<any>;
    /**
     * Provide a thumbnail image path used to represent this document.
     * @type {string}
     */
    get thumbnail(): string;
    /**
     * The Card documents within this stack which are available to be drawn.
     * @type {Card[]}
     */
    get availableCards(): Card[];
    /**
     * The Card documents which belong to this stack but have already been drawn.
     * @type {Card[]}
     */
    get drawnCards(): Card[];
    /**
     * Returns the localized Label for the type of Card Stack this is
     * @type {string}
     */
    get typeLabel(): string;
    /**
     * Can this Cards document be cloned in a duplicate workflow?
     * @type {boolean}
     */
    get canClone(): boolean;
    /** @inheritDoc */
    _preCreate(data: any, options: any, user: any): Promise<void>;
    /**
     * Deal one or more cards from this Cards document to each of a provided array of Cards destinations.
     * Cards are allocated from the top of the deck in cyclical order until the required number of Cards have been dealt.
     * @param {Cards[]} to              An array of other Cards documents to which cards are dealt
     * @param {number} [number=1]       The number of cards to deal to each other document
     * @param {object} [options={}]     Options which modify how the deal operation is performed
     * @param {number} [options.how=0]          How to draw, a value from CONST.CARD_DRAW_MODES
     * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the deal operation,
     *                                          for example the displayed face
     * @param {string} [options.action=deal]    The name of the action being performed, used as part of the dispatched
     *                                          Hook event
     * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
     * @returns {Promise<Cards>}        This Cards document after the deal operation has completed
     */
    deal(to: Cards[], number?: number, { action, how, updateData, chatNotification }?: {
        how?: number;
        updateData?: object;
        action?: string;
        chatNotification?: boolean;
    }): Promise<Cards>;
    /**
     * Pass an array of specific Card documents from this document to some other Cards stack.
     * @param {Cards} to                Some other Cards document that is the destination for the pass operation
     * @param {string[]} ids            The embedded Card ids which should be passed
     * @param {object} [options={}]     Additional options which modify the pass operation
     * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the pass operation,
     *                                          for example the displayed face
     * @param {string} [options.action=pass]    The name of the action being performed, used as part of the dispatched
     *                                          Hook event
     * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
     * @returns {Promise<Card[]>}       An array of the Card embedded documents created within the destination stack
     */
    pass(to: Cards, ids: string[], { updateData, action, chatNotification }?: {
        updateData?: object;
        action?: string;
        chatNotification?: boolean;
    }): Promise<Card[]>;
    /**
     * Draw one or more cards from some other Cards document.
     * @param {Cards} from              Some other Cards document from which to draw
     * @param {number} [number=1]       The number of cards to draw
     * @param {object} [options={}]     Options which modify how the draw operation is performed
     * @param {number} [options.how=0]          How to draw, a value from CONST.CARD_DRAW_MODES
     * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the draw operation,
     *                                          for example the displayed face
     * @returns {Promise<Card[]>}       An array of the Card documents which were drawn
     */
    draw(from: Cards, number?: number, { how, updateData, ...options }?: {
        how?: number;
        updateData?: object;
    }): Promise<Card[]>;
    /**
     * Shuffle this Cards stack, randomizing the sort order of all the cards it contains.
     * @param {object} [options={}]     Options which modify how the shuffle operation is performed.
     * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the shuffle operation,
     *                                          for example the displayed face.
     * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
     * @returns {Promise<Cards>}        The Cards document after the shuffle operation has completed
     */
    shuffle({ updateData, chatNotification }?: {
        updateData?: object;
        chatNotification?: boolean;
    }): Promise<Cards>;
    /**
     * Recall the Cards stack, retrieving all original cards from other stacks where they may have been drawn if this is a
     * deck, otherwise returning all the cards in this stack to the decks where they originated.
     * @param {object} [options={}]             Options which modify the recall operation
     * @param {object} [options.updateData={}]  Modifications to make to each Card as part of the recall operation,
     *                                          for example the displayed face
     * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
     * @returns {Promise<Cards>}                The Cards document after the recall operation has completed.
     */
    recall(options?: {
        updateData?: object;
        chatNotification?: boolean;
    }): Promise<Cards>;
    /**
     * Perform a reset operation for a deck, retrieving all original cards from other stacks where they may have been
     * drawn.
     * @param {object} [options={}]              Options which modify the reset operation.
     * @param {object} [options.updateData={}]           Modifications to make to each Card as part of the reset operation
     * @param {boolean} [options.chatNotification=true]  Create a ChatMessage which notifies that this action has occurred
     * @returns {Promise<Cards>}                 The Cards document after the reset operation has completed.
     * @private
     */
    private _resetDeck;
    /**
     * Return all cards in this stack to their original decks.
     * @param {object} [options={}]              Options which modify the return operation.
     * @param {object} [options.updateData={}]          Modifications to make to each Card as part of the return operation
     * @param {boolean} [options.chatNotification=true] Create a ChatMessage which notifies that this action has occurred
     * @returns {Promise<Cards>}                 The Cards document after the return operation has completed.
     * @private
     */
    private _resetStack;
    /**
     * A sorting function that is used to determine the standard order of Card documents within an un-shuffled stack.
     * @param {Card} a     The card being sorted
     * @param {Card} b     Another card being sorted against
     * @returns {number}
     * @protected
     */
    protected sortStandard(a: Card, b: Card): number;
    /**
     * A sorting function that is used to determine the order of Card documents within a shuffled stack.
     * @param {Card} a     The card being sorted
     * @param {Card} b     Another card being sorted against
     * @returns {number}
     * @protected
     */
    protected sortShuffled(a: Card, b: Card): number;
    /**
     * An internal helper method for drawing a certain number of Card documents from this Cards stack.
     * @param {number} number       The number of cards to draw
     * @param {number} how          A draw mode from CONST.CARD_DRAW_MODES
     * @returns {Card[]}            An array of drawn Card documents
     * @protected
     */
    protected _drawCards(number: number, how: number): Card[];
    /**
     * Create a ChatMessage which provides a notification of the operation which was just performed.
     * Visibility of the resulting message is linked to the default roll mode selected in the chat log dropdown.
     * @param {Cards} source        The source Cards document from which the action originated
     * @param {string} action       The localization key which formats the chat message notification
     * @param {object} context      Data passed to the Localization#format method for the localization key
     * @returns {ChatMessage}       A created ChatMessage document
     * @private
     */
    private _postChatNotification;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    _sheet: any;
    /** @inheritdoc */
    _preDelete(options: any, user: any): Promise<any>;
    /**
     * Display a dialog which prompts the user to deal cards to some number of hand-type Cards documents.
     * @see {@link Cards#deal}
     * @returns {Promise<Cards|null>}
     */
    dealDialog(): Promise<Cards | null>;
    /**
     * Display a dialog which prompts the user to draw cards from some other deck-type Cards documents.
     * @see {@link Cards#draw}
     * @returns {Promise<Card[]|null>}
     */
    drawDialog(): Promise<Card[] | null>;
    /**
     * Display a dialog which prompts the user to pass cards from this document to some other Cards document.
     * @see {@link Cards#deal}
     * @returns {Promise<Cards|null>}
     */
    passDialog(): Promise<Cards | null>;
    /**
     * Display a dialog which prompts the user to play a specific Card to some other Cards document
     * @see {@link Cards#pass}
     * @param {Card} card     The specific card being played as part of this dialog
     * @returns {Promise<Card[]|null>}
     */
    playDialog(card: Card): Promise<Card[] | null>;
    /**
     * Display a confirmation dialog for whether or not the user wishes to reset a Cards stack
     * @see {@link Cards#recall}
     * @returns {Promise<Cards|false|null>}
     */
    resetDialog(): Promise<Cards | false | null>;
    /** @inheritdoc */
    deleteDialog(options?: {}): Promise<any>;
}
/**
 * The client-side ChatMessage document which extends the common BaseChatMessage model.
 *
 * @extends documents.BaseChatMessage
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Messages}                The world-level collection of ChatMessage documents
 *
 * @property {Roll[]} rolls                       The prepared array of Roll instances
 */
declare class ChatMessage {
    /**
     * Transform a provided object of ChatMessage data by applying a certain rollMode to the data object.
     * @param {object} chatData     The object of ChatMessage data prior to applying a rollMode preference
     * @param {string} rollMode     The rollMode preference to apply to this message data
     * @returns {object}            The modified ChatMessage data with rollMode preferences applied
     */
    static applyRollMode(chatData: object, rollMode: string): object;
    /**
     * Attempt to determine who is the speaking character (and token) for a certain Chat Message
     * First assume that the currently controlled Token is the speaker
     *
     * @param {object} [options={}]   Options which affect speaker identification
     * @param {Scene} [options.scene]         The Scene in which the speaker resides
     * @param {Actor} [options.actor]         The Actor who is speaking
     * @param {TokenDocument} [options.token] The Token who is speaking
     * @param {string} [options.alias]        The name of the speaker to display
     *
     * @returns {object}              The identified speaker data
     */
    static getSpeaker({ scene, actor, token, alias }?: {
        scene?: Scene;
        actor?: Actor;
        token?: TokenDocument;
        alias?: string;
    }): object;
    /**
     * A helper to prepare the speaker object based on a target TokenDocument
     * @param {object} [options={}]       Options which affect speaker identification
     * @param {TokenDocument} options.token        The TokenDocument of the speaker
     * @param {string} [options.alias]             The name of the speaker to display
     * @returns {object}                  The identified speaker data
     * @private
     */
    private static _getSpeakerFromToken;
    /**
     * A helper to prepare the speaker object based on a target Actor
     * @param {object} [options={}]       Options which affect speaker identification
     * @param {Scene} [options.scene]             The Scene is which the speaker resides
     * @param {Actor} [options.actor]             The Actor that is speaking
     * @param {string} [options.alias]            The name of the speaker to display
     * @returns {Object}                  The identified speaker data
     * @private
     */
    private static _getSpeakerFromActor;
    /**
     * A helper to prepare the speaker object based on a target User
     * @param {object} [options={}]       Options which affect speaker identification
     * @param {Scene} [options.scene]             The Scene in which the speaker resides
     * @param {User} [options.user]               The User who is speaking
     * @param {string} [options.alias]            The name of the speaker to display
     * @returns {Object}                  The identified speaker data
     * @private
     */
    private static _getSpeakerFromUser;
    /**
     * Obtain an Actor instance which represents the speaker of this message (if any)
     * @param {Object} speaker    The speaker data object
     * @returns {Actor|null}
     */
    static getSpeakerActor(speaker: any): Actor | null;
    /**
     * Given a string whisper target, return an Array of the user IDs which should be targeted for the whisper
     *
     * @param {string} name   The target name of the whisper target
     * @returns {User[]}      An array of User instances
     */
    static getWhisperRecipients(name: string): User[];
    /**
     * Is the display of dice rolls in this message collapsed (false) or expanded (true)
     * @type {boolean}
     * @private
     */
    private _rollExpanded;
    /**
     * Is this ChatMessage currently displayed in the sidebar ChatLog?
     * @type {boolean}
     */
    logged: boolean;
    /**
     * Return the recommended String alias for this message.
     * The alias could be a Token name in the case of in-character messages or dice rolls.
     * Alternatively it could be the name of a User in the case of OOC chat or whispers.
     * @type {string}
     */
    get alias(): string;
    /**
     * Is the current User the author of this message?
     * @type {boolean}
     */
    get isAuthor(): boolean;
    /**
     * Return whether the content of the message is visible to the current user.
     * For certain dice rolls, for example, the message itself may be visible while the content of that message is not.
     * @type {boolean}
     */
    get isContentVisible(): boolean;
    /**
     * Test whether the chat message contains a dice roll
     * @type {boolean}
     */
    get isRoll(): boolean;
    /**
     * Return whether the ChatMessage is visible to the current User.
     * Messages may not be visible if they are private whispers.
     * @type {boolean}
     */
    get visible(): boolean;
    /** @inheritdoc */
    prepareDerivedData(): void;
    rolls: any;
    /**
     * Update the data of a ChatMessage instance to apply a requested rollMode
     * @param {string} rollMode     The rollMode preference to apply to this message data
     */
    applyRollMode(rollMode: string): void;
    /**
     * Obtain a data object used to evaluate any dice rolls associated with this particular chat message
     * @returns {object}
     */
    getRollData(): object;
    /**
     * Render the HTML for the ChatMessage which should be added to the log
     * @returns {Promise<jQuery>}
     */
    getHTML(): Promise<JQueryStatic>;
    /**
     * Render the inner HTML content for ROLL type messages.
     * @param {object} messageData      The chat message data used to render the message HTML
     * @returns {Promise}
     * @private
     */
    private _renderRollContent;
    /**
     * Render HTML for the array of Roll objects included in this message.
     * @param {boolean} isPrivate   Is the chat message private?
     * @returns {Promise<string>}   The rendered HTML string
     * @private
     */
    private _renderRollHTML;
    /** @override */
    override _preCreate(data: any, options: any, user: any): Promise<void>;
    /** @override */
    override _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @override */
    override _onDelete(options: any, userId: any): void;
    /**
     * Export the content of the chat message into a standardized log format
     * @returns {string}
     */
    export(): string;
    /**
     * Return the first Roll instance contained in this chat message, if one is present
     * @deprecated since v10
     * @ignore
     * @type {Roll|null}
     */
    get roll(): Roll;
}
/**
 * @typedef {Object} CombatHistoryData
 * @property {number|null} round
 * @property {number|null} turn
 * @property {string|null} tokenId
 * @property {string|null} combatantId
 */
/**
 * The client-side Combat document which extends the common BaseCombat model.
 *
 * @extends documents.BaseCombat
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Combats}             The world-level collection of Combat documents
 * @see {@link Combatant}                     The Combatant embedded document which exists within a Combat document
 * @see {@link CombatConfig}                  The Combat configuration application
 */
declare class Combat {
    /**
     * The configuration setting used to record Combat preferences
     * @type {string}
     */
    static CONFIG_SETTING: string;
    constructor(data: any, context: any);
    /**
     * Track the sorted turn order of this combat encounter
     * @type {Combatant[]}
     */
    turns: Function[];
    /**
     * Record the current round, turn, and tokenId to understand changes in the encounter state
     * @type {CombatHistoryData}
     */
    current: CombatHistoryData;
    /**
     * Track the previous round, turn, and tokenId to understand changes in the encounter state
     * @type {CombatHistoryData}
     */
    previous: CombatHistoryData;
    /**
     * Get the Combatant who has the current turn.
     * @type {Combatant}
     */
    get combatant(): Function;
    /**
     * Get the Combatant who has the next turn.
     * @type {Combatant}
     */
    get nextCombatant(): Function;
    /**
     * Return the object of settings which modify the Combat Tracker behavior
     * @type {object}
     */
    get settings(): any;
    /**
     * Has this combat encounter been started?
     * @type {boolean}
     */
    get started(): boolean;
    /** @inheritdoc */
    get visible(): boolean;
    /**
     * Is this combat active in the current scene?
     * @type {boolean}
     */
    get isActive(): boolean;
    /**
     * Set the current Combat encounter as active within the Scene.
     * Deactivate all other Combat encounters within the viewed Scene and set this one as active
     * @param {object} [options] Additional context to customize the update workflow
     * @returns {Promise<Combat>}
     */
    activate(options?: object): Promise<Combat>;
    /** @override */
    override prepareDerivedData(): void;
    /**
     * Get a Combatant using its Token id
     * @param {string} tokenId   The id of the Token for which to acquire the combatant
     * @returns {Combatant}
     */
    getCombatantByToken(tokenId: string): Function;
    /**
     * Get a Combatant that represents the given Actor or Actor ID.
     * @param {string|Actor} actorOrId An Actor ID or an Actor instance.
     * @returns {Combatant}
     */
    getCombatantByActor(actorOrId: string | Actor): Function;
    /**
     * Begin the combat encounter, advancing to round 1 and turn 1
     * @returns {Promise<Combat>}
     */
    startCombat(): Promise<Combat>;
    /**
     * Advance the combat to the next round
     * @returns {Promise<Combat>}
     */
    nextRound(): Promise<Combat>;
    /**
     * Rewind the combat to the previous round
     * @returns {Promise<Combat>}
     */
    previousRound(): Promise<Combat>;
    /**
     * Advance the combat to the next turn
     * @returns {Promise<Combat>}
     */
    nextTurn(): Promise<Combat>;
    /**
     * Rewind the combat to the previous turn
     * @returns {Promise<Combat>}
     */
    previousTurn(): Promise<Combat>;
    /**
     * Display a dialog querying the GM whether they wish to end the combat encounter and empty the tracker
     * @returns {Promise<Combat>}
     */
    endCombat(): Promise<Combat>;
    /**
     * Toggle whether this combat is linked to the scene or globally available.
     * @returns {Promise<Combat>}
     */
    toggleSceneLink(): Promise<Combat>;
    /**
     * Reset all combatant initiative scores, setting the turn back to zero
     * @returns {Promise<Combat>}
     */
    resetAll(): Promise<Combat>;
    /**
     * Roll initiative for one or multiple Combatants within the Combat document
     * @param {string|string[]} ids     A Combatant id or Array of ids for which to roll
     * @param {object} [options={}]     Additional options which modify how initiative rolls are created or presented.
     * @param {string|null} [options.formula]         A non-default initiative formula to roll. Otherwise, the system
     *                                                default is used.
     * @param {boolean} [options.updateTurn=true]     Update the Combat turn after adding new initiative scores to
     *                                                keep the turn on the same Combatant.
     * @param {object} [options.messageOptions={}]    Additional options with which to customize created Chat Messages
     * @returns {Promise<Combat>}       A promise which resolves to the updated Combat document once updates are complete.
     */
    rollInitiative(ids: string | string[], { formula, updateTurn, messageOptions }?: {
        formula?: string | null;
        updateTurn?: boolean;
        messageOptions?: object;
    }): Promise<Combat>;
    /**
     * Roll initiative for all combatants which have not already rolled
     * @param {object} [options={}]   Additional options forwarded to the Combat.rollInitiative method
     */
    rollAll(options?: object): Promise<Combat>;
    /**
     * Roll initiative for all non-player actors who have not already rolled
     * @param {object} [options={}]   Additional options forwarded to the Combat.rollInitiative method
     */
    rollNPC(options?: object): Promise<Combat>;
    /**
     * Assign initiative for a single Combatant within the Combat encounter.
     * Update the Combat turn order to maintain the same combatant as the current turn.
     * @param {string} id         The combatant ID for which to set initiative
     * @param {number} value      A specific initiative value to set
     */
    setInitiative(id: string, value: number): Promise<void>;
    /**
     * Return the Array of combatants sorted into initiative order, breaking ties alphabetically by name.
     * @returns {Combatant[]}
     */
    setupTurns(): Function[];
    turn: any;
    /**
     * Debounce changes to the composition of the Combat encounter to de-duplicate multiple concurrent Combatant changes.
     * If this is the currently viewed encounter, re-render the CombatTracker application.
     * @type {Function}
     */
    debounceSetup: Function;
    /**
     * Update active effect durations for all actors present in this Combat encounter.
     */
    updateCombatantActors(): void;
    /**
     * Loads the registered Combat Theme (if any) and plays the requested type of sound.
     * If multiple exist for that type, one is chosen at random.
     * @param {string} announcement     The announcement that should be played: "startEncounter", "nextUp", or "yourTurn".
     * @protected
     */
    protected _playCombatSound(announcement: string): void;
    /**
     * Define how the array of Combatants is sorted in the displayed list of the tracker.
     * This method can be overridden by a system or module which needs to display combatants in an alternative order.
     * The default sorting rules sort in descending order of initiative using combatant IDs for tiebreakers.
     * @param {Combatant} a     Some combatant
     * @param {Combatant} b     Some other combatant
     * @protected
     */
    protected _sortCombatants(a: Function, b: Function): number;
    /**
     * Refresh the Token HUD under certain circumstances.
     * @param {Combatant[]} documents  A list of Combatant documents that were added or removed.
     * @protected
     */
    protected _refreshTokenHUD(documents: Function[]): void;
    /** @inheritdoc */
    _onCreate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onUpdate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDelete(options: any, userId: any): void;
    /** @inheritdoc */
    _onCreateDescendantDocuments(parent: any, collection: any, documents: any, data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onUpdateDescendantDocuments(parent: any, collection: any, documents: any, changes: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDeleteDescendantDocuments(parent: any, collection: any, documents: any, ids: any, options: any, userId: any): void;
    /**
     * Manage the execution of Combat lifecycle events.
     * This method orchestrates the execution of four events in the following order, as applicable:
     * 1. End Turn
     * 2. End Round
     * 3. Begin Round
     * 4. Begin Turn
     * Each lifecycle event is an async method, and each is awaited before proceeding.
     * @param {number} [adjustedTurn]   Optionally, an adjusted turn to commit to the Combat.
     * @returns {Promise<void>}
     * @protected
     */
    protected _manageTurnEvents(adjustedTurn?: number): Promise<void>;
    /**
     * A workflow that occurs at the end of each Combat Turn.
     * This workflow occurs after the Combat document update, prior round information exists in this.previous.
     * This can be overridden to implement system-specific combat tracking behaviors.
     * This method only executes for one designated GM user. If no GM users are present this method will not be called.
     * @param {Combatant} combatant     The Combatant whose turn just ended
     * @returns {Promise<void>}
     * @protected
     */
    protected _onEndTurn(combatant: Function): Promise<void>;
    /**
     * A workflow that occurs at the end of each Combat Round.
     * This workflow occurs after the Combat document update, prior round information exists in this.previous.
     * This can be overridden to implement system-specific combat tracking behaviors.
     * This method only executes for one designated GM user. If no GM users are present this method will not be called.
     * @returns {Promise<void>}
     * @protected
     */
    protected _onEndRound(): Promise<void>;
    /**
     * A workflow that occurs at the start of each Combat Round.
     * This workflow occurs after the Combat document update, new round information exists in this.current.
     * This can be overridden to implement system-specific combat tracking behaviors.
     * This method only executes for one designated GM user. If no GM users are present this method will not be called.
     * @returns {Promise<void>}
     * @protected
     */
    protected _onStartRound(): Promise<void>;
    /**
     * A workflow that occurs at the start of each Combat Turn.
     * This workflow occurs after the Combat document update, new turn information exists in this.current.
     * This can be overridden to implement system-specific combat tracking behaviors.
     * This method only executes for one designated GM user. If no GM users are present this method will not be called.
     * @param {Combatant} combatant     The Combatant whose turn just started
     * @returns {Promise<void>}
     * @protected
     */
    protected _onStartTurn(combatant: Function): Promise<void>;
    /**
     * @deprecated since v11
     * @ignore
     */
    updateEffectDurations(): void;
    #private;
}
/**
 * The client-side Combatant document which extends the common BaseCombatant model.
 *
 * @extends documents.BaseCombatant
 * @mixes ClientDocumentMixin
 *
 * @see {@link Combat}                  The Combat document which contains Combatant embedded documents
 * @see {@link CombatantConfig}         The application which configures a Combatant.
 */
declare class Combatant {
    /**
     * The token video source image (if any)
     * @type {string|null}
     * @internal
     */
    _videoSrc: string | null;
    /**
     * The current value of the special tracked resource which pertains to this Combatant
     * @type {object|null}
     */
    resource: object | null;
    /**
     * A convenience alias of Combatant#parent which is more semantically intuitive
     * @type {Combat|null}
     */
    get combat(): Combat;
    /**
     * This is treated as a non-player combatant if it has no associated actor and no player users who can control it
     * @type {boolean}
     */
    get isNPC(): boolean;
    /** @override */
    override get visible(): any;
    /**
     * A reference to the Actor document which this Combatant represents, if any
     * @type {Actor|null}
     */
    get actor(): Actor;
    /**
     * A reference to the Token document which this Combatant represents, if any
     * @type {TokenDocument|null}
     */
    get token(): TokenDocument;
    /**
     * An array of non-Gamemaster Users who have ownership of this Combatant.
     * @type {User[]}
     */
    get players(): User[];
    /**
     * Has this combatant been marked as defeated?
     * @type {boolean}
     */
    get isDefeated(): boolean;
    /** @inheritdoc */
    testUserPermission(user: any, permission: any, { exact }?: {
        exact?: boolean;
    }): any;
    /**
     * Get a Roll object which represents the initiative roll for this Combatant.
     * @param {string} formula        An explicit Roll formula to use for the combatant.
     * @returns {Roll}                The unevaluated Roll instance to use for the combatant.
     */
    getInitiativeRoll(formula: string): Roll;
    /**
     * Roll initiative for this particular combatant.
     * @param {string} [formula]      A dice formula which overrides the default for this Combatant.
     * @returns {Promise<Combatant>}  The updated Combatant.
     */
    rollInitiative(formula?: string): Promise<Function>;
    /** @override */
    override prepareDerivedData(): void;
    /**
     * Update the value of the tracked resource for this Combatant.
     * @returns {null|object}
     */
    updateResource(): null | object;
    /**
     * Acquire the default dice formula which should be used to roll initiative for this combatant.
     * Modules or systems could choose to override or extend this to accommodate special situations.
     * @returns {string}               The initiative formula to use for this combatant.
     * @protected
     */
    protected _getInitiativeFormula(): string;
}
/**
 * The client-side Drawing document which extends the common BaseDrawing model.
 *
 * @extends documents.BaseDrawing
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}               The Scene document type which contains Drawing embedded documents
 * @see {@link DrawingConfig}       The Drawing configuration application
 */
declare class DrawingDocument {
    set elevation(arg: number);
    /**
     * Define an elevation property on the Drawing Document which in the future will become a part of its data schema.
     * @type {number}
     */
    get elevation(): number;
    /**
     * Define a sort property on the Drawing Document which in the future will become a core part of its data schema.
     * @type {number}
     */
    get sort(): number;
    #private;
}
/**
 * The client-side FogExploration document which extends the common BaseFogExploration model.
 * @extends documents.BaseFogExploration
 * @mixes ClientDocumentMixin
 */
declare class FogExploration {
    /**
     * Obtain the fog of war exploration progress for a specific Scene and User.
     * @param {object} [query]        Parameters for which FogExploration document is retrieved
     * @param {string} [query.scene]    A certain Scene ID
     * @param {string} [query.user]     A certain User ID
     * @param {object} [options={}]   Additional options passed to DatabaseBackend#get
     * @returns {Promise<FogExploration|null>}
     */
    static get({ scene, user }?: {
        scene?: string;
        user?: string;
    }, options?: object): Promise<FogExploration | null>;
    /**
     * Transform the explored base64 data into a PIXI.Texture object
     * @returns {PIXI.Texture|null}
     */
    getTexture(): PIXI.Texture | null;
    /** @override */
    override _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @override */
    override _onDelete(options: any, userId: any): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    explore(source: any, force?: boolean): boolean;
}
/**
 * The client-side Folder document which extends the common BaseFolder model.
 * @extends documents.BaseFolder
 * @mixes ClientDocumentMixin
 *
 * @see {@link Folders}                     The world-level collection of Folder documents
 * @see {@link FolderConfig}                The Folder configuration application
 */
declare class Folder {
    /**
     * Present a Dialog form to create a new Folder.
     * @see ClientDocumentMixin.createDialog
     * @param {object} data              Initial data with which to populate the creation form
     * @param {object} [context={}]      Additional context options or dialog positioning options
     * @param {object} [context.options={}] Dialog options
     * @param {string} [context.options.pack=""] The name of a Compendium pack to which the folder should be created in
     * @returns {Promise<Folder|null>}   A Promise which resolves to the created Folder, or null if the dialog was
     *                                   closed.
     */
    static createDialog(data?: object, options?: {}): Promise<Folder | null>;
    /**
     * The depth of this folder in its sidebar tree
     * @type {number}
     */
    depth: number;
    /**
     * An array of other Folders which are the displayed children of this one. This differs from the results of
     * {@link Folder.getSubfolders} because reports the subset of child folders which  are displayed to the current User
     * in the UI.
     * @type {Folder[]}
     */
    children: Folder[];
    /**
     * Return whether the folder is displayed in the sidebar to the current User.
     * @type {boolean}
     */
    displayed: boolean;
    set contents(arg: any[]);
    /**
     * The array of the Document instances which are contained within this Folder,
     * unless it's a Folder inside a Compendium pack, in which case it's the array
     * of objects inside the index of the pack that are contained in this Folder.
     * @type {(ClientDocument|object)[]}
     */
    get contents(): any[];
    /**
     * The reference to the Document type which is contained within this Folder.
     * @type {Function}
     */
    get documentClass(): Function;
    /**
     * The reference to the WorldCollection instance which provides Documents to this Folder,
     * unless it's a Folder inside a Compendium pack, in which case it's the index of the pack.
     * @type {WorldCollection|Collection}
     */
    get documentCollection(): any;
    /**
     * Return whether the folder is currently expanded within the sidebar interface.
     * @type {boolean}
     */
    get expanded(): boolean;
    /**
     * Return the list of ancestors of this folder, starting with the parent.
     * @type {Folder[]}
     */
    get ancestors(): Folder[];
    /** @override */
    override _preCreate(data: any, options: any, user: any): Promise<void>;
    /**
     * Export all Documents contained in this Folder to a given Compendium pack.
     * Optionally update existing Documents within the Pack by name, otherwise append all new entries.
     * @param {CompendiumCollection} pack       A Compendium pack to which the documents will be exported
     * @param {object} [options]                Additional options which customize how content is exported.
     *                                          See {@link ClientDocumentMixin#toCompendium}
     * @param {boolean} [options.updateByName=false]    Update existing entries in the Compendium pack, matching by name
     * @param {boolean} [options.keepId=false]          Retain the original _id attribute when updating an entity
     * @param {boolean} [options.keepFolders=false]     Retain the existing Folder structure
     * @param {string} [options.folder]                 A target folder id to which the documents will be exported
     * @returns {Promise<CompendiumCollection>}  The updated Compendium Collection instance
     */
    exportToCompendium(pack: CompendiumCollection, options?: {
        updateByName?: boolean;
        keepId?: boolean;
        keepFolders?: boolean;
        folder?: string;
    }): Promise<CompendiumCollection>;
    /**
     * Provide a dialog form that allows for exporting the contents of a Folder into an eligible Compendium pack.
     * @param {string} pack       A pack ID to set as the default choice in the select input
     * @param {object} options    Additional options passed to the Dialog.prompt method
     * @returns {Promise<void>}   A Promise which resolves or rejects once the dialog has been submitted or closed
     */
    exportDialog(pack: string, options?: object): Promise<void>;
    /**
     * Get the Folder documents which are sub-folders of the current folder, either direct children or recursively.
     * @param {boolean} [recursive=false] Identify child folders recursively, if false only direct children are returned
     * @returns {Folder[]}  An array of Folder documents which are subfolders of this one
     */
    getSubfolders(recursive?: boolean): Folder[];
    /**
     * Get the Folder documents which are parent folders of the current folder or any if its parents.
     * @returns {Folder[]}    An array of Folder documents which are parent folders of this one
     */
    getParentFolders(): Folder[];
    /**
     * @deprecated since v10
     * @ignore
     */
    get content(): any[];
    #private;
}
/**
 * The client-side Item document which extends the common BaseItem model.
 * @extends documents.BaseItem
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Items}            The world-level collection of Item documents
 * @see {@link applications.ItemSheet}     The Item configuration application
 */
declare class Item {
    /** @inheritdoc */
    static _onCreateDocuments(items: any, context: any): Promise<any>;
    /** @inheritdoc */
    static _onDeleteDocuments(items: any, context: any): Promise<any>;
    /**
     * A convenience alias of Item#parent which is more semantically intuitive
     * @type {Actor|null}
     */
    get actor(): Actor;
    /**
     * Provide a thumbnail image path used to represent this document.
     * @type {string}
     */
    get thumbnail(): string;
    /**
     * A convenience alias of Item#isEmbedded which is preserves legacy support
     * @type {boolean}
     */
    get isOwned(): boolean;
    /**
     * Return an array of the Active Effect instances which originated from this Item.
     * The returned instances are the ActiveEffect instances which exist on the Item itself.
     * @type {ActiveEffect[]}
     */
    get transferredEffects(): ActiveEffect[];
    /**
     * Prepare a data object which defines the data schema used by dice roll commands against this Item
     * @returns {object}
     */
    getRollData(): object;
    /** @inheritdoc */
    _preCreate(data: any, options: any, user: any): Promise<any>;
}
/**
 * The client-side JournalEntryPage document which extends the common BaseJournalEntryPage document model.
 * @extends documents.BaseJournalEntryPage
 * @mixes ClientDocumentMixin
 *
 * @see {@link JournalEntry}  The JournalEntry document type which contains JournalEntryPage embedded documents.
 */
declare class JournalEntryPage {
    /**
     * Convert a heading into slug suitable for use as an identifier.
     * @param {HTMLHeadingElement|string} heading  The heading element or some text content.
     * @returns {string}
     */
    static slugifyHeading(heading: HTMLHeadingElement | string): string;
    /**
     * Build a table of contents for the given HTML content.
     * @param {HTMLElement[]} html                     The HTML content to generate a ToC outline for.
     * @param {object} [options]                       Additional options to configure ToC generation.
     * @param {boolean} [options.includeElement=true]  Include references to the heading DOM elements in the returned ToC.
     * @returns {Object<JournalEntryPageHeading>}
     */
    static buildTOC(html: HTMLElement[], { includeElement }?: {
        includeElement?: boolean;
    }): any;
    /**
     * Flatten the tree structure into a single object with each node's slug as the key.
     * @param {JournalEntryPageHeading[]} nodes  The root ToC nodes.
     * @returns {Object<JournalEntryPageHeading>}
     * @protected
     */
    protected static _flattenTOC(nodes: {
        /**
         * The heading level, 1-6.
         */
        level: number;
        /**
         * The raw heading text with any internal tags omitted.
         */
        text: string;
        /**
         * The generated slug for this heading.
         */
        slug: string;
        /**
         * The currently rendered element for this heading, if it exists.
         */
        element?: HTMLHeadingElement;
        /**
         * Any child headings of this one.
         */
        children: string[];
    }[]): any;
    /**
     * Construct a table of contents node from a heading element.
     * @param {HTMLHeadingElement} heading             The heading element.
     * @param {object} [options]                       Additional options to configure the returned node.
     * @param {boolean} [options.includeElement=true]  Whether to include the DOM element in the returned ToC node.
     * @returns {JournalEntryPageHeading}
     * @protected
     */
    protected static _makeHeadingNode(heading: HTMLHeadingElement, { includeElement }?: {
        includeElement?: boolean;
    }): {
        /**
         * The heading level, 1-6.
         */
        level: number;
        /**
         * The raw heading text with any internal tags omitted.
         */
        text: string;
        /**
         * The generated slug for this heading.
         */
        slug: string;
        /**
         * The currently rendered element for this heading, if it exists.
         */
        element?: HTMLHeadingElement;
        /**
         * Any child headings of this one.
         */
        children: string[];
    };
    /**
     * @typedef {object} JournalEntryPageHeading
     * @property {number} level                  The heading level, 1-6.
     * @property {string} text                   The raw heading text with any internal tags omitted.
     * @property {string} slug                   The generated slug for this heading.
     * @property {HTMLHeadingElement} [element]  The currently rendered element for this heading, if it exists.
     * @property {string[]} children             Any child headings of this one.
     */
    /**
     * The cached table of contents for this JournalEntryPage.
     * @type {Object<JournalEntryPageHeading>}
     * @protected
     */
    protected _toc: any;
    /**
     * The table of contents for this JournalEntryPage.
     * @type {Object<JournalEntryPageHeading>}
     */
    get toc(): any;
    /** @inheritdoc */
    get permission(): any;
    /**
     * Return a reference to the Note instance for this Journal Entry Page in the current Scene, if any.
     * If multiple notes are placed for this Journal Entry, only the first will be returned.
     * @type {Note|null}
     */
    get sceneNote(): Function;
    /** @inheritdoc */
    _createDocumentLink(eventData: any, { relativeTo, label }?: {
        relativeTo: any;
        label: any;
    }): any;
    /** @inheritdoc */
    _onClickDocumentLink(event: any): any;
    /** @inheritdoc */
    _onUpdate(changed: any, options: any, userId: any): void;
}
/**
 * The client-side JournalEntry document which extends the common BaseJournalEntry model.
 * @extends documents.BaseJournalEntry
 * @mixes ClientDocumentMixin
 *
 * @see {@link Journal}                       The world-level collection of JournalEntry documents
 * @see {@link JournalSheet}                  The JournalEntry configuration application
 */
declare class JournalEntry {
    /**
     * A boolean indicator for whether the JournalEntry is visible to the current user in the directory sidebar
     * @type {boolean}
     */
    get visible(): boolean;
    /** @inheritdoc */
    getUserLevel(user: any): any;
    /**
     * Return a reference to the Note instance for this Journal Entry in the current Scene, if any.
     * If multiple notes are placed for this Journal Entry, only the first will be returned.
     * @type {Note|null}
     */
    get sceneNote(): Function;
    /**
     * Show the JournalEntry to connected players.
     * By default, the entry will only be shown to players who have permission to observe it.
     * If the parameter force is passed, the entry will be shown to all players regardless of normal permission.
     *
     * @param {boolean} [force=false]    Display the entry to all players regardless of normal permissions
     * @returns {Promise<JournalEntry>}  A Promise that resolves back to the shown entry once the request is processed
     * @alias Journal.show
     */
    show(force?: boolean): Promise<JournalEntry>;
    /**
     * If the JournalEntry has a pinned note on the canvas, this method will animate to that note
     * The note will also be highlighted as if hovered upon by the mouse
     * @param {object} [options={}]         Options which modify the pan operation
     * @param {number} [options.scale=1.5]          The resulting zoom level
     * @param {number} [options.duration=250]       The speed of the pan animation in milliseconds
     * @returns {Promise<void>}             A Promise which resolves once the pan animation has concluded
     */
    panToNote(options?: {
        scale?: number;
        duration?: number;
    }): Promise<void>;
    /** @inheritdoc */
    _preCreate(data: any, options: any, user: any): Promise<any>;
    /** @inheritdoc */
    _preUpdate(changed: any, options: any, user: any): Promise<any>;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @override */
    override _onDelete(options: any, userId: any): void;
}
/**
 * The client-side Macro document which extends the common BaseMacro model.
 * @extends documents.BaseMacro
 * @mixes ClientDocumentMixin
 *
 * @see {@link Macros}                       The world-level collection of Macro documents
 * @see {@link MacroConfig}                  The Macro configuration application
 */
declare class Macro {
    /**
     * Is the current User the author of this macro?
     * @type {boolean}
     */
    get isAuthor(): boolean;
    /**
     * Test whether the current user is capable of executing a Macro script
     * @type {boolean}
     */
    get canExecute(): boolean;
    /**
     * Provide a thumbnail image path used to represent this document.
     * @type {string}
     */
    get thumbnail(): string;
    /**
     * Execute the Macro command.
     * @param {object} [scope={}]     Macro execution scope which is passed to script macros
     * @param {Actor} [scope.actor]     An Actor who is the protagonist of the executed action
     * @param {Token} [scope.token]     A Token which is the protagonist of the executed action
     * @returns {ChatMessage|*}       A created ChatMessage from chat macros or returned value from script macros
     */
    execute(scope?: {
        actor?: Actor;
        token?: Function;
    }): ChatMessage | any;
    /** @inheritdoc */
    _onClickDocumentLink(event: any): any;
    #private;
}
/**
 * The client-side MeasuredTemplate document which extends the common BaseMeasuredTemplate document model.
 * @extends documents.BaseMeasuredTemplate
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains MeasuredTemplate documents
 * @see {@link MeasuredTemplateConfig}    The MeasuredTemplate configuration application
 */
declare class MeasuredTemplateDocument {
    /**
     * A reference to the User who created the MeasuredTemplate document.
     * @type {User|null}
     */
    get author(): User;
    /**
     * Rotation is an alias for direction
     * @returns {number}
     */
    get rotation(): number;
}
/**
 * The client-side Note document which extends the common BaseNote document model.
 * @extends documents.BaseNote
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains Note documents
 * @see {@link NoteConfig}                The Note configuration application
 */
declare class NoteDocument {
    /**
     * The associated JournalEntry which is referenced by this Note
     * @type {JournalEntry}
     */
    get entry(): JournalEntry;
    /**
     * The specific JournalEntryPage within the associated JournalEntry referenced by this Note.
     * @type {JournalEntryPage}
     */
    get page(): JournalEntryPage;
    /**
     * The text label used to annotate this Note
     * @type {string}
     */
    get label(): string;
}
/**
 * The client-side PlaylistSound document which extends the common BasePlaylistSound model.
 * Each PlaylistSound belongs to the sounds collection of a Playlist document.
 * @extends documents.BasePlaylistSound
 * @mixes ClientDocumentMixin
 *
 * @see {@link Playlist}              The Playlist document which contains PlaylistSound embedded documents
 * @see {@link PlaylistSoundConfig}   The PlaylistSound configuration application
 * @see {@link Sound}                 The Sound API which manages web audio playback
 */
declare class PlaylistSound {
    /**
     * The debounce tolerance for processing rapid volume changes into database updates in milliseconds
     * @type {number}
     */
    static VOLUME_DEBOUNCE_MS: number;
    constructor(data: any, context: any);
    /**
     * The Sound which manages playback for this playlist sound
     * @type {Sound|null}
     */
    sound: Sound | null;
    /**
     * A debounced function, accepting a single volume parameter to adjust the volume of this sound
     * @type {Function}
     * @param {number} volume     The desired volume level
     */
    debounceVolume: Function;
    /**
     * Create a Sound used to play this PlaylistSound document
     * @returns {Sound|null}
     * @private
     */
    private _createSound;
    /**
     * The effective volume at which this playlist sound is played, incorporating the global playlist volume setting.
     * @type {number}
     */
    get effectiveVolume(): number;
    /**
     * Determine the fade duration for this PlaylistSound based on its own configuration and that of its parent.
     * @type {number}
     */
    get fadeDuration(): number;
    /**
     * Synchronize playback for this particular PlaylistSound instance
     */
    sync(): any;
    /** @inheritdoc */
    toAnchor({ classes, ...options }?: {
        classes?: any[];
    }): any;
    /** @inheritdoc */
    _onClickDocumentLink(event: any): any;
    /** @override */
    override _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _onUpdate(changed: any, options: any, userId: any): void;
    /** @override */
    override _onDelete(options: any, userId: any): void;
    playing: boolean;
    /**
     * Special handling that occurs when a PlaylistSound reaches the natural conclusion of its playback.
     * @private
     */
    private _onEnd;
    /**
     * Special handling that occurs when playback of a PlaylistSound is started.
     * @private
     */
    private _onStart;
    /**
     * Special handling that occurs when a PlaylistSound is manually stopped before its natural conclusion.
     * @private
     */
    private _onStop;
    /**
     * Handle fading in the volume for this sound when it begins to play (or loop)
     * @param {Sound} sound     The sound fading-in
     * @private
     */
    private _fadeIn;
    /**
     * Handle fading out the volume for this sound when it begins to play (or loop)
     * @param {Sound} sound     The sound fading-out
     * @private
     */
    private _fadeOut;
}
/**
 * The client-side Playlist document which extends the common BasePlaylist model.
 * @extends documents.BasePlaylist
 * @mixes ClientDocumentMixin
 *
 * @see {@link Playlists}             The world-level collection of Playlist documents
 * @see {@link PlaylistSound}         The PlaylistSound embedded document within a parent Playlist
 * @see {@link PlaylistConfig}        The Playlist configuration application
 */
declare class Playlist {
    /**
     * Find all content links belonging to a given {@link Playlist} or {@link PlaylistSound}.
     * @param {Playlist|PlaylistSound} doc  The Playlist or PlaylistSound.
     * @returns {NodeListOf<Element>}
     * @protected
     */
    protected static _getSoundContentLinks(doc: Playlist | PlaylistSound): NodeListOf<Element>;
    /**
     * Playlists may have a playback order which defines the sequence of Playlist Sounds
     * @type {string[]}
     */
    _playbackOrder: string[];
    /**
     * The order in which sounds within this playlist will be played (if sequential or shuffled)
     * Uses a stored seed for randomization to guarantee that all clients generate the same random order.
     * @type {string[]}
     */
    get playbackOrder(): string[];
    /** @inheritdoc */
    get visible(): any;
    /** @inheritdoc */
    prepareDerivedData(): void;
    playing: any;
    /**
     * Begin simultaneous playback for all sounds in the Playlist.
     * @returns {Promise<Playlist>} The updated Playlist document
     */
    playAll(): Promise<Playlist>;
    /**
     * Play the next Sound within the sequential or shuffled Playlist.
     * @param {string} [soundId]      The currently playing sound ID, if known
     * @param {object} [options={}]   Additional options which configure the next track
     * @param {number} [options.direction=1] Whether to advance forward (if 1) or backwards (if -1)
     * @returns {Promise<Playlist>}   The updated Playlist document
     */
    playNext(soundId?: string, { direction }?: {
        direction?: number;
    }): Promise<Playlist>;
    /**
     * Begin playback of a specific Sound within this Playlist.
     * Determine which other sounds should remain playing, if any.
     * @param {PlaylistSound} sound       The desired sound that should play
     * @returns {Promise<Playlist>}       The updated Playlist
     */
    playSound(sound: PlaylistSound): Promise<Playlist>;
    /**
     * Stop playback of a specific Sound within this Playlist.
     * Determine which other sounds should remain playing, if any.
     * @param {PlaylistSound} sound       The desired sound that should play
     * @returns {Promise<Playlist>}       The updated Playlist
     */
    stopSound(sound: PlaylistSound): Promise<Playlist>;
    /**
     * End playback for any/all currently playing sounds within the Playlist.
     * @returns {Promise<Playlist>} The updated Playlist document
     */
    stopAll(): Promise<Playlist>;
    /**
     * Cycle the playlist mode
     * @return {Promise.<Playlist>}   A promise which resolves to the updated Playlist instance
     */
    cycleMode(): Promise<Playlist>;
    /**
     * Get the next sound in the cached playback order. For internal use.
     * @private
     */
    private _getNextSound;
    /**
     * Get the previous sound in the cached playback order. For internal use.
     * @private
     */
    private _getPreviousSound;
    /**
     * Define the sorting order for the Sounds within this Playlist. For internal use.
     * @private
     */
    private _sortSounds;
    /** @inheritdoc */
    toAnchor({ classes, ...options }?: {
        classes?: any[];
    }): any;
    /** @inheritdoc */
    _onClickDocumentLink(event: any): Promise<Playlist>;
    /** @inheritdoc */
    _preUpdate(changed: any, options: any, user: any): Promise<any>;
    /** @inheritdoc */
    _onUpdate(changed: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDelete(options: any, userId: any): void;
    /** @inheritdoc */
    _onCreateDescendantDocuments(parent: any, collection: any, documents: any, data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onUpdateDescendantDocuments(parent: any, collection: any, documents: any, changes: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDeleteDescendantDocuments(parent: any, collection: any, documents: any, ids: any, options: any, userId: any): void;
    /**
     * Handle callback logic when an individual sound within the Playlist concludes playback naturally
     * @param {PlaylistSound} sound
     * @private
     */
    private _onSoundEnd;
    /**
     * Handle callback logic when playback for an individual sound within the Playlist is started.
     * Schedule auto-preload of next track
     * @param {PlaylistSound} sound
     * @private
     */
    private _onSoundStart;
    /**
     * Update the playing status of this Playlist in content links.
     * @param {object} changed  The data changes.
     * @private
     */
    private _updateContentLinkPlaying;
    /** @inheritdoc */
    toCompendium(pack: any, options?: {}): any;
}
/**
 * The client-side Scene document which extends the common BaseScene model.
 * @extends documents.BaseItem
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scenes}            The world-level collection of Scene documents
 * @see {@link SceneConfig}       The Scene configuration application
 */
declare class Scene {
    /**
     * @deprecated since v10
     * @ignore
     */
    static getDimensions(data: any): void;
    /**
     * Track the viewed position of each scene (while in memory only, not persisted)
     * When switching back to a previously viewed scene, we can automatically pan to the previous position.
     * @type {CanvasViewPosition}
     */
    _viewPosition: {
        /**
         * The x-coordinate which becomes stage.pivot.x
         */
        x: number;
        /**
         * The y-coordinate which becomes stage.pivot.y
         */
        y: number;
        /**
         * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
         */
        scale: number;
    };
    /**
     * Track whether the scene is the active view
     * @type {boolean}
     */
    _view: boolean;
    /**
     * Determine the canvas dimensions this Scene would occupy, if rendered
     * @type {object}
     */
    dimensions: object;
    /**
     * Provide a thumbnail image path used to represent this document.
     * @type {string}
     */
    get thumbnail(): string;
    /**
     * A convenience accessor for whether the Scene is currently viewed
     * @type {boolean}
     */
    get isView(): boolean;
    /**
     * Set this scene as currently active
     * @returns {Promise<Scene>}  A Promise which resolves to the current scene once it has been successfully activated
     */
    activate(): Promise<Scene>;
    /**
     * Set this scene as the current view
     * @returns {Promise<Scene>}
     */
    view(): Promise<Scene>;
    /** @override */
    override clone(createData?: {}, options?: {}): any;
    /** @override */
    override reset(): void;
    /** @inheritdoc */
    prepareBaseData(): void;
    playlistSound: any;
    foregroundElevation: any;
    /**
     * @typedef {object} SceneDimensions
     * @property {number} width        The width of the canvas.
     * @property {number} height       The height of the canvas.
     * @property {number} size         The grid size.
     * @property {Rectangle} rect      The canvas rectangle.
     * @property {number} sceneX       The X coordinate of the scene rectangle within the larger canvas.
     * @property {number} sceneY       The Y coordinate of the scene rectangle within the larger canvas.
     * @property {number} sceneWidth   The width of the scene.
     * @property {number} sceneHeight  The height of the scene.
     * @property {Rectangle} sceneRect The scene rectangle.
     * @property {number} distance     The number of distance units in a single grid space.
     * @property {number} ratio        The aspect ratio of the scene rectangle.
     * @property {number} maxR               The length of the longest line that can be drawn on the canvas.
     */
    /**
     * Get the Canvas dimensions which would be used to display this Scene.
     * Apply padding to enlarge the playable space and round to the nearest 2x grid size to ensure symmetry.
     * The rounding accomplishes that the padding buffer around the map always contains whole grid spaces.
     * @returns {SceneDimensions}
     */
    getDimensions(): {
        /**
         * The width of the canvas.
         */
        width: number;
        /**
         * The height of the canvas.
         */
        height: number;
        /**
         * The grid size.
         */
        size: number;
        /**
         * The canvas rectangle.
         */
        rect: Rectangle;
        /**
         * The X coordinate of the scene rectangle within the larger canvas.
         */
        sceneX: number;
        /**
         * The Y coordinate of the scene rectangle within the larger canvas.
         */
        sceneY: number;
        /**
         * The width of the scene.
         */
        sceneWidth: number;
        /**
         * The height of the scene.
         */
        sceneHeight: number;
        /**
         * The scene rectangle.
         */
        sceneRect: Rectangle;
        /**
         * The number of distance units in a single grid space.
         */
        distance: number;
        /**
         * The aspect ratio of the scene rectangle.
         */
        ratio: number;
        /**
         * The length of the longest line that can be drawn on the canvas.
         */
        maxR: number;
    };
    /** @inheritdoc */
    _onClickDocumentLink(event: any): any;
    /** @override */
    override _preCreate(data: any, options: any, user: any): Promise<any>;
    /** @override */
    override _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _preUpdate(data: any, options: any, user: any): Promise<any>;
    /**
     * Handle repositioning of placed objects when the Scene dimensions change
     * @private
     */
    private _repositionObjects;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): any;
    thumb: any;
    /** @inheritdoc */
    _preDelete(options: any, user: any): Promise<void>;
    /** @override */
    override _onDelete(options: any, userId: any): void;
    /**
     * Handle Scene activation workflow if the active state is changed to true
     * @param {boolean} active    Is the scene now active?
     * @protected
     */
    protected _onActivate(active: boolean): any;
    /** @inheritdoc */
    _preCreateDescendantDocuments(parent: any, collection: any, data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _preUpdateDescendantDocuments(parent: any, collection: any, changes: any, options: any, userId: any): void;
    /** @inheritdoc */
    _preDeleteDescendantDocuments(parent: any, collection: any, ids: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onUpdateDescendantDocuments(parent: any, collection: any, documents: any, changes: any, options: any, userId: any): void;
    /** @inheritdoc */
    toCompendium(pack: any, options?: {}): any;
    /**
     * Create a 300px by 100px thumbnail image for this scene background
     * @param {object} [options]      Options which modify thumbnail creation
     * @param {string|null} [options.img]  A background image to use for thumbnail creation, otherwise the current scene
     *                          background is used.
     * @param {number} [options.width]        The desired thumbnail width. Default is 300px
     * @param {number} [options.height]       The desired thumbnail height. Default is 100px;
     * @param {string} [options.format]       Which image format should be used? image/png, image/jpg, or image/webp
     * @param {number} [options.quality]      What compression quality should be used for jpeg or webp, between 0 and 1
     * @returns {Promise<object>}      The created thumbnail data.
     */
    createThumbnail({ img, width, height, format, quality }?: {
        img?: string | null;
        width?: number;
        height?: number;
        format?: string;
        quality?: number;
    }): Promise<object>;
}
/**
 * The client-side Setting document which extends the common BaseSetting model.
 * @extends documents.BaseSetting
 * @mixes ClientDocumentMixin
 *
 * @see {@link WorldSettings}       The world-level collection of Setting documents
 */
declare class Setting {
    /**
     * The types of settings which should be constructed as a function call rather than as a class constructor.
     */
    static "__#125@#PRIMITIVE_TYPES": readonly (SymbolConstructor | StringConstructor | BooleanConstructor | NumberConstructor | ArrayConstructor | BigIntConstructor)[];
    /**
     * The setting configuration for this setting document.
     * @type {SettingsConfig|undefined}
     */
    get config(): SettingsConfig;
    /** @inheritDoc */
    _initialize(options?: {}): void;
    value: any;
    /** @override */
    override _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _onUpdate(changed: any, options: any, userId: any): void;
    /**
     * Cast the value of the Setting into its defined type.
     * @returns {*}     The initialized type of the Setting document.
     * @protected
     */
    protected _castType(): any;
}
/**
 * The client-side TableResult document which extends the common BaseTableResult document model.
 * @extends documents.BaseTableResult
 * @mixes ClientDocumentMixin
 *
 * @see {@link RollTable}                The RollTable document type which contains TableResult documents
 */
declare class TableResult {
    /**
     * A path reference to the icon image used to represent this result
     */
    get icon(): any;
    /**
     * Prepare a string representation for the result which (if possible) will be a dynamic link or otherwise plain text
     * @returns {string}  The text to display
     */
    getChatText(): string;
}
/**
 * @typedef {Object} RollTableDraw      An object containing the executed Roll and the produced results
 * @property {Roll} roll                The Dice roll which generated the draw
 * @property {TableResult[]} results    An array of drawn TableResult documents
 */
/**
 * The client-side RollTable document which extends the common BaseRollTable model.
 * @extends documents.BaseRollTable
 * @mixes ClientDocumentMixin
 *
 * @see {@link RollTables}                      The world-level collection of RollTable documents
 * @see {@link TableResult}                     The embedded TableResult document
 * @see {@link RollTableConfig}                 The RollTable configuration application
 */
declare class RollTable {
    /**
     * Create a new RollTable document using all of the Documents from a specific Folder as new results.
     * @param {Folder} folder       The Folder document from which to create a roll table
     * @param {object} options      Additional options passed to the RollTable.create method
     * @returns {Promise<RollTable>}
     */
    static fromFolder(folder: Folder, options?: object): Promise<RollTable>;
    /**
     * Provide a thumbnail image path used to represent this document.
     * @type {string}
     */
    get thumbnail(): string;
    /**
     * Display a result drawn from a RollTable in the Chat Log along.
     * Optionally also display the Roll which produced the result and configure aspects of the displayed messages.
     *
     * @param {TableResult[]} results         An Array of one or more TableResult Documents which were drawn and should
     *                                        be displayed.
     * @param {object} [options={}]           Additional options which modify message creation
     * @param {Roll} [options.roll]                 An optional Roll instance which produced the drawn results
     * @param {Object} [options.messageData={}]     Additional data which customizes the created messages
     * @param {Object} [options.messageOptions={}]  Additional options which customize the created messages
     */
    toMessage(results: TableResult[], { roll, messageData, messageOptions }?: {
        roll?: Roll;
        messageData?: any;
        messageOptions?: any;
    }): Promise<any>;
    /**
     * Draw a result from the RollTable based on the table formula or a provided Roll instance
     * @param {object} [options={}]         Optional arguments which customize the draw behavior
     * @param {Roll} [options.roll]                   An existing Roll instance to use for drawing from the table
     * @param {boolean} [options.recursive=true]      Allow drawing recursively from inner RollTable results
     * @param {TableResult[]} [options.results]       One or more table results which have been drawn
     * @param {boolean} [options.displayChat=true]    Whether to automatically display the results in chat
     * @param {string} [options.rollMode]             The chat roll mode to use when displaying the result
     * @returns {Promise<{RollTableDraw}>}  A Promise which resolves to an object containing the executed roll and the
     *                                      produced results.
     */
    draw({ roll, recursive, results, displayChat, rollMode }?: {
        roll?: Roll;
        recursive?: boolean;
        results?: TableResult[];
        displayChat?: boolean;
        rollMode?: string;
    }): Promise<{
        RollTableDraw;
    }>;
    /**
     * Draw multiple results from a RollTable, constructing a final synthetic Roll as a dice pool of inner rolls.
     * @param {number} number               The number of results to draw
     * @param {object} [options={}]         Optional arguments which customize the draw
     * @param {Roll} [options.roll]                   An optional pre-configured Roll instance which defines the dice
     *                                                roll to use
     * @param {boolean} [options.recursive=true]      Allow drawing recursively from inner RollTable results
     * @param {boolean} [options.displayChat=true]    Automatically display the drawn results in chat? Default is true
     * @param {string} [options.rollMode]             Customize the roll mode used to display the drawn results
     * @returns {Promise<{RollTableDraw}>}  The drawn results
     */
    drawMany(number: number, { roll, recursive, displayChat, rollMode }?: {
        roll?: Roll;
        recursive?: boolean;
        displayChat?: boolean;
        rollMode?: string;
    }): Promise<{
        RollTableDraw;
    }>;
    /**
     * Normalize the probabilities of rolling each item in the RollTable based on their assigned weights
     * @returns {Promise<RollTable>}
     */
    normalize(): Promise<RollTable>;
    /**
     * Reset the state of the RollTable to return any drawn items to the table
     * @returns {Promise<RollTable>}
     */
    resetResults(): Promise<RollTable>;
    /**
     * Evaluate a RollTable by rolling its formula and retrieving a drawn result.
     *
     * Note that this function only performs the roll and identifies the result, the RollTable#draw function should be
     * called to formalize the draw from the table.
     *
     * @param {object} [options={}]       Options which modify rolling behavior
     * @param {Roll} [options.roll]                   An alternative dice Roll to use instead of the default table formula
     * @param {boolean} [options.recursive=true]   If a RollTable document is drawn as a result, recursively roll it
     * @param {number} [options._depth]            An internal flag used to track recursion depth
     * @returns {Promise<RollTableDraw>}  The Roll and results drawn by that Roll
     *
     * @example Draw results using the default table formula
     * ```js
     * const defaultResults = await table.roll();
     * ```
     *
     * @example Draw results using a custom roll formula
     * ```js
     * const roll = new Roll("1d20 + @abilities.wis.mod", actor.getRollData());
     * const customResults = await table.roll({roll});
     * ```
     */
    roll({ roll, recursive, _depth }?: {
        roll?: Roll;
        recursive?: boolean;
        _depth?: number;
    }): Promise<RollTableDraw>;
    /**
     * Get an Array of valid results for a given rolled total
     * @param {number} value    The rolled value
     * @returns {TableResult[]} An Array of results
     */
    getResultsForRoll(value: number): TableResult[];
    /** @inheritdoc */
    _onCreateDescendantDocuments(parent: any, collection: any, documents: any, data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDeleteDescendantDocuments(parent: any, collection: any, documents: any, ids: any, options: any, userId: any): void;
    /** @override */
    override toCompendium(pack: any, options?: {}): any;
}
/**
 * The client-side Tile document which extends the common BaseTile document model.
 * @extends documents.BaseTile
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains Tile documents
 * @see {@link TileConfig}                The Tile configuration application
 */
declare class TileDocument {
    set elevation(arg: number);
    /**
     * Define an elevation property on the Tile Document which in the future will become a core part of its data schema.
     * @type {number}
     */
    get elevation(): number;
    /**
     * Define a sort property on the Tile Document which in the future will become a core part of its data schema.
     * @type {number}
     */
    get sort(): number;
    /** @inheritdoc */
    prepareDerivedData(): void;
    x: any;
    y: any;
    #private;
}
/**
 * The client-side Token document which extends the common BaseToken document model.
 * @extends documents.BaseToken
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains Token documents
 * @see {@link TokenConfig}               The Token configuration application
 */
declare class TokenDocument {
    /**
     * @typedef {object} TrackedAttributesDescription
     * @property {string[][]} bar    A list of property path arrays to attributes with both a value and a max property.
     * @property {string[][]} value  A list of property path arrays to attributes that have only a value property.
     */
    /**
     * Get an Array of attribute choices which could be tracked for Actors in the Combat Tracker
     * @param {object|DataModel|typeof DataModel|SchemaField|string} [data]  The object to explore for attributes, or an
     *                                                                       Actor type.
     * @param {string[]} [_path]
     * @returns {TrackedAttributesDescription}
     */
    static getTrackedAttributes(data?: object | DataModel | typeof DataModel | SchemaField | string, _path?: string[]): {
        /**
         * A list of property path arrays to attributes with both a value and a max property.
         */
        bar: string[][];
        /**
         * A list of property path arrays to attributes that have only a value property.
         */
        value: string[][];
    };
    /**
     * Retrieve an Array of attribute choices from a plain object.
     * @param {object} data  The object to explore for attributes.
     * @param {string[]} _path
     * @returns {TrackedAttributesDescription}
     * @protected
     */
    protected static _getTrackedAttributesFromObject(data: object, _path?: string[]): {
        /**
         * A list of property path arrays to attributes with both a value and a max property.
         */
        bar: string[][];
        /**
         * A list of property path arrays to attributes that have only a value property.
         */
        value: string[][];
    };
    /**
     * Retrieve an Array of attribute choices from a SchemaField.
     * @param {SchemaField} schema  The schema to explore for attributes.
     * @param {string[]} _path
     * @returns {TrackedAttributesDescription}
     * @protected
     */
    protected static _getTrackedAttributesFromSchema(schema: SchemaField, _path?: string[]): {
        /**
         * A list of property path arrays to attributes with both a value and a max property.
         */
        bar: string[][];
        /**
         * A list of property path arrays to attributes that have only a value property.
         */
        value: string[][];
    };
    /**
     * Retrieve any configured attributes for a given Actor type.
     * @param {string} [type]  The Actor type.
     * @returns {TrackedAttributesDescription|void}
     * @protected
     */
    protected static _getConfiguredTrackedAttributes(type?: string): void | {
        /**
         * A list of property path arrays to attributes with both a value and a max property.
         */
        bar: string[][];
        /**
         * A list of property path arrays to attributes that have only a value property.
         */
        value: string[][];
    };
    /**
     * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar
     * @param {object} attributes       The tracked attributes which can be chosen from
     * @returns {object}                A nested object of attribute choices to display
     */
    static getTrackedAttributeChoices(attributes: object): object;
    /**
     * A singleton collection which holds a reference to the synthetic token actor by its base actor's ID.
     * @type {Collection<Actor>}
     */
    actors: Collection<Actor>;
    /**
     * A reference to the Actor this Token modifies.
     * If actorLink is true, then the document is the primary Actor document.
     * Otherwise, the Actor document is a synthetic (ephemeral) document constructed using the Token's ActorDelta.
     * @returns {Actor|null}
     */
    get actor(): Actor;
    /**
     * A reference to the base, World-level Actor this token represents.
     * @returns {Actor}
     */
    get baseActor(): Actor;
    /**
     * An indicator for whether the current User has full control over this Token document.
     * @type {boolean}
     */
    get isOwner(): boolean;
    /**
     * A convenient reference for whether this TokenDocument is linked to the Actor it represents, or is a synthetic copy
     * @type {boolean}
     */
    get isLinked(): boolean;
    /**
     * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.
     * @type {Combatant|null}
     */
    get combatant(): Function;
    /**
     * An indicator for whether this Token is currently involved in the active combat encounter.
     * @type {boolean}
     */
    get inCombat(): boolean;
    set sort(arg: number);
    /**
     * Define a sort order for this TokenDocument.
     * This controls its rendering order in the PrimaryCanvasGroup relative to siblings at the same elevation.
     * In the future this will be replaced with a persisted database field for permanent adjustment of token stacking.
     * In case of ties, Tokens will be sorted above other types of objects.
     * @type {number}
     */
    get sort(): number;
    /** @inheritdoc */
    _initialize(options?: {}): void;
    /** @inheritdoc */
    prepareBaseData(): void;
    alpha: any;
    /** @inheritdoc */
    prepareEmbeddedDocuments(): void;
    /**
     * Prepare detection modes which are available to the Token.
     * Ensure that every Token has the basic sight detection mode configured.
     * @protected
     */
    protected _prepareDetectionModes(): void;
    /**
     * A helper method to retrieve the underlying data behind one of the Token's attribute bars
     * @param {string} barName                The named bar to retrieve the attribute for
     * @param {object} [options]
     * @param {string} [options.alternative]  An alternative attribute path to get instead of the default one
     * @returns {object|null}                 The attribute displayed on the Token bar, if any
     */
    getBarAttribute(barName: string, { alternative }?: {
        alternative?: string;
    }): object | null;
    /**
     * A helper function to toggle a status effect which includes an Active Effect template
     * @param {{id: string, label: string, icon: string}} effectData The Active Effect data
     * @param {object} [options]                                     Options to configure application of the Active Effect
     * @param {boolean} [options.overlay=false]                      Should the Active Effect icon be displayed as an
     *                                                               overlay on the token?
     * @param {boolean} [options.active]                             Force a certain active state for the effect.
     * @returns {Promise<boolean>}                                   Whether the Active Effect is now on or off
     */
    toggleActiveEffect(effectData: {
        id: string;
        label: string;
        icon: string;
    }, { overlay, active }?: {
        overlay?: boolean;
        active?: boolean;
    }): Promise<boolean>;
    /**
     * Test whether a Token has a specific status effect.
     * @param {string} statusId     The status effect ID as defined in CONFIG.statusEffects
     * @returns {boolean}           Does the Token have this status effect?
     */
    hasStatusEffect(statusId: string): boolean;
    /**
     * Convenience method to change a token vision mode.
     * @param {string} visionMode       The vision mode to apply to this token.
     * @param {boolean} [defaults=true] If the vision mode should be updated with its defaults.
     * @returns {Promise<*>}
     */
    updateVisionMode(visionMode: string, defaults?: boolean): Promise<any>;
    /** @inheritdoc */
    getEmbeddedCollection(embeddedName: any): any;
    /** @inheritdoc */
    _preUpdate(data: any, options: any, user: any): Promise<void>;
    /** @inheritdoc */
    _onUpdate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDelete(options: any, userId: any): void;
    /**
     * Support the special case descendant document changes within an ActorDelta.
     * The descendant documents themselves are configured to have a synthetic Actor as their parent.
     * We need this to ensure that the ActorDelta receives these events which do not bubble up.
     * @inheritdoc
     */
    _preCreateDescendantDocuments(parent: any, collection: any, data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _preUpdateDescendantDocuments(parent: any, collection: any, changes: any, options: any, userId: any): void;
    /** @inheritdoc */
    _preDeleteDescendantDocuments(parent: any, collection: any, ids: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onCreateDescendantDocuments(parent: any, collection: any, documents: any, data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onUpdateDescendantDocuments(parent: any, collection: any, documents: any, changes: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDeleteDescendantDocuments(parent: any, collection: any, documents: any, ids: any, options: any, userId: any): void;
    /**
     * When the base Actor for a TokenDocument changes, we may need to update its Actor instance
     * @param {object} update
     * @param {object} options
     * @internal
     */
    _onUpdateBaseActor(update?: object, options?: object): void;
    /**
     * Whenever the token's actor delta changes, or the base actor changes, perform associated refreshes.
     * @param {object} [update]                        The update delta.
     * @param {DocumentModificationContext} [options]  The options provided to the update.
     * @protected
     */
    protected _onRelatedUpdate(update?: object, options?: DocumentModificationContext): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    getActor(): any;
    set actorData(arg: any);
    /**
     * @deprecated since v11
     * @ignore
     */
    get actorData(): any;
    delta: any;
    #private;
}
declare const PrototypeTokenDocument_base: typeof import("../../common/data/data.mjs").PrototypeToken;
/**
 * @deprecated since v10
 * @see data.PrototypeToken
 * @ignore
 */
declare class PrototypeTokenDocument extends PrototypeTokenDocument_base {
    constructor(...args: any[]);
}
/**
 * The client-side User document which extends the common BaseUser model.
 * Each User document contains UserData which defines its data schema.
 *
 * @extends documents.BaseUser
 * @mixes ClientDocumentMixin
 *
 * @see {@link documents.Users}             The world-level collection of User documents
 * @see {@link applications.UserConfig}     The User configuration application
 */
declare class User {
    /**
     * Track whether the user is currently active in the game
     * @type {boolean}
     */
    active: boolean;
    /**
     * Track references to the current set of Tokens which are targeted by the User
     * @type {Set<Token>}
     */
    targets: Set<Function>;
    /**
     * Track the ID of the Scene that is currently being viewed by the User
     * @type {string|null}
     */
    viewedScene: string | null;
    /**
     * A flag for whether the current User is a Trusted Player
     * @type {boolean}
     */
    get isTrusted(): boolean;
    /**
     * A flag for whether this User is the connected client
     * @type {boolean}
     */
    get isSelf(): boolean;
    /** @inheritdoc */
    prepareDerivedData(): void;
    avatar: any;
    border: import("../../common/utils/color.mjs").default;
    /**
     * Assign a Macro to a numbered hotbar slot between 1 and 50
     * @param {Macro|null} macro      The Macro document to assign
     * @param {number|string} [slot]  A specific numbered hotbar slot to fill
     * @param {number} [fromSlot]     An optional origin slot from which the Macro is being shifted
     * @returns {Promise<User>}       A Promise which resolves once the User update is complete
     */
    assignHotbarMacro(macro: Macro | null, slot?: number | string, { fromSlot }?: number): Promise<User>;
    /**
     * Assign a specific boolean permission to this user.
     * Modifies the user permissions to grant or restrict access to a feature.
     *
     * @param {string} permission    The permission name from USER_PERMISSIONS
     * @param {boolean} allowed      Whether to allow or restrict the permission
     */
    assignPermission(permission: string, allowed: boolean): any;
    /**
     * @typedef {object} PingData
     * @property {boolean} [pull=false]  Pulls all connected clients' views to the pinged co-ordinates.
     * @property {string} style          The ping style, see CONFIG.Canvas.pings.
     * @property {string} scene          The ID of the scene that was pinged.
     * @property {number} zoom           The zoom level at which the ping was made.
     */
    /**
     * @typedef {object} ActivityData
     * @property {string|null} [sceneId]           The ID of the scene that the user is viewing.
     * @property {{x: number, y: number}} [cursor] The position of the user's cursor.
     * @property {RulerData|null} [ruler]          The state of the user's ruler, if they are currently using one.
     * @property {string[]} [targets]              The IDs of the tokens the user has targeted in the currently viewed
     *                                             scene.
     * @property {boolean} [active]                Whether the user has an open WS connection to the server or not.
     * @property {PingData} [ping]                 Is the user emitting a ping at the cursor coordinates?
     * @property {AVSettingsData} [av]             The state of the user's AV settings.
     */
    /**
     * Submit User activity data to the server for broadcast to other players.
     * This type of data is transient, persisting only for the duration of the session and not saved to any database.
     * Activity data uses a volatile event to prevent unnecessary buffering if the client temporarily loses connection.
     * @param {ActivityData} activityData  An object of User activity data to submit to the server for broadcast.
     * @param {object} [options]
     * @param {boolean|undefined} [options.volatile]  If undefined, volatile is inferred from the activity data.
     */
    broadcastActivity(activityData?: {
        /**
         * The ID of the scene that the user is viewing.
         */
        sceneId?: string;
        /**
         * The position of the user's cursor.
         */
        cursor?: {
            x: number;
            y: number;
        };
        /**
         * The state of the user's ruler, if they are currently using one.
         */
        ruler?: {
            /**
             * The ruler measurement state.
             */
            _state: number;
            /**
             * A unique name for the ruler containing the owning user's ID.
             */
            name: string;
            /**
             * The current point the ruler has been extended to.
             */
            destination: PIXI.Point;
            /**
             * The class name of this ruler instance.
             */
            class: string;
            /**
             * Additional waypoints along the ruler's length, including the starting point.
             */
            waypoints: PIXI.Point[];
        };
        /**
         * The IDs of the tokens the user has targeted in the currently viewed
         *               scene.
         */
        targets?: string[];
        /**
         * Whether the user has an open WS connection to the server or not.
         */
        active?: boolean;
        /**
         * Is the user emitting a ping at the cursor coordinates?
         */
        ping?: {
            /**
             * Pulls all connected clients' views to the pinged co-ordinates.
             */
            pull?: boolean;
            /**
             * The ping style, see CONFIG.Canvas.pings.
             */
            style: string;
            /**
             * The ID of the scene that was pinged.
             */
            scene: string;
            /**
             * The zoom level at which the ping was made.
             */
            zoom: number;
        };
        /**
         * The state of the user's AV settings.
         */
        av?: AVSettingsData;
    }, { volatile }?: {
        volatile?: boolean | undefined;
    }): void;
    /**
     * Get an Array of Macro Documents on this User's Hotbar by page
     * @param {number} page     The hotbar page number
     * @returns {Array<{slot: number, macro: Macro|null}>}
     */
    getHotbarMacros(page?: number): Array<{
        slot: number;
        macro: Macro | null;
    }>;
    /**
     * Update the set of Token targets for the user given an array of provided Token ids.
     * @param {string[]} targetIds      An array of Token ids which represents the new target set
     */
    updateTokenTargets(targetIds?: string[]): void;
    /** @inheritdoc  */
    _onUpdate(data: any, options: any, userId: any): any;
    /** @inheritdoc  */
    _onDelete(options: any, userId: any): void;
}
/**
 * The client-side Wall document which extends the common BaseWall document model.
 * @extends documents.BaseWall
 * @mixes ClientDocumentMixin
 *
 * @see {@link Scene}                     The Scene document type which contains Wall documents
 * @see {@link WallConfig}                The Wall configuration application
 */
declare class WallDocument {
}
/**
 * The virtual tabletop environment is implemented using a WebGL powered HTML 5 canvas using the powerful PIXI.js
 * library. The canvas is comprised by an ordered sequence of layers which define rendering groups and collections of
 * objects that are drawn on the canvas itself.
 *
 * ### Hook Events
 * {@link hookEvents.canvasConfig}
 * {@link hookEvents.canvasInit}
 * {@link hookEvents.canvasReady}
 * {@link hookEvents.canvasPan}
 * {@link hookEvents.canvasTearDown}
 *
 * @category - Canvas
 *
 * @example Canvas State
 * ```js
 * canvas.ready; // Is the canvas ready for use?
 * canvas.scene; // The currently viewed Scene document.
 * canvas.dimensions; // The dimensions of the current Scene.
 * ```
 * @example Canvas Methods
 * ```js
 * canvas.draw(); // Completely re-draw the game canvas (this is usually unnecessary).
 * canvas.pan(x, y, zoom); // Pan the canvas to new coordinates and scale.
 * canvas.recenter(); // Re-center the canvas on the currently controlled Token.
 * ```
 */
declare class Canvas {
    /**
     * A mapping of named CanvasLayer classes which defines the layers which comprise the Scene.
     * @type {Object<CanvasLayer>}
     */
    static get layers(): any;
    /**
     * Configure the usage of WebGL for the PIXI.Application that will be created.
     * @throws an Error if WebGL is not supported by this browser environment.
     * @private
     */
    private static "__#128@#configureWebGL";
    /**
     * Create the Canvas element which will be the render target for the PIXI.Application instance.
     * Replace the template element which serves as a placeholder in the initially served HTML response.
     * @returns {HTMLCanvasElement}
     * @private
     */
    private static "__#128@#createHTMLCanvas";
    /**
     * Configure the settings used to initialize the PIXI.Application instance.
     * @returns {object}    Options passed to the PIXI.Application constructor.
     * @private
     */
    private static "__#128@#configureCanvasSettings";
    /**
     * Remove all children of the display object and call one cleaning method:
     * clean first, then tearDown, and destroy if no cleaning method is found.
     * @param {PIXI.DisplayObject} displayObject  The display object to clean.
     * @param {boolean} destroy                   If textures should be destroyed.
     */
    static clearContainer(displayObject: PIXI.DisplayObject, destroy?: boolean): void;
    /**
     * Get a texture with the required configuration and clear color.
     * @param {object} options
     * @param {number[]} [options.clearColor]           The clear color to use for this texture. Transparent by default.
     * @param {object} [options.textureConfiguration]   The render texture configuration.
     * @returns {PIXI.RenderTexture}
     */
    static getRenderTexture({ clearColor, textureConfiguration }?: {
        clearColor?: number[];
        textureConfiguration?: object;
    }): PIXI.RenderTexture;
    /**
     * @deprecated since v10
     * @ignore
     */
    static getDimensions(scene: any): any;
    /**
     * A perception manager interface for batching lighting, sight, and sound updates
     * @type {PerceptionManager}
     */
    perception: PerceptionManager;
    /**
     * A flag to indicate whether a new Scene is currently being drawn.
     * @type {boolean}
     */
    loading: boolean;
    /**
     * A promise that resolves when the canvas is first initialized and ready.
     * @type {Promise<void>|null}
     */
    initializing: Promise<void> | null;
    /**
     * Track the last automatic pan time to throttle
     * @type {number}
     * @private
     */
    private _panTime;
    /**
     * A set of blur filter instances which are modified by the zoom level and the "soft shadows" setting
     * @type {Set<PIXI.filters>}
     */
    blurFilters: Set<PIXI.filters>;
    /**
     * A reference to the MouseInteractionManager that is currently controlling pointer-based interaction, or null.
     * @type {MouseInteractionManager|null}
     */
    currentMouseManager: MouseInteractionManager | null;
    /**
     * The current pixel dimensions of the displayed Scene, or null if the Canvas is blank.
     * @type {SceneDimensions}
     */
    dimensions: {
        /**
         * The width of the canvas.
         */
        width: number;
        /**
         * The height of the canvas.
         */
        height: number;
        /**
         * The grid size.
         */
        size: number;
        /**
         * The canvas rectangle.
         */
        rect: Rectangle;
        /**
         * The X coordinate of the scene rectangle within the larger canvas.
         */
        sceneX: number;
        /**
         * The Y coordinate of the scene rectangle within the larger canvas.
         */
        sceneY: number;
        /**
         * The width of the scene.
         */
        sceneWidth: number;
        /**
         * The height of the scene.
         */
        sceneHeight: number;
        /**
         * The scene rectangle.
         */
        sceneRect: Rectangle;
        /**
         * The number of distance units in a single grid space.
         */
        distance: number;
        /**
         * The aspect ratio of the scene rectangle.
         */
        ratio: number;
        /**
         * The length of the longest line that can be drawn on the canvas.
         */
        maxR: number;
    };
    /**
     * Configure options passed to the texture loaded for the Scene.
     * This object can be configured during the canvasInit hook before textures have been loaded.
     * @type {{expireCache: boolean, additionalSources: string[]}}
     */
    loadTexturesOptions: {
        expireCache: boolean;
        additionalSources: string[];
    };
    /**
     * Configure options passed to initialize blur for the Scene and override normal behavior.
     * This object can be configured during the canvasInit hook before blur is initialized.
     * @type {{enabled: boolean, blurClass: Class, strength: number, passes: number, kernels: number}}
     */
    blurOptions: {
        enabled: boolean;
        blurClass: Class;
        strength: number;
        passes: number;
        kernels: number;
    };
    /**
     * Configure the Textures to apply to the Scene.
     * Textures registered here will be automatically loaded as part of the TextureLoader.loadSceneTextures workflow.
     * Textures which need to be loaded should be configured during the "canvasInit" hook.
     * @type {{[background]: PIXI.Texture, [foreground]: PIXI.Texture, [fogOverlay]: PIXI.Texture}}
     */
    sceneTextures: {
        [background]: PIXI.Texture;
        [foreground]: PIXI.Texture;
        [fogOverlay]: PIXI.Texture;
    };
    /**
     * Record framerate performance data.
     * @type {{average: number, values: number[], element: HTMLElement, render: number}}
     */
    fps: {
        average: number;
        values: number[];
        element: HTMLElement;
        render: number;
    };
    /**
     * The singleton interaction manager instance which handles mouse interaction on the Canvas.
     * @type {MouseInteractionManager}
     */
    mouseInteractionManager: MouseInteractionManager;
    /**
     * @typedef {Object} CanvasPerformanceSettings
     * @property {number} mode      The performance mode in CONST.CANVAS_PERFORMANCE_MODES
     * @property {{enabled: boolean, illumination: boolean}} blur   Blur filter configuration
     * @property {string} mipmap    Whether to use mipmaps, "ON" or "OFF"
     * @property {boolean} msaa     Whether to apply MSAA at the overall canvas level
     * @property {number} fps       Maximum framerate which should be the render target
     * @property {boolean} tokenAnimation   Whether to display token movement animation
     * @property {boolean} lightAnimation   Whether to display light source animation
     * @property {boolean} lightSoftEdges   Whether to render soft edges for light sources
     * @property {{enabled: boolean, maxSize: number, p2Steps: number, p2StepsMax: 2}} textures  Texture configuration
     */
    /**
     * Configured performance settings which affect the behavior of the Canvas and its renderer.
     * @type {CanvasPerformanceSettings}
     */
    performance: {
        /**
         * The performance mode in CONST.CANVAS_PERFORMANCE_MODES
         */
        mode: number;
        /**
         * Blur filter configuration
         */
        blur: {
            enabled: boolean;
            illumination: boolean;
        };
        /**
         * Whether to use mipmaps, "ON" or "OFF"
         */
        mipmap: string;
        /**
         * Whether to apply MSAA at the overall canvas level
         */
        msaa: boolean;
        /**
         * Maximum framerate which should be the render target
         */
        fps: number;
        /**
         * Whether to display token movement animation
         */
        tokenAnimation: boolean;
        /**
         * Whether to display light source animation
         */
        lightAnimation: boolean;
        /**
         * Whether to render soft edges for light sources
         */
        lightSoftEdges: boolean;
        /**
         * Texture configuration
         */
        textures: {
            enabled: boolean;
            maxSize: number;
            p2Steps: number;
            p2StepsMax: 2;
        };
    };
    /**
     * @typedef {Object} CanvasSupportedComponents
     * @property {boolean} webGL2           Is WebGL2 supported?
     * @property {boolean} readPixelsRED    Is reading pixels in RED format supported?
     * @property {boolean} offscreenCanvas  Is the OffscreenCanvas supported?
     */
    /**
     * A list of supported webGL capabilities and limitations.
     * @type {CanvasSupportedComponents}
     */
    supported: {
        /**
         * Is WebGL2 supported?
         */
        webGL2: boolean;
        /**
         * Is reading pixels in RED format supported?
         */
        readPixelsRED: boolean;
        /**
         * Is the OffscreenCanvas supported?
         */
        offscreenCanvas: boolean;
    };
    /**
     * Is the photosensitive mode enabled?
     * @type {boolean}
     */
    photosensitiveMode: boolean;
    /**
     * The renderer screen dimensions.
     * @type {number[]}
     */
    screenDimensions: number[];
    /**
     * The singleton Fog of War manager instance.
     * @type {FogManager}
     * @private
     */
    private _fog;
    /**
     * The singleton PIXI.Application instance rendered on the Canvas.
     * @type {PIXI.Application}
     */
    app: PIXI.Application;
    /**
     * The primary stage container of the PIXI.Application.
     * @type {PIXI.Container}
     */
    stage: PIXI.Container;
    /**
     * The primary Canvas group which generally contains tangible physical objects which exist within the Scene.
     * This group is a {@link CachedContainer} which is rendered to the Scene as a {@link SpriteMesh}.
     * This allows the rendered result of the Primary Canvas Group to be affected by a {@link BaseSamplerShader}.
     * @type {PrimaryCanvasGroup}
     */
    primary: PrimaryCanvasGroup;
    /**
     * The effects Canvas group which modifies the result of the {@link PrimaryCanvasGroup} by adding special effects.
     * This includes lighting, weather, vision, and other visual effects which modify the appearance of the Scene.
     * @type {EffectsCanvasGroup}
     */
    effects: EffectsCanvasGroup;
    /**
     * The interface Canvas group which is rendered above other groups and contains all interactive elements.
     * The various {@link InteractionLayer} instances of the interface group provide different control sets for
     * interacting with different types of {@link Document}s which can be represented on the Canvas.
     * @type {InterfaceCanvasGroup}
     */
    interface: InterfaceCanvasGroup;
    /**
     * The overlay Canvas group which is rendered above other groups and contains elements not bound to stage transform.
     * @type {OverlayCanvasGroup}
     */
    overlay: OverlayCanvasGroup;
    /**
     * The singleton HeadsUpDisplay container which overlays HTML rendering on top of this Canvas.
     * @type {HeadsUpDisplay}
     */
    hud: HeadsUpDisplay;
    /**
     * Position of the mouse on stage.
     * @type {PIXI.Point}
     */
    mousePosition: PIXI.Point;
    /**
     * A flag for whether the game Canvas is fully initialized and ready for additional content to be drawn.
     * @type {boolean}
     */
    get initialized(): boolean;
    /**
     * A reference to the currently displayed Scene document, or null if the Canvas is currently blank.
     * @type {Scene|null}
     */
    get scene(): Scene;
    /**
     * A flag for whether the game Canvas is ready to be used. False if the canvas is not yet drawn, true otherwise.
     * @type {boolean}
     */
    get ready(): boolean;
    /**
     * The fog of war bound to this canvas
     * @type {FogManager}
     */
    get fog(): FogManager;
    /**
     * The color manager class bound to this canvas
     * @type {CanvasColorManager}
     */
    get colorManager(): CanvasColorManager;
    /**
     * The colors bound to this scene and handled by the color manager.
     * @type {Color}
     */
    get colors(): typeof import("../../common/utils/color.mjs").default;
    /**
     * Shortcut to get the masks container from HiddenCanvasGroup.
     * @type {PIXI.Container}
     */
    get masks(): PIXI.Container;
    /**
     * The id of the currently displayed Scene.
     * @type {string|null}
     */
    get id(): string;
    /**
     * An Array of all CanvasLayer instances which are active on the Canvas board
     * @type {CanvasLayer[]}
     */
    get layers(): CanvasLayer[];
    /**
     * Return a reference to the active Canvas Layer
     * @type {CanvasLayer}
     */
    get activeLayer(): CanvasLayer;
    /**
     * The currently displayed darkness level, which may override the saved Scene value.
     * @type {number}
     */
    get darknessLevel(): number;
    /**
     * Initialize the Canvas by creating the HTML element and PIXI application.
     * This step should only ever be performed once per client session.
     * Subsequent requests to reset the canvas should go through Canvas#draw
     */
    initialize(): void;
    /**
     * TODO: Add a quality parameter
     * Compute the blur parameters according to grid size and performance mode.
     * @param options            Blur options.
     * @private
     */
    private _initializeBlur;
    blur: {
        enabled: any;
        blurClass: any;
        blurPassClass: any;
        strength: any;
        passes: any;
        kernels: any;
    };
    /**
     * Configure performance settings for hte canvas application based on the selected performance mode.
     * @returns {CanvasPerformanceSettings}
     * @internal
     */
    _configurePerformanceMode(): {
        /**
         * The performance mode in CONST.CANVAS_PERFORMANCE_MODES
         */
        mode: number;
        /**
         * Blur filter configuration
         */
        blur: {
            enabled: boolean;
            illumination: boolean;
        };
        /**
         * Whether to use mipmaps, "ON" or "OFF"
         */
        mipmap: string;
        /**
         * Whether to apply MSAA at the overall canvas level
         */
        msaa: boolean;
        /**
         * Maximum framerate which should be the render target
         */
        fps: number;
        /**
         * Whether to display token movement animation
         */
        tokenAnimation: boolean;
        /**
         * Whether to display light source animation
         */
        lightAnimation: boolean;
        /**
         * Whether to render soft edges for light sources
         */
        lightSoftEdges: boolean;
        /**
         * Texture configuration
         */
        textures: {
            enabled: boolean;
            maxSize: number;
            p2Steps: number;
            p2StepsMax: 2;
        };
    };
    /**
     * Draw the game canvas.
     * @param {Scene} [scene]         A specific Scene document to render on the Canvas
     * @returns {Promise<Canvas>}     A Promise which resolves once the Canvas is fully drawn
     */
    draw(scene?: Scene): Promise<Canvas>;
    /**
     * When re-drawing the canvas, first tear down or discontinue some existing processes
     * @returns {Promise<void>}
     */
    tearDown(): Promise<void>;
    /**
     * Get the value of a GL parameter
     * @param {string} parameter  The GL parameter to retrieve
     * @returns {*}               The GL parameter value
     */
    getGLParameter(parameter: string): any;
    /**
     * Initialize the starting view of the canvas stage
     * If we are re-drawing a scene which was previously rendered, restore the prior view position
     * Otherwise set the view to the top-left corner of the scene at standard scale
     */
    initializeCanvasPosition(): void;
    /**
     * Given an embedded object name, get the canvas layer for that object
     * @param {string} embeddedName
     * @returns {PlaceablesLayer|null}
     */
    getLayerByEmbeddedName(embeddedName: string): PlaceablesLayer | null;
    /**
     * Get the InteractionLayer of the canvas which manages Documents of a certain collection within the Scene.
     * @param {string} collectionName     The collection name
     * @returns {PlaceablesLayer}         The canvas layer
     */
    getCollectionLayer(collectionName: string): PlaceablesLayer;
    /**
     * Activate framerate tracking by adding an HTML element to the display and refreshing it every frame.
     */
    activateFPSMeter(): void;
    /**
     * Deactivate framerate tracking by canceling ticker updates and removing the HTML element.
     */
    deactivateFPSMeter(): void;
    /**
     * @typedef {Object} CanvasViewPosition
     * @property {number|null} x      The x-coordinate which becomes stage.pivot.x
     * @property {number|null} y      The y-coordinate which becomes stage.pivot.y
     * @property {number|null} scale  The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
     */
    /**
     * Pan the canvas to a certain {x,y} coordinate and a certain zoom level
     * @param {CanvasViewPosition} position     The canvas position to pan to
     */
    pan({ x, y, scale }?: {
        /**
         * The x-coordinate which becomes stage.pivot.x
         */
        x: number | null;
        /**
         * The y-coordinate which becomes stage.pivot.y
         */
        y: number | null;
        /**
         * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
         */
        scale: number | null;
    }): void;
    /**
     * Animate panning the canvas to a certain destination coordinate and zoom scale
     * Customize the animation speed with additional options
     * Returns a Promise which is resolved once the animation has completed
     *
     * @param {CanvasViewPosition} view    The desired view parameters
     * @param {number} [view.duration=250] The total duration of the animation in milliseconds; used if speed is not set
     * @param {number} [view.speed]        The speed of animation in pixels per second; overrides duration if set
     * @returns {Promise}           A Promise which resolves once the animation has been completed
     */
    animatePan({ x, y, scale, duration, speed }?: {
        /**
         * The x-coordinate which becomes stage.pivot.x
         */
        x: number | null;
        /**
         * The y-coordinate which becomes stage.pivot.y
         */
        y: number | null;
        /**
         * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
         */
        scale: number | null;
    }): Promise<any>;
    /**
     * Recenter the canvas with a pan animation that ends in the center of the canvas rectangle.
     * @param {CanvasViewPosition} initial    A desired initial position from which to begin the animation
     * @returns {Promise<void>}               A Promise which resolves once the animation has been completed
     */
    recenter(initial: {
        /**
         * The x-coordinate which becomes stage.pivot.x
         */
        x: number | null;
        /**
         * The y-coordinate which becomes stage.pivot.y
         */
        y: number | null;
        /**
         * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
         */
        scale: number | null;
    }): Promise<void>;
    /**
     * Highlight objects on any layers which are visible
     * @param {boolean} active
     */
    highlightObjects(active: boolean): void;
    /**
     * Displays a Ping both locally and on other connected client, following these rules:
     * 1) Displays on the current canvas Scene
     * 2) If ALT is held, becomes an ALERT ping
     * 3) Else if the user is GM and SHIFT is held, becomes a PULL ping
     * 4) Else is a PULSE ping
     * @param {Point} origin                  Point to display Ping at
     * @param {PingOptions} [options]         Additional options to configure how the ping is drawn.
     * @returns {Promise<boolean>}
     */
    ping(origin: Point, options?: PingOptions): Promise<boolean>;
    /**
     * Get the constrained zoom scale parameter which is allowed by the maxZoom parameter
     * @param {CanvasViewPosition} position   The unconstrained position
     * @returns {CanvasViewPosition}          The constrained position
     * @internal
     */
    _constrainView({ x, y, scale }: {
        /**
         * The x-coordinate which becomes stage.pivot.x
         */
        x: number | null;
        /**
         * The y-coordinate which becomes stage.pivot.y
         */
        y: number | null;
        /**
         * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
         */
        scale: number | null;
    }): {
        /**
         * The x-coordinate which becomes stage.pivot.x
         */
        x: number | null;
        /**
         * The y-coordinate which becomes stage.pivot.y
         */
        y: number | null;
        /**
         * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
         */
        scale: number | null;
    };
    /**
     * Create a BlurFilter instance and register it to the array for updates when the zoom level changes.
     * @param {number} blurStrength         The desired blur strength to use for this filter
     * @returns {PIXI.filters.BlurFilter}
     */
    createBlurFilter(blurStrength?: number): PIXI.filters.BlurFilter;
    /**
     * Add a filter to the blur filter list. The filter must have the blur property
     * @param {PIXI.filters.BlurFilter} filter    The Filter instance to add
     * @returns {PIXI.filters.BlurFilter}         The added filter for method chaining
     */
    addBlurFilter(filter: PIXI.filters.BlurFilter): PIXI.filters.BlurFilter;
    /**
     * Update the blur strength depending on the scale of the canvas stage.
     * This number is zero if "soft shadows" are disabled
     * @param {number} [strength]      Optional blur strength to apply
     * @private
     */
    private updateBlur;
    /**
     * Convert canvas co-ordinates to the client's viewport.
     * @param {Point} origin  The canvas coordinates.
     * @returns {Point}       The corresponding co-ordinates relative to the client's viewport.
     */
    clientCoordinatesFromCanvas(origin: Point): Point;
    /**
     * Convert client viewport co-ordinates to canvas co-ordinates.
     * @param {Point} origin  The client coordinates.
     * @returns {Point}       The corresponding canvas co-ordinates.
     */
    canvasCoordinatesFromClient(origin: Point): Point;
    /**
     * Determine whether given canvas co-ordinates are off-screen.
     * @param {Point} position  The canvas co-ordinates.
     * @returns {boolean}       Is the coordinate outside the screen bounds?
     */
    isOffscreen(position: Point): boolean;
    /**
     * Handle mouse movement on the game canvas.
     * This handler fires on both a throttle and a debounce, ensuring that the final update is always recorded.
     * @param {PIXI.FederatedEvent} event
     * @private
     */
    private _onMouseMove;
    /**
     * Handle left mouse-click events occurring on the Canvas.
     * @see {MouseInteractionManager##handleClickLeft}
     * @param {PIXI.FederatedEvent} event
     * @private
     */
    private _onClickLeft;
    /**
     * Handle double left-click events occurring on the Canvas.
     * @see {MouseInteractionManager##handleClickLeft2}
     * @param {PIXI.FederatedEvent} event
     */
    _onClickLeft2(event: PIXI.FederatedEvent): void;
    /**
     * Handle long press events occurring on the Canvas.
     * @see {MouseInteractionManager##handleLongPress}
     * @param {PIXI.FederatedEvent}   event   The triggering canvas interaction event.
     * @param {PIXI.Point}            origin  The local canvas coordinates of the mousepress.
     * @private
     */
    private _onLongPress;
    /**
     * Handle the beginning of a left-mouse drag workflow on the Canvas stage or its active Layer.
     * @see {MouseInteractionManager##handleDragStart}
     * @param {PIXI.FederatedEvent} event
     * @internal
     */
    _onDragLeftStart(event: PIXI.FederatedEvent): any;
    /**
     * Handle mouse movement events occurring on the Canvas.
     * @see {MouseInteractionManager##handleDragMove}
     * @param {PIXI.FederatedEvent} event
     * @internal
     */
    _onDragLeftMove(event: PIXI.FederatedEvent): any;
    /**
     * Handle the conclusion of a left-mouse drag workflow when the mouse button is released.
     * @see {MouseInteractionManager##handleDragDrop}
     * @param {PIXI.FederatedEvent} event
     * @internal
     */
    _onDragLeftDrop(event: PIXI.FederatedEvent): any;
    /**
     * Handle the cancellation of a left-mouse drag workflow
     * @see {MouseInteractionManager##handleDragCancel}
     * @param {PointerEvent} event
     * @internal
     */
    _onDragLeftCancel(event: PointerEvent): true | void;
    /**
     * Handle right mouse-click events occurring on the Canvas.
     * @see {MouseInteractionManager##handleClickRight}
     * @param {PIXI.FederatedEvent} event
     * @private
     */
    private _onClickRight;
    /**
     * Handle double right-click events occurring on the Canvas.
     * @see {MouseInteractionManager##handleClickRight}
     * @param {PIXI.FederatedEvent} event
     * @private
     */
    private _onClickRight2;
    /**
     * Handle right-mouse drag events occurring on the Canvas.
     * @see {MouseInteractionManager##handleDragMove}
     * @param {PIXI.FederatedEvent} event
     * @private
     */
    private _onDragRightMove;
    /**
     * Handle the conclusion of a right-mouse drag workflow the Canvas stage.
     * @see {MouseInteractionManager##handleDragDrop}
     * @param {PIXI.FederatedEvent} event
     * @private
     */
    private _onDragRightDrop;
    /**
     * Determine selection coordinate rectangle during a mouse-drag workflow
     * @param {PIXI.FederatedEvent} event
     * @private
     */
    private _onDragSelect;
    /**
     * Pan the canvas view when the cursor position gets close to the edge of the frame
     * @param {MouseEvent} event    The originating mouse movement event
     */
    _onDragCanvasPan(event: MouseEvent): Promise<any>;
    /**
     * Handle window resizing with the dimensions of the window viewport change
     * @param {Event} event     The Window resize event
     * @private
     */
    private _onResize;
    /**
     * Handle mousewheel events which adjust the scale of the canvas
     * @param {WheelEvent} event    The mousewheel event that zooms the canvas
     * @private
     */
    private _onMouseWheel;
    /**
     * Event handler for the drop portion of a drag-and-drop event.
     * @param {DragEvent} event  The drag event being dropped onto the canvas
     * @private
     */
    private _onDrop;
    /**
     * Track objects which have pending render flags.
     * @enum {Set<RenderFlagObject>}
     */
    pendingRenderFlags: any;
    /**
     * @deprecated since v10
     * @ignore
     */
    set blurDistance(arg: any);
    /**
     * @deprecated since v10
     * @ignore
     */
    get blurDistance(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    activateLayer(layerName: any): void;
    /**
     * @deprecated since v10
     * @ignore
     */
    setBackgroundColor(color: any): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    addPendingOperation(name: any, fn: any, scope: any, args: any): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    triggerPendingOperations(): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    get pendingOperations(): any[];
    #private;
}
/**
 * An Abstract Base Class which defines a Placeable Object which represents a Document placed on the Canvas
 * @extends {PIXI.Container}
 * @abstract
 * @interface
 *
 * @param {abstract.Document} document      The Document instance which is represented by this object
 */
declare class PlaceableObject {
    /**
     * Identify the official Document name for this PlaceableObject class
     * @type {string}
     */
    static embeddedName: string;
    /**
     * The flags declared here are required for all PlaceableObject subclasses to also support.
     * @override
     */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshState: {};
    };
    constructor(document: any);
    /**
     * Retain a reference to the Scene within which this Placeable Object resides
     * @type {Scene}
     */
    scene: Scene;
    /**
     * A reference to the Scene embedded Document instance which this object represents
     * @type {abstract.Document}
     */
    document: abstract.Document;
    /**
     * Track the field of vision for the placeable object.
     * This is necessary to determine whether a player has line-of-sight towards a placeable object or vice-versa
     * @type {{fov: PIXI.Circle, los: PointSourcePolygon}}
     */
    vision: {
        fov: PIXI.Circle;
        los: PointSourcePolygon;
    };
    /**
     * A control icon for interacting with the object
     * @type {ControlIcon}
     */
    controlIcon: ControlIcon;
    /**
     * A mouse interaction manager instance which handles mouse workflows related to this object.
     * @type {MouseInteractionManager}
     */
    mouseInteractionManager: MouseInteractionManager;
    cullable: boolean;
    /**
     * Passthrough certain drag operations on locked objects.
     * @type {boolean}
     * @protected
     */
    protected _dragPassthrough: boolean;
    /**
     * Know if a placeable is in the hover-in state.
     * @type {boolean}
     * @protected
     */
    protected _isHoverIn: boolean;
    /**
     * The mouse interaction state of this placeable.
     * @type {MouseInteractionManager.INTERACTION_STATES|undefined}
     */
    get interactionState(): {
        NONE: number;
        HOVER: number;
        CLICKED: number;
        DRAG: number;
        DROP: number;
    };
    /**
     * The bounding box for this PlaceableObject.
     * This is required if the layer uses a Quadtree, otherwise it is optional
     * @returns {Rectangle}
     */
    get bounds(): Rectangle;
    /**
     * The central coordinate pair of the placeable object based on it's own width and height
     * @type {PIXI.Point}
     */
    get center(): PIXI.Point;
    /**
     * The id of the corresponding Document which this PlaceableObject represents.
     * @type {string}
     */
    get id(): string;
    /**
     * A unique identifier which is used to uniquely identify elements on the canvas related to this object.
     * @type {string}
     */
    get objectId(): string;
    /**
     * The named identified for the source object associated with this PlaceableObject.
     * This differs from the objectId because the sourceId is the same for preview objects as for the original.
     * @type {string}
     */
    get sourceId(): string;
    /**
     * Is this placeable object a temporary preview?
     * @type {boolean}
     */
    get isPreview(): boolean;
    /**
     * Does there exist a temporary preview of this placeable object?
     * @type {boolean}
     */
    get hasPreview(): boolean;
    /**
     * The field-of-vision polygon for the object, if it has been computed
     * @type {PIXI.Circle}
     */
    get fov(): PIXI.Circle;
    /**
     * Provide a reference to the CanvasLayer which contains this PlaceableObject.
     * @type {PlaceablesLayer}
     */
    get layer(): PlaceablesLayer;
    /**
     * The line-of-sight polygon for the object, if it has been computed
     * @type {PointSourcePolygon|null}
     */
    get los(): PointSourcePolygon;
    /**
     * A Form Application which is used to configure the properties of this Placeable Object or the Document it
     * represents.
     * @type {FormApplication}
     */
    get sheet(): FormApplication;
    /**
     * An indicator for whether the object is currently controlled
     * @type {boolean}
     */
    get controlled(): boolean;
    set hover(arg: boolean);
    /**
     * An indicator for whether the object is currently a hover target
     * @type {boolean}
     */
    get hover(): boolean;
    /** @override */
    override applyRenderFlags(): void;
    /**
     * Apply render flags before a render occurs.
     * @param {Object<boolean>} flags  The render flags which must be applied
     * @protected
     */
    protected _applyRenderFlags(flags: any): void;
    /**
     * Clear the display of the existing object.
     * @returns {PlaceableObject}    The cleared object
     */
    clear(): PlaceableObject;
    /** @inheritdoc */
    destroy(options: any): any;
    /**
     * The inner _destroy method which may optionally be defined by each PlaceableObject subclass.
     * @param {object} [options]    Options passed to the initial destroy call
     * @protected
     */
    protected _destroy(options?: object): void;
    /**
     * Draw the placeable object into its parent container
     * @param {object} [options]            Options which may modify the draw and refresh workflow
     * @returns {Promise<PlaceableObject>}  The drawn object
     */
    draw(options?: object): Promise<PlaceableObject>;
    visible: any;
    renderable: any;
    /**
     * The inner _draw method which must be defined by each PlaceableObject subclass.
     * @param {object} options            Options which may modify the draw workflow
     * @abstract
     * @protected
     */
    protected _draw(options: object): Promise<void>;
    /**
     * Refresh all incremental render flags for the PlaceableObject.
     * This method is no longer used by the core software but provided for backwards compatibility.
     * @param {object} [options]      Options which may modify the refresh workflow
     * @returns {PlaceableObject}     The refreshed object
     */
    refresh(options?: object): PlaceableObject;
    /**
     * Update the quadtree.
     * @internal
     */
    _updateQuadtree(): void;
    /**
     * Get the target opacity that should be used for a Placeable Object depending on its preview state.
     * @returns {number}
     * @protected
     */
    protected _getTargetAlpha(): number;
    /**
     * Register pending canvas operations which should occur after a new PlaceableObject of this type is created
     * @param {object} data
     * @param {object} options
     * @param {string} userId
     * @protected
     */
    protected _onCreate(data: object, options: object, userId: string): void;
    /**
     * Define additional steps taken when an existing placeable object of this type is updated with new data
     * @param {object} data
     * @param {object} options
     * @param {string} userId
     * @protected
     */
    protected _onUpdate(data: object, options: object, userId: string): void;
    /**
     * Define additional steps taken when an existing placeable object of this type is deleted
     * @param {object} options
     * @param {string} userId
     * @protected
     */
    protected _onDelete(options: object, userId: string): void;
    /**
     * Assume control over a PlaceableObject, flagging it as controlled and enabling downstream behaviors
     * @param {Object} options                  Additional options which modify the control request
     * @param {boolean} options.releaseOthers   Release any other controlled objects first
     * @returns {boolean}                        A flag denoting whether control was successful
     */
    control(options?: {
        releaseOthers: boolean;
    }): boolean;
    /**
     * Additional events which trigger once control of the object is established
     * @param {Object} options    Optional parameters which apply for specific implementations
     * @protected
     */
    protected _onControl(options: any): void;
    /**
     * Release control over a PlaceableObject, removing it from the controlled set
     * @param {object} options          Options which modify the releasing workflow
     * @returns {boolean}               A Boolean flag confirming the object was released.
     */
    release(options?: object): boolean;
    /**
     * Additional events which trigger once control of the object is released
     * @param {object} options          Options which modify the releasing workflow
     * @protected
     */
    protected _onRelease(options: object): void;
    /**
     * Clone the placeable object, returning a new object with identical attributes.
     * The returned object is non-interactive, and has no assigned ID.
     * If you plan to use it permanently you should call the create method.
     * @returns {PlaceableObject}  A new object with identical data
     */
    clone(): PlaceableObject;
    _preview: any;
    /**
     * Rotate the PlaceableObject to a certain angle of facing
     * @param {number} angle        The desired angle of rotation
     * @param {number} snap         Snap the angle of rotation to a certain target degree increment
     * @returns {Promise<PlaceableObject>} The rotated object
     */
    rotate(angle: number, snap: number): Promise<PlaceableObject>;
    /**
     * Determine a new angle of rotation for a PlaceableObject either from an explicit angle or from a delta offset.
     * @param {object} options    An object which defines the rotation update parameters
     * @param {number} [options.angle]    An explicit angle, either this or delta must be provided
     * @param {number} [options.delta=0]  A relative angle delta, either this or the angle must be provided
     * @param {number} [options.snap=0]   A precision (in degrees) to which the resulting angle should snap. Default is 0.
     * @returns {number}          The new rotation angle for the object
     */
    _updateRotation({ angle, delta, snap }?: {
        angle?: number;
        delta?: number;
        snap?: number;
    }): number;
    /**
     * Obtain a shifted position for the Placeable Object
     * @param {number} dx         The number of grid units to shift along the X-axis
     * @param {number} dy         The number of grid units to shift along the Y-axis
     * @returns {{x:number, y:number}} The shifted target coordinates
     */
    _getShiftedPosition(dx: number, dy: number): {
        x: number;
        y: number;
    };
    /**
     * Activate interactivity for the Placeable Object
     */
    activateListeners(): void;
    /**
     * Create a standard MouseInteractionManager for the PlaceableObject
     * @protected
     */
    protected _createInteractionManager(): MouseInteractionManager;
    /**
     * Test whether a user can perform a certain interaction regarding a Placeable Object
     * @param {User} user       The User performing the action
     * @param {string} action   The named action being attempted
     * @returns {boolean}       Does the User have rights to perform the action?
     */
    can(user: User, action: string): boolean;
    /**
     * Can the User access the HUD for this Placeable Object?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canHUD(user: User, event: object): boolean;
    /**
     * Does the User have permission to configure the Placeable Object?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canConfigure(user: User, event: object): boolean;
    /**
     * Does the User have permission to control the Placeable Object?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canControl(user: User, event: object): boolean;
    /**
     * Does the User have permission to view details of the Placeable Object?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canView(user: User, event: object): boolean;
    /**
     * Does the User have permission to create the underlying Document?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canCreate(user: User, event: object): boolean;
    /**
     * Does the User have permission to drag this Placeable Object?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canDrag(user: User, event: object): boolean;
    /**
     * Does the User have permission to hover on this Placeable Object?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canHover(user: User, event: object): boolean;
    /**
     * Does the User have permission to update the underlying Document?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canUpdate(user: User, event: object): boolean;
    /**
     * Does the User have permission to delete the underlying Document?
     * @param {User} user       The User performing the action.
     * @param {object} event    The event object.
     * @returns {boolean}       The returned status.
     * @protected
     */
    protected _canDelete(user: User, event: object): boolean;
    /**
     * Actions that should be taken for this Placeable Object when a mouseover event occurs.
     * Hover events on PlaceableObject instances allow event propagation by default.
     * @see MouseInteractionManager##handleMouseOver
     * @param {PIXI.FederatedEvent} event                The triggering canvas interaction event
     * @param {object} options                           Options which customize event handling
     * @param {boolean} [options.hoverOutOthers=false]   Trigger hover-out behavior on sibling objects
     * @returns {boolean}                                True if the event was handled, otherwise false
     * @protected
     */
    protected _onHoverIn(event: PIXI.FederatedEvent, { hoverOutOthers }?: {
        hoverOutOthers?: boolean;
    }): boolean;
    /**
     * Actions that should be taken for this Placeable Object when a mouseout event occurs
     * @see MouseInteractionManager##handleMouseOut
     * @param {PIXI.FederatedEvent} event  The triggering canvas interaction event
     * @returns {boolean}                  True if the event was handled, otherwise false
     * @protected
     */
    protected _onHoverOut(event: PIXI.FederatedEvent): boolean;
    /**
     * Should the placeable propagate left click downstream?
     * @param {PIXI.FederatedEvent} event
     * @returns {boolean}
     * @protected
     */
    protected _propagateLeftClick(event: PIXI.FederatedEvent): boolean;
    /**
     * Callback actions which occur on a single left-click event to assume control of the object
     * @see MouseInteractionManager##handleClickLeft
     * @param {PIXI.FederatedEvent} event  The triggering canvas interaction event
     * @protected
     */
    protected _onClickLeft(event: PIXI.FederatedEvent): void;
    /**
     * Callback actions which occur on a double left-click event to activate
     * @see MouseInteractionManager##handleClickLeft2
     * @param {PIXI.FederatedEvent} event  The triggering canvas interaction event
     * @protected
     */
    protected _onClickLeft2(event: PIXI.FederatedEvent): void;
    /**
     * Should the placeable propagate right click downstream?
     * @param {PIXI.FederatedEvent} event
     * @returns {boolean}
     * @protected
     */
    protected _propagateRightClick(event: PIXI.FederatedEvent): boolean;
    /**
     * Callback actions which occur on a single right-click event to configure properties of the object
     * @see MouseInteractionManager##handleClickRight
     * @param {PIXI.FederatedEvent} event  The triggering canvas interaction event
     * @protected
     */
    protected _onClickRight(event: PIXI.FederatedEvent): void;
    /**
     * Callback actions which occur on a double right-click event to configure properties of the object
     * @see MouseInteractionManager##handleClickRight2
     * @param {PIXI.FederatedEvent} event  The triggering canvas interaction event
     * @protected
     */
    protected _onClickRight2(event: PIXI.FederatedEvent): void;
    /**
     * Callback actions which occur when a mouse-drag action is first begun.
     * @see MouseInteractionManager##handleDragStart
     * @param {PIXI.FederatedEvent} event  The triggering canvas interaction event
     * @protected
     */
    protected _onDragLeftStart(event: PIXI.FederatedEvent): any;
    /**
     * Begin a drag operation from the perspective of the preview clone.
     * Modify the appearance of both the clone (this) and the original (_original) object.
     * @protected
     */
    protected _onDragStart(): void;
    /**
     * Conclude a drag operation from the perspective of the preview clone.
     * Modify the appearance of both the clone (this) and the original (_original) object.
     * @protected
     */
    protected _onDragEnd(): void;
    /**
     * Callback actions which occur on a mouse-move operation.
     * @see MouseInteractionManager##handleDragMove
     * @param {PIXI.FederatedEvent} event  The triggering canvas interaction event
     * @protected
     */
    protected _onDragLeftMove(event: PIXI.FederatedEvent): any;
    /**
     * Callback actions which occur on a mouse-move operation.
     * @see MouseInteractionManager##handleDragDrop
     * @param {PIXI.FederatedEvent} event  The triggering canvas interaction event
     * @returns {Promise<*>}
     * @protected
     */
    protected _onDragLeftDrop(event: PIXI.FederatedEvent): Promise<any>;
    /**
     * Callback actions which occur on a mouse-move operation.
     * @see MouseInteractionManager##handleDragCancel
     * @param {PIXI.FederatedEvent} event  The triggering mouse click event
     * @protected
     */
    protected _onDragLeftCancel(event: PIXI.FederatedEvent): any;
    /**
     * Callback action which occurs on a long press.
     * @see MouseInteractionManager##handleLongPress
     * @param {PIXI.FederatedEvent}   event   The triggering canvas interaction event
     * @param {PIXI.Point}            origin  The local canvas coordinates of the mousepress.
     * @protected
     */
    protected _onLongPress(event: PIXI.FederatedEvent, origin: PIXI.Point): any;
    #private;
}
/**
 * A Loader class which helps with loading video and image textures.
 */
declare class TextureLoader {
    /**
     * The duration in milliseconds for which a texture will remain cached
     * @type {number}
     */
    static CACHE_TTL: number;
    /**
     * Record the timestamps when each asset path is retrieved from cache.
     * @type {Map<PIXI.BaseTexture|PIXI.Spritesheet,{src:string,time:number}>}
     */
    static "__#130@#cacheTime": Map<PIXI.BaseTexture | PIXI.Spritesheet, {
        src: string;
        time: number;
    }>;
    /**
     * A mapping of url to cached texture buffer data
     * @type {Map<string,object>}
     */
    static textureBufferDataMap: Map<string, object>;
    /**
     * Create a fixed retry string to use for CORS retries.
     * @type {string}
     */
    static "__#130@#retryString": string;
    /**
     * Check if a source has a text file extension.
     * @param {string} src          The source.
     * @returns {boolean}           If the source has a text extension or not.
     */
    static hasTextExtension(src: string): boolean;
    /**
     * Load all the textures which are required for a particular Scene
     * @param {Scene} scene                                 The Scene to load
     * @param {object} [options={}]                         Additional options that configure texture loading
     * @param {boolean} [options.expireCache=true]          Destroy other expired textures
     * @param {boolean} [options.additionalSources=[]]      Additional sources to load during canvas initialize
     * @param {number} [options.maxConcurrent]              The maximum number of textures that can be loaded concurrently
     * @returns {Promise<void[]>}
     */
    static loadSceneTextures(scene: Scene, { expireCache, additionalSources, maxConcurrent }?: {
        expireCache?: boolean;
        additionalSources?: boolean;
        maxConcurrent?: number;
    }): Promise<void[]>;
    /**
     * Use the Fetch API to retrieve a resource and return a Blob instance for it.
     * @param {string} src
     * @param {object} [options]                   Options to configure the loading behaviour.
     * @param {boolean} [options.bustCache=false]  Append a cache-busting query parameter to the request.
     * @returns {Promise<Blob>}                    A Blob containing the loaded data
     */
    static fetchResource(src: string, { bustCache }?: {
        bustCache?: boolean;
    }): Promise<Blob>;
    /**
     * Log texture loading progress in the console and in the Scene loading bar
     * @param {string} src          The source URL being loaded
     * @param {object} progress     Loading progress
     * @private
     */
    private static "__#130@#onProgress";
    /**
     * Log failed texture loading
     * @param {string} src          The source URL being loaded
     * @param {object} progress     Loading progress
     * @param {Error} error         The error which occurred
     * @private
     */
    private static "__#130@#onError";
    /**
     * Return a URL with a cache-busting query parameter appended.
     * @param {string} src        The source URL being attempted
     * @returns {string|boolean}  The new URL, or false on a failure.
     */
    static getCacheBustURL(src: string): string | boolean;
    /**
     * Load an Array of provided source URL paths
     * @param {string[]} sources      The source URLs to load
     * @param {object} [options={}]   Additional options which modify loading
     * @param {string} [options.message]              The status message to display in the load bar
     * @param {boolean} [options.expireCache=false]   Expire other cached textures?
     * @param {number} [options.maxConcurrent]        The maximum number of textures that can be loaded concurrently.
     * @returns {Promise<void[]>}     A Promise which resolves once all textures are loaded
     */
    load(sources: string[], { message, expireCache, maxConcurrent }?: {
        message?: string;
        expireCache?: boolean;
        maxConcurrent?: number;
    }): Promise<void[]>;
    /**
     * Load a single texture or spritesheet on-demand from a given source URL path
     * @param {string} src                                          The source texture path to load
     * @returns {Promise<PIXI.BaseTexture|PIXI.Spritesheet|null>}   The loaded texture object
     */
    loadTexture(src: string): Promise<PIXI.BaseTexture | PIXI.Spritesheet | null>;
    /**
     * Add an image or a sprite sheet url to the assets cache.
     * @param {string} src                                 The source URL.
     * @param {PIXI.BaseTexture|PIXI.Spritesheet} asset    The asset
     */
    setCache(src: string, asset: PIXI.BaseTexture | PIXI.Spritesheet): void;
    /**
     * Retrieve a texture or a sprite sheet from the assets cache
     * @param {string} src                                     The source URL
     * @returns {PIXI.BaseTexture|PIXI.Spritesheet|null}       The cached texture, a sprite sheet or undefined
     */
    getCache(src: string): PIXI.BaseTexture | PIXI.Spritesheet | null;
    /**
     * Expire and unload assets from the cache which have not been used for more than CACHE_TTL milliseconds.
     */
    expireCache(): Promise<void>;
    /**
     * @deprecated since v11
     * @ignore
     */
    loadImageTexture(src: any): Promise<any>;
    /**
     * @deprecated since v11
     * @ignore
     */
    loadVideoTexture(src: any): Promise<any>;
}
declare namespace TextureLoader {
    let loader: TextureLoader;
}
/**
 * A mixin which decorates any container with base canvas common properties.
 * @category - Mixins
 * @param {typeof Container} ContainerClass  The parent Container class being mixed.
 * @returns {typeof BaseCanvasMixin}         A ContainerClass subclass mixed with BaseCanvasMixin features.
 */
declare function BaseCanvasMixin(ContainerClass: any): typeof BaseCanvasMixin;
/**
 * A special type of PIXI.Container which draws its contents to a cached RenderTexture.
 * This is accomplished by overriding the Container#render method to draw to our own special RenderTexture.
 */
declare class CachedContainer {
    /**
     * The texture configuration to use for this cached container
     * @type {{multisample: PIXI.MSAA_QUALITY, scaleMode: PIXI.SCALE_MODES, format: PIXI.FORMATS}}
     * @abstract
     */
    static textureConfiguration: {
        multisample: PIXI.MSAA_QUALITY;
        scaleMode: PIXI.SCALE_MODES;
        format: PIXI.FORMATS;
    };
    /**
     * Resize a render texture passed as a parameter with the renderer.
     * @param {PIXI.Renderer} renderer    The active canvas renderer.
     * @param {PIXI.RenderTexture} rt     The render texture to resize.
     */
    static resizeRenderTexture(renderer: PIXI.Renderer, rt: PIXI.RenderTexture): void;
    /**
     * Construct a CachedContainer.
     * @param {PIXI.Sprite|SpriteMesh} [sprite]  A specific sprite to bind to this CachedContainer and its renderTexture.
     */
    constructor(sprite?: PIXI.Sprite | SpriteMesh);
    set sprite(arg: any);
    /**
     * A PIXI.Sprite or SpriteMesh which is bound to this CachedContainer.
     * The RenderTexture from this Container is associated with the Sprite which is automatically rendered.
     * @type {PIXI.Sprite|SpriteMesh}
     */
    get sprite(): any;
    /**
     * An map of render textures, linked to their render function and an optional RGBA clear color.
     * @type {Map<PIXI.RenderTexture,Object<Function, number[]>>}
     * @protected
     */
    protected _renderPaths: Map<PIXI.RenderTexture, any>;
    /**
     * An RGBA array used to define the clear color of the RenderTexture
     * @type {number[]}
     */
    clearColor: number[];
    /**
     * Should our Container also be displayed on screen, in addition to being drawn to the cached RenderTexture?
     * @type {boolean}
     */
    displayed: boolean;
    /**
     * The primary render texture bound to this cached container.
     * @type {PIXI.RenderTexture}
     */
    get renderTexture(): PIXI.RenderTexture;
    /**
     * Set the alpha mode of the cached container render texture.
     * @param {PIXI.ALPHA_MODES} mode
     */
    set alphaMode(arg: PIXI.ALPHA_MODES);
    /**
     * Create a render texture, provide a render method and an optional clear color.
     * @param {object} [options={}]                 Optional parameters.
     * @param {Function} [options.renderFunction]   Render function that will be called to render into the RT.
     * @param {number[]} [options.clearColor]       An optional clear color to clear the RT before rendering into it.
     * @returns {PIXI.RenderTexture}              A reference to the created render texture.
     */
    createRenderTexture({ renderFunction, clearColor }?: {
        renderFunction?: Function;
        clearColor?: number[];
    }): PIXI.RenderTexture;
    /**
     * Remove a previously created render texture.
     * @param {PIXI.RenderTexture} renderTexture   The render texture to remove.
     * @param {boolean} [destroy=true]             Should the render texture be destroyed?
     */
    removeRenderTexture(renderTexture: PIXI.RenderTexture, destroy?: boolean): void;
    /**
     * Clear the cached container, removing its current contents.
     * @param {boolean} [destroy=true]    Tell children that we should destroy texture as well.
     * @returns {CachedContainer}         A reference to the cleared container for chaining.
     */
    clear(destroy?: boolean): CachedContainer;
    /** @inheritdoc */
    destroy(options: any): void;
    /** @inheritdoc */
    render(renderer: any): void;
    #private;
}
/**
 * @deprecated since v11
 * @ignore
 */
declare class FullCanvasContainer {
    constructor(...args: any[]);
}
/**
 * Extension of a PIXI.Mesh, with the capabilities to provide a snapshot of the framebuffer.
 * @extends PIXI.Mesh
 */
declare class PointSourceMesh {
    /**
     * To store the previous blend mode of the last renderer PointSourceMesh.
     * @type {PIXI.BLEND_MODES}
     * @protected
     */
    protected static _priorBlendMode: PIXI.BLEND_MODES;
    /**
     * The current texture used by the mesh.
     * @type {PIXI.Texture}
     * @protected
     */
    protected static _currentTexture: PIXI.Texture;
    /**
     * The transform world ID of the bounds.
     * @type {number}
     */
    _worldID: number;
    /**
     * The geometry update ID of the bounds.
     * @type {number}
     */
    _updateID: number;
    /** @override */
    override set geometry(arg: any);
    /** @override */
    override get geometry(): any;
    /** @override */
    override addChild(): void;
    /** @override */
    override addChildAt(): void;
    /** @override */
    override addChildren(): void;
    /** @override */
    override _render(renderer: any): void;
    /** @override */
    override calculateBounds(): void;
    /** @override */
    override _calculateBounds(): void;
    /**
     * The local bounds need to be drawn from the underlying geometry.
     * @override
     */
    override getLocalBounds(rect: any): any;
}
/**
 * A basic rectangular mesh with a shader only. Does not natively handle textures (but a bound shader can).
 * Bounds calculations are simplified and the geometry does not need to handle texture coords.
 * @param {AbstractBaseShader} shaderCls     The shader class to use.
 */
declare class QuadMesh {
    constructor(shaderCls: any);
    set geometry(arg: PIXI.Geometry);
    /**
     * Assigned geometry to this mesh.
     * We need to handle the refCount.
     * @type {PIXI.Geometry}
     */
    get geometry(): PIXI.Geometry;
    /**
     * The state.
     * @type {PIXI.State}
     */
    state: PIXI.State;
    cullable: boolean;
    set blendMode(arg: PIXI.BLEND_MODES);
    /**
     * Assigned blend mode to this mesh.
     * @type {PIXI.BLEND_MODES}
     */
    get blendMode(): PIXI.BLEND_MODES;
    /**
     * The shader.
     * @type {BaseSamplerShader}
     */
    shader: BaseSamplerShader;
    /**
     * Initialize shader based on the shader class type.
     * @param {class} shaderCls         Shader class used. Must inherit from AbstractBaseShader.
     */
    setShaderClass(shaderCls: class): void;
    /** @override */
    override _render(renderer: any): void;
    override set width(arg: number);
    /** @override */
    override get width(): number;
    _width: any;
    override set height(arg: number);
    /** @override */
    override get height(): number;
    _height: any;
    /** @override */
    override _calculateBounds(): void;
    /**
     * Tests if a point is inside this QuadMesh.
     * @param {PIXI.IPointData} point
     * @returns {boolean}
     */
    containsPoint(point: PIXI.IPointData): boolean;
    /** @override */
    override destroy(...args: any[]): void;
    #private;
}
/**
 * @typedef {object} QuadtreeObject
 * @property {Rectangle} r
 * @property {*} t
 * @property {Set<Quadtree>} [n]
 */
/**
 * A Quadtree implementation that supports collision detection for rectangles.
 *
 * @param {Rectangle} bounds                The outer bounds of the region
 * @param {object} [options]                Additional options which configure the Quadtree
 * @param {number} [options.maxObjects=20]  The maximum number of objects per node
 * @param {number} [options.maxDepth=4]     The maximum number of levels within the root Quadtree
 * @param {number} [options._depth=0]       The depth level of the sub-tree. For internal use
 * @param {number} [options._root]          The root of the quadtree. For internal use
 */
declare class Quadtree {
    /**
     * A constant that enumerates the index order of the quadtree nodes from top-left to bottom-right.
     * @enum {number}
     */
    static INDICES: {
        tl: number;
        tr: number;
        bl: number;
        br: number;
    };
    constructor(bounds: any, { maxObjects, maxDepth, _depth, _root }?: {
        maxObjects?: number;
        maxDepth?: number;
        _depth?: number;
        _root: any;
    });
    /**
     * The bounding rectangle of the region
     * @type {Rectangle}
     */
    bounds: Rectangle;
    /**
     * The maximum number of objects allowed within this node before it must split
     * @type {number}
     */
    maxObjects: number;
    /**
     * The maximum number of levels that the base quadtree is allowed
     * @type {number}
     */
    maxDepth: number;
    /**
     * The depth of this node within the root Quadtree
     * @type {number}
     */
    depth: number;
    /**
     * The objects contained at this level of the tree
     * @type {QuadtreeObject[]}
     */
    objects: QuadtreeObject[];
    /**
     * Children of this node
     * @type {Quadtree[]}
     */
    nodes: Quadtree[];
    /**
     * The root Quadtree
     * @type {Quadtree}
     */
    root: Quadtree;
    /**
     * Return an array of all the objects in the Quadtree (recursive)
     * @returns {QuadtreeObject[]}
     */
    get all(): QuadtreeObject[];
    /**
     * Split this node into 4 sub-nodes.
     * @returns {Quadtree}     The split Quadtree
     */
    split(): Quadtree;
    /**
     * Clear the quadtree of all existing contents
     * @returns {Quadtree}     The cleared Quadtree
     */
    clear(): Quadtree;
    /**
     * Add a rectangle object to the tree
     * @param {QuadtreeObject} obj  The object being inserted
     * @returns {Quadtree[]}        The Quadtree nodes the object was added to.
     */
    insert(obj: QuadtreeObject): Quadtree[];
    /**
     * Remove an object from the quadtree
     * @param {*} target     The quadtree target being removed
     * @returns {Quadtree}   The Quadtree for method chaining
     */
    remove(target: any): Quadtree;
    /**
     * Remove an existing object from the quadtree and re-insert it with a new position
     * @param {QuadtreeObject} obj  The object being inserted
     * @returns {Quadtree[]}        The Quadtree nodes the object was added to
     */
    update(obj: QuadtreeObject): Quadtree[];
    /**
     * Get all the objects which could collide with the provided rectangle
     * @param {Rectangle} rect    The normalized target rectangle
     * @param {object} [options]                    Options affecting the collision test.
     * @param {Function} [options.collisionTest]    Function to further refine objects to return
     *   after a potential collision is found. Parameters are the object and rect, and the
     *   function should return true if the object should be added to the result set.
     * @param {Set} [options._s]                    The existing result set, for internal use.
     * @returns {Set}           The objects in the Quadtree which represent potential collisions
     */
    getObjects(rect: Rectangle, { collisionTest, _s }?: {
        collisionTest?: Function;
        _s?: Set<any>;
    }): Set<any>;
    /**
     * Obtain the leaf nodes to which a target rectangle belongs.
     * This traverses the quadtree recursively obtaining the final nodes which have no children.
     * @param {Rectangle} rect  The target rectangle.
     * @returns {Quadtree[]}    The Quadtree nodes to which the target rectangle belongs
     */
    getLeafNodes(rect: Rectangle): Quadtree[];
    /**
     * Obtain the child nodes within the current node which a rectangle belongs to.
     * Note that this function is not recursive, it only returns nodes at the current or child level.
     * @param {Rectangle} rect  The target rectangle.
     * @returns {Quadtree[]}    The Quadtree nodes to which the target rectangle belongs
     */
    getChildNodes(rect: Rectangle): Quadtree[];
    /**
     * Identify all nodes which are adjacent to this one within the parent Quadtree.
     * @returns {Quadtree[]}
     */
    getAdjacentNodes(): Quadtree[];
    /**
     * Visualize the nodes and objects in the quadtree
     * @param {boolean} [objects]    Visualize the rectangular bounds of objects in the Quadtree. Default is false.
     * @private
     */
    private visualize;
}
/**
 * A subclass of Quadtree specifically intended for classifying the location of objects on the game canvas.
 */
declare class CanvasQuadtree extends Quadtree {
    constructor(options?: {});
}
/**
 * An extension of PIXI.Mesh which emulate a PIXI.Sprite with a specific shader.
 * @param [texture=PIXI.Texture.EMPTY]      Texture bound to this sprite mesh.
 * @param [shaderClass=BaseSamplerShader]   Shader class used by this sprite mesh.
 * @extends PIXI.Mesh
 */
declare class SpriteMesh {
    /**
     * Create a SpriteMesh from another source.
     * You can specify texture options and a specific shader class derived from AbstractBaseShader.
     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source  Source to create texture from.
     * @param {object} [textureOptions]               See {@link PIXI.BaseTexture}'s constructor for options.
     * @param {AbstractBaseShader} [shaderCls]        The shader class to use. BaseSamplerShader by default.
     * @returns {SpriteMesh}
     */
    static from(source: string | PIXI.Texture | HTMLCanvasElement | HTMLVideoElement, textureOptions?: object, shaderCls?: AbstractBaseShader): SpriteMesh;
    constructor(texture: any, shaderCls?: typeof BaseSamplerShader);
    /** @override */
    override _cachedTint: number[];
    vertexData: any;
    uvs: any;
    indices: any;
    _texture: any;
    _anchor: any;
    override set texture(arg: any);
    /** @override */
    override get texture(): any;
    alpha: number;
    override set tint(arg: any);
    /** @override */
    override get tint(): any;
    blendMode: any;
    /**
     * Snapshot of some parameters of this display object to render in batched mode.
     * TODO: temporary object until the upstream issue is fixed: https://github.com/pixijs/pixijs/issues/8511
     * @type {{_tintRGB: number, _texture: PIXI.Texture, indices: number[],
     * uvs: number[], blendMode: PIXI.BLEND_MODES, vertexData: number[], worldAlpha: number}}
     * @protected
     */
    protected _batchData: {
        _tintRGB: number;
        _texture: PIXI.Texture;
        indices: number[];
        uvs: number[];
        blendMode: PIXI.BLEND_MODES;
        vertexData: number[];
        worldAlpha: number;
    };
    /** @override */
    override _transformID: number;
    /** @override */
    override _textureID: number;
    /** @override */
    override _textureTrimmedID: number;
    /** @override */
    override _transformTrimmedID: number;
    /** @override */
    override _roundPixels: boolean;
    /** @override */
    override vertexTrimmedData: any;
    /** @override */
    override isSprite: boolean;
    set alphaMode(arg: any);
    /**
     * Used to force an alpha mode on this sprite mesh.
     * If this property is non null, this value will replace the texture alphaMode when computing color channels.
     * Affects how tint, worldAlpha and alpha are computed each others.
     * @type {PIXI.ALPHA_MODES|undefined}
     */
    get alphaMode(): any;
    set pluginName(arg: string);
    /**
     * Returns the SpriteMesh associated batch plugin. By default the returned plugin is that of the associated shader.
     * If a plugin is forced, it will returns the forced plugin.
     * @type {string}
     */
    get pluginName(): string;
    override set width(arg: number);
    /** @override */
    override get width(): number;
    _width: any;
    override set height(arg: number);
    /** @override */
    override get height(): number;
    _height: any;
    override set anchor(arg: any);
    /** @override */
    override get anchor(): any;
    _tintRGB: number;
    _tintColor: any;
    /**
     * The HTML source element for this SpriteMesh texture.
     * @type {HTMLImageElement|HTMLVideoElement|null}
     */
    get sourceElement(): HTMLImageElement | HTMLVideoElement;
    /**
     * Is this SpriteMesh rendering a video texture?
     * @type {boolean}
     */
    get isVideo(): boolean;
    /** @override */
    override _onTextureUpdate(): void;
    /** @override */
    override _onAnchorUpdate(): void;
    /**
     * Update uvs and push vertices and uv buffers on GPU if necessary.
     */
    updateUvs(): void;
    /**
     * Initialize shader based on the shader class type.
     * @param {class} shaderCls         Shader class used. Must inherit from AbstractBaseShader.
     */
    setShaderClass(shaderCls: class): void;
    shader: any;
    /** @override */
    override updateTransform(parentTransform: any): void;
    /** @override */
    override calculateVertices(): void;
    /** @override */
    override calculateTrimmedVertices(...args: any[]): any;
    /** @override */
    override _render(renderer: any): void;
    /** @override */
    override _renderToBatch(renderer: any): void;
    /** @override */
    override _renderDefault(renderer: any): void;
    /**
     * Update the batch data object.
     * TODO: temporary method until the upstream issue is fixed: https://github.com/pixijs/pixijs/issues/8511
     * @protected
     */
    protected _updateBatchData(): void;
    /** @override */
    override _calculateBounds(...args: any[]): any;
    /** @override */
    override getLocalBounds(...args: any[]): any;
    /** @override */
    override containsPoint(...args: any[]): any;
    /** @override */
    override destroy(...args: any[]): any;
    geometry: any;
    #private;
}
/**
 * UnboundContainers behave like PIXI.Containers except that they are not bound to their parent's transforms.
 * However, they normally propagate their own transformations to their children.
 */
declare class UnboundContainer {
    constructor(...args: any[]);
    transform: UnboundTransform;
}
/**
 * A custom Transform class which is not bound to the parent worldTransform.
 * localTransform are working as usual.
 */
declare class UnboundTransform {
    /** @override */
    static override IDENTITY: UnboundTransform;
    /** @override */
    override updateTransform(parentTransform: any): void;
    _currentLocalID: any;
    _parentID: any;
}
/**
 * @typedef {Object} CanvasAnimationAttribute
 * @property {string} attribute             The attribute name being animated
 * @property {Object} parent                The object within which the attribute is stored
 * @property {number} to                    The destination value of the attribute
 * @property {number} [from]                An initial value of the attribute, otherwise parent[attribute] is used
 * @property {number} [delta]               The computed delta between to and from
 * @property {number} [done]                The amount of the total delta which has been animated
 * @property {boolean} [color]              Is this a color animation that applies to RGB channels
 */
/**
 * @typedef {Object} CanvasAnimationOptions
 * @property {PIXI.DisplayObject} [context] A DisplayObject which defines context to the PIXI.Ticker function
 * @property {string} [name]                A unique name which can be used to reference the in-progress animation
 * @property {number} [duration]            A duration in milliseconds over which the animation should occur
 * @property {number} [priority]            A priority in PIXI.UPDATE_PRIORITY which defines when the animation
 *                                          should be evaluated related to others
 * @property {Function|string} [easing]     An easing function used to translate animation time or the string name
 *                                          of a static member of the CanvasAnimation class
 * @property {function(number, CanvasAnimationData)} [ontick] A callback function which fires after every frame
 */
/**
 * @typedef {CanvasAnimationOptions} CanvasAnimationData
 * @property {Function} fn                  The animation function being executed each frame
 * @property {number} time                  The current time of the animation, in milliseconds
 * @property {CanvasAnimationAttribute[]} attributes  The attributes being animated
 * @property {Promise} [promise]            A Promise which resolves once the animation is complete
 * @property {Function} [resolve]           The resolution function, allowing animation to be ended early
 * @property {Function} [reject]            The rejection function, allowing animation to be ended early
 */
/**
 * A helper class providing utility methods for PIXI Canvas animation
 */
declare class CanvasAnimation {
    static get ticker(): any;
    /**
     * Track an object of active animations by name, context, and function
     * This allows a currently playing animation to be referenced and terminated
     * @type {Object<string, CanvasAnimationData>}
     */
    static animations: {
        [x: string]: CanvasAnimationData;
    };
    /**
     * Apply an animation from the current value of some attribute to a new value
     * Resolve a Promise once the animation has concluded and the attributes have reached their new target
     *
     * @param {CanvasAnimationAttribute[]} attributes   An array of attributes to animate
     * @param {CanvasAnimationOptions} options          Additional options which customize the animation
     *
     * @returns {Promise}                               A Promise which resolves to true once the animation has concluded
     *                                                  or false if the animation was prematurely terminated
     *
     * @example Animate Token Position
     * ```js
     * let animation = [
     *   {
     *     parent: token,
     *     attribute: "x",
     *     to: 1000
     *   },
     *   {
     *     parent: token,
     *     attribute: "y",
     *     to: 2000
     *   }
     * ];
     * CanvasAnimation.animate(attributes, {duration:500});
     * ```
     */
    static animate(attributes: CanvasAnimationAttribute[], { context, name, duration, easing, ontick, priority }?: CanvasAnimationOptions): Promise<any>;
    /**
     * Retrieve an animation currently in progress by its name
     * @param {string} name             The animation name to retrieve
     * @returns {CanvasAnimationData}   The animation data, or undefined
     */
    static getAnimation(name: string): CanvasAnimationData;
    /**
     * If an animation using a certain name already exists, terminate it
     * @param {string} name       The animation name to terminate
     */
    static terminateAnimation(name: string): void;
    /**
     * Cosine based easing with smooth in-out.
     * @param {number} pt     The proportional animation timing on [0,1]
     * @returns {number}      The eased animation progress on [0,1]
     */
    static easeInOutCosine(pt: number): number;
    /**
     * Shallow ease out.
     * @param {number} pt     The proportional animation timing on [0,1]
     * @returns {number}      The eased animation progress on [0,1]
     */
    static easeOutCircle(pt: number): number;
    /**
     * Shallow ease in.
     * @param {number} pt     The proportional animation timing on [0,1]
     * @returns {number}      The eased animation progress on [0,1]
     */
    static easeInCircle(pt: number): number;
    /**
     * Generic ticker function to implement the animation.
     * This animation wrapper executes once per frame for the duration of the animation event.
     * Once the animated attributes have converged to their targets, it resolves the original Promise.
     * The user-provided ontick function runs each frame update to apply additional behaviors.
     *
     * @param {number} deltaTime                The incremental time which has elapsed
     * @param {CanvasAnimationData} animation   The animation which is being performed
     */
    static "__#135@#animateFrame"(deltaTime: number, animation: CanvasAnimationData): void;
    /**
     * Update a single attribute according to its animation completion percentage
     * @param {CanvasAnimationAttribute} attribute    The attribute being animated
     * @param {number} percentage                     The animation completion percentage
     */
    static "__#135@#updateAttribute"(attribute: CanvasAnimationAttribute, percentage: number): void;
    /**
     * @alias CanvasAnimation.animate
     * @see {CanvasAnimation.animate}
     * @deprecated since v10
     * @ignore
     */
    static animateLinear(attributes: any, options: any): Promise<any>;
}
/**
 * A generic helper for drawing a standard Control Icon
 * @type {PIXI.Container}
 */
declare class ControlIcon {
    constructor({ texture, size, borderColor, tint }?: {
        texture: any;
        size?: number;
        borderColor?: number;
        tint?: any;
    }, ...args: any[]);
    iconSrc: any;
    size: number;
    rect: number[];
    borderColor: number;
    /**
     * The color of the icon tint, if any
     * @type {number|null}
     */
    tintColor: number | null;
    eventMode: string;
    interactiveChildren: boolean;
    hitArea: PIXI.Rectangle;
    cursor: string;
    bg: any;
    icon: any;
    border: any;
    /**
     * Initial drawing of the ControlIcon
     * @returns {Promise<ControlIcon>}
     */
    draw(): Promise<ControlIcon>;
    texture: any;
    /**
     * Incremental refresh for ControlIcon appearance.
     */
    refresh({ visible, iconColor, borderColor, borderVisible }?: {
        visible: any;
        iconColor: any;
        borderColor: any;
        borderVisible: any;
    }): this;
    visible: any;
}
/**
 * Handle mouse interaction events for a Canvas object.
 * There are three phases of events: hover, click, and drag
 *
 * Hover Events:
 * _handleMouseOver
 *  action: hoverIn
 * _handleMouseOut
 *  action: hoverOut
 *
 * Left Click and Double-Click
 * _handleMouseDown
 *  action: clickLeft
 *  action: clickLeft2
 *
 * Right Click and Double-Click
 * _handleRightDown
 *  action: clickRight
 *  action: clickRight2
 *
 * Drag and Drop
 * _handleMouseMove
 *  action: dragLeftStart
 *  action: dragRightStart
 *  action: dragLeftMove
 *  action: dragRightMove
 * _handleMouseUp
 *  action: dragLeftDrop
 *  action: dragRightDrop
 * _handleDragCancel
 *  action: dragLeftCancel
 *  action: dragRightCancel
 */
declare class MouseInteractionManager {
    /**
     * Enumerate the states of a mouse interaction workflow.
     * 0: NONE - the object is inactive
     * 1: HOVER - the mouse is hovered over the object
     * 2: CLICKED - the object is clicked
     * 3: DRAG - the object is being dragged
     * 4: DROP - the object is being dropped
     * @enum {number}
     */
    static INTERACTION_STATES: {
        NONE: number;
        HOVER: number;
        CLICKED: number;
        DRAG: number;
        DROP: number;
    };
    /**
     * Enumerate the states of handle outcome.
     * -2: SKIPPED - the handler has been skipped by previous logic
     * -1: DISALLOWED - the handler has dissallowed further process
     *  1: REFUSED - the handler callback has been processed and is refusing further process
     *  2: ACCEPTED - the handler callback has been processed and is accepting further process
     * @enum {number}
     */
    static "__#136@#HANDLER_OUTCOME": {
        SKIPPED: number;
        DISALLOWED: number;
        REFUSED: number;
        ACCEPTED: number;
    };
    /**
     * The number of milliseconds of mouse click depression to consider it a long press.
     * @type {number}
     */
    static LONG_PRESS_DURATION_MS: number;
    /**
     * Global timeout for the long-press event.
     * @type {number|null}
     */
    static longPressTimeout: number | null;
    constructor(object: any, layer: any, permissions?: {}, callbacks?: {}, options?: {});
    object: any;
    layer: any;
    permissions: {};
    callbacks: {};
    /**
     * Interaction options which configure handling workflows
     * @type {{target: PIXI.DisplayObject, dragResistance: number}}
     */
    options: {
        target: PIXI.DisplayObject;
        dragResistance: number;
    };
    /**
     * The current interaction state
     * @type {number}
     */
    state: number;
    /**
     * Bound interaction data object to populate with custom data.
     * @type {Object<any>}
     */
    interactionData: any;
    /**
     * The drag handling time
     * @type {number}
     */
    dragTime: number;
    /**
     * The time of the last left-click event
     * @type {number}
     */
    lcTime: number;
    /**
     * The time of the last right-click event
     * @type {number}
     */
    rcTime: number;
    /**
     * A flag for whether we are right-click dragging
     * @type {boolean}
     */
    _dragRight: boolean;
    /**
     * An optional ControlIcon instance for the object
     * @type {ControlIcon}
     */
    controlIcon: ControlIcon;
    viewId: any;
    /**
     * Get the target.
     * @type {PIXI.DisplayObject}
     */
    get target(): PIXI.DisplayObject;
    /**
     * Is this mouse manager in a dragging state?
     * @type {boolean}
     */
    get isDragging(): boolean;
    /**
     * Activate interactivity for the handled object
     */
    activate(): this;
    /**
     * Test whether the current user has permission to perform a step of the workflow
     * @param {string} action     The action being attempted
     * @param {Event|PIXI.FederatedEvent} event The event being handled
     * @returns {boolean}         Can the action be performed?
     */
    can(action: string, event: Event | PIXI.FederatedEvent): boolean;
    /**
     * Execute a callback function associated with a certain action in the workflow
     * @param {string} action     The action being attempted
     * @param {Event|PIXI.FederatedEvent} event The event being handled
     * @param {...*} args         Additional callback arguments.
     * @returns {boolean}         A boolean which may indicate that the event was handled by the callback.
     *                            Events which do not specify a callback are assumed to have been handled as no-op.
     */
    callback(action: string, event: Event | PIXI.FederatedEvent, ...args: any[]): boolean;
    /**
     * A reference to the possible interaction states which can be observed
     * @returns {Object<string, number>}
     */
    get states(): {
        [x: string]: number;
    };
    /**
     * A reference to the possible interaction states which can be observed
     * @returns {Object<string, number>}
     */
    get handlerOutcomes(): {
        [x: string]: number;
    };
    /**
     * A public method to handle directly an event into this manager, according to its type.
     * Note: drag events are not handled.
     * @param {PIXI.FederatedEvent} event
     * @returns {boolean} Has the event been processed?
     */
    handleEvent(event: PIXI.FederatedEvent): boolean;
    /**
     * A public method to cancel a current interaction workflow from this manager.
     * @param {PIXI.FederatedEvent} event     The event that initiates the cancellation
     */
    cancel(event: PIXI.FederatedEvent): void;
    /**
     * Reset the mouse manager.
     * @param {object} [options]
     * @param {boolean} [options.interactionData=true]    Reset the interaction data?
     * @param {boolean} [options.state=true]              Reset the state?
     */
    reset({ interactionData, state }?: {
        interactionData?: boolean;
        state?: boolean;
    }): void;
    #private;
}
/**
 * @typedef {object} PingOptions
 * @property {number} [duration=900]   The duration of the animation in milliseconds.
 * @property {number} [size=128]       The size of the ping graphic.
 * @property {string} [color=#ff6400]  The color of the ping graphic.
 * @property {string} [name]           The name for the ping animation to pass to {@link CanvasAnimation.animate}.
 */
/**
 * A class to manage a user ping on the canvas.
 * @param {PIXI.Point} origin       The canvas co-ordinates of the origin of the ping.
 * @param {PingOptions} [options]   Additional options to configure the ping animation.
 */
declare class Ping {
    constructor(origin: any, options?: {});
    x: any;
    y: any;
    options: any;
    _color: number | import("../../common/utils/color.mjs").default;
    /** @inheritdoc */
    destroy(options?: {}): void;
    /**
     * Start the ping animation.
     * @returns {Promise<boolean>}  Returns true if the animation ran to completion, false otherwise.
     */
    animate(): Promise<boolean>;
    /**
     * On each tick, advance the animation.
     * @param {number} dt                      The number of ms that elapsed since the previous frame.
     * @param {CanvasAnimationData} animation  The animation state.
     * @protected
     */
    protected _animateFrame(dt: number, animation: CanvasAnimationData): void;
}
/**
 * @typedef {Object} RenderFlag
 * @property {string[]} propagate     Activating this flag also sets these flags to true
 * @property {string[]} reset         Activating this flag resets these flags to false
 */
/**
 * A data structure for tracking a set of boolean status flags.
 * This is a restricted set which can only accept flag values which are pre-defined.
 * @param {Object<RenderFlag>} flags  An object which defines the flags which are supported for tracking
 * @param {object} [config]           Optional configuration
 * @param {RenderFlagObject} [config.object]  The object which owns this RenderFlags instance
 * @param {number} [config.priority]          The ticker priority at which these render flags are handled
 */
declare class RenderFlags extends Set<any> {
    constructor(flags?: {}, { object, priority }?: {
        object: any;
        priority?: any;
    });
    /**
     * @inheritDoc
     * @returns {Object<boolean>}     The flags which were previously set that have been cleared.
     */
    clear(): any;
    /**
     * Allow for handling one single flag at a time.
     * This function returns whether the flag needs to be handled and removes it from the pending set.
     * @param {string} flag
     * @returns {boolean}
     */
    handle(flag: string): boolean;
    /**
     * Activate certain flags, also toggling propagation and reset behaviors
     * @param {Object<boolean>} changes
     */
    set(changes: any): void;
    #private;
}
declare const ResizeHandle_base: any;
declare class ResizeHandle extends ResizeHandle_base {
    [x: string]: any;
    constructor(offset: any, handlers?: {});
    offset: any;
    handlers: {};
    cursor: string;
    /**
     * Track whether the handle is being actively used for a drag workflow
     * @type {boolean}
     */
    active: boolean;
    refresh(bounds: any): void;
    hitArea: PIXI.Rectangle;
    updateDimensions(current: any, origin: any, destination: any, { aspectRatio }?: {
        aspectRatio?: any;
    }): {
        x: any;
        y: any;
        width: number;
        height: number;
    };
    activateListeners(): void;
    eventMode: string;
    /**
     * Handle mouse-over event on a control handle
     * @param {PIXI.FederatedEvent} event   The mouseover event
     * @protected
     */
    protected _onHoverIn(event: PIXI.FederatedEvent): void;
    /**
     * Handle mouse-out event on a control handle
     * @param {PIXI.FederatedEvent} event   The mouseout event
     * @protected
     */
    protected _onHoverOut(event: PIXI.FederatedEvent): void;
    /**
     * When we start a drag event - create a preview copy of the Tile for re-positioning
     * @param {PIXI.FederatedEvent} event   The mousedown event
     * @protected
     */
    protected _onMouseDown(event: PIXI.FederatedEvent): void;
}
/**
 * A subclass of Set which manages the Token ids which the User has targeted.
 * @extends {Set}
 * @see User#targets
 */
declare class UserTargets extends Set<any> {
    constructor(user: any);
    user: any;
    /**
     * Return the Token IDs which are user targets
     * @type {string[]}
     */
    get ids(): string[];
    /** @override */
    override add(token: any): this;
    /** @override */
    override delete(token: any): boolean;
    #private;
}
/**
 * A special class of Polygon which implements a limited angle of emission for a Point Source.
 * The shape is defined by a point origin, radius, angle, and rotation.
 * The shape is further customized by a configurable density which informs the approximation.
 * An optional secondary externalRadius can be provided which adds supplementary visibility outside the primary angle.
 */
declare class LimitedAnglePolygon extends PIXI.Polygon {
    /**
     * Test whether a vertex lies between two boundary rays.
     * If the angle is greater than 180, test for points between rMax and rMin (inverse).
     * Otherwise, keep vertices that are between the rays directly.
     * @param {Point} point             The candidate point
     * @param {PolygonRay} rMin         The counter-clockwise bounding ray
     * @param {PolygonRay} rMax         The clockwise bounding ray
     * @param {number} angle            The angle being tested, in degrees
     * @returns {boolean}               Is the vertex between the two rays?
     */
    static pointBetweenRays(point: Point, rMin: PolygonRay, rMax: PolygonRay, angle: number): boolean;
    constructor(origin: any, { radius, angle, rotation, density, externalRadius }?: {
        radius: any;
        angle?: number;
        rotation?: number;
        density: any;
        externalRadius?: number;
    });
    /**
     * The origin point of the Polygon
     * @type {Point}
     */
    origin: Point;
    /**
     * The radius of the emitted cone.
     * @type {number}
     */
    radius: number;
    /**
     * The angle of the Polygon in degrees.
     * @type {number}
     */
    angle: number;
    /**
     * The direction of rotation at the center of the emitted angle in degrees.
     * @type {number}
     */
    rotation: number;
    /**
     * The density of rays which approximate the cone, defined as rays per PI.
     * @type {number}
     */
    density: number;
    /**
     * An optional "external radius" which is included in the polygon for the supplementary area outside the cone.
     * @type {number}
     */
    externalRadius: number;
    /**
     * The angle of the left (counter-clockwise) edge of the emitted cone in radians.
     * @type {number}
     */
    aMin: number;
    /**
     * The angle of the right (clockwise) edge of the emitted cone in radians.
     * @type {number}
     */
    aMax: number;
    /**
     * The bounding box of the circle defined by the externalRadius, if any
     * @type {PIXI.Rectangle}
     */
    externalBounds: PIXI.Rectangle;
    /**
     * Restrict the edges which should be included in a PointSourcePolygon based on this specialized shape.
     * We use two tests to jointly keep or reject edges.
     * 1. If this shape uses an externalRadius, keep edges which collide with the bounding box of that circle.
     * 2. Keep edges which are contained within or collide with one of the primary angle boundary rays.
     * @param {Point} a             The first edge vertex
     * @param {Point} b             The second edge vertex
     * @returns {boolean}           Should the edge be included in the PointSourcePolygon computation?
     * @internal
     */
    _includeEdge(a: Point, b: Point): boolean;
    #private;
}
/**
 * An internal data structure for polygon vertices
 * @private
 * @ignore
 */
declare class PolygonVertex {
    /**
     * The effective maximum texture size that Foundry VTT "ever" has to worry about.
     * @type {number}
     */
    static "__#140@#MAX_TEXTURE_SIZE": number;
    /**
     * Determine the sort key to use for this vertex, arranging points from north-west to south-east.
     * @param {number} x    The x-coordinate
     * @param {number} y    The y-coordinate
     */
    static "__#140@#getSortKey"(x: number, y: number): number;
    /**
     * Construct a PolygonVertex instance from some other Point structure.
     * @param {Point} point           The point
     * @param {object} [options]      Additional options that apply to this vertex
     * @returns {PolygonVertex}       The constructed vertex
     */
    static fromPoint(point: Point, options?: object): PolygonVertex;
    constructor(x: any, y: any, { distance, index }?: {
        distance: any;
        index: any;
    });
    x: number;
    y: number;
    key: number;
    _distance: any;
    _d2: any;
    _index: any;
    /**
     * The set of edges which connect to this vertex.
     * This set is initially empty and populated later after vertices are de-duplicated.
     * @type {EdgeSet}
     */
    edges: EdgeSet;
    /**
     * The subset of edges which continue clockwise from this vertex.
     * @type {EdgeSet}
     */
    cwEdges: EdgeSet;
    /**
     * The subset of edges which continue counter-clockwise from this vertex.
     * @type {EdgeSet}
     */
    ccwEdges: EdgeSet;
    /**
     * The set of vertices collinear to this vertex
     * @type {Set<PolygonVertex>}
     */
    collinearVertices: Set<PolygonVertex>;
    /**
     * The maximum restriction type of this vertex
     * @type {number|null}
     */
    type: number | null;
    /**
     * Is this vertex an endpoint of one or more edges?
     * @type {boolean}
     */
    isEndpoint: boolean;
    /**
     * Does this vertex have a single counterclockwise limiting edge?
     * @type {boolean}
     */
    isLimitingCCW: boolean;
    /**
     * Does this vertex have a single clockwise limiting edge?
     * @type {boolean}
     */
    isLimitingCW: boolean;
    /**
     * Does this vertex have non-limited edges or 2+ limited edges counterclockwise?
     * @type {boolean}
     */
    isBlockingCCW: boolean;
    /**
     * Does this vertex have non-limited edges or 2+ limited edges clockwise?
     * @type {boolean}
     */
    isBlockingCW: boolean;
    /**
     * Associate an edge with this vertex.
     * @param {PolygonEdge} edge      The edge being attached
     * @param {number} orientation    The orientation of the edge with respect to the origin
     */
    attachEdge(edge: PolygonEdge, orientation?: number): void;
    /**
     * Is this vertex limited in type?
     * @returns {boolean}
     */
    get isLimited(): boolean;
    /**
     * Is this vertex terminal (at the maximum radius)
     * @returns {boolean}
     */
    get isTerminal(): boolean;
    /**
     * Is this vertex the same point as some other vertex?
     * @param {PolygonVertex} other   Some other vertex
     * @returns {boolean}             Are they the same point?
     */
    equals(other: PolygonVertex): boolean;
    #private;
}
/**
 * An internal data structure for polygon edges
 * @private
 * @ignore
 */
declare class PolygonEdge {
    /**
     * Construct a PolygonEdge instance from a Wall placeable object.
     * @param {Wall|WallDocument} wall  The Wall from which to construct an edge
     * @param {string} type             The type of polygon being constructed
     * @returns {PolygonEdge}
     */
    static fromWall(wall: Wall | WallDocument, type: string): PolygonEdge;
    constructor(a: any, b: any, type: number, wall: any);
    A: PolygonVertex;
    B: PolygonVertex;
    type: number;
    wall: any;
    /**
     * An internal flag used to record whether an Edge represents a canvas boundary.
     * @type {boolean}
     * @internal
     */
    _isBoundary: boolean;
    /**
     * Is this edge limited in type?
     * @returns {boolean}
     */
    get isLimited(): boolean;
}
/**
 * An object containing the result of a collision test.
 * @private
 * @ignore
 */
declare class CollisionResult {
    constructor({ target, collisions, cwEdges, ccwEdges, isBehind, isLimited, wasLimited }?: {
        target?: any;
        collisions?: any[];
        cwEdges: any;
        ccwEdges: any;
        isBehind: any;
        isLimited: any;
        wasLimited: any;
    });
    /**
     * The vertex that was the target of this result
     * @type {PolygonVertex}
     */
    target: PolygonVertex;
    /**
     * The array of collision points which apply to this result
     * @type {PolygonVertex[]}
     */
    collisions: PolygonVertex[];
    /**
     * The set of edges connected to the target vertex that continue clockwise
     * @type {EdgeSet}
     */
    cwEdges: EdgeSet;
    /**
     * The set of edges connected to the target vertex that continue counter-clockwise
     * @type {EdgeSet}
     */
    ccwEdges: EdgeSet;
    /**
     * Is the target vertex for this result behind some closer active edge?
     * @type {boolean}
     */
    isBehind: boolean;
    /**
     * Does the target vertex for this result impose a limited collision?
     * @type {boolean}
     */
    isLimited: boolean;
    /**
     * Has the set of collisions for this result encountered a limited edge?
     * @type {boolean}
     */
    wasLimited: boolean;
    /**
     * Is this result limited in the clockwise direction?
     * @type {boolean}
     */
    limitedCW: boolean;
    /**
     * Is this result limited in the counter-clockwise direction?
     * @type {boolean}
     */
    limitedCCW: boolean;
    /**
     * Is this result blocking in the clockwise direction?
     * @type {boolean}
     */
    blockedCW: boolean;
    /**
     * Is this result blocking in the counter-clockwise direction?
     * @type {boolean}
     */
    blockedCCW: boolean;
    /**
     * Previously blocking in the clockwise direction?
     * @type {boolean}
     */
    blockedCWPrev: boolean;
    /**
     * Previously blocking in the counter-clockwise direction?
     */
    blockedCCWPrev: boolean;
}
/**
 * A helper class used to construct triangulated polygon meshes
 * Allow to add padding and a specific depth value.
 * @param {number[]|PIXI.Polygon} poly      Closed polygon to be processed and converted to a mesh
 *                                          (array of points or PIXI Polygon)
 * @param {object|{}} options               Various options : normalizing, offsetting, add depth, ...
 */
declare class PolygonMesher {
    /**
     * Default options values
     * @type {Object<string,boolean|number>}
     */
    static _defaultOptions: {
        [x: string]: boolean | number;
    };
    /**
     * Convert a flat points array into a 2 dimensional ClipperLib path
     * @param {number[]|PIXI.Polygon} poly             PIXI.Polygon or points flat array.
     * @param {number} [dimension=2]                   Dimension.
     * @returns {number[]|undefined}                   The clipper lib path.
     */
    static getClipperPathFromPoints(poly: number[] | PIXI.Polygon, dimension?: number): number[] | undefined;
    constructor(poly: any, options?: {});
    /**
     * Contains options to apply during the meshing process
     * @type {Object<string,boolean|number>}
     */
    options: {
        [x: string]: boolean | number;
    };
    /**
     * Polygon mesh vertices
     * @type {number[]}
     */
    vertices: number[];
    /**
     * Polygon mesh indices
     * @type {number[]}
     */
    indices: number[];
    /**
     * Execute the triangulation to create indices
     * @param {PIXI.Geometry} geometry    A geometry to update
     * @returns {PIXI.Geometry}           The resulting geometry
     */
    triangulate(geometry: PIXI.Geometry): PIXI.Geometry;
    #private;
}
/**
 * An extension of the default PIXI.Text object which forces double resolution.
 * At default resolution Text often looks blurry or fuzzy.
 */
declare class PreciseText {
    /**
     * Prepare a TextStyle object which merges the canvas defaults with user-provided options
     * @param {object} [options={}]   Additional options merged with the default TextStyle
     * @param {number} [options.anchor]       A text anchor point from CONST.TEXT_ANCHOR_POINTS
     * @returns {PIXI.TextStyle}      The prepared TextStyle
     */
    static getTextStyle({ anchor, ...options }?: {
        anchor?: number;
    }): PIXI.TextStyle;
    constructor(...args: any[]);
    _autoResolution: boolean;
    _resolution: number;
}
/**
 * @typedef {Object} RayIntersection
 * @property {number} x     The x-coordinate of intersection
 * @property {number} y     The y-coordinate of intersection
 * @property {number} t0    The proximity to the Ray origin, as a ratio of distance
 * @property {number} t1    The proximity to the Ray destination, as a ratio of distance
 */
/**
 * A ray for the purposes of computing sight and collision
 * Given points A[x,y] and B[x,y]
 *
 * Slope-Intercept form:
 * y = a + bx
 * y = A.y + ((B.y - A.Y) / (B.x - A.x))x
 *
 * Parametric form:
 * R(t) = (1-t)A + tB
 *
 * @param {Point} A      The origin of the Ray
 * @param {Point} B      The destination of the Ray
 */
declare class Ray {
    /**
     * A factory method to construct a Ray from an origin point, an angle, and a distance
     * @param {number} x          The origin x-coordinate
     * @param {number} y          The origin y-coordinate
     * @param {number} radians    The ray angle in radians
     * @param {number} distance   The distance of the ray in pixels
     * @returns {Ray}             The constructed Ray instance
     */
    static fromAngle(x: number, y: number, radians: number, distance: number): Ray;
    /**
     * A factory method to construct a Ray from points in array format.
     * @param {number[]} A    The origin point [x,y]
     * @param {number[]} B    The destination point [x,y]
     * @returns {Ray}         The constructed Ray instance
     */
    static fromArrays(A: number[], B: number[]): Ray;
    /**
     * Create a Ray by projecting a certain distance towards a known point.
     * @param {Point} origin      The origin of the Ray
     * @param {Point} point       The point towards which to project
     * @param {number} distance   The distance of projection
     * @returns {Ray}
     */
    static towardsPoint(origin: Point, point: Point, distance: number): Ray;
    /**
     * Create a Ray by projecting a certain squared-distance towards a known point.
     * @param {Point} origin      The origin of the Ray
     * @param {Point} point       The point towards which to project
     * @param {number} distance2  The squared distance of projection
     * @returns {Ray}
     */
    static towardsPointSquared(origin: Point, point: Point, distance2: number): Ray;
    constructor(A: any, B: any);
    /**
     * The origin point, {x, y}
     * @type {Point}
     */
    A: Point;
    /**
     * The destination point, {x, y}
     * @type {Point}
     */
    B: Point;
    /**
     * The origin y-coordinate
     * @type {number}
     */
    y0: number;
    /**
     * The origin x-coordinate
     * @type {number}
     */
    x0: number;
    /**
     * The horizontal distance of the ray, x1 - x0
     * @type {number}
     */
    dx: number;
    /**
     * The vertical distance of the ray, y1 - y0
     * @type {number}
     */
    dy: number;
    /**
     * The slope of the ray, dy over dx
     * @type {number}
     */
    slope: number;
    /**
     * The cached angle, computed lazily in Ray#angle
     * @type {number}
     * @private
     */
    private _angle;
    /**
     * The cached distance, computed lazily in Ray#distance
     * @type {number}
     * @private
     */
    private _distance;
    set angle(arg: number);
    /**
     * The normalized angle of the ray in radians on the range (-PI, PI).
     * The angle is computed lazily (only if required) and cached.
     * @type {number}
     */
    get angle(): number;
    /**
     * A normalized bounding rectangle that encompasses the Ray
     * @type {PIXI.Rectangle}
     */
    get bounds(): PIXI.Rectangle;
    set distance(arg: number);
    /**
     * The distance (length) of the Ray in pixels.
     * The distance is computed lazily (only if required) and cached.
     * @type {number}
     */
    get distance(): number;
    /**
     * Project the Array by some proportion of it's initial distance.
     * Return the coordinates of that point along the path.
     * @param {number} t    The distance along the Ray
     * @returns {Object}    The coordinates of the projected point
     */
    project(t: number): any;
    /**
     * Reverse the direction of the Ray, returning a second Ray
     * @returns {Ray}
     */
    reverse(): Ray;
    /**
     * Create a new ray which uses the same origin point, but a slightly offset angle and distance
     * @param {number} offset       An offset in radians which modifies the angle of the original Ray
     * @param {number} [distance]   A distance the new ray should project, otherwise uses the same distance.
     * @return {Ray}                A new Ray with an offset angle
     */
    shiftAngle(offset: number, distance?: number): Ray;
    /**
     * Find the point I[x,y] and distance t* on ray R(t) which intersects another ray
     * @see foundry.utils.lineLineIntersection
     */
    intersectSegment(coords: any): import("../../common/utils/geometry.mjs").LineIntersection;
}
/**
 * @typedef {Object} PointSourcePolygonConfig
 * @property {string} [type]        The type of polygon being computed
 * @property {number} [angle=360]   The angle of emission, if limited
 * @property {number} [density]     The desired density of padding rays, a number per PI
 * @property {number} [radius]      A limited radius of the resulting polygon
 * @property {number} [rotation]    The direction of facing, required if the angle is limited
 * @property {number} [wallDirectionMode] Customize how wall direction of one-way walls is applied
 * @property {boolean} [useThreshold] Compute the polygon with threshold wall constraints applied
 * @property {boolean} [debug]      Display debugging visualization and logging for the polygon
 * @property {PointSource} [source] The object (if any) that spawned this polygon.
 * @property {Array<PIXI.Rectangle|PIXI.Circle|PIXI.Polygon>} [boundaryShapes] Limiting polygon boundary shapes
 * @property {Readonly<boolean>} [useInnerBounds]   Does this polygon use the Scene inner or outer bounding rectangle
 * @property {Readonly<boolean>} [hasLimitedRadius] Does this polygon have a limited radius?
 * @property {Readonly<boolean>} [hasLimitedAngle]  Does this polygon have a limited angle?
 * @property {Readonly<PIXI.Rectangle>} [boundingBox] The computed bounding box for the polygon
 */
/**
 * An extension of the default PIXI.Polygon which is used to represent the line of sight for a point source.
 * @extends {PIXI.Polygon}
 */
declare class PointSourcePolygon extends PIXI.Polygon {
    /**
     * Customize how wall direction of one-way walls is applied
     * @enum {number}
     */
    static WALL_DIRECTION_MODES: Readonly<{
        NORMAL: 0;
        REVERSED: 1;
        BOTH: 2;
    }>;
    /**
     * Benchmark the performance of polygon computation for this source
     * @param {number} iterations                 The number of test iterations to perform
     * @param {Point} origin                      The origin point to benchmark
     * @param {PointSourcePolygonConfig} config   The polygon configuration to benchmark
     */
    static benchmark(iterations: number, origin: Point, config: PointSourcePolygonConfig): Promise<void>;
    /**
     * Compute the polygon given a point origin and radius
     * @param {Point} origin                          The origin source point
     * @param {PointSourcePolygonConfig} [config={}]  Configuration options which customize the polygon computation
     * @returns {PointSourcePolygon}                  The computed polygon instance
     */
    static create(origin: Point, config?: PointSourcePolygonConfig): PointSourcePolygon;
    /**
     * Test whether a Ray between the origin and destination points would collide with a boundary of this Polygon.
     * A valid wall restriction type is compulsory and must be passed into the config options.
     * @param {Point} origin                          An origin point
     * @param {Point} destination                     A destination point
     * @param {PointSourcePolygonConfig} config       The configuration that defines a certain Polygon type
     * @param {string} [config.mode]                  The collision mode to test: "any", "all", or "closest"
     * @returns {boolean|PolygonVertex|PolygonVertex[]|null} The collision result depends on the mode of the test:
     *                                                * any: returns a boolean for whether any collision occurred
     *                                                * all: returns a sorted array of PolygonVertex instances
     *                                                * closest: returns a PolygonVertex instance or null
     */
    static testCollision(origin: Point, destination: Point, { mode, ...config }?: PointSourcePolygonConfig): boolean | PolygonVertex | PolygonVertex[] | null;
    /**
     * Augment a PointSourcePolygon by adding additional coverage for shapes permitted by threshold walls.
     * @param {PointSourcePolygon} polygon        The computed polygon
     * @returns {PointSourcePolygon}              The augmented polygon
     */
    static applyThresholdAttenuation(polygon: PointSourcePolygon): PointSourcePolygon;
    /**
     * Identify walls in the Scene which include an active threshold.
     * @param {Point} origin
     * @param {object} config
     * @returns {{thresholdWalls: Wall[], nAttenuated: number}}
     */
    static "__#142@#getThresholdWalls"(origin: Point, config: object): {
        thresholdWalls: Wall[];
        nAttenuated: number;
    };
    /**
     * @typedef {ClipperPoint[]} ClipperPoints
     */
    /**
     * For each threshold wall that this source passes through construct a shape representing the attenuated source.
     * The attenuated shape is a circle with a radius modified by origin proximity to the threshold wall.
     * Intersect the attenuated shape against the LOS with threshold walls considered.
     * The result is the LOS for the attenuated light source.
     * @param {PointSourcePolygon} thresholdPolygon   The computed polygon with thresholds applied
     * @param {Wall[]} thresholdWalls                 The identified array of threshold walls
     * @returns {ClipperPoints[]}                     The resulting array of intersected threshold shapes
     */
    static "__#142@#createThresholdShapes"(thresholdPolygon: PointSourcePolygon, thresholdWalls: Wall[]): ClipperPoint[][];
    /**
     * Calculate the attenuation of the source as it passes through the threshold wall.
     * The distance of perception through the threshold wall depends on proximity of the source from the wall.
     * @param {Wall} wall         The wall for which this threshold applies
     * @param {Point} origin      Origin point on the canvas for this source
     * @param {number} radius     Radius to use for this source, before considering attenuation
     * @param {number} externalRadius The external radius of the source
     * @param {string} type       Sense type for the source
     * @returns {{inside: number, outside: number}} The inside and outside portions of the radius
     */
    static "__#142@#calculateThresholdAttenuation"(wall: Wall, origin: Point, radius: number, externalRadius: number, type: string): {
        inside: number;
        outside: number;
    };
    /**
     * Union the attenuated shape-LOS intersections with the closed LOS.
     * The portion of the light sources "inside" the threshold walls are not modified from their default radius or shape.
     * Clipper can union everything at once. Use a positive fill to avoid checkerboard; fill any overlap.
     * @param {PointSourcePolygon} los    The LOS polygon with threshold walls inactive
     * @param {ClipperPoints[]} shapes    Attenuation shapes for threshold walls
     * @returns {PIXI.Polygon}            The combined LOS polygon with threshold shapes
     */
    static "__#142@#combineThresholdShapes"(los: PointSourcePolygon, shapes: ClipperPoint[][]): PIXI.Polygon;
    /**
     * The rectangular bounds of this polygon
     * @type {PIXI.Rectangle}
     */
    bounds: PIXI.Rectangle;
    /**
     * The origin point of the source polygon.
     * @type {Point}
     */
    origin: Point;
    /**
     * The configuration of this polygon.
     * @type {PointSourcePolygonConfig}
     */
    config: PointSourcePolygonConfig;
    /**
     * An indicator for whether this polygon is constrained by some boundary shape?
     * @type {boolean}
     */
    get isConstrained(): boolean;
    /**
     * Create a clone of this polygon.
     * This overrides the default PIXI.Polygon#clone behavior.
     * @override
     * @returns {PointSourcePolygon}    A cloned instance
     */
    override clone(): PointSourcePolygon;
    /**
     * Compute the polygon using the origin and configuration options.
     * @returns {PointSourcePolygon}    The computed polygon
     */
    compute(): PointSourcePolygon;
    /**
     * Perform the implementation-specific computation
     * @protected
     */
    protected _compute(): void;
    /**
     * Customize the provided configuration object for this polygon type.
     * @param {Point} origin                        The provided polygon origin
     * @param {PointSourcePolygonConfig} config     The provided configuration object
     */
    initialize(origin: Point, config: PointSourcePolygonConfig): void;
    /**
     * Get the super-set of walls which could potentially apply to this polygon.
     * Define a custom collision test used by the Quadtree to obtain candidate Walls.
     * @returns {Set<Wall>}
     * @protected
     */
    protected _getWalls(): Set<Wall>;
    /**
     * Test whether a wall should be included in the computed polygon for a given origin and type
     * @param {Wall} wall         The Wall being considered
     * @param {PIXI.Rectangle} bounds   The overall bounding box
     * @returns {boolean}         Should the wall be included?
     * @protected
     */
    protected _testWallInclusion(wall: Wall, bounds: PIXI.Rectangle): boolean;
    /**
     * Compute the aggregate bounding box which is the intersection of all boundary shapes.
     * Round and pad the resulting rectangle by 1 pixel to ensure it always contains the origin.
     * @returns {PIXI.Rectangle}
     * @protected
     */
    protected _defineBoundingBox(): PIXI.Rectangle;
    /**
     * Apply a constraining boundary shape to an existing PointSourcePolygon.
     * Return a new instance of the polygon with the constraint applied.
     * The new instance is only a "shallow clone", as it shares references to component properties with the original.
     * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Polygon} constraint      The constraining boundary shape
     * @param {object} [intersectionOptions]                            Options passed to the shape intersection method
     * @returns {PointSourcePolygon}                                    A new constrained polygon
     */
    applyConstraint(constraint: PIXI.Circle | PIXI.Rectangle | PIXI.Polygon, intersectionOptions?: object): PointSourcePolygon;
    /** @inheritDoc */
    contains(x: any, y: any): any;
    /**
     * Constrain polygon points by applying boundary shapes.
     * @protected
     */
    protected _constrainBoundaryShapes(): void;
    points: any;
    /**
     * Determine the set of collisions which occurs for a Ray.
     * @param {Ray} ray                           The Ray to test
     * @param {string} mode                       The collision mode being tested
     * @returns {boolean|PolygonVertex|PolygonVertex[]|null} The collision test result
     * @protected
     * @abstract
     */
    protected _testCollision(ray: Ray, mode: string): boolean | PolygonVertex | PolygonVertex[] | null;
    /**
     * Visualize the polygon, displaying its computed area and applied boundary shapes.
     * @returns {PIXI.Graphics|undefined}     The rendered debugging shape
     */
    visualize(): any | undefined;
    /**
     * Determine if the shape is a complete circle.
     * The config object must have an angle and a radius properties.
     */
    isCompleteCircle(): any;
    set rays(arg: any[]);
    /** @ignore */
    get rays(): any[];
    #private;
}
/**
 * A type of ping that points to a specific location.
 * @param {PIXI.Point} origin      The canvas co-ordinates of the origin of the ping.
 * @param {PingOptions} [options]  Additional options to configure the ping animation.
 * @extends Ping
 */
declare class ChevronPing extends Ping {
    /**
     * The path to the chevron texture.
     * @type {string}
     * @private
     */
    private static _CHEVRON_PATH;
    _r: number;
    _rInner: number;
    _t14: number;
    _t12: number;
    _t34: number;
    _chevron: PIXI.Sprite;
    /** @inheritdoc */
    _animateFrame(dt: any, animation: any): void;
    /**
     * Draw the outer and inner rings.
     * @param {number} a  The alpha.
     * @private
     */
    private _drawRings;
    /**
     * Load the chevron texture.
     * @returns {Promise<PIXI.Sprite>}
     * @private
     */
    private _loadChevron;
    _h2: number;
    _y: number;
    /**
     * Draw the two rings that are used as part of the ping animation.
     * @returns {PIXI.Graphics[]}
     * @private
     */
    private _createRings;
    _outer: any;
    _inner: any;
}
/**
 * @typedef {PingOptions} PulsePingOptions
 * @property {number} [rings=3]         The number of rings used in the animation.
 * @property {string} [color2=#ffffff]  The alternate color that the rings begin at. Use white for a 'flashing' effect.
 */
/**
 * A type of ping that produces a pulsing animation.
 * @param {PIXI.Point} origin           The canvas co-ordinates of the origin of the ping.
 * @param {PulsePingOptions} [options]  Additional options to configure the ping animation.
 * @extends Ping
 */
declare class PulsePing extends Ping {
    constructor(origin: any, { rings, color2, ...options }?: {
        rings?: number;
        color2?: string;
    });
    _color2: number | import("../../common/utils/color.mjs").default;
    _r: number;
    _r0: number;
    /**
     * Initialize some time slice variables that will be used to control the animation.
     *
     * The animation for each ring can be separated into two consecutive stages.
     * Stage 1: Fade in a white ring with radius r0.
     * Stage 2: Expand radius outward. While the radius is expanding outward, we have two additional, consecutive
     * animations:
     *  Stage 2.1: Transition color from white to the configured color.
     *  Stage 2.2: Fade out.
     * 1/5th of the animation time is allocated to Stage 1. 4/5ths are allocated to Stage 2. Of those 4/5ths, 2/5ths
     * are allocated to Stage 2.1, and 2/5ths are allocated to Stage 2.2.
     * @private
     */
    private _computeTimeSlices;
    _timeSlice: number;
    _timeSlice2: number;
    _timeSlice15: number;
    _timeSlice25: number;
    _timeSlice45: number;
    filters: any[];
    /** @inheritdoc */
    _animateFrame(dt: any, animation: any): void;
    /**
     * Transition linearly from one color to another.
     * @param {Color} from       The color to transition from.
     * @param {Color} to         The color to transition to.
     * @param {number} duration  The length of the transition in milliseconds.
     * @param {number} t         The current time along the duration.
     * @returns {number}         The incremental color between from and to.
     * @private
     */
    private _colorTransition;
    /**
     * Draw the shape for this ping.
     * @param {PIXI.Graphics} g  The graphics object to draw to.
     * @param {number} color     The color of the shape.
     * @param {number} alpha     The alpha of the shape.
     * @param {number} size      The size of the shape to draw.
     * @protected
     */
    protected _drawShape(g: any, color: number, alpha: number, size: number): void;
}
/**
 * A type of ping that produces an arrow pointing in a given direction.
 * @property {PIXI.Point} origin            The canvas co-ordinates of the origin of the ping. This becomes the arrow's
 *                                          tip.
 * @property {PulsePingOptions} [options]   Additional options to configure the ping animation.
 * @property {number} [options.rotation=0]  The angle of the arrow in radians.
 * @extends PulsePing
 */
declare class ArrowPing extends PulsePing {
    constructor(origin: any, { rotation, ...options }?: {
        rotation?: number;
    });
    rotation: any;
    /** @inheritdoc */
    _drawShape(g: any, color: any, alpha: any, size: any): void;
}
/**
 * A type of ping that produces a pulse warning sign animation.
 * @param {PIXI.Point} origin           The canvas co-ordinates of the origin of the ping.
 * @param {PulsePingOptions} [options]  Additional options to configure the ping animation.
 * @extends PulsePing
 */
declare class AlertPing extends PulsePing {
    constructor(origin: any, { color, ...options }?: {
        color?: string;
    });
    _r: any;
    /** @inheritdoc */
    _drawShape(g: any, color: any, alpha: any, size: any): void;
}
/**
 * An abstract pattern for primary layers of the game canvas to implement.
 * @category - Canvas
 * @abstract
 * @interface
 */
declare class CanvasLayer {
    /**
     * Customize behaviors of this CanvasLayer by modifying some behaviors at a class level.
     * @type {{name: string}}
     */
    static get layerOptions(): {
        name: string;
    };
    /**
     * Return a reference to the active instance of this canvas layer
     * @type {CanvasLayer}
     */
    static get instance(): CanvasLayer;
    /**
     * Options for this layer instance.
     * @type {{name: string}}
     */
    options: {
        name: string;
    };
    interactiveChildren: boolean;
    /**
     * The canonical name of the CanvasLayer is the name of the constructor that is the immediate child of the
     * defined baseClass for the layer type.
     * @type {string}
     *
     * @example
     * canvas.lighting.name -> "LightingLayer"
     * canvas.grid.name -> "GridLayer"
     */
    get name(): string;
    /**
     * The name used by hooks to construct their hook string.
     * Note: You should override this getter if hookName should not return the class constructor name.
     * @type {string}
     */
    get hookName(): string;
    /**
     * Draw the canvas layer, rendering its internal components and returning a Promise.
     * The Promise resolves to the drawn layer once its contents are successfully rendered.
     * @param {object} [options]      Options which configure how the layer is drawn
     * @returns {Promise<CanvasLayer>}
     */
    draw(options?: object): Promise<CanvasLayer>;
    /**
     * The inner _draw method which must be defined by each CanvasLayer subclass.
     * @param {object} [options]      Options which configure how the layer is drawn
     * @abstract
     * @protected
     */
    protected _draw(options?: object): Promise<void>;
    /**
     * Deconstruct data used in the current layer in preparation to re-draw the canvas
     * @param {object} [options]      Options which configure how the layer is deconstructed
     * @returns {Promise<CanvasLayer>}
     */
    tearDown(options?: object): Promise<CanvasLayer>;
    renderable: boolean;
    /**
     * The inner _tearDown method which may be customized by each CanvasLayer subclass.
     * @param {object} [options]      Options which configure how the layer is deconstructed
     * @protected
     */
    protected _tearDown(options?: object): Promise<void>;
}
/**
 * A subclass of CanvasLayer which provides support for user interaction with its contained objects.
 * @category - Canvas
 */
declare class InteractionLayer extends CanvasLayer {
    /**
     * Customize behaviors of this CanvasLayer by modifying some behaviors at a class level.
     * @type {{name: string, sortActiveTop: boolean, zIndex: number}}
     */
    static get layerOptions(): {
        name: string;
        sortActiveTop: boolean;
        zIndex: number;
    };
    /**
     * Is this layer currently active
     * @type {boolean}
     */
    get active(): boolean;
    /**
     * Activate the InteractionLayer, deactivating other layers and marking this layer's children as interactive.
     * @param {object} [options]      Options which configure layer activation
     * @param {string} [options.tool]   A specific tool in the control palette to set as active
     * @returns {InteractionLayer}    The layer instance, now activated
     */
    activate({ tool }?: {
        tool?: string;
    }): InteractionLayer;
    zIndex: number;
    eventMode: string;
    /**
     * The inner _activate method which may be defined by each InteractionLayer subclass.
     * @protected
     */
    protected _activate(): void;
    /**
     * Deactivate the InteractionLayer, removing interactivity from its children.
     * @returns {InteractionLayer}    The layer instance, now inactive
     */
    deactivate(): InteractionLayer;
    /**
     * The inner _deactivate method which may be defined by each InteractionLayer subclass.
     * @protected
     */
    protected _deactivate(): void;
    hitArea: any;
    /**
     * Get the zIndex that should be used for ordering this layer vertically relative to others in the same Container.
     * @returns {number}
     */
    getZIndex(): number;
    /**
     * Handle left mouse-click events which originate from the Canvas stage.
     * @see {@link Canvas._onClickLeft}
     * @param {PIXI.FederatedEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
     * @protected
     */
    protected _onClickLeft(event: PIXI.FederatedEvent): void;
    /**
     * Handle double left-click events which originate from the Canvas stage.
     * @see {@link Canvas._onClickLeft2}
     * @param {PIXI.FederatedEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
     * @protected
     */
    protected _onClickLeft2(event: PIXI.FederatedEvent): void;
    /**
     * Start a left-click drag workflow originating from the Canvas stage.
     * @see {@link Canvas._onDragLeftStart}
     * @param {PIXI.FederatedEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
     * @protected
     */
    protected _onDragLeftStart(event: PIXI.FederatedEvent): Promise<void>;
    /**
     * Continue a left-click drag workflow originating from the Canvas stage.
     * @see {@link Canvas._onDragLeftMove}
     * @param {PIXI.FederatedEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
     * @protected
     */
    protected _onDragLeftMove(event: PIXI.FederatedEvent): void;
    /**
     * Conclude a left-click drag workflow originating from the Canvas stage.
     * @see {@link Canvas._onDragLeftDrop}
     * @param {PIXI.FederatedEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
     * @protected
     */
    protected _onDragLeftDrop(event: PIXI.FederatedEvent): Promise<void>;
    /**
     * Cancel a left-click drag workflow originating from the Canvas stage.
     * @see {@link Canvas._onDragLeftDrop}
     * @param {PointerEvent} event              A right-click pointer event on the document.
     * @protected
     */
    protected _onDragLeftCancel(event: PointerEvent): void;
    /**
     * Handle right mouse-click events which originate from the Canvas stage.
     * @see {@link Canvas._onClickRight}
     * @param {PIXI.FederatedEvent} event      The PIXI InteractionEvent which wraps a PointerEvent
     * @protected
     */
    protected _onClickRight(event: PIXI.FederatedEvent): void;
    /**
     * Handle mouse-wheel events which occur for this active layer.
     * @see {@link MouseManager._onWheel}
     * @param {WheelEvent} event                The WheelEvent initiated on the document
     * @protected
     */
    protected _onMouseWheel(event: WheelEvent): void;
    /**
     * Handle a DELETE keypress while this layer is active.
     * @see {@link ClientKeybindings._onDelete}
     * @param {KeyboardEvent} event             The delete key press event
     * @protected
     */
    protected _onDeleteKey(event: KeyboardEvent): Promise<void>;
    #private;
}
/**
 * @typedef {Object} CanvasHistory
 * @property {string} type    The type of operation stored as history (create, update, delete)
 * @property {Object[]} data  The data corresponding to the action which may later be un-done
 */
/**
 * A subclass of Canvas Layer which is specifically designed to contain multiple PlaceableObject instances,
 * each corresponding to an embedded Document.
 * @category - Canvas
 */
declare class PlaceablesLayer extends InteractionLayer {
    /**
     * @inheritdoc
     * @property {boolean} canDragCreate        Does this layer support a mouse-drag workflow to create new objects?
     * @property {boolean} canDelete            Can objects be deleted from this layer?
     * @property {boolean} controllableObjects  Can placeable objects in this layer be controlled?
     * @property {boolean} rotatableObjects     Can placeable objects in this layer be rotated?
     * @property {boolean} snapToGrid           Do objects in this layer snap to the grid
     * @property {PlaceableObject} objectClass  The class used to represent an object on this layer.
     * @property {boolean} quadtree             Does this layer use a quadtree to track object positions?
     * @property {boolean} elevationSorting     Are contained objects sorted based on elevation instead of zIndex
     */
    static get layerOptions(): any;
    /**
     * A reference to the named Document type which is contained within this Canvas Layer.
     * @type {string}
     */
    static documentName: string;
    /**
     * Creation states affected to placeables during their construction.
     * @enum {number}
     */
    static CREATION_STATES: {
        NONE: number;
        POTENTIAL: number;
        CONFIRMED: number;
        COMPLETED: number;
    };
    /**
     * Obtain a reference to the PlaceableObject class definition which represents the Document type in this layer.
     * @type {Function}
     */
    static get placeableClass(): Function;
    /**
     * Placeable Layer Objects
     * @type {PIXI.Container|null}
     */
    objects: PIXI.Container | null;
    /**
     * Preview Object Placement
     */
    preview: any;
    /**
     * Keep track of history so that CTRL+Z can undo changes
     * @type {CanvasHistory[]}
     */
    history: CanvasHistory[];
    /**
     * Keep track of an object copied with CTRL+C which can be pasted later
     * @type {PlaceableObject[]}
     */
    _copy: PlaceableObject[];
    /**
     * A Quadtree which partitions and organizes Walls into quadrants for efficient target identification.
     * @type {Quadtree|null}
     */
    quadtree: Quadtree | null;
    /**
     * Obtain a reference to the Collection of embedded Document instances within the currently viewed Scene
     * @type {Collection|null}
     */
    get documentCollection(): any;
    /**
     * Return the precision relative to the Scene grid with which Placeable objects should be snapped
     * @type {number}
     */
    get gridPrecision(): number;
    /**
     * If objects on this PlaceableLayer have a HUD UI, provide a reference to its instance
     * @type {BasePlaceableHUD|null}
     */
    get hud(): BasePlaceableHUD;
    /**
     * A convenience method for accessing the placeable object instances contained in this layer
     * @type {PlaceableObject[]}
     */
    get placeables(): PlaceableObject[];
    /**
     * An Array of placeable objects in this layer which have the _controlled attribute
     * @returns {PlaceableObject[]}
     */
    get controlled(): PlaceableObject[];
    /**
     * Iterates over placeable objects that are eligible for control/select.
     * @yields A placeable object
     * @returns {Generator<PlaceableObject>}
     */
    controllableObjects(): Generator<PlaceableObject>;
    /**
     * Track the set of PlaceableObjects on this layer which are currently controlled.
     * @type {Map<string,PlaceableObject>}
     */
    get controlledObjects(): Map<string, PlaceableObject>;
    set hover(arg: PlaceableObject);
    /**
     * Track the PlaceableObject on this layer which is currently hovered upon.
     * @type {PlaceableObject|null}
     */
    get hover(): PlaceableObject;
    /**
     * Track whether "highlight all objects" is currently active
     * @type {boolean}
     */
    highlightObjects: boolean;
    /**
     * Obtain an iterable of objects which should be added to this PlaceableLayer
     * @returns {Document[]}
     */
    getDocuments(): Document[];
    visible: boolean;
    /**
     * Draw a single placeable object
     * @param {ClientDocument} document     The Document instance used to create the placeable object
     * @returns {PlaceableObject}
     */
    createObject(document: ClientDocument): PlaceableObject;
    /**
     * Override the default PIXI.Container behavior for how objects in this container are sorted.
     * @internal
     */
    _sortObjectsByElevation(): void;
    sortDirty: boolean;
    /**
     * Clear the contents of the preview container, restoring visibility of original (non-preview) objects.
     */
    clearPreviewContainer(): void;
    /**
     * Get a PlaceableObject contained in this layer by its ID.
     * Returns undefined if the object doesn't exist or if the canvas is not rendering a Scene.
     * @param {string} objectId   The ID of the contained object to retrieve
     * @returns {PlaceableObject}  The object instance, or undefined
     */
    get(objectId: string): PlaceableObject;
    /**
     * Acquire control over all PlaceableObject instances which are visible and controllable within the layer.
     * @param {object} options      Options passed to the control method of each object
     * @returns {PlaceableObject[]}  An array of objects that were controlled
     */
    controlAll(options?: object): PlaceableObject[];
    /**
     * Release all controlled PlaceableObject instance from this layer.
     * @param {object} options   Options passed to the release method of each object
     * @returns {number}         The number of PlaceableObject instances which were released
     */
    releaseAll(options?: object): number;
    /**
     * Simultaneously rotate multiple PlaceableObjects using a provided angle or incremental.
     * This executes a single database operation using Scene.update.
     * If rotating only a single object, it is better to use the PlaceableObject.rotate instance method.
     *
     * @param {object} options    Options which configure how multiple objects are rotated
     * @param {number} [options.angle]      A target angle of rotation (in degrees) where zero faces "south"
     * @param {number} [options.delta]      An incremental angle of rotation (in degrees)
     * @param {number} [options.snap]       Snap the resulting angle to a multiple of some increment (in degrees)
     * @param {Array} [options.ids]         An Array of object IDs to target for rotation
     * @returns {Promise<PlaceableObject[]>} An array of objects which were rotated
     */
    rotateMany({ angle, delta, snap, ids }?: {
        angle?: number;
        delta?: number;
        snap?: number;
        ids?: any[];
    }): Promise<PlaceableObject[]>;
    /**
     * Simultaneously move multiple PlaceableObjects via keyboard movement offsets.
     * This executes a single database operation using Scene.update.
     * If moving only a single object, this will delegate to PlaceableObject.update for performance reasons.
     *
     * @param {object} options    Options which configure how multiple objects are moved
     * @param {number} [options.dx=0]       The number of incremental grid units in the horizontal direction
     * @param {number} [options.dy=0]       The number of incremental grid units in the vertical direction
     * @param {boolean} [options.rotate=false] Rotate the token to the keyboard direction instead of moving
     * @param {Array} [options.ids]         An Array of object IDs to target for movement
     *
     * @returns {Promise<PlaceableObject[]>} An array of objects which were moved during the operation
     */
    moveMany({ dx, dy, rotate, ids }?: {
        dx?: number;
        dy?: number;
        rotate?: boolean;
        ids?: any[];
    }): Promise<PlaceableObject[]>;
    /**
     * Undo a change to the objects in this layer
     * This method is typically activated using CTRL+Z while the layer is active
     * @returns {Promise<Document[]>}     An array of documents which were modified by the undo operation
     */
    undoHistory(): Promise<Document[]>;
    /**
     * A helper method to prompt for deletion of all PlaceableObject instances within the Scene
     * Renders a confirmation dialogue to confirm with the requester that all objects will be deleted
     * @returns {Promise<Document[]>}    An array of Document objects which were deleted by the operation
     */
    deleteAll(): Promise<Document[]>;
    /**
     * Record a new CRUD event in the history log so that it can be undone later
     * @param {string} type   The event type (create, update, delete)
     * @param {Object[]} data   The object data
     */
    storeHistory(type: string, data: any[]): void;
    /**
     * Copy currently controlled PlaceableObjects to a temporary Array, ready to paste back into the scene later
     * @returns {PlaceableObject[]}             The Array of copied PlaceableObject instances
     */
    copyObjects(): PlaceableObject[];
    /**
     * Paste currently copied PlaceableObjects back to the layer by creating new copies
     * @param {Point} position      The destination position for the copied data.
     * @param {object} [options]    Options which modify the paste operation
     * @param {boolean} [options.hidden]    Paste data in a hidden state, if applicable. Default is false.
     * @param {boolean} [options.snap]      Snap the resulting objects to the grid. Default is true.
     * @returns {Promise<Document[]>} An Array of created Document instances
     */
    pasteObjects(position: Point, { hidden, snap }?: {
        hidden?: boolean;
        snap?: boolean;
    }): Promise<Document[]>;
    /**
     * Select all PlaceableObject instances which fall within a coordinate rectangle.
     * @param {object} [options={}]
     * @param {number} [options.x]                     The top-left x-coordinate of the selection rectangle.
     * @param {number} [options.y]                     The top-left y-coordinate of the selection rectangle.
     * @param {number} [options.width]                 The width of the selection rectangle.
     * @param {number} [options.height]                The height of the selection rectangle.
     * @param {object} [options.releaseOptions={}]     Optional arguments provided to any called release() method.
     * @param {object} [options.controlOptions={}]     Optional arguments provided to any called control() method.
     * @param {object} [aoptions]                      Additional options to configure selection behaviour.
     * @param {boolean} [aoptions.releaseOthers=true]  Whether to release other selected objects.
     * @returns {boolean}       A boolean for whether the controlled set was changed in the operation.
     */
    selectObjects({ x, y, width, height, releaseOptions, controlOptions }?: {
        x?: number;
        y?: number;
        width?: number;
        height?: number;
        releaseOptions?: object;
        controlOptions?: object;
    }, { releaseOthers }?: {
        releaseOthers?: boolean;
    }): boolean;
    /**
     * Update all objects in this layer with a provided transformation.
     * Conditionally filter to only apply to objects which match a certain condition.
     * @param {Function|object} transformation     An object of data or function to apply to all matched objects
     * @param {Function|null}  condition           A function which tests whether to target each object
     * @param {object} [options]                   Additional options passed to Document.update
     * @returns {Promise<Document[]>}              An array of updated data once the operation is complete
     */
    updateAll(transformation: Function | object, condition?: Function | null, options?: object): Promise<Document[]>;
    /**
     * Get the world-transformed drop position.
     * @param {DragEvent} event
     * @param {object} [options]
     * @param {boolean} [options.center=true]  Return the co-ordinates of the center of the nearest grid element.
     * @returns {number[]|boolean}     Returns the transformed x, y co-ordinates, or false if the drag event was outside
     *                                 the canvas.
     * @protected
     */
    protected _canvasCoordinatesFromDrop(event: DragEvent, { center }?: {
        center?: boolean;
    }): number[] | boolean;
    /**
     * Create a preview of this layer's object type from a world document and show its sheet to be finalized.
     * @param {object} createData                     The data to create the object with.
     * @param {object} [options]                      Options which configure preview creation
     * @param {boolean} [options.renderSheet]           Render the preview object config sheet?
     * @param {number} [options.top]                    The offset-top position where the sheet should be rendered
     * @param {number} [options.left]                   The offset-left position where the sheet should be rendered
     * @returns {PlaceableObject}                     The created preview object
     * @internal
     */
    _createPreview(createData: object, { renderSheet, top, left }?: {
        renderSheet?: boolean;
        top?: number;
        left?: number;
    }): PlaceableObject;
    /** @override */
    override _onClickLeft(event: any): void;
    /** @override */
    override _onDragLeftStart(event: any): Promise<void>;
    /** @override */
    override _onDragLeftMove(event: any): void;
    /** @override */
    override _onDragLeftDrop(event: any): Promise<any>;
    /** @override */
    override _onDragLeftCancel(event: any): void;
    /** @override */
    override _onClickRight(event: any): void;
    /** @override */
    override _onMouseWheel(event: any): Promise<PlaceableObject[]>;
    /** @override */
    override _onDeleteKey(event: any): Promise<any>;
    /**
     * @deprecated since v11
     * @ignore
     */
    set _highlight(arg: boolean);
    /**
     * @deprecated since v11
     * @ignore
     */
    get _highlight(): boolean;
    #private;
}
/**
 * An interface for defining particle-based weather effects
 * @param {PIXI.Container} parent     The parent container within which the effect is rendered
 * @param {object} [options]          Options passed to the getParticleEmitters method which can be used to customize
 *                                    values of the emitter configuration.
 * @interface
 */
declare class ParticleEffect {
    constructor(options?: {});
    /**
     * The array of emitters which are active for this particle effect
     * @type {PIXI.particles.Emitter[]}
     */
    emitters: PIXI.particles.Emitter[];
    /**
     * Create an emitter instance which automatically updates using the shared PIXI.Ticker
     * @param {PIXI.particles.EmitterConfigV3} config   The emitter configuration
     * @returns {PIXI.particles.Emitter}                The created Emitter instance
     */
    createEmitter(config: PIXI.particles.EmitterConfigV3): PIXI.particles.Emitter;
    /**
     * Get the particle emitters which should be active for this particle effect.
     * @param {object} [options]    Options provided to the ParticleEffect constructor which can be used to customize
     *                              configuration values for created emitters.
     * @returns {PIXI.particles.Emitter[]}
     */
    getParticleEmitters(options?: object): PIXI.particles.Emitter[];
    /** @override */
    override destroy(...args: any[]): void;
    /**
     * Begin animation for the configured emitters.
     */
    play(): void;
    /**
     * Stop animation for the configured emitters.
     */
    stop(): void;
}
/**
 * @deprecated since v10
 * @ignore
 */
declare class SpecialEffect extends ParticleEffect {
    constructor();
}
/**
 * A full-screen weather effect which renders gently falling autumn leaves.
 * @extends {ParticleEffect}
 */
declare class AutumnLeavesWeatherEffect extends ParticleEffect {
    /** @inheritdoc */
    static label: string;
    /**
     * Configuration for the particle emitter for falling leaves
     * @type {PIXI.particles.EmitterConfigV3}
     */
    static LEAF_CONFIG: PIXI.particles.EmitterConfigV3;
    /** @inheritdoc */
    getParticleEmitters(): PIXI.particles.Emitter[];
}
/**
 * A single Mouse Cursor
 * @type {PIXI.Container}
 */
declare class Cursor {
    constructor(user: any);
    target: {
        x: number;
        y: number;
    };
    /**
     * Draw the user's cursor as a small dot with their user name attached as text
     */
    draw(user: any): void;
    /**
     * Move an existing cursor to a new position smoothly along the animation loop
     */
    _animate(): void;
    /** @inheritdoc */
    destroy(options: any): void;
}
/**
 * An icon representing a Door Control
 * @extends {PIXI.Container}
 */
declare class DoorControl {
    constructor(wall: any);
    wall: any;
    visible: boolean;
    /**
     * The center of the wall which contains the door.
     * @returns {PIXI.Point|PIXI.Point|boolean|*}
     */
    get center(): any;
    /**
     * Draw the DoorControl icon, displaying its icon texture and border
     * @returns {Promise<DoorControl>}
     */
    draw(): Promise<DoorControl>;
    bg: any;
    icon: any;
    border: any;
    eventMode: string;
    interactiveChildren: boolean;
    hitArea: PIXI.Rectangle;
    cursor: string;
    alpha: number;
    /**
     * Get the icon texture to use for the Door Control icon based on the door state
     * @returns {PIXI.Texture}
     */
    _getTexture(): PIXI.Texture;
    reposition(): void;
    /**
     * Determine whether the DoorControl is visible to the calling user's perspective.
     * The control is always visible if the user is a GM and no Tokens are controlled.
     * @see {CanvasVisibility#testVisibility}
     * @type {boolean}
     */
    get isVisible(): boolean;
    /**
     * Handle mouse over events on a door control icon.
     * @param {PIXI.FederatedEvent} event      The originating interaction event
     * @protected
     */
    protected _onMouseOver(event: PIXI.FederatedEvent): boolean;
    /**
     * Handle mouse out events on a door control icon.
     * @param {PIXI.FederatedEvent} event      The originating interaction event
     * @protected
     */
    protected _onMouseOut(event: PIXI.FederatedEvent): boolean;
    /**
     * Handle left mouse down events on a door control icon.
     * This should only toggle between the OPEN and CLOSED states.
     * @param {PIXI.FederatedEvent} event      The originating interaction event
     * @protected
     */
    protected _onMouseDown(event: PIXI.FederatedEvent): any;
    /**
     * Handle right mouse down events on a door control icon.
     * This should toggle whether the door is LOCKED or CLOSED.
     * @param {PIXI.FederatedEvent} event      The originating interaction event
     * @protected
     */
    protected _onRightDown(event: PIXI.FederatedEvent): any;
}
/**
 * @deprecated since v10
 * @ignore
 */
declare class SynchronizedTransform {
    /**
     * A list of attributes from the transform reference which should be synchronized
     * @type {string}
     */
    static synchronizedAttributes: string;
    constructor(transform: any);
    set reference(arg: PIXI.Transform);
    /**
     * A Transform instance which defines the reference point for the worldTransform
     * @type {PIXI.Transform}
     */
    get reference(): PIXI.Transform;
    _reference: PIXI.Transform;
    _syncLocalID: any;
    /** @override */
    override updateTransform(parentTransform: any): void;
    _parentID: number;
    /** @override */
    override updateLocalTransform(): void;
}
/**
 * @deprecated since v10
 * @ignore
 */
declare class ObjectHUD {
    constructor(object: any);
    /**
     * The object that this HUD container is linked to
     * @type {PIXI.DisplayObject}
     */
    object: PIXI.DisplayObject;
    /**
     * Use the linked object's transform matrix to easily synchronize position
     * @type {PIXI.Transform}
     */
    transform: PIXI.Transform;
    cullable: boolean;
    override set visible(arg: any);
    /** @override */
    override get visible(): any;
    override set renderable(arg: any);
    /** @override */
    override get renderable(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    createScrollingText(content: any, { direction, ...options }?: {
        direction?: number;
    }): Promise<any>;
}
/**
 * A CanvasLayer for displaying UI controls which are overlayed on top of other layers.
 *
 * We track three types of events:
 * 1) Cursor movement
 * 2) Ruler measurement
 * 3) Map pings
 */
declare class ControlsLayer extends InteractionLayer {
    /** @override */
    static override get layerOptions(): any;
    /**
     * A container of DoorControl instances
     * @type {PIXI.Container}
     */
    doors: PIXI.Container;
    /**
     * A container of HUD interface elements
     * @type {PIXI.Container}
     */
    hud: PIXI.Container;
    /**
     * A container of cursor interaction elements.
     * Contains cursors, rulers, interaction rectangles, and pings
     * @type {PIXI.Container}
     */
    cursors: PIXI.Container;
    /**
     * Ruler tools, one per connected user
     * @type {PIXI.Container}
     */
    rulers: PIXI.Container;
    /**
     * A graphics instance used for drawing debugging visualization
     * @type {PIXI.Graphics}
     */
    debug: any;
    /**
     * The Canvas selection rectangle
     * @type {PIXI.Graphics}
     */
    select: any;
    /**
     * A mapping of user IDs to Cursor instances for quick access
     * @type {Object<string, Cursor>}
     */
    _cursors: {
        [x: string]: Cursor;
    };
    /**
     * A mapping of user IDs to Ruler instances for quick access
     * @type {Object<string, Ruler>}
     * @private
     */
    private _rulers;
    /**
     * The positions of any offscreen pings we are tracking.
     * @type {Object<string, Point>}
     * @private
     */
    private _offscreenPings;
    /**
     * A convenience accessor to the Ruler for the active game user
     * @type {Ruler}
     */
    get ruler(): Ruler;
    /**
     * Get the Ruler display for a specific User ID
     * @param {string} userId
     * @returns {Ruler|null}
     */
    getRulerForUser(userId: string): Ruler | null;
    /**
     * Draw the cursors container
     */
    drawCursors(): void;
    /**
     * Create and add Ruler graphics instances for every game User.
     */
    drawRulers(): void;
    /**
     * Draw door control icons to the doors container.
     */
    drawDoors(): void;
    /**
     * Draw the select rectangle given an event originated within the base canvas layer
     * @param {Object} coords   The rectangle coordinates of the form {x, y, width, height}
     */
    drawSelect({ x, y, width, height }: any): void;
    visible: boolean;
    /**
     * Handle mousemove events on the game canvas to broadcast activity of the user's cursor position
     * @param {PIXI.FederatedEvent} event
     */
    _onMouseMove(event: PIXI.FederatedEvent): void;
    /**
     * Handle pinging the canvas.
     * @param {PIXI.FederatedEvent}   event   The triggering canvas interaction event.
     * @param {PIXI.Point}            origin  The local canvas coordinates of the mousepress.
     * @protected
     */
    protected _onLongPress(event: PIXI.FederatedEvent, origin: PIXI.Point): any;
    /**
     * Handle the canvas panning to a new view.
     * @protected
     */
    protected _onCanvasPan(): void;
    /**
     * Create and draw the Cursor object for a given User
     * @param {User} user   The User document for whom to draw the cursor Container
     */
    drawCursor(user: User): any;
    /**
     * Update the cursor when the user moves to a new position
     * @param {User} user         The User for whom to update the cursor
     * @param {Point} position    The new cursor position
     */
    updateCursor(user: User, position: Point): void;
    /**
     * Update display of an active Ruler object for a user given provided data
     * @param {User} user             The User for whom to update the ruler
     * @param {object} rulerData      Data which describes the new ruler measurement to display
     */
    updateRuler(user: User, rulerData: object): void;
    /**
     * Handle a broadcast ping.
     * @param {User} user                 The user who pinged.
     * @param {PIXI.Point} position       The position on the canvas that was pinged.
     * @param {PingData} [data]           The broadcast ping data.
     * @returns {Promise<boolean>}   {@see Ping#animate}
     */
    handlePing(user: User, position: PIXI.Point, { scene, style, pull, zoom, ...pingOptions }?: {
        /**
         * Pulls all connected clients' views to the pinged co-ordinates.
         */
        pull?: boolean;
        /**
         * The ping style, see CONFIG.Canvas.pings.
         */
        style: string;
        /**
         * The ID of the scene that was pinged.
         */
        scene: string;
        /**
         * The zoom level at which the ping was made.
         */
        zoom: number;
    }): Promise<boolean>;
    /**
     * Draw a ping at the edge of the viewport, pointing to the location of an off-screen ping.
     * @param {PIXI.Point} position           The co-ordinates of the off-screen ping.
     * @param {PingOptions} [options]         Additional options to configure how the ping is drawn.
     * @param {string} [options.style=arrow]  The style of ping to draw, from CONFIG.Canvas.pings.
     * @param {User} [options.user]           The user who pinged.
     * @returns {Promise<boolean>}            {@see Ping#animate}
     */
    drawOffscreenPing(position: PIXI.Point, { style, user, ...pingOptions }?: PingOptions): Promise<boolean>;
    /**
     * Draw a ping on the canvas.
     * @param {PIXI.Point} position           The position on the canvas that was pinged.
     * @param {PingOptions} [options]         Additional options to configure how the ping is drawn.
     * @param {string} [options.style=pulse]  The style of ping to draw, from CONFIG.Canvas.pings.
     * @param {User} [options.user]           The user who pinged.
     * @returns {Promise<boolean>}            {@see Ping#animate}
     */
    drawPing(position: PIXI.Point, { style, user, ...pingOptions }?: PingOptions): Promise<boolean>;
    /**
     * Given an off-screen co-ordinate, determine the closest point at the edge of the viewport to that co-ordinate.
     * @param {Point} position                                     The off-screen co-ordinate.
     * @returns {{ray: Ray, intersection: LineIntersection|null}}  The closest point at the edge of the viewport to that
     *                                                             co-ordinate and a ray cast from the centre of the
     *                                                             screen towards it.
     * @private
     */
    private _findViewportIntersection;
}
/**
 * @typedef {Object} RulerMeasurementSegment
 * @property {Ray} ray              The Ray which represents the point-to-point line segment
 * @property {PreciseText} label    The text object used to display a label for this segment
 * @property {number} distance      The measured distance of the segment
 * @property {string} text          The string text displayed in the label
 * @property {boolean} last         Is this segment the last one?
 */
/**
 * The Ruler - used to measure distances and trigger movements
 * @param {User}  The User for whom to construct the Ruler instance
 * @type {PIXI.Container}
 */
declare class Ruler {
    /**
     * An enumeration of the possible Ruler measurement states.
     * @enum {number}
     */
    static STATES: {
        INACTIVE: number;
        STARTING: number;
        MEASURING: number;
        MOVING: number;
    };
    /**
     * Is the ruler ready for measure?
     * @returns {boolean}
     */
    static get canMeasure(): boolean;
    constructor(user: any, { color }?: {
        color?: any;
    });
    /**
     * Record the User which this Ruler references
     * @type {User}
     */
    user: User;
    /**
     * The ruler name - used to differentiate between players
     * @type {string}
     */
    name: string;
    /**
     * The ruler color - by default the color of the active user
     * @type {Color}
     */
    color: typeof import("../../common/utils/color.mjs").default;
    /**
     * This Array tracks individual waypoints along the ruler's measured path.
     * The first waypoint is always the origin of the route.
     * @type {Array<PIXI.Point>}
     */
    waypoints: Array<PIXI.Point>;
    /**
     * The Ruler element is a Graphics instance which draws the line and points of the measured path
     * @type {PIXI.Graphics}
     */
    ruler: any;
    /**
     * The Labels element is a Container of Text elements which label the measured path
     * @type {PIXI.Container}
     */
    labels: PIXI.Container;
    /**
     * Track the current measurement state
     * @type {number}
     */
    _state: number;
    /**
     * The current destination point at the end of the measurement
     * @type {PIXI.Point}
     */
    destination: PIXI.Point;
    /**
     * The array of most recently computed ruler measurement segments
     * @type {RulerMeasurementSegment[]}
     */
    segments: RulerMeasurementSegment[];
    /**
     * The computed total distance of the Ruler.
     * @type {number}
     */
    totalDistance: number;
    /**
     * Is the Ruler being actively used to measure distance?
     * @type {boolean}
     */
    get active(): boolean;
    /**
     * Get a GridHighlight layer for this Ruler
     * @type {GridHighlight}
     */
    get highlightLayer(): GridHighlight;
    /**
     * Clear display of the current Ruler
     */
    clear(): void;
    /**
     * Measure the distance between two points and render the ruler UI to illustrate it
     * @param {PIXI.Point} destination       The destination point to which to measure
     * @param {boolean} [gridSpaces=true]    Restrict measurement only to grid spaces
     * @param {boolean} [force=false]        Do the measure whatever is the destination point?
     * @returns {RulerMeasurementSegment[]} The array of measured segments
     */
    measure(destination: PIXI.Point, { gridSpaces, force }?: boolean): RulerMeasurementSegment[];
    /**
     * While measurement is in progress, update the destination to be the central point of the target grid space.
     * @param {Point} destination     The current pixel coordinates of the mouse movement
     * @returns {Point}               The destination point, a center of a grid space
     * @protected
     */
    protected _getMeasurementDestination(destination: Point): Point;
    /**
     * Translate the waypoints and destination point of the Ruler into an array of Ray segments.
     * @returns {RulerMeasurementSegment[]} The segments of the measured path
     * @protected
     */
    protected _getMeasurementSegments(): RulerMeasurementSegment[];
    /**
     * Compute the distance of each segment and the total distance of the measured path.
     * @param {boolean} gridSpaces    Base distance on the number of grid spaces moved?
     * @protected
     */
    protected _computeDistance(gridSpaces: boolean): void;
    /**
     * Get the text label for a segment of the measured path
     * @param {RulerMeasurementSegment} segment
     * @param {number} totalDistance
     * @returns {string}
     * @protected
     */
    protected _getSegmentLabel(segment: RulerMeasurementSegment, totalDistance: number): string;
    /**
     * Draw each segment of the measured path.
     * @protected
     */
    protected _drawMeasuredPath(): void;
    /**
     * Highlight the measurement required to complete the move in the minimum number of discrete spaces
     * @param {RulerMeasurementSegment} segment
     * @protected
     */
    protected _highlightMeasurementSegment(segment: RulerMeasurementSegment): void;
    /**
     * Determine whether a SPACE keypress event entails a legal token movement along a measured ruler
     * @returns {Promise<boolean>}  An indicator for whether a token was successfully moved or not. If True the
     *                              event should be prevented from propagating further, if False it should move on
     *                              to other handlers.
     */
    moveToken(): Promise<boolean>;
    /**
     * Acquire a Token, if any, which is eligible to perform a movement based on the starting point of the Ruler
     * @returns {Token}
     * @protected
     */
    protected _getMovementToken(): Function;
    /**
     * Test whether a Token is allowed to execute a measured movement path.
     * @param {Token} token       The Token being tested
     * @returns {boolean}         Whether the movement is allowed
     * @throws                    A specific Error message used instead of returning false
     * @protected
     */
    protected _canMove(token: Function): boolean;
    /**
     * Animate piecewise Token movement along the measured segment path.
     * @param {Token} token           The Token being animated
     * @returns {Promise<void>}       A Promise which resolves once all animation is completed
     * @protected
     */
    protected _animateMovement(token: Function): Promise<void>;
    /**
     * Update Token position and configure its animation properties for the next leg of its animation.
     * @param {Token} token                         The Token being updated
     * @param {RulerMeasurementSegment} segment     The measured segment being moved
     * @param {Point} destination                   The adjusted destination coordinate
     * @returns {Promise<unknown>}                  A Promise which resolves once the animation for this segment is done
     * @protected
     */
    protected _animateSegment(token: Function, segment: RulerMeasurementSegment, destination: Point): Promise<unknown>;
    /**
     * An method which can be extended by a subclass of Ruler to define custom behaviors before a confirmed movement.
     * @param {Token} token       The Token that will be moving
     * @returns {Promise<void>}
     * @protected
     */
    protected _preMove(token: Function): Promise<void>;
    /**
     * An event which can be extended by a subclass of Ruler to define custom behaviors before a confirmed movement.
     * @param {Token} token       The Token that finished moving
     * @returns {Promise<void>}
     * @protected
     */
    protected _postMove(token: Function): Promise<void>;
    /**
     * Handle the beginning of a new Ruler measurement workflow
     * @param {PIXI.FederatedEvent} event   The drag start event
     * @see {Canvas._onDragLeftStart}
     */
    _onDragStart(event: PIXI.FederatedEvent): void;
    /**
     * Handle left-click events on the Canvas during Ruler measurement.
     * @param {PIXI.FederatedEvent} event   The pointer-down event
     * @see {Canvas._onClickLeft}
     */
    _onClickLeft(event: PIXI.FederatedEvent): void;
    /**
     * Handle right-click events on the Canvas during Ruler measurement.
     * @param {PIXI.FederatedEvent} event   The pointer-down event
     * @see {Canvas._onClickRight}
     */
    _onClickRight(event: PIXI.FederatedEvent): false | void;
    /**
     * Continue a Ruler measurement workflow for left-mouse movements on the Canvas.
     * @param {PIXI.FederatedEvent} event   The mouse move event
     * @see {Canvas._onDragLeftMove}
     */
    _onMouseMove(event: PIXI.FederatedEvent): void;
    /**
     * Conclude a Ruler measurement workflow by releasing the left-mouse button.
     * @param {PIXI.FederatedEvent} event   The pointer-up event
     * @see {Canvas._onDragLeftDrop}
     */
    _onMouseUp(event: PIXI.FederatedEvent): void;
    /**
     * Handle the addition of a new waypoint in the Ruler measurement path
     * @param {PIXI.Point} point
     * @private
     */
    private _addWaypoint;
    /**
     * Handle the removal of a waypoint in the Ruler measurement path
     * @param {PIXI.Point} point      The current cursor position to snap to
     * @param {boolean} [snap]        Snap exactly to grid spaces?
     * @private
     */
    private _removeWaypoint;
    /**
     * Handle the conclusion of a Ruler measurement workflow
     * @private
     */
    private _endMeasurement;
    /**
     * @typedef {object} RulerData
     * @property {number} _state           The ruler measurement state.
     * @property {string} name             A unique name for the ruler containing the owning user's ID.
     * @property {PIXI.Point} destination  The current point the ruler has been extended to.
     * @property {string} class            The class name of this ruler instance.
     * @property {PIXI.Point[]} waypoints  Additional waypoints along the ruler's length, including the starting point.
     */
    /**
     * Package Ruler data to an object which can be serialized to a string.
     * @returns {RulerData}
     */
    toJSON(): {
        /**
         * The ruler measurement state.
         */
        _state: number;
        /**
         * A unique name for the ruler containing the owning user's ID.
         */
        name: string;
        /**
         * The current point the ruler has been extended to.
         */
        destination: PIXI.Point;
        /**
         * The class name of this ruler instance.
         */
        class: string;
        /**
         * Additional waypoints along the ruler's length, including the starting point.
         */
        waypoints: PIXI.Point[];
    };
    /**
     * Update a Ruler instance using data provided through the cursor activity socket
     * @param {Object} data   Ruler data with which to update the display
     */
    update(data: any): void;
}
/**
 * A layer of background alteration effects which change the appearance of the primary group render texture.
 * @category - Canvas
 */
declare class CanvasBackgroundAlterationEffects extends CanvasLayer {
    /**
     * A collection of effects which provide background vision alterations.
     * @type {PIXI.Container}
     */
    vision: PIXI.Container;
    /**
     * A collection of effects which provide background preferred vision alterations.
     * @type {PIXI.Container}
     */
    visionPreferred: PIXI.Container;
    /**
     * A collection of effects which provide other background alterations.
     * @type {PIXI.Container}
     */
    lighting: PIXI.Container;
    /**
     * Clear background alteration effects vision and lighting containers
     */
    clear(): void;
}
/**
 * A CanvasLayer for displaying coloration visual effects
 * @category - Canvas
 */
declare class CanvasColorationEffects extends CanvasLayer {
    sortableChildren: boolean;
    /**
     * The filter used to mask visual effects on this layer
     * @type {VisualEffectsMaskingFilter}
     */
    filter: VisualEffectsMaskingFilter;
    /**
     * Clear coloration effects container
     */
    clear(): void;
    filterArea: any;
    filters: VisualEffectsMaskingFilter[];
}
/**
 * A CanvasLayer for displaying illumination visual effects
 * @category - Canvas
 */
declare class CanvasIlluminationEffects extends CanvasLayer {
    /**
     * A minimalist texture that holds the background color.
     * @type {PIXI.Texture}
     */
    backgroundColorTexture: PIXI.Texture;
    background: any;
    lights: any;
    /**
     * Is global illumination currently applied to the canvas?
     * @type {boolean}
     */
    get globalLight(): boolean;
    /**
     * The filter used to mask visual effects on this layer
     * @type {VisualEffectsMaskingFilter}
     */
    filter: VisualEffectsMaskingFilter;
    /**
     * Set or retrieve the illumination background color.
     * @param {number} color
     */
    set backgroundColor(arg: number);
    /**
     * Clear illumination effects container
     */
    clear(): void;
    /**
     * Create the background color texture used by illumination point source meshes.
     * 1x1 single pixel texture.
     * @returns {PIXI.Texture}    The background color texture.
     * @protected
     */
    protected _createBackgroundColorTexture(): PIXI.Texture;
    /** @override */
    override render(renderer: any): void;
    darknessLevel: any;
    filterArea: any;
    filters: VisualEffectsMaskingFilter[];
    /**
     * Draw illumination baseline
     */
    drawBaseline(): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    updateGlobalLight(): boolean;
}
/**
 * The visibility Layer which implements dynamic vision, lighting, and fog of war
 * This layer uses an event-driven workflow to perform the minimal required calculation in response to changes.
 * @see {@link PointSource}
 * @category - Canvas
 *
 * @property {PIXI.Container} explored        The exploration container which tracks exploration progress
 * @property {CanvasVisionContainer} vision   The container of current vision exploration
 */
declare class CanvasVisibility extends CanvasLayer {
    /**
     * The maximum allowable visibility texture size.
     * @type {number}
     */
    static "__#145@#MAXIMUM_VISIBILITY_TEXTURE_SIZE": number;
    /**
     * Give the visibility requirement of the lighting background shader.
     * @param {VisionMode} visionMode             The single Vision Mode active at the moment (if any).
     * @returns {VisionMode.LIGHTING_VISIBILITY}
     */
    static "__#145@#requireBackgroundShader"(visionMode: VisionMode): {
        DISABLED: number;
        ENABLED: number;
        REQUIRED: number;
    };
    /**
     * The current vision container which provides line-of-sight for vision sources and field-of-view of light sources.
     * @type {PIXI.Container}
     */
    vision: PIXI.Container;
    /**
     * The canonical line-of-sight polygon which defines current Token visibility.
     * @type {PIXI.Graphics}
     */
    los: any;
    /**
     * The optional visibility overlay sprite that should be drawn instead of the unexplored color in the fog of war.
     * @type {PIXI.Sprite}
     */
    visibilityOverlay: PIXI.Sprite;
    /**
     * The active vision source data object
     * @type {{source: VisionSource|null, activeLightingOptions: object}}
     */
    visionModeData: {
        source: VisionSource | null;
        activeLightingOptions: object;
    };
    /**
     * Define whether each lighting layer is enabled, required, or disabled by this vision mode.
     * The value for each lighting channel is a number in LIGHTING_VISIBILITY
     * @type {{illumination: number, background: number, coloration: number, any: boolean}}
     */
    lightingVisibility: {
        illumination: number;
        background: number;
        coloration: number;
        any: boolean;
    };
    /**
     * A status flag for whether the layer initialization workflow has succeeded.
     * @type {boolean}
     */
    get initialized(): boolean;
    /**
     * Does the currently viewed Scene support Token field of vision?
     * @type {boolean}
     */
    get tokenVision(): boolean;
    /**
     * The configured options used for the saved fog-of-war texture.
     * @type {FogTextureConfiguration}
     */
    get textureConfiguration(): FogTextureConfiguration;
    /**
     * Initialize all Token vision sources which are present on this layer
     */
    initializeSources(): void;
    explored: any;
    filter: any;
    filters: any[];
    filterArea: any;
    visible: any;
    /**
     * Update the display of the sight layer.
     * Organize sources into rendering queues and draw lighting containers for each source
     */
    refresh(): void;
    /**
     * Update vision (and fog if necessary)
     */
    refreshVisibility(): void;
    /**
     * Reset the exploration container with the fog sprite
     */
    resetExploration(): void;
    /**
     * Restrict the visibility of certain canvas assets (like Tokens or DoorControls) based on the visibility polygon
     * These assets should only be displayed if they are visible given the current player's field of view
     */
    restrictVisibility(): void;
    /**
     * @typedef {Object} CanvasVisibilityTestConfig
     * @property {PlaceableObject} object           The target object
     * @property {CanvasVisibilityTest[]} tests     An array of visibility tests
     */
    /**
     * @typedef {Object} CanvasVisibilityTest
     * @property {PIXI.Point} point
     * @property {Map<VisionSource, boolean>} los
     */
    /**
     * Test whether a target point on the Canvas is visible based on the current vision and LOS polygons.
     * @param {Point} point                               The point in space to test, an object with coordinates x and y.
     * @param {object} [options]                          Additional options which modify visibility testing.
     * @param {number} [options.tolerance=2]              A numeric radial offset which allows for a non-exact match.
     *                                                    For example, if tolerance is 2 then the test will pass if the point
     *                                                    is within 2px of a vision polygon.
     * @param {PlaceableObject|object|null} [options.object] An optional reference to the object whose visibility is being tested
     * @returns {boolean}                                 Whether the point is currently visible.
     */
    testVisibility(point: Point, { tolerance, object }?: {
        tolerance?: number;
        object?: PlaceableObject | object | null;
    }): boolean;
    /**
     * @deprecated since v11
     * @ignore
     */
    get fogOverlay(): PIXI.Sprite;
    #private;
}
/**
 * A CanvasLayer for displaying visual effects like weather, transitions, flashes, or more.
 */
declare class WeatherEffects {
    /**
     * Sorting values to deal with ties.
     * @type {number}
     */
    static PRIMARY_SORT_ORDER: number;
    /** @inheritdoc */
    static get layerOptions(): any;
    /**
     * Set the occlusion uniforms for this weather shader.
     * @param {PIXI.Shader} context                       The shader context
     * @param {WeatherOcclusionMaskConfiguration} config  Occlusion masking options
     * @protected
     */
    protected static configureOcclusionMask(context: PIXI.Shader, { enabled, channelWeights, reverse, texture }?: {
        /**
         * Enable or disable this mask.
         */
        enabled: boolean;
        /**
         * An RGBA array of channel weights applied to the mask texture.
         */
        channelWeights: number[];
        /**
         * =false                    If the mask should be reversed.
         */
        reverse: boolean;
        /**
         * A texture which defines the mask region.
         */
        texture: PIXI.Texture | PIXI.RenderTexture;
    }): void;
    /**
     * Set the terrain uniforms for this weather shader.
     * @param {PIXI.Shader} context                     The shader context
     * @param {WeatherTerrainMaskConfiguration} config  Terrain masking options
     * @protected
     */
    protected static configureTerrainMask(context: PIXI.Shader, { enabled, channelWeights, reverse, texture }?: {
        /**
         * Enable or disable this mask.
         */
        enabled: boolean;
        /**
         * An RGBA array of channel weights applied to the mask texture.
         */
        channelWeights: number[];
        /**
         * =false                    If the mask should be reversed.
         */
        reverse: boolean;
        /**
         * A texture which defines the mask region.
         */
        texture: PIXI.Texture | PIXI.RenderTexture;
    }): void;
    mask: any;
    sortableChildren: boolean;
    eventMode: string;
    /**
     * The inverse occlusion mask filter bound to this container.
     * @type {WeatherOcclusionMaskFilter}
     */
    occlusionFilter: WeatherOcclusionMaskFilter;
    filterArea: any;
    filters: WeatherOcclusionMaskFilter[];
    /**
     * Array of weather effects linked to this weather container.
     * @type {Map<string,(ParticleEffect|WeatherShaderEffect)[]>}
     */
    effects: Map<string, (ParticleEffect | WeatherShaderEffect)[]>;
    /**
     * @typedef {Object} WeatherTerrainMaskConfiguration
     * @property {boolean} enabled                          Enable or disable this mask.
     * @property {number[]} channelWeights                  An RGBA array of channel weights applied to the mask texture.
     * @property {boolean} reverse=false                    If the mask should be reversed.
     * @property {PIXI.Texture|PIXI.RenderTexture} texture  A texture which defines the mask region.
     */
    /**
     * A default configuration of the terrain mask that is automatically applied to any shader-based weather effects.
     * This configuration is automatically passed to WeatherShaderEffect#configureTerrainMask upon construction.
     * @type {WeatherTerrainMaskConfiguration}
     */
    terrainMaskConfig: {
        /**
         * Enable or disable this mask.
         */
        enabled: boolean;
        /**
         * An RGBA array of channel weights applied to the mask texture.
         */
        channelWeights: number[];
        /**
         * =false                    If the mask should be reversed.
         */
        reverse: boolean;
        /**
         * A texture which defines the mask region.
         */
        texture: PIXI.Texture | PIXI.RenderTexture;
    };
    /**
     * @typedef {Object} WeatherOcclusionMaskConfiguration
     * @property {boolean} enabled                          Enable or disable this mask.
     * @property {number[]} channelWeights                  An RGBA array of channel weights applied to the mask texture.
     * @property {boolean} reverse=false                    If the mask should be reversed.
     * @property {PIXI.Texture|PIXI.RenderTexture} texture  A texture which defines the mask region.
     */
    /**
     * A default configuration of the terrain mask that is automatically applied to any shader-based weather effects.
     * This configuration is automatically passed to WeatherShaderEffect#configureTerrainMask upon construction.
     * @type {WeatherOcclusionMaskConfiguration}
     */
    occlusionMaskConfig: {
        /**
         * Enable or disable this mask.
         */
        enabled: boolean;
        /**
         * An RGBA array of channel weights applied to the mask texture.
         */
        channelWeights: number[];
        /**
         * =false                    If the mask should be reversed.
         */
        reverse: boolean;
        /**
         * A texture which defines the mask region.
         */
        texture: PIXI.Texture | PIXI.RenderTexture;
    };
    set elevation(arg: number);
    /**
     * Define an elevation property on the WeatherEffects layer.
     * This approach is used for now until the weather elevation property is formally added to the Scene data schema.
     * @type {number}
     */
    get elevation(): number;
    /** @override */
    override _draw(options: any): Promise<void>;
    /** @override */
    override _tearDown(options: any): Promise<void>;
    /**
     * Initialize the weather container from a weather config object.
     * @param {object} [weatherEffectsConfig]        Weather config object (or null/undefined to clear the container).
     */
    initializeEffects(weatherEffectsConfig?: object): void;
    /**
     * Clear the weather container.
     */
    clearEffects(): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    get weather(): this;
    #private;
}
/**
 * The base grid class.
 * This double-dips to implement the "gridless" option
 */
declare class BaseGrid {
    /**
     * Returns the class responsible for the implementation of a given grid type.
     * @param {number} gridType  The grid type. {@see CONST.GRID_TYPES}
     * @returns {Function}  (typeof BaseGrid) A constructor for a grid of the given type.
     */
    static implementationFor(gridType: number): Function;
    /**
     * Calculate the total size of the canvas with padding applied, as well as the top-left co-ordinates of the inner
     * rectangle that houses the scene.
     * @param {number} gridType           The grid type to calculate padding for. {@see CONST.GRID_TYPES}
     * @param {number} width              The width of the scene.
     * @param {number} height             The height of the scene.
     * @param {number} size               The grid size.
     * @param {number} padding            The percentage of padding.
     * @param {object} [options]          Options to configure the padding calculation.
     * @param {boolean} [options.legacy]  Are we computing padding for a legacy scene?
     * @returns {{width: number, height: number, x: number, y: number}}
     */
    static calculatePadding(gridType: number, width: number, height: number, size: number, padding: number, options?: {
        legacy?: boolean;
    }): {
        width: number;
        height: number;
        x: number;
        y: number;
    };
    constructor(options: any);
    options: any;
    /**
     * Grid Unit Width
     */
    w: any;
    /**
     * Grid Unit Height
     */
    h: any;
    /**
     * Draw the grid. Subclasses are expected to override this method to perform their type-specific drawing logic.
     * @param {object} [options]                  Override settings used in place of those saved to the scene data.
     * @param {string|null} [options.color=null]  The grid color.
     * @param {number|null} [options.alpha=null]  The grid transparency.
     * @returns {BaseGrid}
     */
    draw(options?: {
        color?: string | null;
        alpha?: number | null;
    }): BaseGrid;
    /**
     * Highlight a grid position for a certain coordinate
     * @param {GridHighlight} layer                The highlight layer to use
     * @param {object} [options]                   Additional options to configure behaviour.
     * @param {number} [options.x]                 The x-coordinate of the highlighted position
     * @param {number} [options.y]                 The y-coordinate of the highlighted position
     * @param {number} [options.color=0x33BBFF]    The hex fill color of the highlight
     * @param {number|null} [options.border=null]  The hex border color of the highlight
     * @param {number} [options.alpha=0.25]        The opacity of the highlight
     * @param {PIXI.Polygon} [options.shape=null]  A predefined shape to highlight
     */
    highlightGridPosition(layer: GridHighlight, { x, y, color, border, alpha, shape }?: {
        x?: number;
        y?: number;
        color?: number;
        border?: number | null;
        alpha?: number;
        shape?: PIXI.Polygon;
    }): void;
    /**
     * Tests whether the given co-ordinates at the center of a grid space are contained within a given shape.
     * @param {number} x            The X co-ordinate.
     * @param {number} y            The Y co-ordinate.
     * @param {PIXI.Polygon} shape  The shape.
     * @returns {boolean}
     * @private
     */
    private _testShape;
    /**
     * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
     * @return {number[]}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
     */
    getTopLeft(x: any, y: any): number[];
    /**
     * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
     * @param {number} x          The x-coordinate
     * @param {number} y          The y-coordinate
     * @return {number[]}         An array [cx, cy] of the central point of the grid space which contains (x, y)
     */
    getCenter(x: number, y: number): number[];
    /**
     * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
     * Under a "gridless" system, every pixel position is a valid snapping position
     *
     * @param {number} x                The exact target location x
     * @param {number} y                The exact target location y
     * @param {number|null} [interval]  An interval of grid spaces at which to snap.
     *                                  At interval=1, snapping occurs at pixel intervals defined by the grid size
     *                                  At interval=2, snapping would occur at the center-points of each grid size
     *                                  At interval=null, no snapping occurs
     * @param {object} [options]        Additional options to configure snapping behaviour.
     * @param {Token} [options.token]   The token that is being moved.
     * @returns {{x, y}}                An object containing the coordinates of the snapped location
     */
    getSnappedPosition(x: number, y: number, interval?: number | null, options?: {
        token?: Function;
    }): {
        x;
        y;
    };
    /**
     * Given a pair of pixel coordinates, return the grid position as an Array.
     * Always round down to the nearest grid position so the pixels are within the grid space (from top-left).
     * @param {number} x    The x-coordinate pixel position
     * @param {number} y    The y-coordinate pixel position
     * @returns {number[]}  An array representing the position in grid units
     */
    getGridPositionFromPixels(x: number, y: number): number[];
    /**
     * Given a pair of grid coordinates, return the pixel position as an Array.
     * Always round up to a whole pixel so the pixel is within the grid space (from top-left).
     * @param {number} x    The x-coordinate grid position
     * @param {number} y    The y-coordinate grid position
     * @returns {number[]}  An array representing the position in pixels
     */
    getPixelsFromGridPosition(x: number, y: number): number[];
    /**
     * Shift a pixel position [x,y] by some number of grid units dx and dy
     * @param {number} x               The starting x-coordinate in pixels
     * @param {number} y               The starting y-coordinate in pixels
     * @param {number} dx              The number of grid positions to shift horizontally
     * @param {number} dy              The number of grid positions to shift vertically
     * @param {object} [options]       Additional options to configure shift behaviour.
     * @param {Token} [options.token]  The token that is being shifted.
     */
    shiftPosition(x: number, y: number, dx: number, dy: number, options?: {
        token?: Function;
    }): number[];
    /**
     * Measure the distance traversed over an array of measured segments
     * @param {object[]} segments                An Array of measured movement segments
     * @param {MeasureDistancesOptions} options  Additional options which modify the measurement
     * @returns {number[]}                       An Array of distance measurements for each segment
     */
    measureDistances(segments: object[], options?: {
        /**
         * Return the distance in grid increments rather than the co-ordinate distance.
         */
        gridSpaces?: boolean;
    }): number[];
    /**
     * Get the grid row and column positions which are neighbors of a certain position
     * @param {number} row  The grid row coordinate against which to test for neighbors
     * @param {number} col  The grid column coordinate against which to test for neighbors
     * @returns {Array<[number, number]>} An array of grid positions which are neighbors of the row and column
     */
    getNeighbors(row: number, col: number): Array<[number, number]>;
    /**
     * Determine a placeable's bounding box based on the size of the grid.
     * @param {number} w  The width in grid spaces.
     * @param {number} h  The height in grid spaces.
     * @returns {PIXI.Rectangle}
     */
    getRect(w: number, h: number): PIXI.Rectangle;
    /**
     * Calculate the resulting token position after moving along a ruler segment.
     * @param {Ray} ray       The ray being moved along.
     * @param {Point} offset  The offset of the ruler's origin relative to the token's position.
     * @param {Token} token   The token placeable being moved.
     * @internal
     */
    _getRulerDestination(ray: Ray, offset: Point, token: Function): {
        x: number;
        y: number;
    };
}
/**
 * @typedef {Object} HexGridConfiguration
 * @property {boolean} columns    Columnar orientation?
 * @property {boolean} even       Offset even rows?
 * @property {number} size        Hex size in pixels
 * @property {number} [width]     Hex width in pixels
 * @property {number} [height]    Hex height in pixels
 * @property {boolean} [legacy]   Legacy hex grid computation (not recommended)
 */
/**
 * @typedef {Object} HexCubeCoordinate
 * @property {number} q     Coordinate along the SW - NE axis
 * @property {number} r     Coordinate along the S - N axis
 * @property {number} s     Coordinate along the NW - SE axis
 */
/**
 * @typedef {Object} HexOffsetCoordinate
 * @property {number} row   The row coordinate
 * @property {number} col   The column coordinate
 */
/**
 * A helper class which represents a single hexagon as part of a HexagonalGrid.
 * This class relies on having an active canvas scene in order to know the configuration of the hexagonal grid.
 */
declare class GridHex {
    /**
     * Construct a GridHex instance by providing a hex coordinate.
     * @param {HexOffsetCoordinate|HexCubeCoordinate} coordinate The coordinates of the hex to construct
     * @param {HexGridConfiguration} config       The grid configuration used for this hex
     */
    constructor(coordinate: HexOffsetCoordinate | HexCubeCoordinate, config: HexGridConfiguration);
    /**
     * The hexagonal grid type which this hex belongs to.
     * @type {HexGridConfiguration}
     */
    config: HexGridConfiguration;
    /**
     * The cube coordinates representation of this Hexagon
     * @type {HexCubeCoordinate}
     */
    cube: HexCubeCoordinate;
    /**
     * The offset coordinates representation of this Hexagon
     * @type {HexOffsetCoordinate}
     */
    offset: HexOffsetCoordinate;
    /**
     * Return a reference to the pixel point in the center of this hexagon.
     * @type {Point}
     */
    get center(): Point;
    /**
     * Return a reference to the pixel point of the top-left corner of this hexagon.
     * @type {Point}
     */
    get topLeft(): Point;
    /**
     * Return the array of hexagons which are neighbors of this one.
     * This result is un-bounded by the confines of the game canvas and may include hexes which are off-canvas.
     * @returns {GridHex[]}
     */
    getNeighbors(): GridHex[];
    /**
     * Get a neighboring hex by shifting along cube coordinates
     * @param {number} dq     A number of hexes to shift along the q axis
     * @param {number} dr     A number of hexes to shift along the r axis
     * @param {number} ds     A number of hexes to shift along the s axis
     * @returns {GridHex}     The shifted hex
     */
    shiftCube(dq: number, dr: number, ds: number): GridHex;
    /**
     * Return whether this GridHex equals the same position as some other GridHex instance.
     * @param {GridHex} other     Some other GridHex
     * @returns {boolean}         Are the positions equal?
     */
    equals(other: GridHex): boolean;
}
/**
 * Construct a hexagonal grid
 * @param {HexGridConfiguration} config       The hexagonal grid configuration
 * @extends {BaseGrid}
 */
declare class HexagonalGrid extends BaseGrid {
    /**
     * Compute the grid configuration from a provided type
     * @param {number} type     The grid type
     * @param {number} size     The grid size in pixels
     */
    static getConfig(type: number, size: number): {
        columns: boolean;
        even: boolean;
        size: number;
    };
    /**
     * Special border polygons for different token sizes.
     * @type {Object<PointArray[]>}
     */
    static POINTY_HEX_BORDERS: any;
    /**
     * Special border polygons for different token sizes.
     * @type {Object<PointArray[]>}
     */
    static FLAT_HEX_BORDERS: any;
    /**
     * A matrix of x and y offsets which is multiplied by the width/height vector to get pointy-top polygon coordinates
     * @type {Array<number[]>}
     */
    static get pointyHexPoints(): number[][];
    /**
     * A matrix of x and y offsets which is multiplied by the width/height vector to get flat-top polygon coordinates
     * @type {Array<number[]>}
     */
    static get flatHexPoints(): number[][];
    /** @inheritdoc */
    static calculatePadding(gridType: any, width: any, height: any, size: any, padding: any, { legacy }?: {
        legacy: any;
    }): {
        width: any;
        height: any;
        x: number;
        y: number;
    };
    /**
     * Convert an offset coordinate (row, col) into a cube coordinate (q, r, s).
     * See https://www.redblobgames.com/grids/hexagons/ for reference
     * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
     * @param {HexOffsetCoordinate} offset                  The offset coordinate
     * @param {{columns: boolean, even: boolean}} config    The hex grid configuration
     * @returns {HexCubeCoordinate}                         The cube coordinate
     */
    static offsetToCube({ row, col }?: HexOffsetCoordinate, { columns, even }?: {
        columns: boolean;
        even: boolean;
    }): HexCubeCoordinate;
    /**
     * Convert a cube coordinate (q, r, s) into an offset coordinate (row, col).
     * See https://www.redblobgames.com/grids/hexagons/ for reference
     * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
     * @param {HexCubeCoordinate} cube          The cube coordinate
     * @param {HexGridConfiguration} config     The hex grid configuration
     * @returns {HexOffsetCoordinate}           The offset coordinate
     */
    static cubeToOffset({ q, r, s }?: HexCubeCoordinate, { columns, even }?: HexGridConfiguration): HexOffsetCoordinate;
    /**
     * Given a cursor position (x, y), obtain the cube coordinate hex (q, r, s) of the hex which contains it
     * http://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html
     * @param {Point} point                     The pixel point
     * @param {HexGridConfiguration} config     The hex grid configuration
     * @returns {HexCubeCoordinate}             The cube coordinate
     */
    static pixelToCube({ x, y }: Point, config: HexGridConfiguration): HexCubeCoordinate;
    /**
     * Measure the distance in hexagons between two cube coordinates.
     * @param {HexCubeCoordinate} a         The first cube coordinate
     * @param {HexCubeCoordinate} b         The second cube coordinate
     * @returns {number}                    The distance between the two cube coordinates in hexagons
     */
    static cubeDistance(a: HexCubeCoordinate, b: HexCubeCoordinate): number;
    /**
     * Compute the top-left pixel coordinate of a hexagon from its offset coordinate.
     * @param {HexOffsetCoordinate} offset      The offset coordinate
     * @param {HexGridConfiguration} config     The hex grid configuration
     * @returns {Point}                         The coordinate in pixels
     */
    static offsetToPixels({ row, col }: HexOffsetCoordinate, { columns, even, size, width, height }: HexGridConfiguration): Point;
    /**
     * Compute the offset coordinate of a hexagon from a pixel coordinate contained within that hex.
     * @param {Point} point                     The pixel coordinate
     * @param {HexGridConfiguration} config     The hex grid configuration
     * @param {string} [method=floor]           Which Math rounding method to use
     * @returns {HexOffsetCoordinate}           The offset coordinate
     */
    static pixelsToOffset({ x, y }: Point, config: HexGridConfiguration, method?: string): HexOffsetCoordinate;
    /**
     * We set the 'size' of a hexagon (the distance from a hexagon's centre to a vertex) to be equal to the grid size
     * divided by √3. This makes the distance from top-to-bottom on a flat-topped hexagon, or left-to-right on a pointy-
     * topped hexagon equal to the grid size.
     * @param {HexGridConfiguration} config         The grid configuration
     * @returns {{width: number, height: number}}   The width and height of a single hexagon, in pixels.
     */
    static computeDimensions(config: HexGridConfiguration): {
        width: number;
        height: number;
    };
    /**
     * Is this hex grid column-based (flat-topped), or row-based (pointy-topped)?
     * @type {boolean}
     */
    columnar: boolean;
    /**
     * Is this hex grid even or odd?
     * @type {boolean}
     */
    even: boolean;
    w: number;
    h: number;
    /**
     * An array of the points which define a hexagon for this grid shape
     * @returns {PointArray[]}
     */
    get hexPoints(): PointArray[];
    /** @inheritdoc */
    draw(options?: {}): this;
    width: any;
    height: any;
    /**
     * A convenience method for getting all the polygon points relative to a top-left [x,y] coordinate pair
     * @param {number} x               The top-left x-coordinate
     * @param {number} y               The top-right y-coordinate
     * @param {number} [w]             An optional polygon width
     * @param {number} [h]             An optional polygon height
     * @param {PointArray[]} [points]  An optional list of polygon points.
     */
    getPolygon(x: number, y: number, w?: number, h?: number, points?: PointArray[]): number[];
    /**
     * Get a border polygon based on the width and height of a given token.
     * @param {number} w  The width of the token in hexes.
     * @param {number} h  The height of the token in hexes.
     * @param {number} p  The padding size in pixels.
     * @returns {number[]|null}
     */
    getBorderPolygon(w: number, h: number, p: number): number[] | null;
    /**
     * Draw the grid lines.
     * @param {object} [preview]                  Override settings used in place of those saved to the scene data.
     * @param {string|null} [preview.color=null]  The grid color.
     * @param {number|null} [preview.alpha=null]  The grid transparency.
     * @returns {Graphics}
     * @private
     */
    private _drawGrid;
    /**
     * Compute and draw row style hexagons.
     * @param {PIXI.Graphics} grid    Reference to the grid graphics.
     * @param {number} nrows          Number of rows.
     * @param {number} ncols          Number of columns.
     * @protected
     */
    protected _drawRows(grid: any, nrows: number, ncols: number): void;
    /**
     * Compute and draw column style hexagons.
     * @param {PIXI.Graphics} grid    Reference to the grid graphics.
     * @param {number} nrows          Number of rows.
     * @param {number} ncols          Number of columns.
     * @protected
     */
    protected _drawColumns(grid: any, nrows: number, ncols: number): void;
    /**
     * Draw a hexagon from polygon points.
     * @param {PIXI.Graphics} grid    Reference to the grid graphics.
     * @param {number[]} poly         Array of points to draw the hexagon.
     * @protected
     */
    protected _drawHexagon(grid: any, poly: number[]): void;
    /** @override */
    override getGridPositionFromPixels(x: any, y: any): number[];
    /** @override */
    override getPixelsFromGridPosition(row: any, col: any): any[];
    /** @override */
    override getCenter(x: any, y: any): number[];
    /** @override */
    override getSnappedPosition(x: any, y: any, interval?: number, { token }?: {
        token: any;
    }): {
        x: any;
        y: any;
    };
    _getClosestVertex(xc: any, yc: any, ox: any, oy: any): {
        x: number;
        y: number;
    };
    /** @override */
    override shiftPosition(x: any, y: any, dx: any, dy: any, { token }?: {
        token: any;
    }): any[];
    /** @inheritdoc */
    _getRulerDestination(ray: any, offset: any, token: any): {
        x: any;
        y: any;
    };
    /**
     * Implement special rules for snapping tokens of various sizes on a hex grid.
     * @param {number} x     The X co-ordinate of the hexagon's top-left bounding box.
     * @param {number} y     The Y co-ordinate of the hexagon's top-left bounding box.
     * @param {Token} token  The token.
     * @returns {[number, number]}
     * @protected
     */
    protected _adjustSnapForTokenSize(x: number, y: number, token: Function): [number, number];
    /**
     * Implement special rules for determining the grid position of tokens of various sizes on a hex grid.
     * @param {number} row          The row number.
     * @param {number} col          The column number.
     * @param {Token} token         The token.
     * @returns {[number, number]}  The adjusted row and column number.
     * @protected
     */
    protected _adjustPositionForTokenSize(row: number, col: number, token: Function): [number, number];
    /** @inheritdoc */
    getRect(w: any, h: any): PIXI.Rectangle;
    /** @override */
    override highlightGridPosition(layer: any, options?: {}): void;
    /** @override */
    override getNeighbors(row: any, col: any): number[][];
    /** @override */
    override measureDistances(segments: any, options?: {}): any;
    /**
     * Measure the distance in grid units between two pixel-based coordinates.
     * @param {Point} p0      The initial point
     * @param {Point} p1      The terminal point
     * @returns {number}      The measured distance in grid units
     */
    measureDistance(p0: Point, p1: Point): number;
    /**
     * Compute the shortest path between two hexagons using the A-star algorithm.
     * See https://www.redblobgames.com/pathfinding/a-star/introduction.html for reference
     * @param {GridHex} start     The starting hexagon
     * @param {GridHex} goal      The objective hexagon
     * @returns {{cost: number, path: GridHex[]}} The optimal path of hexagons to traverse
     */
    getAStarPath(start: GridHex, goal: GridHex): {
        cost: number;
        path: GridHex[];
    };
    /**
     * @see {@link HexagonalGrid.offsetToCube}
     * @deprecated since v11
     * @ignore
     */
    offsetToCube(offset: any): any;
    /**
     * @see {@link HexagonalGrid.cubeToOffset}
     * @deprecated since v11
     * @ignore
     */
    cubeToOffset(cube: any): HexOffsetCoordinate;
}
declare const GridHighlight_base: any;
/**
 * A special Graphics class which handles Grid layer highlighting
 * @extends {PIXI.Graphics}
 */
declare class GridHighlight extends GridHighlight_base {
    [x: string]: any;
    constructor(name: any, ...args: any[]);
    /**
     * Track the Grid Highlight name
     * @type {string}
     */
    name: string;
    /**
     * Track distinct positions which have already been highlighted
     * @type {Set}
     */
    positions: Set<any>;
    /**
     * Record a position that is highlighted and return whether or not it should be rendered
     * @param {number} x    The x-coordinate to highlight
     * @param {number} y    The y-coordinate to highlight
     * @return {boolean}    Whether or not to draw the highlight for this location
     */
    highlight(x: number, y: number): boolean;
    /** @inheritdoc */
    clear(): any;
    /** @inheritdoc */
    destroy(...args: any[]): any;
}
/**
 * A CanvasLayer responsible for drawing a square grid
 */
declare class GridLayer extends CanvasLayer {
    /** @inheritdoc */
    static get layerOptions(): any;
    /**
     * The Grid container
     * @type {BaseGrid}
     */
    grid: BaseGrid;
    /**
     * The Grid Highlight container
     * @type {PIXI.Container}
     */
    highlight: PIXI.Container;
    /**
     * Map named highlight layers
     * @type {Object<GridHighlight>}
     */
    highlightLayers: any;
    /**
     * Placeable Object borders which are drawn overtop of the Grid
     * @type {PIXI.Container}
     */
    borders: PIXI.Container;
    /**
     * The grid type rendered in this Scene
     * @type {number}
     */
    get type(): number;
    /**
     * A convenient reference to the pixel grid size used throughout this layer
     * @type {number}
     */
    get size(): number;
    /**
     * Get grid unit width
     */
    get w(): any;
    /**
     * Get grid unit height
     */
    get h(): any;
    /**
     * A boolean flag for whether the current grid is hexagonal
     * @type {boolean}
     */
    get isHex(): boolean;
    /**
     * Draw the grid
     * @param {Object} preview    Override settings used in place of those saved to the Scene data
     * @param {number|null} [preview.type]
     * @param {object|null} [preview.dimensions]
     * @param {number} preview.color
     * @param {number} preview.alpha
     * @param {number} preview.gridColor
     * @param {number} preview.gridAlpha
     */
    _draw({ type, dimensions, color, alpha, gridColor, gridAlpha }?: {
        type?: number | null;
        dimensions?: object | null;
        color: number;
        alpha: number;
        gridColor: number;
        gridAlpha: number;
    }): Promise<void>;
    filterArea: any;
    filters: any[];
    /**
     * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
     * @param {number} x          The exact target location x
     * @param {number} y          The exact target location y
     * @param {number} [interval=1]  An interval of grid spaces at which to snap, default is 1.
     *                               If the interval is zero, no snapping occurs.
     * @param {object} [options]  Additional options to configure snapping behaviour.
     * @param {Token} [options.token]  The token.
     */
    getSnappedPosition(x: number, y: number, interval?: number, options?: {
        token?: Function;
    }): {
        x: any;
        y: any;
    };
    /**
     * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
     * @param {number} x      Coordinate X.
     * @param {number} y      Coordinate Y.
     * @returns {number[]}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
     */
    getTopLeft(x: number, y: number): number[];
    /**
     * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
     * @param {number} x      Coordinate X.
     * @param {number} y      Coordinate Y.
     * @returns {number[]}    An Array [x, y] of the central point of the square which contains (x, y)
     */
    getCenter(x: number, y: number): number[];
    /**
     * @typedef {object} MeasureDistancesOptions
     * @property {boolean} [gridSpaces]  Return the distance in grid increments rather than the co-ordinate distance.
     */
    /**
     * Measure the distance between two point coordinates.
     * @param {{x: number, y: number}} origin    The origin point
     * @param {{x: number, y: number}} target    The target point
     * @param {MeasureDistancesOptions} options  Additional options which modify the measurement
     * @returns {number}                         The measured distance between these points
     *
     * @example Measure grid distance between two points
     * ```js
     * let distance = canvas.grid.measureDistance({x: 1000, y: 1000}, {x: 2000, y: 2000});
     * ```
     */
    measureDistance(origin: {
        x: number;
        y: number;
    }, target: {
        x: number;
        y: number;
    }, options?: {
        /**
         * Return the distance in grid increments rather than the co-ordinate distance.
         */
        gridSpaces?: boolean;
    }): number;
    /**
     * Measure the distance traveled over an array of distance segments.
     * @param {object[]} segments                An array of measured segments
     * @param {MeasureDistancesOptions} options  Additional options which modify the measurement
     */
    measureDistances(segments: object[], options?: {
        /**
         * Return the distance in grid increments rather than the co-ordinate distance.
         */
        gridSpaces?: boolean;
    }): number[];
    /**
     * Define a new Highlight graphic
     * @param {string} name     The name for the referenced highlight layer
     */
    addHighlightLayer(name: string): any;
    /**
     * Clear a specific Highlight graphic
     * @param {string} name     The name for the referenced highlight layer
     */
    clearHighlightLayer(name: string): void;
    /**
     * Destroy a specific Highlight graphic
     * @param {string} name     The name for the referenced highlight layer
     */
    destroyHighlightLayer(name: string): void;
    /**
     * Obtain the highlight layer graphic by name
     * @param {string} name     The name for the referenced highlight layer
     */
    getHighlightLayer(name: string): any;
    /**
     * Add highlighting for a specific grid position to a named highlight graphic
     * @param {string} name       The name for the referenced highlight layer
     * @param {object} options    Options for the grid position that should be highlighted
     */
    highlightPosition(name: string, options: object): boolean;
    /**
     * Test if a specific row and column position is a neighboring location to another row and column coordinate
     * @param {number} r0     The original row position
     * @param {number} c0     The original column position
     * @param {number} r1     The candidate row position
     * @param {number} c1     The candidate column position
     */
    isNeighbor(r0: number, c0: number, r1: number, c1: number): boolean;
}
/**
 * Construct a square grid container
 * @type {BaseGrid}
 */
declare class SquareGrid extends BaseGrid {
    /** @inheritdoc */
    draw(options?: {}): this;
    width: any;
    height: any;
    /** @override */
    override getCenter(x: any, y: any): number[];
    /** @override */
    override getGridPositionFromPixels(x: any, y: any): number[];
    /** @override */
    override getPixelsFromGridPosition(row: any, col: any): number[];
    /** @override */
    override getSnappedPosition(x: any, y: any, interval?: number, options?: {}): {
        x: number;
        y: number;
    };
    /** @inheritdoc */
    shiftPosition(x: any, y: any, dx: any, dy: any, options?: {}): any;
    _getNearestVertex(x: any, y: any): number[];
    /** @override */
    override highlightGridPosition(layer: any, options?: {}): void;
    /** @override */
    override measureDistances(segments: any, options?: {}): any;
    /** @override */
    override getNeighbors(row: any, col: any): any[][];
    #private;
}
/**
 * The depth mask which contains a mapping of elevation. Needed to know if we must render objects according to depth.
 * @category - Canvas
 */
declare class CanvasDepthMask extends CachedContainer {
    /** @override */
    static override textureConfiguration: {
        scaleMode: any;
        format: any;
    };
    constructor(...args: any[]);
    /**
     * Container in which roofs are rendered with depth data.
     * @type {PIXI.Container}
     */
    roofs: PIXI.Container;
    /**
     * Clear the depth mask.
     */
    clear(): void;
    #private;
}
/**
 * The occlusion mask which contains radial occlusion and vision occlusion from tokens.
 * @category - Canvas
 */
declare class CanvasOcclusionMask extends CachedContainer {
    /** @override */
    static override textureConfiguration: {
        scaleMode: any;
        format: any;
    };
    constructor(...args: any[]);
    /**
     * Graphics in which token radial and vision occlusion shapes are drawn.
     * @type {PIXI.LegacyGraphics}
     */
    tokens: any;
    /**
     * Clear the occlusion mask.
     */
    clear(): void;
    /**
     * Update the state of occlusion, rendering a new occlusion mask and updating the occluded flag on all Tiles.
     */
    updateOcclusion(): void;
    /**
     * Determine the set of objects which should be currently occluded by a Token.
     * @param {Token[]} tokens                   The set of currently controlled Token objects
     * @returns {Set<PrimaryCanvasObjectMixin>}  The PCO objects which should be currently occluded
     * @protected
     */
    protected _identifyOccludedObjects(tokens: Function[]): Set<typeof PrimaryCanvasObjectMixin>;
    /**
     * @deprecated since v11
     * @ignore
     */
    _identifyOccludedTiles(): Set<typeof PrimaryCanvasObjectMixin>;
    #private;
}
/**
 * @typedef {PIXI.Container} CanvasVisionContainer
 * @property {PIXI.Graphics} los      LOS polygons
 * @property {PIXI.Graphics} base     Base vision
 * @property {PIXI.Graphics} fov      FOV polygons
 * @property {PIXI.Graphics} mask     Alias of los
 * @property {boolean} _explored      Does this vision point represent an explored position?
 */
/**
 * The vision mask which contains the current line-of-sight texture.
 * @category - Canvas
 */
declare class CanvasVisionMask extends CachedContainer {
    /** @override */
    static override textureConfiguration: {
        scaleMode: any;
        format: any;
    };
    /**
     * The current vision Container.
     * @type {CanvasVisionContainer}
     */
    vision: PIXI.Container;
    /**
     * The BlurFilter which applies to the vision mask texture.
     * This filter applies a NORMAL blend mode to the container.
     * @type {AlphaBlurFilter}
     */
    blurFilter: AlphaBlurFilter;
    filterArea: any;
    draw(): Promise<void>;
    /**
     * Initialize the vision mask with the los and the fov graphics objects.
     * @param {PIXI.Container} vision         The vision container to attach
     * @returns {CanvasVisionContainer}
     */
    attachVision(vision: PIXI.Container): PIXI.Container;
    /**
     * Detach the vision mask from the cached container.
     * @returns {CanvasVisionContainer} The detached vision container.
     */
    detachVision(): PIXI.Container;
    /**
     * @deprecated since v11
     * @ignore
     */
    set filter(arg: AlphaBlurFilter);
    /**
     * @deprecated since v11
     * @ignore
     */
    get filter(): AlphaBlurFilter;
    #private;
}
/**
 * The DrawingsLayer subclass of PlaceablesLayer.
 * This layer implements a container for drawings.
 * @category - Canvas
 */
declare class DrawingsLayer extends PlaceablesLayer {
    /**
     * The named game setting which persists default drawing configuration for the User
     * @type {string}
     */
    static DEFAULT_CONFIG_SETTING: string;
    /** @inheritdoc */
    get hud(): any;
    /**
     * Render a configuration sheet to configure the default Drawing settings
     */
    configureDefault(): void;
    /**
     * Get initial data for a new drawing.
     * Start with some global defaults, apply user default config, then apply mandatory overrides per tool.
     * @param {Point} origin      The initial coordinate
     * @returns {object}          The new drawing data
     */
    _getNewDrawingData(origin: Point): object;
    /** @inheritdoc */
    _onClickLeft(event: any): any;
    /** @inheritdoc */
    _onClickLeft2(event: any): Promise<any>;
    /** @inheritdoc */
    _onDragLeftStart(event: any): Promise<any>;
    /**
     * Handling of mouse-up events which conclude a new object creation after dragging
     * @param {PIXI.FederatedEvent} event       The drag drop event
     * @private
     */
    private _onDragLeftDrop;
    /** @inheritdoc */
    _onDragLeftCancel(event: any): any;
    /** @inheritdoc */
    _onClickRight(event: any): boolean;
}
/**
 * The Lighting Layer which ambient light sources as part of the CanvasEffectsGroup.
 * @category - Canvas
 */
declare class LightingLayer extends PlaceablesLayer {
    /** @override */
    override _onDragLeftStart(event: any): Promise<any>;
    /** @override */
    override _onMouseWheel(event: any): Promise<PlaceableObject>;
    /**
     * Actions to take when the darkness level of the Scene is changed
     * @param {number} darkness   The new darkness level
     * @param {number} prior      The prior darkness level
     * @internal
     */
    _onDarknessChange(darkness: number, prior: number): void;
    /**
     * @deprecated since v10
     * @ignore
     */
    get background(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    get illumination(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    get channels(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    get coloration(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    get darknessLevel(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    get globalLight(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    get sources(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    get version(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    activateAnimation(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    deactivateAnimation(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    animateDarkness(...args: any[]): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    initializeSources(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    refresh(options: any): any;
}
/**
 * The Notes Layer which contains Note canvas objects.
 * @category - Canvas
 */
declare class NotesLayer extends PlaceablesLayer {
    /**
     * The named core setting which tracks the toggled visibility state of map notes
     * @type {string}
     */
    static TOGGLE_SETTING: string;
    /**
     * Register game settings used by the NotesLayer
     */
    static registerSettings(): void;
    /**
     * Visually indicate in the Scene Controls that there are visible map notes present in the Scene.
     */
    hintMapNotes(): void;
    /**
     * Pan to a given note on the layer.
     * @param {Note} note                      The note to pan to.
     * @param {object} [options]               Options which modify the pan operation.
     * @param {number} [options.scale=1.5]     The resulting zoom level.
     * @param {number} [options.duration=250]  The speed of the pan animation in milliseconds.
     * @returns {Promise<void>}                A Promise which resolves once the pan animation has concluded.
     */
    panToNote(note: Function, { scale, duration }?: {
        scale?: number;
        duration?: number;
    }): Promise<void>;
    /** @inheritdoc */
    _onClickLeft(event: any): Promise<any>;
    /**
     * Handle JournalEntry document drop data
     * @param {DragEvent} event   The drag drop event
     * @param {object} data       The dropped data transfer data
     * @protected
     */
    protected _onDropData(event: DragEvent, data: object): Promise<false | PlaceableObject>;
}
/**
 * This Canvas Layer provides a container for AmbientSound objects.
 * @category - Canvas
 */
declare class SoundsLayer extends PlaceablesLayer {
    /**
     * Track whether to actively preview ambient sounds with mouse cursor movements
     * @type {boolean}
     */
    livePreview: boolean;
    /**
     * A mapping of ambient audio sources which are active within the rendered Scene
     * @type {Collection<string,SoundSource>}
     */
    sources: Collection<string, SoundSource>;
    /**
     * Initialize all AmbientSound sources which are present on this layer
     */
    initializeSources(): void;
    /**
     * Update all AmbientSound effects in the layer by toggling their playback status.
     * Sync audio for the positions of tokens which are capable of hearing.
     * @param {object} [options={}]   Additional options forwarded to AmbientSound synchronization
     */
    refresh(options?: object): any;
    /**
     * Preview ambient audio for a given mouse cursor position
     * @param {Point} position      The cursor position to preview
     */
    previewSound(position: Point): void;
    /**
     * Terminate playback of all ambient audio sources
     */
    stopAll(): void;
    /**
     * Sync the playing state and volume of all AmbientSound objects based on the position of listener points
     * @param {Point[]} listeners     Locations of listeners which have the capability to hear
     * @param {object} [options={}]   Additional options forwarded to AmbientSound synchronization
     * @private
     */
    private _syncPositions;
    /**
     * Define the easing function used to map radial distance to volume.
     * Uses cosine easing which graduates from volume 1 at distance 0 to volume 0 at distance 1
     * @returns {number}            The target volume level
     * @private
     */
    private _getEasingVolume;
    /**
     * Actions to take when the darkness level of the Scene is changed
     * @param {number} darkness   The new darkness level
     * @param {number} prior      The prior darkness level
     * @internal
     */
    _onDarknessChange(darkness: number, prior: number): void;
    /**
     * Handle mouse cursor movements which may cause ambient audio previews to occur
     * @param {PIXI.FederatedEvent} event     The initiating mouse move interaction event
     */
    _onMouseMove(event: PIXI.FederatedEvent): void;
    /** @inheritdoc */
    _onDragLeftStart(event: any): Promise<any>;
    /** @inheritdoc */
    _onDragLeftDrop(event: any): Promise<void>;
    /**
     * Handle PlaylistSound document drop data.
     * @param {DragEvent} event  The drag drop event
     * @param {object} data      The dropped transfer data.
     */
    _onDropData(event: DragEvent, data: object): Promise<false | PlaceableObject>;
}
/**
 * This Canvas Layer provides a container for MeasuredTemplate objects.
 * @category - Canvas
 */
declare class TemplateLayer extends PlaceablesLayer {
    /**
     * Register game settings used by the TemplatesLayer
     */
    static registerSettings(): void;
    /** @inheritdoc */
    _onDragLeftStart(event: any): Promise<any>;
    /** @inheritdoc */
    _onMouseWheel(event: any): Promise<PlaceableObject>;
}
/**
 * A PlaceablesLayer designed for rendering the visual Scene for a specific vertical cross-section.
 * @category - Canvas
 */
declare class TilesLayer extends PlaceablesLayer {
    /** @inheritdoc */
    get hud(): any;
    /**
     * An array of Tile objects which are rendered within the objects container
     * @type {Tile[]}
     */
    get tiles(): Function[];
    /**
     * Get an array of overhead Tile objects which are roofs
     * @returns {Tile[]}
     */
    get roofs(): Function[];
    /**
     * Determine whether to display roofs
     * @type {boolean}
     */
    get displayRoofs(): boolean;
    /**
     * A convenience reference to the tile occlusion mask on the primary canvas group.
     * @type {CachedContainer}
     */
    get depthMask(): CachedContainer;
    /** @override */
    override controllableObjects(): Generator<any, void, unknown>;
    /**
     * Activate a sublayer of the tiles layer, which controls interactivity of placeables and release controlled objects.
     * @param {boolean} [foreground=false]  Which sublayer need to be activated? Foreground or background?
     * @internal
     */
    _activateSubLayer(foreground?: boolean): void;
    /** @inheritdoc */
    _onDragLeftDrop(event: any): void;
    /**
     * Handle drop events for Tile data on the Tiles Layer
     * @param {DragEvent} event     The concluding drag event
     * @param {object} data         The extracted Tile data
     * @private
     */
    private _onDropData;
    /**
     * Prepare the data object when a new Tile is dropped onto the canvas
     * @param {DragEvent} event     The concluding drag event
     * @param {object} data         The extracted Tile data
     * @returns {object}            The prepared data to create
     */
    _getDropData(event: DragEvent, data: object): object;
    /**
     * @deprecated since v11
     * @ignore
     */
    get textureDataMap(): Map<string, any>;
}
/**
 * The Tokens Container.
 * @category - Canvas
 */
declare class TokenLayer extends PlaceablesLayer {
    /**
     * The current index position in the tab cycle
     * @type {number|null}
     * @private
     */
    private _tabIndex;
    /**
     * Token objects on this layer utilize the TokenHUD
     */
    get hud(): any;
    /**
     * An Array of tokens which belong to actors which are owned
     * @type {Token[]}
     */
    get ownedTokens(): Function[];
    /**
     * Target all Token instances which fall within a coordinate rectangle.
     *
     * @param {object} rectangle                      The selection rectangle.
     * @param {number} rectangle.x                    The top-left x-coordinate of the selection rectangle
     * @param {number} rectangle.y                    The top-left y-coordinate of the selection rectangle
     * @param {number} rectangle.width                The width of the selection rectangle
     * @param {number} rectangle.height               The height of the selection rectangle
     * @param {object} [options]                      Additional options to configure targeting behaviour.
     * @param {boolean} [options.releaseOthers=true]  Whether or not to release other targeted tokens
     * @returns {number}                              The number of Token instances which were targeted.
     */
    targetObjects({ x, y, width, height }: {
        x: number;
        y: number;
        width: number;
        height: number;
    }, { releaseOthers }?: {
        releaseOthers?: boolean;
    }): number;
    /**
     * Cycle the controlled token by rotating through the list of Owned Tokens that are available within the Scene
     * Tokens are currently sorted in order of their TokenID
     *
     * @param {boolean} forwards  Which direction to cycle. A truthy value cycles forward, while a false value
     *                            cycles backwards.
     * @param {boolean} reset     Restart the cycle order back at the beginning?
     * @returns {Token|null}       The Token object which was cycled to, or null
     */
    cycleTokens(forwards: boolean, reset: boolean): Function;
    /**
     * Add or remove the set of currently controlled Tokens from the active combat encounter
     * @param {boolean} state         The desired combat state which determines if each Token is added (true) or
     *                                removed (false)
     * @param {Combat|null} combat    A Combat encounter from which to add or remove the Token
     * @param {Token|null} [token]    A specific Token which is the origin of the group toggle request
     * @return {Promise<Combatant[]>} The Combatants added or removed
     */
    toggleCombat(state?: boolean, combat?: Combat | null, { token }?: Function): Promise<Function[]>;
    /**
     * Get the tab cycle order for tokens by sorting observable tokens based on their distance from top-left.
     * @returns {Token[]}
     * @private
     */
    private _getCycleOrder;
    /**
     * Immediately conclude the animation of any/all tokens
     */
    concludeAnimation(): void;
    /**
     * Animate targeting arrows on targeted tokens.
     * @private
     */
    private _animateTargets;
    _t: number;
    /**
     * Provide an array of Tokens which are eligible subjects for overhead tile occlusion.
     * By default, only tokens which are currently controlled or owned by a player are included as subjects.
     * @protected
     */
    protected _getOccludableTokens(): any;
    /** @inheritdoc */
    storeHistory(type: any, data: any): void;
    /**
     * Handle dropping of Actor data onto the Scene canvas
     * @private
     */
    private _onDropActorData;
    /** @inheritDoc */
    _onClickLeft(event: any): any;
    /**
     * Reset canvas and tokens mouse manager.
     */
    onClickTokenTools(): void;
}
/**
 * The Walls canvas layer which provides a container for Wall objects within the rendered Scene.
 * @category - Canvas
 */
declare class WallsLayer extends PlaceablesLayer {
    /**
     * Given a point and the coordinates of a wall, determine which endpoint is closer to the point
     * @param {Point} point         The origin point of the new Wall placement
     * @param {Wall} wall           The existing Wall object being chained to
     * @returns {PointArray}        The [x,y] coordinates of the starting endpoint
     */
    static getClosestEndpoint(point: Point, wall: Wall): PointArray;
    /**
     * Synthetic Wall instances which represent the outer boundaries of the game canvas.
     * @type {Wall[]}
     */
    outerBounds: Wall[];
    /**
     * Synthetic Wall instances which represent the inner boundaries of the scene rectangle.
     * @type {Wall[]}
     */
    innerBounds: Wall[];
    /**
     * A graphics layer used to display chained Wall selection
     * @type {PIXI.Graphics}
     */
    chain: any;
    /**
     * Track whether we are currently within a chained placement workflow
     * @type {boolean}
     */
    _chain: boolean;
    /**
     * Track whether the layer is currently toggled to snap at exact grid precision
     * @type {boolean}
     */
    _forceSnap: boolean;
    /**
     * Track the most recently created or updated wall data for use with the clone tool
     * @type {Object|null}
     * @private
     */
    private _cloneType;
    /**
     * Reference the last interacted wall endpoint for the purposes of chaining
     * @type {{point: PointArray}}
     * @private
     */
    private last;
    /**
     * An Array of Wall instances in the current Scene which act as Doors.
     * @type {Wall[]}
     */
    get doors(): Wall[];
    /**
     * Perform initialization steps for the WallsLayer whenever the composition of walls in the Scene is changed.
     * Cache unique wall endpoints and identify interior walls using overhead roof tiles.
     */
    initialize(): void;
    /**
     * Initialization to identify all intersections between walls.
     * These intersections are cached and used later when computing point source polygons.
     */
    identifyWallIntersections(): void;
    /**
     * Identify walls which are treated as "interior" because they are contained fully within a roof tile.
     */
    identifyInteriorWalls(): void;
    /** @inheritdoc */
    pasteObjects(position: any, options: any): Promise<any>;
    /**
     * Pan the canvas view when the cursor position gets close to the edge of the frame
     * @param {MouseEvent} event    The originating mouse movement event
     * @param {number} x            The x-coordinate
     * @param {number} y            The y-coordinate
     * @private
     */
    private _panCanvasEdge;
    /**
     * Get the endpoint coordinates for a wall placement, snapping to grid at a specified precision
     * Require snap-to-grid until a redesign of the wall chaining system can occur.
     * @param {Object} point          The initial candidate point
     * @param {boolean} [snap=true]   Whether to snap to grid
     * @returns {number[]}             The endpoint coordinates [x,y]
     * @private
     */
    private _getWallEndpointCoordinates;
    /**
     * The Scene Controls tools provide several different types of prototypical Walls to choose from
     * This method helps to translate each tool into a default wall data configuration for that type
     * @param {string} tool     The active canvas tool
     * @private
     */
    private _getWallDataFromActiveTool;
    /** @inheritdoc */
    _onDragLeftStart(event: any): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    get boundaries(): Set<Wall>;
    /**
     * @deprecated since v11
     * @ignore
     */
    checkCollision(ray: any, options?: {}): any;
    /**
     * @deprecated since v11
     * @ignore
     */
    highlightControlledSegments(): void;
    #private;
}
/**
 * An abstract base class which defines a framework for effect sources which originate radially from a specific point.
 * This abstraction is used by the LightSource, VisionSource, SoundSource, and MovementSource subclasses.
 *
 * @example A standard PointSource lifecycle:
 * ```js
 * const source = new PointSource({object}); // Create the point source
 * source.initialize(data);                  // Configure the point source with new data
 * source.refresh();                         // Refresh the point source
 * source.destroy();                         // Destroy the point source
 * ```
 *
 * @param {object} [options]
 * @param {object} [options.object]    Some other object which is responsible for this source
 * @abstract
 */
declare class PointSource {
    /**
     * The type of source represented by this data structure.
     * Each subclass must implement this attribute.
     * @type {string}
     */
    static sourceType: string;
    constructor(options: any);
    /**
     * @typedef {Object} PointSourceData
     * @property {number} x                   The x-coordinate of the source location
     * @property {number} y                   The y-coordinate of the source location
     * @property {number} elevation           The elevation of the point source
     * @property {number|null} z              An index for sorting the source relative to others at the same elevation
     * @property {number} radius              The radius of the source
     * @property {number} externalRadius      A secondary radius used for limited angles
     * @property {number} rotation            The angle of rotation for this point source
     * @property {number} angle               The angle of emission for this point source
     * @property {boolean} walls              Whether or not the source is constrained by walls
     * @property {boolean} disabled           Whether or not the source is disabled
     */
    /**
     * Some other object which is responsible for this source.
     * @type {object|null}
     */
    object: object | null;
    /**
     * The data of this source.
     * @type {PointSourceData}
     */
    data: {
        /**
         * The x-coordinate of the source location
         */
        x: number;
        /**
         * The y-coordinate of the source location
         */
        y: number;
        /**
         * The elevation of the point source
         */
        elevation: number;
        /**
         * An index for sorting the source relative to others at the same elevation
         */
        z: number | null;
        /**
         * The radius of the source
         */
        radius: number;
        /**
         * A secondary radius used for limited angles
         */
        externalRadius: number;
        /**
         * The angle of rotation for this point source
         */
        rotation: number;
        /**
         * The angle of emission for this point source
         */
        angle: number;
        /**
         * Whether or not the source is constrained by walls
         */
        walls: boolean;
        /**
         * Whether or not the source is disabled
         */
        disabled: boolean;
    };
    /**
     * The polygonal shape of the point source, generated from its origin, radius, and other data.
     * @type {PointSourcePolygon|PIXI.Polygon}
     */
    shape: PointSourcePolygon | PIXI.Polygon;
    /**
     * A collection of boolean flags which control rendering and refresh behavior for the source.
     * @type {Object<string,boolean|number>}
     * @protected
     */
    protected _flags: {
        [x: string]: boolean | number;
    };
    /**
     * Returns the update ID associated with this point source.
     * The update ID is increased whenever the source is initialized.
     * @type {number}
     */
    get updateId(): number;
    /**
     * Is this point source currently active?
     * Returns false if the source is disabled, temporarily suppressed, or not initialized.
     * @type {boolean}
     */
    get active(): boolean;
    /**
     * Is this source currently disabled?
     * Returns false if the source hasn't been initialized yet.
     * @type {boolean}
     */
    get disabled(): boolean;
    /**
     * Has this point source been initialized?
     * @type {boolean}
     */
    get initialized(): boolean;
    /**
     * The x-coordinate of the point source origin.
     * @type {number}
     */
    get x(): number;
    /**
     * The y-coordinate of the point source origin.
     * @type {number}
     */
    get y(): number;
    /**
     * The elevation bound to this source.
     * @type {number}
     */
    get elevation(): number;
    /**
     * @deprecated since v11
     * @ignore
     */
    set radius(arg: number);
    /**
     * A convenience reference to the radius of the source.
     * @type {number}
     */
    get radius(): number;
    /**
     * Initialize and configure the PointSource using provided data.
     * @param {object} data         Provided data for configuration
     * @returns {PointSource}       The configured source
     */
    initialize(data?: object): PointSource;
    /**
     * Subclass specific data initialization steps.
     * This method is responsible for populating the instance data object.
     * @param {object} data         Provided data for configuration
     * @protected
     */
    protected _initialize(data: object): void;
    /**
     * Subclass specific configuration steps. Occurs after data initialization and shape computation.
     * @param {object} changes      The fields of data which changed during initialization
     * @protected
     */
    protected _configure(changes?: object): void;
    /**
     * Refresh the state and uniforms of the PointSource.
     */
    refresh(): void;
    /**
     * Test whether this source should be active under current conditions?
     * @returns {boolean}
     * @protected
     */
    protected _isActive(): boolean;
    /**
     * Subclass-specific refresh steps.
     * @protected
     * @abstract
     */
    protected _refresh(): void;
    /**
     * Steps that must be performed when the base source is destroyed.
     */
    destroy(): void;
    /**
     * Subclass specific destruction steps.
     * @protected
     * @abstract
     */
    protected _destroy(): void;
    /**
     * Configure the parameters of the polygon that is generated for this source.
     * @returns {PointSourcePolygonConfig}
     * @protected
     */
    protected _getPolygonConfiguration(): PointSourcePolygonConfig;
    /**
     * Create the polygon shape for this source using configured data.
     * @returns {PointSourcePolygon}
     * @protected
     */
    protected _createPolygon(): PointSourcePolygon;
    /**
     * @deprecated since v11
     * @ignore
     */
    get sourceType(): any;
    /**
     * @deprecated since v11
     * @ignore
     */
    set los(arg: PointSourcePolygon | PIXI.Polygon);
    /**
     * @deprecated since v11
     * @ignore
     */
    get los(): PointSourcePolygon | PIXI.Polygon;
    /**
     * @deprecated since v10
     * @ignore
     */
    refreshSource(): void;
    #private;
}
/**
 * @typedef {PointSourceData}             RenderedPointSourceData
 * @property {number|null} color          A color applied to the rendered effect
 * @property {number|null} seed           An integer seed to synchronize (or de-synchronize) animations
 * @property {boolean} preview            Is this source a temporary preview?
 */
/**
 * @typedef {Object} RenderedPointSourceAnimationConfig
 * @property {string} [label]                                   The human-readable (localized) label for the animation
 * @property {Function} [animation]                             The animation function that runs every frame
 * @property {AdaptiveIlluminationShader} [illuminationShader]  A custom illumination shader used by this animation
 * @property {AdaptiveColorationShader} [colorationShader]      A custom coloration shader used by this animation
 * @property {AdaptiveBackgroundShader} [backgroundShader]      A custom background shader used by this animation
 * @property {number} [seed]                                    The animation seed
 * @property {number} [time]                                    The animation time
 */
/**
 * An abstract class which extends the base PointSource to provide common functionality for rendering.
 * This class is extended by both the LightSource and VisionSource subclasses.
 */
declare class RenderedPointSource extends PointSource {
    /**
     * Keys of the data object which require shaders to be re-initialized.
     * @type {string[]}
     * @protected
     */
    protected static _initializeShaderKeys: string[];
    /**
     * Keys of the data object which require uniforms to be refreshed.
     * @type {string[]}
     * @protected
     */
    protected static _refreshUniformsKeys: string[];
    /**
     * The offset in pixels applied to create soft edges.
     * @type {number}
     */
    static EDGE_OFFSET: number;
    /**
     * Create a new shader using a provider shader class
     * @param {typeof AdaptiveLightingShader} cls   The shader class to create
     * @param {PointSourceMesh} container           The container which requires a new shader
     * @returns {AdaptiveLightingShader}            The shader instance used
     */
    static "__#153@#createShader"(cls: typeof AdaptiveLightingShader, container: PointSourceMesh): AdaptiveLightingShader;
    /**
     * The animation configuration applied to this source
     * @type {RenderedPointSourceAnimationConfig}
     */
    animation: RenderedPointSourceAnimationConfig;
    /**
     * @typedef {Object} RenderedPointSourceLayer
     * @property {boolean} active             Is this layer actively rendered?
     * @property {boolean} reset              Do uniforms need to be reset?
     * @property {boolean} suppressed         Is this layer temporarily suppressed?
     * @property {PointSourceMesh} mesh       The rendered mesh for this layer
     * @property {AdaptiveLightingShader} shader  The shader instance used for the layer
     */
    /**
     * Track the status of rendering layers
     * @type {{background: RenderedPointSourceLayer, coloration: RenderedPointSourceLayer, illumination: RenderedPointSourceLayer}}
     */
    layers: {
        background: {
            /**
             * Is this layer actively rendered?
             */
            active: boolean;
            /**
             * Do uniforms need to be reset?
             */
            reset: boolean;
            /**
             * Is this layer temporarily suppressed?
             */
            suppressed: boolean;
            /**
             * The rendered mesh for this layer
             */
            mesh: PointSourceMesh;
            /**
             * The shader instance used for the layer
             */
            shader: AdaptiveLightingShader;
        };
        coloration: {
            /**
             * Is this layer actively rendered?
             */
            active: boolean;
            /**
             * Do uniforms need to be reset?
             */
            reset: boolean;
            /**
             * Is this layer temporarily suppressed?
             */
            suppressed: boolean;
            /**
             * The rendered mesh for this layer
             */
            mesh: PointSourceMesh;
            /**
             * The shader instance used for the layer
             */
            shader: AdaptiveLightingShader;
        };
        illumination: {
            /**
             * Is this layer actively rendered?
             */
            active: boolean;
            /**
             * Do uniforms need to be reset?
             */
            reset: boolean;
            /**
             * Is this layer temporarily suppressed?
             */
            suppressed: boolean;
            /**
             * The rendered mesh for this layer
             */
            mesh: PointSourceMesh;
            /**
             * The shader instance used for the layer
             */
            shader: AdaptiveLightingShader;
        };
    };
    /**
     * The color of the source as a RGB vector.
     * @type {[number, number, number]|null}
     */
    colorRGB: [number, number, number] | null;
    /**
     * A convenience accessor to the background layer mesh.
     * @type {PointSourceMesh}
     */
    get background(): PointSourceMesh;
    /**
     * A convenience accessor to the coloration layer mesh.
     * @type {PointSourceMesh}
     */
    get coloration(): PointSourceMesh;
    /**
     * A convenience accessor to the illumination layer mesh.
     * @type {PointSourceMesh}
     */
    get illumination(): PointSourceMesh;
    /**
     * Is the rendered source animated?
     * @type {boolean}
     */
    get isAnimated(): boolean;
    /**
     * Has the rendered source at least one active layer?
     * @type {boolean}
     */
    get hasActiveLayer(): boolean;
    /**
     * Is this RenderedPointSource a temporary preview?
     * @returns {boolean}
     */
    get isPreview(): boolean;
    /** @override */
    override _initialize(data: any): void;
    /**
     * Decide whether to render soft edges with a blur.
     * @protected
     */
    protected _configureSoftEdges(): void;
    /**
     * Configure the derived color attributes and associated flag.
     * @param {number|null} color     The color to configure (usually a color coming for the rendered point source data)
     *                                or null if no color is configured for this rendered source.
     * @protected
     */
    protected _configureColorAttributes(color: number | null): void;
    /**
     * Configure which shaders are used for each rendered layer.
     * @returns {{
     *  background: AdaptiveLightingShader,
     *  coloration: AdaptiveLightingShader,
     *  illumination: AdaptiveLightingShader
     * }}
     * @private
     */
    private _configureShaders;
    /**
     * Specific configuration for a layer.
     * @param {object} layer
     * @param {string} layerId
     * @protected
     */
    protected _configureLayer(layer: object, layerId: string): void;
    /**
     * Initialize the blend mode and vertical sorting of this source relative to others in the container.
     * @protected
     */
    protected _initializeBlending(): void;
    /**
     * Render the containers used to represent this light source within the LightingLayer
     * @returns {{background: PIXI.Mesh, coloration: PIXI.Mesh, illumination: PIXI.Mesh}}
     */
    drawMeshes(): {
        background: PIXI.Mesh;
        coloration: PIXI.Mesh;
        illumination: PIXI.Mesh;
    };
    /**
     * Update shader uniforms used for the background layer.
     * @protected
     */
    protected _updateBackgroundUniforms(): void;
    /**
     * Update shader uniforms used for the coloration layer.
     * @protected
     */
    protected _updateColorationUniforms(): void;
    /**
     * Update shader uniforms used for the illumination layer.
     * @protected
     */
    protected _updateIlluminationUniforms(): void;
    /**
     * Animate the PointSource, if an animation is enabled and if it currently has rendered containers.
     * @param {number} dt         Delta time.
     */
    animate(dt: number): any;
    /**
     * Generic time-based animation used for Rendered Point Sources.
     * @param {number} dt           Delta time.
     * @param {object} [options]    Options which affect the time animation
     * @param {number} [options.speed=5]            The animation speed, from 1 to 10
     * @param {number} [options.intensity=5]        The animation intensity, from 1 to 10
     * @param {boolean} [options.reverse=false]     Reverse the animation direction
     */
    animateTime(dt: number, { speed, intensity, reverse }?: {
        speed?: number;
        intensity?: number;
        reverse?: boolean;
    }): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    set preview(arg: boolean);
    /**
     * @deprecated since v11
     * @ignore
     */
    get preview(): boolean;
    #private;
}
/**
 * @typedef {RenderedPointSourceData}     LightSourceData
 * @see {@link foundry.data.LightData}
 * @property {number} alpha               An opacity for the emitted light, if any
 * @property {object} animation           An animation configuration for the source
 * @property {number} bright              The allowed radius of bright vision or illumination
 * @property {number} coloration          The coloration technique applied in the shader
 * @property {number} contrast            The amount of contrast this light applies to the background texture
 * @property {number} dim                 The allowed radius of dim vision or illumination
 * @property {number} attenuation         Strength of the attenuation between bright, dim, and dark
 * @property {number} luminosity          The luminosity applied in the shader
 * @property {number} saturation          The amount of color saturation this light applies to the background texture
 * @property {number} shadows             The depth of shadows this light applies to the background texture
 * @property {boolean} vision             Whether or not this source provides a source of vision
 */
/**
 * A specialized subclass of the PointSource abstraction which is used to control the rendering of light sources.
 */
declare class LightSource extends RenderedPointSource {
    /**
     * The ratio of dim:bright as part of the source radius
     * @type {number}
     */
    ratio: number;
    /**
     * Is this darkness?
     * @type {boolean}
     */
    get isDarkness(): boolean;
    /** @inheritDoc */
    _getPolygonConfiguration(): PointSourcePolygonConfig & {
        useThreshold: boolean;
    };
    /**
     * Update shader uniforms shared by all shader types
     * @param {AdaptiveLightingShader} shader        The shader being updated
     * @protected
     */
    protected _updateCommonUniforms(shader: AdaptiveLightingShader): void;
    computedAttenuation: number;
    cachedAttenuation: any;
    /**
     * Map luminosity value to exposure value
     * luminosity[-1  , 0  [ => Darkness => map to exposure ]   0, 1]
     * luminosity[ 0  , 0.5[ => Light    => map to exposure [-0.5, 0[
     * luminosity[ 0.5, 1  ] => Light    => map to exposure [   0, 1]
     * @param {number} lum        The luminosity value
     * @returns {number}           The exposure value
     * @private
     */
    private _mapLuminosity;
    /**
     * An animation with flickering ratio and light intensity.
     * @param {number} dt                       Delta time
     * @param {object} [options={}]             Additional options which modify the flame animation
     * @param {number} [options.speed=5]        The animation speed, from 1 to 10
     * @param {number} [options.intensity=5]    The animation intensity, from 1 to 10
     * @param {boolean} [options.reverse=false] Reverse the animation direction
     */
    animateTorch(dt: number, { speed, intensity, reverse }?: {
        speed?: number;
        intensity?: number;
        reverse?: boolean;
    }): void;
    /**
     * An animation with flickering ratio and light intensity
     * @param {number} dt                                 Delta time
     * @param {object} [options={}]                       Additional options which modify the flame animation
     * @param {number} [options.speed=5]                  The animation speed, from 1 to 10
     * @param {number} [options.intensity=5]              The animation intensity, from 1 to 10
     * @param {number} [options.amplification=1]          Noise amplification (>1) or dampening (<1)
     * @param {boolean} [options.reverse=false]           Reverse the animation direction
     */
    animateFlickering(dt: number, { speed, intensity, reverse, amplification }?: {
        speed?: number;
        intensity?: number;
        amplification?: number;
        reverse?: boolean;
    }): void;
    _noise: SmoothNoise;
    /**
     * A basic "pulse" animation which expands and contracts.
     * @param {number} dt                           Delta time
     * @param {object} [options={}]                 Additional options which modify the pulse animation
     * @param {number} [options.speed=5]              The animation speed, from 1 to 10
     * @param {number} [options.intensity=5]          The animation intensity, from 1 to 10
     * @param {boolean} [options.reverse=false]       Reverse the animation direction
     */
    animatePulse(dt: number, { speed, intensity, reverse }?: {
        speed?: number;
        intensity?: number;
        reverse?: boolean;
    }): void;
    /**
     * Test whether this LightSource provides visibility to see a certain target object.
     * @param {object} config               The visibility test configuration
     * @param {CanvasVisibilityTest[]} config.tests  The sequence of tests to perform
     * @param {PlaceableObject} config.object        The target object being tested
     * @returns {boolean}                   Is the target object visible to this source?
     */
    testVisibility({ tests, object }?: {
        tests: {
            point: PIXI.Point;
            los: Map<VisionSource, boolean>;
        }[];
        object: PlaceableObject;
    }): boolean;
    /**
     * Can this LightSource theoretically detect a certain object based on its properties?
     * This check should not consider the relative positions of either object, only their state.
     * @param {PlaceableObject} target      The target object being tested
     * @returns {boolean}                   Can the target object theoretically be detected by this vision source?
     */
    _canDetectObject(target: PlaceableObject): boolean;
}
/**
 * A specialized subclass of the LightSource which is used to render global light source linked to the scene.
 */
declare class GlobalLightSource extends LightSource {
    /** @override */
    override _createPolygon(): any;
}
/**
 * A subclass of PointSource which is used when computing the polygonal area where movement is possible.
 */
declare class MovementSource extends PointSource {
}
/**
 * A specialized subclass of the PointSource abstraction which is used to control the rendering of sound sources.
 */
declare class SoundSource extends PointSource {
    /** @inheritDoc */
    _getPolygonConfiguration(): PointSourcePolygonConfig & {
        useThreshold: boolean;
    };
}
/**
 * @typedef {RenderedPointSourceData}     VisionSourceData
 * @property {number} contrast            The amount of contrast
 * @property {number} attenuation         Strength of the attenuation between bright, dim, and dark
 * @property {number} saturation          The amount of color saturation
 * @property {number} brightness          The vision brightness.
 * @property {string} visionMode          The vision mode.
 * @property {boolean} blinded            Is this vision source blinded?
 */
/**
 * A specialized subclass of the PointSource abstraction which is used to control the rendering of vision sources.
 * @property {VisionSourceData} data
 */
declare class VisionSource extends RenderedPointSource {
    /**
     * The vision mode linked to this VisionSource
     * @type {VisionMode|null}
     */
    visionMode: VisionMode | null;
    /**
     * The vision mode activation flag for handlers
     * @type {boolean}
     * @internal
     */
    _visionModeActivated: boolean;
    /**
     * The unconstrained LOS polygon.
     * @type {PointSourcePolygon}
     */
    los: PointSourcePolygon;
    /**
     * An alias for the shape of the vision source.
     * @type {PointSourcePolygon|PIXI.Polygon}
     */
    get fov(): PointSourcePolygon | PIXI.Polygon;
    /**
     * If this vision source background is rendered into the lighting container.
     * @type {boolean}
     */
    get preferred(): boolean;
    /** @override */
    override _configureLayer(layer: any, layerId: any): void;
    /**
     * Responsible for assigning the Vision Mode and handling exceptions based on vision special status.
     * @protected
     */
    protected _initializeVisionMode(): void;
    /** @override */
    override _getPolygonConfiguration(): PointSourcePolygonConfig & {
        radius: any;
        useThreshold: boolean;
    };
    /**
     * Create a restricted FOV polygon by limiting the radius of the unrestricted LOS polygon.
     * @returns {PointSourcePolygon}
     * @protected
     */
    protected _createRestrictedPolygon(): PointSourcePolygon;
    /** @override */
    override _configureShaders(): {
        background: any;
        coloration: any;
        illumination: any;
    };
    /**
     * Update shader uniforms shared by all shader types
     * @param {AdaptiveVisionShader} shader        The shader being updated
     * @private
     */
    private _updateCommonUniforms;
    /**
     * Update layer uniforms according to vision mode uniforms, if any.
     * @param {AdaptiveVisionShader} shader        The shader being updated.
     * @param {Array} vmUniforms                   The targeted layer.
     * @private
     */
    private _updateVisionModeUniforms;
}
/**
 * A batch renderer with a customizable data transfer function to packed geometries.
 * @extends PIXI.AbstractBatchRenderer
 */
declare class BatchRenderer {
    /**
     * Verify if a PIXI plugin exists. Check by name.
     * @param {string} name       The name of the pixi plugin to check.
     * @returns {boolean}         True if the plugin exists, false otherwise.
     */
    static hasPlugin(name: string): boolean;
    /**
     * The PackInterleavedGeometry function provided by the sampler.
     * @type {Function}
     * @protected
     */
    protected _packInterleavedGeometry: Function;
    /**
     * The preRender function provided by the sampler and that is called just before a flush.
     * @type {Function}
     * @protected
     */
    protected _preRenderBatch: Function;
    /**
     * Get the uniforms bound to this abstract batch renderer.
     * @returns {object|undefined}
     */
    get uniforms(): any;
    /**
     * The number of reserved texture units that the shader generator should not use (maximum 4).
     * @param {number} val
     * @protected
     */
    set reservedTextureUnits(arg: number);
    /**
     * Number of reserved texture units reserved by the batch shader that cannot be used by the batch renderer.
     * @returns {number}
     */
    get reservedTextureUnits(): number;
    /**
     * This override allows to allocate a given number of texture units reserved for a custom batched shader.
     * These reserved texture units won't be used to batch textures for PIXI.Sprite or SpriteMesh.
     * @override
     */
    override contextChange(): void;
    maxTextures: any;
    _shader: any;
    /** @override */
    override start(): void;
    /** @override */
    override packInterleavedGeometry(element: any, attributeBuffer: any, indexBuffer: any, aIndex: any, iIndex: any): void;
    #private;
}
/**
 * A batch shader generator that could handle extra uniforms during initialization.
 */
declare class BatchShaderGenerator {
    constructor(vertexSrc: any, fragTemplate: any, batchDefaultUniforms: any);
    /**
     * Extra uniforms that could be handled by a custom batch shader.
     * @type {Function|undefined}
     */
    _batchDefaultUniforms: Function | undefined;
    /** @override */
    override generateShader(maxTextures: any): any;
}
declare namespace BLEND_MODES {
    let MAX_COLOR: number[];
    let MIN_COLOR: number[];
    let MIN_ALL: number[];
}
/**
 * A mixin which decorates a PIXI.Filter or PIXI.Shader with common properties.
 * @category - Mixins
 * @param {typeof PIXI.Shader} ShaderClass   The parent ShaderClass class being mixed.
 * @returns {typeof BaseShaderMixin}         A Shader/Filter subclass mixed with BaseShaderMixin features.
 */
declare function BaseShaderMixin(ShaderClass: any): typeof BaseShaderMixin;
/**
 * A mixin wich decorates a shader or filter and construct a fragment shader according to a choosen channel.
 * @category - Mixins
 * @param {typeof PIXI.Shader|PIXI.Filter} ShaderClass The parent ShaderClass class being mixed.
 * @returns {typeof AdaptiveFragmentChannelMixin}      A Shader/Filter subclass mixed with AdaptiveFragmentChannelMixin.
 */
declare function AdaptiveFragmentChannelMixin(ShaderClass: typeof PIXI.Shader | PIXI.Filter): typeof AdaptiveFragmentChannelMixin;
/**
 * This class defines an interface which all shaders utilize
 * @extends {PIXI.Shader}
 * @property {object} uniforms      The current uniforms of the Shader
 * @interface
 */
declare class AbstractBaseShader {
    /**
     * The raw vertex shader used by this class.
     * A subclass of AbstractBaseShader must implement the vertexShader static field.
     * @type {string}
     */
    static vertexShader: string;
    /**
     * The raw fragment shader used by this class.
     * A subclass of AbstractBaseShader must implement the fragmentShader static field.
     * @type {string}
     */
    static fragmentShader: string;
    /**
     * The default uniform values for the shader.
     * A subclass of AbstractBaseShader must implement the defaultUniforms static field.
     * @type {object}
     */
    static defaultUniforms: object;
    /**
     * A factory method for creating the shader using its defined default values
     * @param {object} defaultUniforms
     * @returns {AbstractBaseShader}
     */
    static create(defaultUniforms: object): AbstractBaseShader;
    constructor(program: any, uniforms: any);
    /**
     * The initial default values of shader uniforms
     * @type {object}
     */
    _defaults: object;
    /**
     * Reset the shader uniforms back to their provided default values
     * @private
     */
    private reset;
}
/**
 * An abstract filter which provides a framework for reusable definition
 * @extends {PIXI.Filter}
 */
declare class AbstractBaseFilter {
    /**
     * The default uniforms used by the filter
     * @type {object}
     */
    static defaultUniforms: object;
    /**
     * The fragment shader which renders this filter.
     * @type {string}
     */
    static fragmentShader: string;
    /**
     * The vertex shader which renders this filter.
     * @type {string}
     */
    static vertexShader: string;
    /**
     * A factory method for creating the filter using its defined default values.
     * @param {object} [uniforms]     Initial uniform values which override filter defaults
     * @returns {AbstractBaseFilter}      The constructed AbstractFilter instance.
     */
    static create(uniforms?: object): AbstractBaseFilter;
    set resolution(arg: number);
    /**
     * Always target the resolution of the render texture or renderer
     * @type {number}
     */
    get resolution(): number;
    set multisample(arg: PIXI.MSAA_QUALITY);
    /**
     * Always target the MSAA level of the render texture or renderer
     * @type {PIXI.MSAA_QUALITY}
     */
    get multisample(): PIXI.MSAA_QUALITY;
}
/**
 * The base sampler shader exposes a simple sprite shader and all the framework to handle:
 * - Batched shaders and plugin subscription
 * - And pre-rendering method
 * All othe sampler shaders (batched or not) should extend BaseSamplerShader
 */
declare class BaseSamplerShader extends AbstractBaseShader {
    /**
     * The named batch sampler plugin that is used by this shader, or null if no batching is used.
     * @type {string}
     */
    static classPluginName: string;
    /**
     * Contrast adjustment
     * @type {string}
     */
    static CONTRAST: string;
    /**
     * Saturation adjustment
     * @type {string}
     */
    static SATURATION: string;
    /**
     * Exposure adjustment.
     * @type {string}
     */
    static EXPOSURE: string;
    /**
     * The adjustments made into fragment shaders.
     * @type {string}
     */
    static get ADJUSTMENTS(): string;
    /**
     * Batch default vertex
     * @type {string}
     */
    static batchVertexShader: string;
    /**
     * Batch default fragment
     * @type {string}
     */
    static batchFragmentShader: string;
    /** @inheritdoc */
    static defaultUniforms: {
        tintAlpha: number[];
        sampler: number;
    };
    /**
     * Batch geometry associated with this sampler.
     * @type {typeof PIXI.BatchGeometry}
     */
    static batchGeometry: any;
    /**
     * The size of a vertice with all its packed attributes.
     * @type {number}
     */
    static batchVertexSize: number;
    /**
     * Pack interleaved geometry custom function.
     * @type {Function|undefined}
     * @protected
     */
    protected static _packInterleavedGeometry: Function | undefined;
    /**
     * A prerender function happening just before the batch renderer is flushed.
     * @type {Function}
     * @protected
     */
    protected static _preRenderBatch(): void;
    /**
     * A function that returns default uniforms associated with the batched version of this sampler.
     * @abstract
     * @type {Function|undefined}
     */
    static batchDefaultUniforms: Function | undefined;
    /**
     * The number of reserved texture units for this shader that cannot be used by the batch renderer.
     * @type {number}
     */
    static reservedTextureUnits: number;
    /**
     * Initialize the batch geometry with custom properties.
     * @abstract
     */
    static initializeBatchGeometry(): void;
    /**
     * The batch renderer to use.
     * @type {typeof BatchRenderer}
     */
    static batchRendererClass: typeof BatchRenderer;
    /**
     * The batch generator to use.
     * @type {typeof BatchShaderGenerator}
     */
    static batchShaderGeneratorClass: typeof BatchShaderGenerator;
    /**
     * Create a batch plugin for this sampler class.
     * @returns {typeof BatchPlugin}            The batch plugin class linked to this sampler class.
     */
    static createPlugin(): any;
    /**
     * Register the plugin for this sampler.
     */
    static registerPlugin(): void;
    constructor(...args: any[]);
    /**
     * The plugin name associated for this instance.
     * @type {string}
     */
    pluginName: string;
    set enabled(arg: boolean);
    /**
     * Activate or deactivate this sampler. If set to false, the batch rendering is redirected to "batch".
     * Otherwise, the batch rendering is directed toward the instance pluginName (might be null)
     * @type {boolean}
     */
    get enabled(): boolean;
    /**
     * Perform operations which are required before binding the Shader to the Renderer.
     * @param {SpriteMesh} mesh      The mesh linked to this shader.
     * @internal
     */
    _preRender(mesh: SpriteMesh): void;
    #private;
}
/**
 * The base shader class for weather shaders.
 */
declare class AbstractWeatherShader extends AbstractBaseShader {
    /**
     * Compute the weather masking value.
     * @type {string}
     */
    static COMPUTE_MASK: string;
    /**
     * Compute the weather masking value.
     * @type {string}
     */
    static FRAGMENT_HEADER: string;
    /**
     * Common uniforms for all weather shaders.
     * @type {{
     *  useOcclusion: boolean,
     *  occlusionTexture: PIXI.Texture|null,
     *  reverseOcclusion: boolean,
     *  occlusionWeights: number[],
     *  useTerrain: boolean,
     *  terrainTexture: PIXI.Texture|null,
     *  reverseTerrain: boolean,
     *  terrainWeights: number[],
     *  alpha: number,
     *  tint: number[],
     *  screenDimensions: [number, number],
     *  effectDimensions: [number, number],
     *  depthElevation: number,
     *  time: number
     * }}
     */
    static commonUniforms: {
        useOcclusion: boolean;
        occlusionTexture: PIXI.Texture | null;
        reverseOcclusion: boolean;
        occlusionWeights: number[];
        useTerrain: boolean;
        terrainTexture: PIXI.Texture | null;
        reverseTerrain: boolean;
        terrainWeights: number[];
        alpha: number;
        tint: number[];
        screenDimensions: [number, number];
        effectDimensions: [number, number];
        depthElevation: number;
        time: number;
    };
    /** @override */
    static override create(initialUniforms: any): AbstractWeatherShader;
    /**
     * Create the shader program.
     * @returns {PIXI.Program}
     */
    static createProgram(): PIXI.Program;
    constructor(...args: any[]);
    /**
     * Update the scale of this effect with new values
     * @param {number|{x: number, y: number}} scale    The desired scale
     */
    set scale(arg: number | {
        x: number;
        y: number;
    });
    set scaleX(arg: any);
    set scaleY(arg: any);
    /**
     * The speed multiplier applied to animation.
     * 0 stops animation.
     * @type {number}
     */
    speed: number;
    /**
     * Perform operations which are required before binding the Shader to the Renderer.
     * @param {QuadMesh} mesh      The mesh linked to this shader.
     * @internal
     */
    _preRender(mesh: QuadMesh): void;
    #private;
}
/**
 * An interface for defining shader-based weather effects
 * @param {object} config   The config object to create the shader effect
 */
declare class WeatherShaderEffect extends QuadMesh {
    constructor(config: any, shaderClass: any);
    /**
     * Set shader parameters.
     * @param {object} [config={}]
     */
    configure(config?: object): void;
    /**
     * Begin animation
     */
    play(): void;
    visible: boolean;
    /**
     * Stop animation
     */
    stop(): void;
    /**
     * Initialize the weather effect.
     * @param {object} config        Config object.
     * @protected
     */
    protected _initialize(config: object): void;
}
/**
 * Fog shader effect.
 */
declare class FogShader extends AbstractWeatherShader {
    /** @inheritdoc */
    static defaultUniforms: {
        intensity: number;
        rotation: number;
        slope: number;
    };
    /**
     * Configure the number of octaves into the shaders.
     * @param {number} mode
     * @returns {string}
     */
    static OCTAVES(mode: number): string;
    /**
     * Configure the fog complexity according to mode (performance).
     * @param {number} mode
     * @returns {string}
     */
    static FOG(mode: number): string;
    /** @inheritdoc */
    static fragmentShader(mode: any): string;
}
/**
 * Rain shader effect.
 */
declare class RainShader extends AbstractWeatherShader {
    /** @inheritdoc */
    static defaultUniforms: {
        opacity: number;
        intensity: number;
        strength: number;
        rotation: number;
        resolution: number[];
    };
}
/**
 * Snow shader effect.
 */
declare class SnowShader extends AbstractWeatherShader {
    /** @inheritdoc */
    static defaultUniforms: {
        direction: number;
    };
}
/**
 * A PIXI.Rectangle where the width and height are always positive and the x and y are always the top-left
 * @extends {PIXI.Rectangle}
 */
declare class NormalizedRectangle extends PIXI.Rectangle {
    constructor(...args: any[]);
}
/**
 * A container group which contains visual effects rendered above the primary group.
 *
 * ### Hook Events
 * - {@link hookEvents.drawEffectsCanvasGroup}
 * - {@link hookEvents.createEffectsCanvasGroup}
 * - {@link hookEvents.lightingRefresh}
 *
 * @category - Canvas
 */
declare class EffectsCanvasGroup {
    /**
     * The current global light source.
     * @type {GlobalLightSource}
     */
    globalLightSource: GlobalLightSource;
    /**
     * Whether to currently animate light sources.
     * @type {boolean}
     */
    animateLightSources: boolean;
    /**
     * Whether to currently animate vision sources.
     * @type {boolean}
     */
    animateVisionSources: boolean;
    /**
     * A mapping of light sources which are active within the rendered Scene.
     * @type {Collection<string, LightSource>}
     */
    lightSources: Collection<string, LightSource>;
    /**
     * A Collection of vision sources which are currently active within the rendered Scene.
     * @type {Collection<string, VisionSource>}
     */
    visionSources: Collection<string, VisionSource>;
    /**
     * A set of vision mask filters used in visual effects group
     * @type {Set<VisualEffectsMaskingFilter>}
     */
    visualEffectsMaskingFilters: Set<VisualEffectsMaskingFilter>;
    /**
     * A layer of background alteration effects which change the appearance of the primary group render texture.
     * @type {CanvasBackgroundAlterationEffects}
     */
    background: CanvasBackgroundAlterationEffects;
    /**
     * A layer which adds illumination-based effects to the scene.
     * @type {CanvasIlluminationEffects}
     */
    illumination: CanvasIlluminationEffects;
    /**
     * A layer which adds color-based effects to the scene.
     * @type {CanvasColorationEffects}
     */
    coloration: CanvasColorationEffects;
    /**
     * A layer which controls the current visibility of the scene.
     * @type {CanvasVisibility}
     */
    visibility: CanvasVisibility;
    /**
     * Clear all effects containers and animated sources.
     */
    clearEffects(): void;
    /**
     * Draw the component layers of the canvas group.
     * @returns {Promise<void>}
     */
    draw(): Promise<void>;
    /**
     * Actions to take when the darkness level is changed
     * @param {number} darkness   The new darkness level
     * @param {number} prior      The prior darkness level
     * @internal
     */
    _onDarknessChange(darkness: number, prior: number): void;
    /**
     * Initialize LightSource objects for all AmbientLightDocument instances which exist within the active Scene.
     */
    initializeLightSources(): void;
    /**
     * Update the global light source which provides global illumination to the Scene.
     * @param {object} [options={}]         Options which modify how the source is updated
     * @param {boolean} [options.defer]     Defer updating perception to manually update it later
     */
    updateGlobalLightSource({ defer }?: {
        defer?: boolean;
    }): void;
    /**
     * Refresh the state and uniforms of all LightSource objects.
     */
    refreshLightSources(): void;
    /**
     * Refresh the state and uniforms of all VisionSource objects.
     */
    refreshVisionSources(): void;
    /**
     * Refresh the active display of lighting.
     */
    refreshLighting(): void;
    /**
     * Perform a deconstruction workflow for this canvas group when the canvas is retired.
     * @returns {Promise<void>}
     */
    tearDown(): Promise<void>;
    /**
     * Activate vision masking for visual effects
     * @param {boolean} [enabled=true]    Whether to enable or disable vision masking
     */
    toggleMaskingFilters(enabled?: boolean): void;
    /**
     * Activate post-processing effects for a certain effects channel.
     * @param {string} filterMode                     The filter mode to target.
     * @param {string[]} [postProcessingModes=[]]     The post-processing modes to apply to this filter.
     * @param {Object} [uniforms={}]                  The uniforms to update.
     */
    activatePostProcessingFilters(filterMode: string, postProcessingModes?: string[], uniforms?: any): void;
    /**
     * Reset post-processing modes on all Visual Effects masking filters.
     */
    resetPostProcessingFilters(): void;
    /**
     * Activate light source animation for AmbientLight objects within this layer
     */
    activateAnimation(): void;
    /**
     * Deactivate light source animation for AmbientLight objects within this layer
     */
    deactivateAnimation(): void;
    /**
     * Animate a smooth transition of the darkness overlay to a target value.
     * Only begin animating if another animation is not already in progress.
     * @param {number} target     The target darkness level between 0 and 1
     * @param {number} duration   The desired animation time in milliseconds. Default is 10 seconds
     * @returns {Promise}         A Promise which resolves once the animation is complete
     */
    animateDarkness(target?: number, { duration }?: number): Promise<any>;
    #private;
}
/**
 * A container group which contains the primary canvas group and the effects canvas group.
 *
 * @category - Canvas
 */
declare class EnvironmentCanvasGroup {
    /** @override */
    static override groupName: string;
    /** @override */
    static override tearDownChildren: boolean;
    /** @override */
    override draw(): Promise<void>;
    #private;
}
/**
 * A specialized canvas group for rendering hidden containers before all others (like masks).
 * @extends {PIXI.Container}
 */
declare class HiddenCanvasGroup {
    /** @override */
    static override groupName: string;
    eventMode: string;
    /**
     * The container which hold masks.
     * @type {PIXI.Container}
     */
    masks: PIXI.Container;
    /**
     * Add a mask to this group.
     * @param {string} name                           Name of the mask.
     * @param {PIXI.DisplayObject} displayObject      Display object to add.
     * @param {number|undefined} [position=undefined] Position of the mask.
     */
    addMask(name: string, displayObject: PIXI.DisplayObject, position?: number | undefined): void;
    /** @override */
    override draw(): Promise<void>;
    /** @override */
    override tearDown(): Promise<void>;
    #private;
}
/**
 * A container group which displays interface elements rendered above other canvas groups.
 * @extends {BaseCanvasMixin(PIXI.Container)}
 */
declare class InterfaceCanvasGroup {
    /** @override */
    static override groupName: string;
    /**
     * Draw the canvas group and all its component layers.
     * @returns {Promise<void>}
     */
    draw(): Promise<void>;
    /**
     * Display scrolling status text originating from this ObjectHUD container.
     * @param {Point} origin            An origin point where the text should first emerge
     * @param {string} content          The text content to display
     * @param {object} [options]        Options which customize the text animation
     * @param {number} [options.duration=2000]  The duration of the scrolling effect in milliseconds
     * @param {number} [options.distance]       The distance in pixels that the scrolling text should travel
     * @param {TEXT_ANCHOR_POINTS} [options.anchor]     The original anchor point where the text appears
     * @param {TEXT_ANCHOR_POINTS} [options.direction]  The direction in which the text scrolls
     * @param {number} [options.jitter=0]       An amount of randomization between [0, 1] applied to the initial position
     * @param {object} [options.textStyle={}]   Additional parameters of PIXI.TextStyle which are applied to the text
     * @returns {Promise<PreciseText|null>}   The created PreciseText object which is scrolling
     */
    createScrollingText(origin: Point, content: string, { duration, distance, jitter, anchor, direction, ...textStyle }?: {
        duration?: number;
        distance?: number;
        anchor?: TEXT_ANCHOR_POINTS;
        direction?: TEXT_ANCHOR_POINTS;
        jitter?: number;
        textStyle?: object;
    }): Promise<PreciseText | null>;
    /**
     * @deprecated since v11
     * @ignore
     */
    get reverseMaskfilter(): any;
    #private;
}
/**
 * A container group which is not bound to the stage world transform.
 *
 * @category - Canvas
 */
declare class OverlayCanvasGroup {
    /** @override */
    static override groupName: string;
    /** @override */
    static override tearDownChildren: boolean;
}
/**
 * The primary Canvas group which generally contains tangible physical objects which exist within the Scene.
 * This group is a {@link CachedContainer} which is rendered to the Scene as a {@link SpriteMesh}.
 * This allows the rendered result of the Primary Canvas Group to be affected by a {@link BaseSamplerShader}.
 * @extends {BaseCanvasMixin(CachedContainer)}
 * @category - Canvas
 */
declare class PrimaryCanvasGroup {
    /** @override */
    static override groupName: string;
    /**
     * Allow API users to override the default elevation of the background layer.
     * This is a temporary solution until more formal support for scene levels is added in a future release.
     * @type {number}
     */
    static BACKGROUND_ELEVATION: number;
    /**
     * The sorting function used to order objects inside the Primary Canvas Group.
     * Overrides the default sorting function defined for the PIXI.Container.
     * Sort TokenMesh above other objects except WeatherEffects, then DrawingShape, all else held equal.
     * @param {PrimaryCanvasObject|PIXI.DisplayObject} a     An object to display
     * @param {PrimaryCanvasObject|PIXI.DisplayObject} b     Some other object to display
     * @returns {number}
     * @private
     */
    private static _sortObjects;
    constructor(sprite: any);
    eventMode: string;
    tokensRenderTexture: any;
    /** @override */
    override clearColor: number[];
    /**
     * Track the set of HTMLVideoElements which are currently playing as part of this group.
     * @type {Set<SpriteMesh>}
     */
    videoMeshes: Set<SpriteMesh>;
    /**
     * The primary background image configured for the Scene, rendered as a SpriteMesh.
     * @type {SpriteMesh}
     */
    background: SpriteMesh;
    /**
     * The primary foreground image configured for the Scene, rendered as a SpriteMesh.
     * @type {SpriteMesh}
     */
    foreground: SpriteMesh;
    /**
     * A Quadtree which partitions and organizes primary canvas objects.
     * @type {CanvasQuadtree}
     */
    quadtree: CanvasQuadtree;
    /**
     * The collection of PrimaryDrawingContainer objects which are rendered in the Scene.
     * @type {Collection<string, PrimaryDrawingContainer>}
     */
    drawings: Collection<string, PrimaryDrawingContainer>;
    /**
     * The collection of SpriteMesh objects which are rendered in the Scene.
     * @type {Collection<string, TokenMesh>}
     */
    tokens: Collection<string, TokenMesh>;
    /**
     * The collection of SpriteMesh objects which are rendered in the Scene.
     * @type {Collection<string, TileMesh|TileSprite>}
     */
    tiles: Collection<string, TileMesh | TileSprite>;
    /**
     * Render all tokens in their own render texture.
     * @param {PIXI.Renderer} renderer    The renderer to use.
     * @private
     */
    private _renderTokens;
    /**
     * Return the base HTML image or video element which provides the background texture.
     * @type {HTMLImageElement|HTMLVideoElement}
     */
    get backgroundSource(): HTMLImageElement | HTMLVideoElement;
    /**
     * Return the base HTML image or video element which provides the foreground texture.
     * @type {HTMLImageElement|HTMLVideoElement}
     */
    get foregroundSource(): HTMLImageElement | HTMLVideoElement;
    /**
     * Refresh the primary mesh.
     */
    refreshPrimarySpriteMesh(): void;
    /**
     * Draw the canvas group and all its component layers.
     * @returns {Promise<void>}
     */
    draw(): Promise<void>;
    /**
     * Remove and destroy all children from the group.
     * Clear container references to rendered objects.
     * @returns {Promise<void>}
     */
    tearDown(): Promise<void>;
    /**
     * Draw the SpriteMesh for a specific Token object.
     * @param {Token} token     The Token being added
     * @returns {TokenMesh}     The added TokenMesh
     */
    addToken(token: Function): TokenMesh;
    /**
     * Remove a TokenMesh from the group.
     * @param {Token} token     The Token being removed
     */
    removeToken(token: Function): void;
    /**
     * Draw the SpriteMesh for a specific Token object.
     * @param {Tile} tile               The Tile being added
     * @returns {TileMesh|TileSprite}   The added TileMesh or TileSprite
     */
    addTile(tile: Function): TileMesh | TileSprite;
    /**
     * Remove a TokenMesh from the group.
     * @param {Tile} tile     The Tile being removed
     */
    removeTile(tile: Function): void;
    /**
     * Add a DrawingShape to the group.
     * @param {Drawing} drawing     The Drawing being added
     * @returns {DrawingShape}      The created DrawingShape instance
     */
    addDrawing(drawing: Function): DrawingShape;
    /**
     * Remove a DrawingShape from the group.
     * @param {Drawing} drawing     The Drawing being removed
     */
    removeDrawing(drawing: Function): void;
    /**
     * Map an elevation value to a depth value with the right precision.
     * @param {number} elevation      A current elevation (or zIndex) in distance units.
     * @returns {number}              The depth value for this elevation on the range [1/255, 1]
     */
    mapElevationToDepth(elevation: number): number;
    /**
     * Override the default PIXI.Container behavior for how objects in this container are sorted.
     * @override
     */
    override sortChildren(): void;
    sortDirty: boolean;
    /**
     * @deprecated since v11
     * @ignore
     */
    mapElevationAlpha(elevation: any): number;
    #private;
}
/**
 * A container group which contains the environment canvas group and the interface canvas group.
 *
 * @category - Canvas
 */
declare class RenderedCanvasGroup {
    /** @override */
    static override groupName: string;
    /** @override */
    static override tearDownChildren: boolean;
}
/**
 * @typedef {Map<number,PolygonVertex>} VertexMap
 */
/**
 * @typedef {Set<PolygonEdge>} EdgeSet
 */
/**
 * @typedef {Ray} PolygonRay
 * @property {CollisionResult} result
 */
/**
 * A PointSourcePolygon implementation that uses CCW (counter-clockwise) geometry orientation.
 * Sweep around the origin, accumulating collision points based on the set of active walls.
 * This algorithm was created with valuable contributions from https://github.com/caewok
 *
 * @extends PointSourcePolygon
 */
declare class ClockwiseSweepPolygon extends PointSourcePolygon {
    /**
     * @deprecated since v10
     * @ignore
     */
    static getRayCollisions(ray: any, config?: {}): boolean | PolygonVertex | PolygonVertex[];
    /**
     * A mapping of vertices which define potential collision points
     * @type {VertexMap}
     */
    vertices: VertexMap;
    /**
     * The set of edges which define potential boundaries of the polygon
     * @type {EdgeSet}
     */
    edges: EdgeSet;
    /**
     * A collection of rays which are fired at vertices
     * @type {PolygonRay[]}
     */
    rays: PolygonRay[];
    /** @inheritDoc */
    initialize(origin: any, config: any): void;
    /**
     * Translate walls and other obstacles into edges which limit visibility
     * @private
     */
    private _identifyEdges;
    /**
     * Consolidate all vertices from identified edges and register them as part of the vertex mapping.
     * @private
     */
    private _identifyVertices;
    /**
     * Add additional vertices for intersections between edges.
     * @param {Map<string,PolygonEdge>} wallEdgeMap    A mapping of wall IDs to PolygonEdge instances
     * @private
     */
    private _identifyIntersections;
    /**
     * Execute the sweep over wall vertices
     * @private
     */
    private _executeSweep;
    /**
     * Update active edges at a given vertex
     * Must delete first, in case the edge is in both sets.
     * @param {PolygonVertex} vertex   The current vertex
     * @param {EdgeSet} activeEdges    A set of currently active edges
     * @private
     */
    private _updateActiveEdges;
    /**
     * Determine the initial set of active edges as those which intersect with the initial ray
     * @returns {EdgeSet}             A set of initially active edges
     * @private
     */
    private _initializeActiveEdges;
    /**
     * Sort vertices clockwise from the initial ray (due west).
     * @returns {PolygonVertex[]}             The array of sorted vertices
     * @private
     */
    private _sortVertices;
    /**
     * Test whether a target vertex is behind some closer active edge.
     * If the vertex is to the left of the edge, is must be behind the edge relative to origin.
     * If the vertex is collinear with the edge, it should be considered "behind" and ignored.
     * We know edge.A is ccw to edge.B because of the logic in _identifyVertices.
     * @param {PolygonVertex} vertex      The target vertex
     * @param {EdgeSet} activeEdges       The set of active edges
     * @returns {{isBehind: boolean, wasLimited: boolean}} Is the target vertex behind some closer edge?
     * @private
     */
    private _isVertexBehindActiveEdges;
    /**
     * Determine the result for the sweep at a given vertex
     * @param {PolygonVertex} vertex      The target vertex
     * @param {EdgeSet} activeEdges       The set of active edges
     * @param {boolean} hasCollinear      Are there collinear vertices behind the target vertex?
     * @private
     */
    private _determineSweepResult;
    /**
     * Switch to a new active edge.
     * Moving from the origin, a collision that first blocks a side must be stored as a polygon point.
     * Subsequent collisions blocking that side are ignored. Once both sides are blocked, we are done.
     *
     * Collisions that limit a side will block if that side was previously limited.
     *
     * If neither side is blocked and the ray internally collides with a non-limited edge, n skip without adding polygon
     * endpoints. Sight is unaffected before this edge, and the internal collision can be ignored.
     * @private
     *
     * @param {CollisionResult} result    The pending collision result
     * @param {EdgeSet} activeEdges       The set of currently active edges
     */
    private _switchEdge;
    /**
     * Identify the collision points between an emitted Ray and a set of active edges.
     * @param {PolygonRay} ray            The candidate ray to test
     * @param {EdgeSet} internalEdges     The set of edges to check for collisions against the ray
     * @returns {PolygonVertex[]}         A sorted array of collision points
     * @private
     */
    private _getInternalEdgeCollisions;
    /** @override */
    override _testCollision(ray: any, mode: any): any;
    /**
     * Visualize the polygon, displaying its computed area, rays, and collision points
     * @param {Ray} ray
     * @param {PolygonVertex[]} collisions
     * @private
     */
    private _visualizeCollision;
    #private;
}
/**
 * A singleton class dedicated to manage the color spaces associated with the scene and the canvas.
 * @category - Canvas
 */
declare class CanvasColorManager {
    /**
     * Fallback colors.
     * @enum {Color}
     */
    static "__#163@#fallbackColors": {
        darknessColor: number;
        daylightColor: number;
        brightestColor: number;
        backgroundColor: number;
        fogUnexplored: number;
        fogExplored: number;
    };
    /**
     * Colors exposed by the manager.
     * @enum {Color}
     */
    colors: {
        darkness: any;
        halfdark: any;
        background: any;
        dim: any;
        bright: any;
        ambientBrightest: any;
        ambientDaylight: any;
        ambientDarkness: any;
        sceneBackground: any;
        fogExplored: any;
        fogUnexplored: any;
    };
    /**
     * Weights used by the manager to compute colors.
     * @enum {number}
     */
    weights: {
        dark: any;
        halfdark: any;
        dim: any;
        bright: any;
    };
    /**
     * Returns the darkness penalty for the actual scene configuration.
     * @returns {number}
     */
    get darknessPenalty(): number;
    /**
     * Get the darkness level of this scene.
     * @returns {number}
     */
    get darknessLevel(): number;
    /**
     * Initialize color space pertaining to a specific scene.
     * @param {object} [colors={}]
     * @param {Color|number|string} [colors.backgroundColor]     The background canvas color
     * @param {Color|number|string} [colors.brightestColor]      The brightest ambient color
     * @param {Color|number|string} [colors.darknessColor]       The color of darkness
     * @param {number} [colors.darknessLevel]                    A preview darkness level
     * @param {Color|number|string} [colors.daylightColor]       The ambient daylight color
     * @param {number} [colors.fogExploredColor]                 The color applied to explored areas
     * @param {number} [colors.fogUnexploredColor]               The color applied to unexplored areas
     */
    initialize({ backgroundColor, brightestColor, darknessColor, darknessLevel, daylightColor, fogExploredColor, fogUnexploredColor }?: {
        backgroundColor?: typeof import("../../common/utils/color.mjs").default | number | string;
        brightestColor?: typeof import("../../common/utils/color.mjs").default | number | string;
        darknessColor?: typeof import("../../common/utils/color.mjs").default | number | string;
        darknessLevel?: number;
        daylightColor?: typeof import("../../common/utils/color.mjs").default | number | string;
        fogExploredColor?: number;
        fogUnexploredColor?: number;
    }): void;
    #private;
}
declare const DetectionMode_base: typeof import("../../common/abstract/data.mjs").default;
/**
 * A Detection Mode which can be associated with any kind of sense/vision/perception.
 * A token could have multiple detection modes.
 */
declare class DetectionMode extends DetectionMode_base {
    /** @inheritDoc */
    static defineSchema(): {
        id: import("../../common/data/fields.mjs").StringField;
        label: import("../../common/data/fields.mjs").StringField;
        tokenConfig: import("../../common/data/fields.mjs").BooleanField;
        walls: import("../../common/data/fields.mjs").BooleanField;
        angle: import("../../common/data/fields.mjs").BooleanField;
        type: import("../../common/data/fields.mjs").NumberField;
    };
    /**
     * Get the detection filter pertaining to this mode.
     * @returns {PIXI.Filter|undefined}
     */
    static getDetectionFilter(): PIXI.Filter | undefined;
    /**
     * An optional filter to apply on the target when it is detected with this mode.
     * @type {PIXI.Filter|undefined}
     */
    static _detectionFilter: PIXI.Filter | undefined;
    /**
     * The type of the detection mode. If its sight based, sound based, etc.
     * It is related to wall's WALL_RESTRICTION_TYPES
     * @see CONST.WALL_RESTRICTION_TYPES
     * @enum {number}
     */
    static DETECTION_TYPES: {
        SIGHT: number;
        SOUND: number;
        MOVE: number;
        OTHER: number;
    };
    /**
     * The identifier of the basic sight detection mode.
     * @type {string}
     */
    static BASIC_MODE_ID: string;
    /**
     * Test visibility of a target object or array of points for a specific vision source.
     * @param {VisionSource} visionSource           The vision source being tested
     * @param {TokenDetectionMode} mode             The detection mode configuration
     * @param {CanvasVisibilityTestConfig} config   The visibility test configuration
     * @returns {boolean}                           Is the test target visible?
     */
    testVisibility(visionSource: VisionSource, mode: TokenDetectionMode, { object, tests }?: {
        /**
         * The target object
         */
        object: PlaceableObject;
        /**
         * An array of visibility tests
         */
        tests: {
            point: PIXI.Point;
            los: Map<VisionSource, boolean>;
        }[];
    }): boolean;
    /**
     * Can this VisionSource theoretically detect a certain object based on its properties?
     * This check should not consider the relative positions of either object, only their state.
     * @param {VisionSource} visionSource   The vision source being tested
     * @param {PlaceableObject} target      The target object being tested
     * @returns {boolean}                   Can the target object theoretically be detected by this vision source?
     * @protected
     */
    protected _canDetect(visionSource: VisionSource, target: PlaceableObject): boolean;
    /**
     * Evaluate a single test point to confirm whether it is visible.
     * Standard detection rules require that the test point be both within LOS and within range.
     * @param {VisionSource} visionSource           The vision source being tested
     * @param {TokenDetectionMode} mode             The detection mode configuration
     * @param {PlaceableObject} target              The target object being tested
     * @param {CanvasVisibilityTest} test           The test case being evaluated
     * @returns {boolean}
     * @protected
     */
    protected _testPoint(visionSource: VisionSource, mode: TokenDetectionMode, target: PlaceableObject, test: {
        point: PIXI.Point;
        los: Map<VisionSource, boolean>;
    }): boolean;
    /**
     * Test whether the line-of-sight requirement for detection is satisfied.
     * Always true if the detection mode bypasses walls, otherwise the test point must be contained by the LOS polygon.
     * The result of is cached for the vision source so that later checks for other detection modes do not repeat it.
     * @param {VisionSource} visionSource       The vision source being tested
     * @param {TokenDetectionMode} mode         The detection mode configuration
     * @param {PlaceableObject} target          The target object being tested
     * @param {CanvasVisibilityTest} test       The test case being evaluated
     * @returns {boolean}                       Is the LOS requirement satisfied for this test?
     * @protected
     */
    protected _testLOS(visionSource: VisionSource, mode: TokenDetectionMode, target: PlaceableObject, test: {
        point: PIXI.Point;
        los: Map<VisionSource, boolean>;
    }): boolean;
    /**
     * Test whether the target is within the vision angle.
     * @param {VisionSource} visionSource       The vision source being tested
     * @param {TokenDetectionMode} mode         The detection mode configuration
     * @param {PlaceableObject} target          The target object being tested
     * @param {CanvasVisibilityTest} test       The test case being evaluated
     * @returns {boolean}                       Is the point within the vision angle?
     * @protected
     */
    protected _testAngle(visionSource: VisionSource, mode: TokenDetectionMode, target: PlaceableObject, test: {
        point: PIXI.Point;
        los: Map<VisionSource, boolean>;
    }): boolean;
    /**
     * Verify that a target is in range of a source.
     * @param {VisionSource} visionSource           The vision source being tested
     * @param {TokenDetectionMode} mode             The detection mode configuration
     * @param {PlaceableObject} target              The target object being tested
     * @param {CanvasVisibilityTest} test           The test case being evaluated
     * @returns {boolean}                           Is the target within range?
     * @protected
     */
    protected _testRange(visionSource: VisionSource, mode: TokenDetectionMode, target: PlaceableObject, test: {
        point: PIXI.Point;
        los: Map<VisionSource, boolean>;
    }): boolean;
}
/**
 * A special detection mode which models standard human vision.
 * This mode is the default case which is tested first when evaluating visibility of objects.
 * It is also a special case, in that it is the only detection mode which considers the area of distant light sources.
 */
declare class DetectionModeBasicSight extends DetectionMode {
    /** @override */
    override _testPoint(visionSource: any, mode: any, target: any, test: any): boolean;
}
/**
 * Detection mode that see invisible creatures.
 * This detection mode allows the source to:
 * - See/Detect the invisible target as if visible.
 * - The "See" version needs sight and is affected by blindness
 */
declare class DetectionModeInvisibility extends DetectionMode {
    /** @override */
    override _canDetect(visionSource: any, target: any): boolean;
}
/**
 * Detection mode that see creatures in contact with the ground.
 */
declare class DetectionModeTremor extends DetectionMode {
    /** @override */
    override _canDetect(visionSource: any, target: any): boolean;
}
/**
 * Detection mode that see ALL creatures (no blockers).
 * If not constrained by walls, see everything within the range.
 */
declare class DetectionModeAll extends DetectionMode {
    /** @override */
    override _canDetect(visionSource: any, target: any): boolean;
}
/**
 * A fog of war management class which is the singleton canvas.fog instance.
 * @category - Canvas
 */
declare class FogManager {
    /**
     * Define the number of fog refresh needed before the fog texture is extracted and pushed to the server.
     * @type {number}
     */
    static COMMIT_THRESHOLD: number;
    /**
     * The FogExploration document which applies to this canvas view
     * @type {FogExploration|null}
     */
    exploration: FogExploration | null;
    /**
     * The exploration SpriteMesh which holds the fog exploration texture.
     * @type {SpriteMesh}
     */
    get sprite(): SpriteMesh;
    /**
     * The configured options used for the saved fog-of-war texture.
     * @type {FogTextureConfiguration}
     */
    get textureConfiguration(): FogTextureConfiguration;
    /**
     * Does the currently viewed Scene support Token field of vision?
     * @type {boolean}
     */
    get tokenVision(): boolean;
    /**
     * Does the currently viewed Scene support fog of war exploration?
     * @type {boolean}
     */
    get fogExploration(): boolean;
    /**
     * Initialize fog of war - resetting it when switching scenes or re-drawing the canvas
     * @returns {Promise<void>}
     */
    initialize(): Promise<void>;
    /**
     * Clear the fog and reinitialize properties (commit and save in non reset mode)
     * @returns {Promise<void>}
     */
    clear(): Promise<void>;
    /**
     * Once a new Fog of War location is explored, composite the explored container with the current staging sprite.
     * Once the number of refresh is > to the commit threshold, save the fog texture to the database.
     */
    commit(): void;
    /**
     * Load existing fog of war data from local storage and populate the initial exploration sprite
     * @returns {Promise<(PIXI.Texture|void)>}
     */
    load(): Promise<(PIXI.Texture | void)>;
    /**
     * Dispatch a request to reset the fog of war exploration status for all users within this Scene.
     * Once the server has deleted existing FogExploration documents, the _onReset handler will re-draw the canvas.
     */
    reset(): Promise<void>;
    /**
     * Request a fog of war save operation.
     * Note: if a save operation is pending, we're waiting for its conclusion.
     */
    save(): Promise<any>;
    /**
     * If fog of war data is reset from the server, deactivate the current fog and initialize the exploration.
     * @returns {Promise}
     * @internal
     */
    _handleReset(): Promise<any>;
    /**
     * @deprecated since v11
     * @ignore
     */
    get pending(): any;
    /**
     * @deprecated since v11
     * @ignore
     */
    get revealed(): any;
    /**
     * @deprecated since v11
     * @ignore
     */
    update(source: any, force?: boolean): boolean;
    /**
     * @deprecated since v11
     * @ignore
     */
    get resolution(): any;
    #private;
}
/**
 * A helper class which manages the refresh workflow for perception layers on the canvas.
 * This controls the logic which batches multiple requested updates to minimize the amount of work required.
 * A singleton instance is available as canvas#perception.
 * @see {Canvas#perception}
 */
declare class PerceptionManager {
    /**
     * @typedef {RenderFlags} PerceptionManagerFlags
     * @property {boolean} initializeLighting       Re-initialize the entire lighting configuration
     * @property {boolean} refreshLighting          Refresh the rendered appearance of lighting
     * @property {boolean} refreshLightSources      Update the configuration of light sources
     * @property {boolean} initializeVision         Re-initialize the entire vision configuration
     * @property {boolean} refreshVisionSources     Update the configuration of vision sources
     * @property {boolean} refreshVision            Refresh the rendered appearance of vision
     * @property {boolean} initializeSounds         Re-initialize the entire ambient sound configuration
     * @property {boolean} refreshSounds            Refresh the audio state of ambient sounds
     * @property {boolean} soundFadeDuration        Apply a fade duration to sound refresh workflow
     * @property {boolean} refreshTiles             Refresh the visual appearance of tiles
     * @property {boolean} refreshPrimary           Refresh the contents of the PrimaryCanvasGroup mesh
     */
    /** @override */
    static override RENDER_FLAGS: {
        initializeLighting: {
            propagate: string[];
        };
        refreshLighting: {
            propagate: string[];
        };
        refreshLightSources: {};
        refreshVisionSources: {};
        refreshPrimary: {};
        initializeVision: {
            propagate: string[];
        };
        refreshVision: {
            propagate: string[];
        };
        initializeSounds: {
            propagate: string[];
        };
        refreshSounds: {};
        refreshTiles: {
            propagate: string[];
        };
        soundFadeDuration: {};
        identifyInteriorWalls: {
            propagate: string[];
        };
        forceUpdateFog: {
            propagate: string[];
        };
    };
    /** @override */
    static override RENDER_FLAG_PRIORITY: string;
    /**
     * A shim mapping which supports backwards compatibility for old-style (V9 and before) perception manager flags.
     * @enum {string}
     */
    static COMPATIBILITY_MAPPING: {
        "lighting.initialize": string;
        "lighting.refresh": string;
        "sight.initialize": string;
        "sight.refresh": string;
        "sounds.initialize": string;
        "sounds.refresh": string;
        "sounds.fade": string;
        "foreground.refresh": string;
    };
    /**
     * @deprecated since v11
     * @ignore
     */
    static forceUpdateFog(): void;
    /**
     * @deprecated since v10
     * @ignore
     */
    static get DEFAULTS(): void;
    /** @override */
    override applyRenderFlags(): void;
    /**
     * Update perception manager flags which configure which behaviors occur on the next frame render.
     * @param {object} flags        Flag values (true) to assign where the keys belong to PerceptionManager.FLAGS
     * @param {boolean} [v2=true]   Opt-in to passing v2 flags, otherwise a backwards compatibility shim will be applied
     */
    update(flags: object, v2?: boolean): void;
    /**
     * A helper function to perform an immediate initialization plus incremental refresh.
     */
    initialize(): void;
    /**
     * A helper function to perform an incremental refresh only.
     */
    refresh(): void;
    /**
     * @deprecated since v10
     * @ignore
     */
    cancel(): any;
    /**
     * @deprecated since v10
     * @ignore
     */
    schedule(options?: {}): void;
}
declare const ShaderField_base: typeof import("../../common/data/fields.mjs").DataField;
/**
 * A special subclass of DataField used to reference an AbstractBaseShader definition.
 */
declare class ShaderField extends ShaderField_base {
    /** @override */
    override _cast(value: any): any;
}
declare const VisionMode_base: typeof import("../../common/abstract/data.mjs").default;
/**
 * A Vision Mode which can be selected for use by a Token.
 * The selected Vision Mode alters the appearance of various aspects of the canvas while that Token is the POV.
 */
declare class VisionMode extends VisionMode_base {
    /** @inheritDoc */
    static defineSchema(): {
        id: import("../../common/data/fields.mjs").StringField;
        label: import("../../common/data/fields.mjs").StringField;
        tokenConfig: import("../../common/data/fields.mjs").BooleanField;
        canvas: import("../../common/data/fields.mjs").SchemaField;
        lighting: import("../../common/data/fields.mjs").SchemaField;
        vision: import("../../common/data/fields.mjs").SchemaField;
    };
    /**
     * The lighting illumination levels which are supported.
     * @enum {number}
     */
    static LIGHTING_LEVELS: {
        DARKNESS: number;
        HALFDARK: number;
        UNLIT: number;
        DIM: number;
        BRIGHT: number;
        BRIGHTEST: number;
    };
    /**
     * Flags for how each lighting channel should be rendered for the currently active vision modes:
     * - Disabled: this lighting layer is not rendered, the shaders does not decide.
     * - Enabled: this lighting layer is rendered normally, and the shaders can choose if they should be rendered or not.
     * - Required: the lighting layer is rendered, the shaders does not decide.
     * @enum {number}
     */
    static LIGHTING_VISIBILITY: {
        DISABLED: number;
        ENABLED: number;
        REQUIRED: number;
    };
    /**
     * Construct a Vision Mode using provided configuration parameters and callback functions.
     * @param {object} data             Data which fulfills the model defined by the VisionMode schema.
     * @param {object} [options]        Additional options passed to the DataModel constructor.
     */
    constructor(data?: object, options?: object);
    /**
     * A flag for whether this vision source is animated
     * @type {boolean}
     */
    animated: boolean;
    /**
     * Special activation handling that could be implemented by VisionMode subclasses
     * @param {VisionSource} source   Activate this VisionMode for a specific source
     * @abstract
     */
    _activate(source: VisionSource): void;
    /**
     * Special deactivation handling that could be implemented by VisionMode subclasses
     * @param {VisionSource} source   Deactivate this VisionMode for a specific source
     * @abstract
     */
    _deactivate(source: VisionSource): void;
    /**
     * Special handling which is needed when this Vision Mode is activated for a VisionSource.
     * @param {VisionSource} source   Activate this VisionMode for a specific source
     */
    activate(source: VisionSource): void;
    /**
     * Special handling which is needed when this Vision Mode is deactivated for a VisionSource.
     * @param {VisionSource} source   Deactivate this VisionMode for a specific source
     */
    deactivate(source: VisionSource): void;
    /**
     * An animation function which runs every frame while this Vision Mode is active.
     * @param {number} dt         The deltaTime passed by the PIXI Ticker
     */
    animate(dt: number): any;
}
/**
 * An implementation of the Weiler Atherton algorithm for clipping polygons.
 * This currently only handles combinations that will not result in any holes.
 * Support may be added for holes in the future.
 *
 * This algorithm is faster than the Clipper library for this task because it relies on the unique properties of the
 * circle, ellipse, or convex simple clip object.
 * It is also more precise in that it uses the actual intersection points between the circle/ellipse and polygon,
 * instead of relying on the polygon approximation of the circle/ellipse to find the intersection points.
 *
 * For more explanation of the underlying algorithm, see:
 * https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton_clipping_algorithm
 * https://www.geeksforgeeks.org/weiler-atherton-polygon-clipping-algorithm
 * https://h-educate.in/weiler-atherton-polygon-clipping-algorithm/
 */
declare class WeilerAthertonClipper {
    /**
     * The supported clip types.
     * Values are equivalent to those in ClipperLib.ClipType.
     * @enum {number}
     */
    static CLIP_TYPES: Readonly<{
        INTERSECT: 0;
        UNION: 1;
    }>;
    /**
     * The supported intersection types.
     * @enum {number}
     */
    static INTERSECTION_TYPES: Readonly<{
        OUT_IN: -1;
        IN_OUT: 1;
        TANGENT: 0;
    }>;
    /**
     * Union a polygon and clipObject using the Weiler Atherton algorithm.
     * @param {PIXI.Polygon} polygon                    Polygon to clip
     * @param {PIXI.Rectangle|PIXI.Circle} clipObject   Object to clip against the polygon
     * @param {object} clipOpts                         Options passed to the clipping object
     *                                                  methods toPolygon and pointsBetween
     * @returns {PIXI.Polygon[]}
     */
    static union(polygon: PIXI.Polygon, clipObject: PIXI.Rectangle | PIXI.Circle, clipOpts?: object): PIXI.Polygon[];
    /**
     * Intersect a polygon and clipObject using the Weiler Atherton algorithm.
     * @param {PIXI.Polygon} polygon                    Polygon to clip
     * @param {PIXI.Rectangle|PIXI.Circle} clipObject   Object to clip against the polygon
     * @param {object} clipOpts                         Options passed to the clipping object
     *                                                  methods toPolygon and pointsBetween
     * @returns {PIXI.Polygon[]}
     */
    static intersect(polygon: PIXI.Polygon, clipObject: PIXI.Rectangle | PIXI.Circle, clipOpts?: object): PIXI.Polygon[];
    /**
     * Clip a given clipObject using the Weiler-Atherton algorithm.
     *
     * At the moment, this will return a single PIXI.Polygon in the array unless clipType is a union and the polygon
     * and clipObject do not overlap, in which case the [polygon, clipObject.toPolygon()] array will be returned.
     * If this algorithm is expanded in the future to handle holes, an array of polygons may be returned.
     *
     * @param {PIXI.Polygon} polygon                    Polygon to clip
     * @param {PIXI.Rectangle|PIXI.Circle} clipObject   Object to clip against the polygon
     * @param {object} [options]                        Options which configure how the union or intersection is computed
     * @param {WeilerAthertonClipper.CLIP_TYPES} [options.clipType]   One of CLIP_TYPES
     * @param {boolean} [options.canMutate]             If the WeilerAtherton constructor could mutate or not
     *                                                  the subject polygon points
     * @param {object} [options.clipOpts]               Options passed to the WeilerAthertonClipper constructor
     * @returns {PIXI.Polygon[]}                        Array of polygons and clipObjects
     */
    static combine(polygon: PIXI.Polygon, clipObject: PIXI.Rectangle | PIXI.Circle, { clipType, canMutate, ...clipOpts }?: {
        clipType?: Readonly<{
            INTERSECT: 0;
            UNION: 1;
        }>;
        canMutate?: boolean;
        clipOpts?: object;
    }): PIXI.Polygon[];
    /**
     * Test if one shape envelops the other. Assumes the shapes do not intersect.
     *  1. Polygon is contained within the clip object. Union: clip object; Intersect: polygon
     *  2. Clip object is contained with polygon. Union: polygon; Intersect: clip object
     *  3. Polygon and clip object are outside one another. Union: both; Intersect: null
     * @param {PIXI.Polygon} polygon                    Polygon to clip
     * @param {PIXI.Rectangle|PIXI.Circle} clipObject   Object to clip against the polygon
     * @param {WeilerAthertonClipper.CLIP_TYPES} clipType One of CLIP_TYPES
     * @param {object} clipOpts                         Clip options which are forwarded to toPolygon methods
     * @returns {PIXI.Polygon[]}  Returns the polygon, the clipObject.toPolygon(), both, or neither.
     */
    static testForEnvelopment(polygon: PIXI.Polygon, clipObject: PIXI.Rectangle | PIXI.Circle, clipType: Readonly<{
        INTERSECT: 0;
        UNION: 1;
    }>, clipOpts: object): PIXI.Polygon[];
    /**
     * Given an array of labeled points, consolidate into a tracking array of intersections,
     * where each intersection contains its array of leadingPoints.
     * @param {Point[]} labeledPoints   Array of points, from _buildLabeledIntersectionsArray
     * @returns {Point[]} Array of intersections
     */
    static "__#165@#consolidatePoints"(labeledPoints: Point[]): Point[];
    /**
     * Construct a WeilerAthertonClipper instance used to perform the calculation.
     * @param {PIXI.Polygon} polygon    Polygon to clip
     * @param {PIXI.Rectangle|PIXI.Circle} clipObject  Object used to clip the polygon
     * @param {number} clipType         Type of clip to use
     * @param {object} clipOpts         Object passed to the clippingObject methods toPolygon and pointsBetween
     */
    constructor(polygon: PIXI.Polygon, clipObject: PIXI.Rectangle | PIXI.Circle, clipType: number, clipOpts: object);
    /** @type {PIXI.Polygon} */
    polygon: PIXI.Polygon;
    /** @type {PIXI.Rectangle|PIXI.Circle} */
    clipObject: PIXI.Rectangle | PIXI.Circle;
    /**
     * Configuration settings
     * @type {object} [config]
     * @param {WeilerAthertonClipper.CLIP_TYPES} [config.clipType]     One of CLIP_TYPES
     * @param {object} [config.clipOpts]      Object passed to the clippingObject methods
     *                                        toPolygon and pointsBetween
     */
    config: object;
    #private;
}
/**
 * The Drawing object is an implementation of the PlaceableObject container.
 * Each Drawing is a placeable object in the DrawingsLayer.
 *
 * @category - Canvas
 * @property {DrawingsLayer} layer                Each Drawing object belongs to the DrawingsLayer
 * @property {DrawingDocument} document           Each Drawing object provides an interface for a DrawingDocument
 */
declare class Drawing extends PlaceableObject {
    /** @override */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshState: {
            propagate: string[];
        };
        refreshShape: {
            propagate: string[];
        };
        refreshFrame: {};
        refreshText: {};
        refreshMesh: {};
    };
    /**
     * The rate at which points are sampled (in milliseconds) during a freehand drawing workflow
     * @type {number}
     */
    static FREEHAND_SAMPLE_RATE: number;
    /**
     * A convenience reference to the possible shape types.
     * @enum {string}
     */
    static SHAPE_TYPES: {
        RECTANGLE: string;
        CIRCLE: string;
        ELLIPSE: string;
        POLYGON: string;
    };
    /**
     * Get a vectorized rescaling transformation for drawing data and dimensions passed in parameter
     * @param {Object} original     The original drawing data
     * @param {number} dx           The pixel distance dragged in the horizontal direction
     * @param {number} dy           The pixel distance dragged in the vertical direction
     * @returns {object}            The adjusted shape data
     */
    static rescaleDimensions(original: any, dx: number, dy: number): object;
    /**
     * Adjust the location, dimensions, and points of the Drawing before committing the change.
     * @param {object} data   The DrawingData pending update
     * @returns {object}      The adjusted data
     */
    static normalizeShape(data: object): object;
    /**
     * The border frame and resizing handles for the drawing.
     * @type {PIXI.Container}
     */
    frame: PIXI.Container;
    /**
     * A text label that may be displayed as part of the interface layer for the Drawing.
     * @type {PreciseText|null}
     */
    text: PreciseText | null;
    /**
     * The drawing shape which is rendered as a PIXI.Graphics subclass in the PrimaryCanvasGroup.
     * @type {DrawingShape}
     */
    shape: DrawingShape;
    /** @override */
    override get bounds(): PIXI.Rectangle;
    /**
     * A Boolean flag for whether the Drawing utilizes a tiled texture background?
     * @type {boolean}
     */
    get isTiled(): boolean;
    /**
     * A Boolean flag for whether the Drawing is a Polygon type (either linear or freehand)?
     * @type {boolean}
     */
    get isPolygon(): boolean;
    /**
     * Does the Drawing have text that is displayed?
     * @type {boolean}
     */
    get hasText(): boolean;
    /**
     * The shape type that this Drawing represents. A value in Drawing.SHAPE_TYPES.
     * @see {@link Drawing.SHAPE_TYPES}
     * @type {string}
     */
    get type(): string;
    _pendingText: any;
    /** @override */
    override _draw(options: any): Promise<void>;
    texture: any;
    cursor: string;
    /**
     * Prepare the text style used to instantiate a PIXI.Text or PreciseText instance for this Drawing document.
     * @returns {PIXI.TextStyle}
     * @protected
     */
    protected _getTextStyle(): PIXI.TextStyle;
    /** @override */
    override _applyRenderFlags(flags: any): void;
    hitArea: any;
    zIndex: abstract.Document;
    alpha: number;
    /**
     * Add a new polygon point to the drawing, ensuring it differs from the last one
     * @param {Point} position            The drawing point to add
     * @param {object} [options]          Options which configure how the point is added
     * @param {boolean} [options.round=false]     Should the point be rounded to integer coordinates?
     * @param {boolean} [options.snap=false]      Should the point be snapped to grid precision?
     * @param {boolean} [options.temporary=false] Is this a temporary control point?
     * @internal
     */
    _addPoint(position: Point, { round, snap, temporary }?: {
        round?: boolean;
        snap?: boolean;
        temporary?: boolean;
    }): void;
    /**
     * Remove the last fixed point from the polygon
     * @internal
     */
    _removePoint(): void;
    /** @inheritDoc */
    _onControl(options: any): void;
    /** @inheritDoc */
    _onRelease(options: any): any;
    _onkeydown: any;
    /** @override */
    override _onDelete(options: any, userId: any): void;
    /**
     * Enable text editing for this drawing.
     * @param {object} [options]
     */
    enableTextEditing(options?: object): void;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): any;
    /** @override */
    override _canControl(user: any, event: any): any;
    /** @override */
    override _canConfigure(user: any, event: any): boolean;
    /**
     * Handle mouse movement which modifies the dimensions of the drawn shape.
     * @param {PIXI.FederatedEvent} event
     * @protected
     */
    protected _onMouseDraw(event: PIXI.FederatedEvent): void;
    /** @override */
    override _onDragLeftStart(event: any): any;
    /** @override */
    override _onDragLeftMove(event: any): any;
    /** @override */
    override _onDragLeftDrop(event: any): Promise<any>;
    /** @inheritDoc */
    _onDragLeftCancel(event: any): any;
    /**
     * Handle mouse-over event on a control handle
     * @param {PIXI.FederatedEvent} event   The mouseover event
     * @protected
     */
    protected _onHandleHoverIn(event: PIXI.FederatedEvent): void;
    /**
     * Handle mouse-out event on a control handle
     * @param {PIXI.FederatedEvent} event   The mouseout event
     * @protected
     */
    protected _onHandleHoverOut(event: PIXI.FederatedEvent): void;
    /**
     * When clicking the resize handle, initialize the drag property.
     * @param {PIXI.FederatedEvent} event   The mousedown event
     * @protected
     */
    protected _onHandleMouseDown(event: PIXI.FederatedEvent): void;
    _dragHandle: boolean;
    /**
     * Starting the resize handle drag event, initialize the original data.
     * @param {PIXI.FederatedEvent} event   The mouse interaction event
     * @protected
     */
    protected _onHandleDragStart(event: PIXI.FederatedEvent): void;
    /**
     * Handle mousemove while dragging a tile scale handler
     * @param {PIXI.FederatedEvent} event   The mouse interaction event
     * @protected
     */
    protected _onHandleDragMove(event: PIXI.FederatedEvent): void;
    /**
     * Handle mouseup after dragging a tile scale handler
     * @param {PIXI.FederatedEvent} event   The mouseup event
     * @protected
     */
    protected _onHandleDragDrop(event: PIXI.FederatedEvent): any;
    /**
     * Handle cancellation of a drag event for one of the resizing handles
     * @param {PointerEvent} event            The drag cancellation event
     * @protected
     */
    protected _onHandleDragCancel(event: PointerEvent): void;
    #private;
}
/**
 * An AmbientLight is an implementation of PlaceableObject which represents a dynamic light source within the Scene.
 * @category - Canvas
 * @see {@link AmbientLightDocument}
 * @see {@link LightingLayer}
 */
declare class AmbientLight extends PlaceableObject {
    /** @override */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshField: {
            propagate: string[];
        };
        refreshPosition: {};
        refreshState: {};
    };
    /**
     * A reference to the PointSource object which defines this light source area of effect
     * @type {LightSource}
     */
    source: LightSource;
    /** @inheritdoc */
    get bounds(): PIXI.Rectangle;
    /**
     * A convenience accessor to the LightData configuration object
     * @returns {LightData}
     */
    get config(): LightData;
    /**
     * Test whether a specific AmbientLight source provides global illumination
     * @type {boolean}
     */
    get global(): boolean;
    /**
     * The maximum radius in pixels of the light field
     * @type {number}
     */
    get radius(): number;
    /**
     * Get the pixel radius of dim light emitted by this light source
     * @type {number}
     */
    get dimRadius(): number;
    /**
     * Get the pixel radius of bright light emitted by this light source
     * @type {number}
     */
    get brightRadius(): number;
    /**
     * Is this Ambient Light currently visible? By default, true only if the source actively emits light.
     * @type {boolean}
     */
    get isVisible(): boolean;
    /**
     * Does this Ambient Light actively emit light given its properties and the current darkness level of the Scene?
     * @type {boolean}
     */
    get emitsLight(): boolean;
    /** @override */
    override _draw(options: any): Promise<void>;
    field: any;
    /** @override */
    override _applyRenderFlags(flags: any): void;
    alpha: number;
    /**
     * Refresh the display of the ControlIcon for this AmbientLight source.
     */
    refreshControl(): void;
    /**
     * Update the LightSource associated with this AmbientLight object.
     * @param {object} [options={}]   Options which modify how the source is updated
     * @param {boolean} [options.defer]     Defer updating perception to manually update it later
     * @param {boolean} [options.deleted]   Indicate that this light source has been deleted
     */
    updateSource({ defer, deleted }?: {
        defer?: boolean;
        deleted?: boolean;
    }): void;
    /** @inheritdoc */
    _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDelete(options: any, userId: any): void;
    /** @inheritdoc */
    _canHUD(user: any, event: any): any;
    /** @inheritdoc */
    _canConfigure(user: any, event: any): boolean;
    /** @inheritdoc */
    _onClickRight(event: any): void;
    /** @inheritdoc */
    _onDragLeftMove(event: any): void;
    #private;
}
/**
 * A Note is an implementation of PlaceableObject which represents an annotated location within the Scene.
 * Each Note links to a JournalEntry document and represents its location on the map.
 * @category - Canvas
 * @see {@link NoteDocument}
 * @see {@link NotesLayer}
 */
declare class Note extends PlaceableObject {
    /** @override */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshPosition: {
            propagate: string[];
        };
        refreshState: {
            propagate: string[];
        };
        refreshVisibility: {};
        refreshText: {};
    };
    /** @override */
    override get bounds(): PIXI.Rectangle;
    /**
     * The associated JournalEntry which is referenced by this Note
     * @type {JournalEntry}
     */
    get entry(): JournalEntry;
    /**
     * The specific JournalEntryPage within the associated JournalEntry referenced by this Note.
     */
    get page(): any;
    /**
     * The text label used to annotate this Note
     * @type {string}
     */
    get text(): string;
    /**
     * The Map Note icon size
     * @type {number}
     */
    get size(): number;
    /**
     * Determine whether the Note is visible to the current user based on their perspective of the Scene.
     * Visibility depends on permission to the underlying journal entry, as well as the perspective of controlled Tokens.
     * If Token Vision is required, the user must have a token with vision over the note to see it.
     * @type {boolean}
     */
    get isVisible(): boolean;
    /** @override */
    override _draw(options: any): Promise<void>;
    /**
     * Draw the ControlIcon for the Map Note.
     * This method replaces any prior controlIcon with the new one.
     * @returns {ControlIcon}
     * @protected
     */
    protected _drawControlIcon(): ControlIcon;
    /**
     * Draw the map note Tooltip as a Text object.
     * This method replaces any prior text with the new one.
     * @returns {PIXI.Text}
     * @protected
     */
    protected _drawTooltip(): PIXI.Text;
    tooltip: any;
    /**
     * Define a PIXI TextStyle object which is used for the tooltip displayed for this Note
     * @returns {PIXI.TextStyle}
     * @protected
     */
    protected _getTextStyle(): PIXI.TextStyle;
    /** @override */
    override _applyRenderFlags(flags: any): void;
    /**
     * Refresh the visibility.
     * @protected
     */
    protected _refreshVisibility(): void;
    alpha: number;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): any;
    /** @override */
    override _canHover(user: any): boolean;
    /** @override */
    override _canView(user: any): any;
    /** @override */
    override _canConfigure(user: any): any;
    /** @inheritdoc */
    _onHoverIn(event: any, options: any): boolean;
    zIndex: any;
    /** @inheritdoc */
    _onClickLeft2(event: any): Application;
    #private;
}
/**
 * An AmbientSound is an implementation of PlaceableObject which represents a dynamic audio source within the Scene.
 * @category - Canvas
 * @see {@link AmbientSoundDocument}
 * @see {@link SoundsLayer}
 */
declare class AmbientSound extends PlaceableObject {
    /** @override */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshField: {
            propagate: string[];
        };
        refreshPosition: {};
        refreshState: {};
    };
    /**
     * The Sound which manages playback for this AmbientSound effect
     * @type {Sound|null}
     */
    sound: Sound | null;
    /**
     * A SoundSource object which manages the area of effect for this ambient sound
     * @type {SoundSource}
     */
    source: SoundSource;
    /**
     * Is this ambient sound is currently audible based on its hidden state and the darkness level of the Scene?
     * @type {boolean}
     */
    get isAudible(): boolean;
    /** @inheritdoc */
    get bounds(): PIXI.Rectangle;
    /**
     * A convenience accessor for the sound radius in pixels
     * @type {number}
     */
    get radius(): number;
    /**
     * Toggle playback of the sound depending on whether it is audible.
     * @param {boolean} isAudible     Is the sound audible?
     * @param {number} volume         The target playback volume
     * @param {object} [options={}]   Additional options which affect sound synchronization
     * @param {number} [options.fade=250]  A duration in milliseconds to fade volume transition
     */
    sync(isAudible: boolean, volume: number, { fade }?: {
        fade?: number;
    }): void;
    /** @override */
    override _draw(): Promise<void>;
    field: any;
    /** @override */
    override _applyRenderFlags(flags: any): void;
    alpha: number;
    /**
     * Refresh the display of the ControlIcon for this AmbientSound source.
     */
    refreshControl(): void;
    /**
     * Compute the field-of-vision for an object, determining its effective line-of-sight and field-of-vision polygons
     * @param {object} [options={}]   Options which modify how the audio source is updated
     * @param {boolean} [options.defer]    Defer updating perception to manually update it later
     * @param {boolean} [options.deleted]  Indicate that this SoundSource has been deleted.
     */
    updateSource({ defer, deleted }?: {
        defer?: boolean;
        deleted?: boolean;
    }): void;
    /** @inheritdoc */
    _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDelete(options: any, userId: any): void;
    /** @inheritdoc */
    _canHUD(user: any, event: any): any;
    /** @inheritdoc */
    _canConfigure(user: any, event: any): boolean;
    /** @override */
    override _onClickRight(event: any): void;
    /** @override */
    override _onDragLeftMove(event: any): void;
    #private;
}
/**
 * A type of Placeable Object which highlights an area of the grid as covered by some area of effect.
 * @category - Canvas
 * @see {@link MeasuredTemplateDocument}
 * @see {@link TemplateLayer}
 */
declare class MeasuredTemplate extends PlaceableObject {
    /** @override */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshState: {};
        refreshShape: {
            propagate: string[];
        };
        refreshTemplate: {};
        refreshPosition: {
            propagate: string[];
        };
        refreshGrid: {};
        refreshText: {};
    };
    /**
     * Get a Circular area of effect given a radius of effect
     * @param {number} distance
     * @returns {PIXI.Circle}
     */
    static getCircleShape(distance: number): PIXI.Circle;
    /**
     * Get a Conical area of effect given a direction, angle, and distance
     * @param {number} direction
     * @param {number} angle
     * @param {number} distance
     * @returns {PIXI.Polygon}
     */
    static getConeShape(direction: number, angle: number, distance: number): PIXI.Polygon;
    /**
     * Get a Rectangular area of effect given a width and height
     * @param {number} direction
     * @param {number} distance
     * @returns {PIXI.Rectangle}
     */
    static getRectShape(direction: number, distance: number): PIXI.Rectangle;
    /**
     * Get a rotated Rectangular area of effect given a width, height, and direction
     * @param {number} direction
     * @param {number} distance
     * @param {number} width
     * @returns {PIXI.Polygon}
     */
    static getRayShape(direction: number, distance: number, width: number): PIXI.Polygon;
    /**
     * The geometry shape used for testing point intersection
     * @type {PIXI.Circle | PIXI.Ellipse | PIXI.Polygon | PIXI.Rectangle | PIXI.RoundedRectangle}
     */
    shape: PIXI.Circle | PIXI.Ellipse | PIXI.Polygon | PIXI.Rectangle | PIXI.RoundedRectangle;
    /**
     * The tiling texture used for this template, if any
     * @type {PIXI.Texture}
     */
    texture: PIXI.Texture;
    /**
     * The template graphics
     * @type {PIXI.Graphics}
     */
    template: any;
    /**
     * The measurement ruler label
     * @type {PreciseText}
     */
    ruler: PreciseText;
    /**
     * Internal property used to configure the control border thickness
     * @type {number}
     * @protected
     */
    protected _borderThickness: number;
    /** @inheritdoc */
    get bounds(): PIXI.Rectangle;
    /**
     * A convenience accessor for the border color as a numeric hex code
     * @returns {number}
     */
    get borderColor(): number;
    /**
     * A convenience accessor for the fill color as a numeric hex code
     * @returns {number}
     */
    get fillColor(): number;
    /**
     * A flag for whether the current User has full ownership over the MeasuredTemplate document.
     * @type {boolean}
     */
    get owner(): boolean;
    /**
     * Is this MeasuredTemplate currently visible on the Canvas?
     * @type {boolean}
     */
    get isVisible(): boolean;
    /**
     * A unique identifier which is used to uniquely identify related objects like a template effect or grid highlight.
     * @type {string}
     */
    get highlightId(): string;
    /** @override */
    override _draw(): Promise<void>;
    /** @override */
    override _applyRenderFlags(flags: any): void;
    alpha: number;
    /** @override */
    override _getTargetAlpha(): 1 | 0.8;
    ray: Ray;
    /**
     * Compute the geometry for the template using its document data.
     * Subclasses can override this method to take control over how different shapes are rendered.
     * @returns {PIXI.Circle|PIXI.Rectangle|PIXI.Polygon}
     * @protected
     */
    protected _computeShape(): PIXI.Circle | PIXI.Rectangle | PIXI.Polygon;
    /**
     * Refresh the display of the template outline and shape.
     * Subclasses may override this method to take control over how the template is visually rendered.
     * @protected
     */
    protected _refreshTemplate(): void;
    /**
     * Update the displayed ruler tooltip text
     * @protected
     */
    protected _refreshRulerText(): void;
    /**
     * Highlight the grid squares which should be shown under the area of effect
     */
    highlightGrid(): void;
    /**
     * Get the shape to highlight on a Scene which uses grid-less mode.
     * @returns {PIXI.Polygon|PIXI.Circle|PIXI.Rectangle}
     * @protected
     */
    protected _getGridHighlightShape(): PIXI.Polygon | PIXI.Circle | PIXI.Rectangle;
    /**
     * Get an array of points which define top-left grid spaces to highlight for square or hexagonal grids.
     * @returns {Point[]}
     * @protected
     */
    protected _getGridHighlightPositions(): Point[];
    /** @override */
    override rotate(angle: any, snap: any): Promise<any>;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): any;
    /** @override */
    override _canControl(user: any, event: any): any;
    /** @inheritdoc */
    _canHUD(user: any, event: any): boolean;
    /** @inheritdoc */
    _canConfigure(user: any, event: any): boolean;
    /** @override */
    override _canView(user: any, event: any): any;
    /** @inheritdoc */
    _onClickRight(event: any): void;
    #private;
}
/**
 * A Tile is an implementation of PlaceableObject which represents a static piece of artwork or prop within the Scene.
 * Tiles are drawn inside the {@link TilesLayer} container.
 * @category - Canvas
 *
 * @see {@link TileDocument}
 * @see {@link TilesLayer}
 */
declare class Tile extends PlaceableObject {
    /** @override */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshState: {
            propagate: string[];
        };
        refreshShape: {
            propagate: string[];
        };
        refreshMesh: {};
        refreshFrame: {};
        refreshElevation: {
            propagate: string[];
        };
        refreshPerception: {};
        refreshVideo: {};
    };
    /**
     * Create a preview tile with a background texture instead of an image
     * @param {object} data     Initial data with which to create the preview Tile
     * @returns {PlaceableObject}
     */
    static createPreview(data: object): PlaceableObject;
    /**
     * The Tile border frame
     * @extends {PIXI.Container}
     * @property {PIXI.Graphics} border
     * @property {ResizeHandle} handle
     */
    frame: any;
    /**
     * The primary tile image texture
     * @type {PIXI.Texture}
     */
    texture: PIXI.Texture;
    /**
     * The Tile image sprite
     * @type {PIXI.Sprite}
     */
    tile: PIXI.Sprite;
    /**
     * A Tile background which is displayed if no valid image texture is present
     * @type {PIXI.Graphics}
     */
    bg: any;
    /**
     * A flag which tracks if the Tile is currently playing
     * @type {boolean}
     */
    playing: boolean;
    /**
     * Get the native aspect ratio of the base texture for the Tile sprite
     * @type {number}
     */
    get aspectRatio(): number;
    /** @override */
    override get bounds(): PIXI.Rectangle;
    /**
     * The HTML source element for the primary Tile texture
     * @type {HTMLImageElement|HTMLVideoElement}
     */
    get sourceElement(): HTMLImageElement | HTMLVideoElement;
    /**
     * Does this Tile depict an animated video texture?
     * @type {boolean}
     */
    get isVideo(): boolean;
    /**
     * Is this tile a roof?
     * @returns {boolean}
     */
    get isRoof(): boolean;
    /**
     * Is this tile occluded?
     * @returns {boolean}
     */
    get occluded(): boolean;
    /**
     * The effective volume at which this Tile should be playing, including the global ambient volume modifier
     * @type {number}
     */
    get volume(): number;
    /**
     * Debounce assignment of the Tile occluded state to avoid cases like animated token movement which can rapidly
     */
    debounceSetOcclusion: (occluded: any) => any;
    /** @override */
    override _draw(options?: {}): Promise<void>;
    mesh: any;
    cursor: string;
    /** @inheritdoc */
    clear(options: any): void;
    /** @override */
    override _applyRenderFlags(flags: any): void;
    alpha: number;
    hitArea: any;
    zIndex: any;
    /**
     * Refresh the display of the Tile resizing handle.
     * Shift the position of the drag handle from the bottom-right (default) depending on which way we are dragging.
     * @protected
     */
    protected _refreshHandle(): void;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): any;
    /** @inheritdoc */
    _canConfigure(user: any, event: any): boolean;
    /** @inheritdoc */
    _onClickLeft(event: any): any;
    /** @inheritdoc */
    _onClickLeft2(event: any): void;
    _dragHandle: boolean;
    /** @inheritdoc */
    _onDragLeftStart(event: any): any;
    /** @inheritdoc */
    _onDragLeftMove(event: any): any;
    /** @inheritdoc */
    _onDragLeftDrop(event: any): Promise<any>;
    /** @inheritdoc */
    _onDragLeftCancel(event: any): any;
    /**
     * Handle mouse-over event on a control handle
     * @param {PIXI.FederatedEvent} event   The mouseover event
     * @protected
     */
    protected _onHandleHoverIn(event: PIXI.FederatedEvent): void;
    /**
     * Handle mouse-out event on a control handle
     * @param {PIXI.FederatedEvent} event   The mouseout event
     * @protected
     */
    protected _onHandleHoverOut(event: PIXI.FederatedEvent): void;
    /**
     * When clicking the resize handle, initialize the handle properties.
     * @param {PIXI.FederatedEvent} event   The mousedown event
     * @protected
     */
    protected _onHandleMouseDown(event: PIXI.FederatedEvent): void;
    _dragScaleX: number;
    _dragScaleY: number;
    /**
     * Handle the beginning of a drag event on a resize handle.
     * @param {PIXI.FederatedEvent} event   The mousedown event
     * @protected
     */
    protected _onHandleDragStart(event: PIXI.FederatedEvent): void;
    /**
     * Handle mousemove while dragging a tile scale handler
     * @param {PIXI.FederatedEvent} event   The mousemove event
     * @protected
     */
    protected _onHandleDragMove(event: PIXI.FederatedEvent): void;
    /**
     * Handle mouseup after dragging a tile scale handler
     * @param {PIXI.FederatedEvent} event   The mouseup event
     * @protected
     */
    protected _onHandleDragDrop(event: PIXI.FederatedEvent): any;
    /**
     * Handle cancellation of a drag event for one of the resizing handles
     * @param {PIXI.FederatedEvent} event   The mouseup event
     * @protected
     */
    protected _onHandleDragCancel(event: PIXI.FederatedEvent): void;
    /**
     * @deprecated since v11
     * @ignore
     */
    testOcclusion(...args: any[]): any;
    /**
     * @deprecated since v11
     * @ignore
     */
    containsPixel(...args: any[]): any;
    /**
     * @deprecated since v11
     * @ignore
     */
    getPixelAlpha(...args: any[]): any;
    /**
     * @deprecated since v11
     * @ignore
     */
    _getAlphaBounds(): any;
    #private;
}
/**
 * A Token is an implementation of PlaceableObject which represents an Actor within a viewed Scene on the game canvas.
 * @category - Canvas
 * @see {TokenDocument}
 * @see {TokenLayer}
 */
declare class Token extends PlaceableObject {
    /** @override */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        redrawEffects: {};
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshState: {
            propagate: string[];
        };
        refreshSize: {
            propagate: string[];
        };
        refreshPosition: {
            propagate: string[];
        };
        refreshElevation: {
            propagate: string[];
        };
        refreshVisibility: {};
        refreshEffects: {};
        refreshMesh: {};
        refreshShader: {};
        refreshBars: {};
        refreshNameplate: {};
        refreshBorder: {};
        refreshTarget: {};
    };
    /**
     * Defines the filter to use for detection.
     * @param {PIXI.Filter|null} filter
     */
    detectionFilter: any;
    /**
     * A Graphics instance which renders the border frame for this Token inside the GridLayer.
     * @type {PIXI.Graphics}
     */
    border: any;
    /**
     * Track the set of User documents which are currently targeting this Token
     * @type {Set<User>}
     */
    targeted: Set<User>;
    /**
     * A reference to the SpriteMesh which displays this Token in the PrimaryCanvasGroup.
     * @type {TokenMesh}
     */
    mesh: TokenMesh;
    /**
     * A reference to the VisionSource object which defines this vision source area of effect
     * @type {VisionSource}
     */
    vision: VisionSource;
    /**
     * A reference to the LightSource object which defines this light source area of effect
     * @type {LightSource}
     */
    light: LightSource;
    /**
     * A reference to an animation that is currently in progress for this Token, if any
     * @type {Promise|null}
     * @internal
     */
    _animation: Promise<any> | null;
    /**
     * A convenient reference to the Actor object associated with the Token embedded document.
     * @returns {Actor|null}
     */
    get actor(): Actor;
    /**
     * A convenient reference for whether the current User has full control over the Token document.
     * @type {boolean}
     */
    get owner(): boolean;
    get isOwner(): any;
    /**
     * A boolean flag for whether the current game User has observer permission for the Token
     * @type {boolean}
     */
    get observer(): boolean;
    /**
     * Is the HUD display active for this token?
     * @returns {boolean}
     */
    get hasActiveHUD(): boolean;
    /**
     * Convenience access to the token's nameplate string
     * @type {string}
     */
    get name(): string;
    /** @override */
    override get bounds(): PIXI.Rectangle;
    /**
     * Translate the token's grid width into a pixel width based on the canvas size
     * @type {number}
     */
    get w(): number;
    /**
     * Translate the token's grid height into a pixel height based on the canvas size
     * @type {number}
     */
    get h(): number;
    /**
     * The Token's central position, adjusted in each direction by one or zero pixels to offset it relative to walls.
     * @type {Point}
     */
    getMovementAdjustedPoint(point: any, { offsetX, offsetY }?: {
        offsetX: any;
        offsetY: any;
    }): {
        x: number;
        y: number;
    };
    /**
     * The HTML source element for the primary Tile texture
     * @type {HTMLImageElement|HTMLVideoElement}
     */
    get sourceElement(): HTMLImageElement | HTMLVideoElement;
    /**
     * Does this Tile depict an animated video texture?
     * @type {boolean}
     */
    get isVideo(): boolean;
    /**
     * An indicator for whether or not this token is currently involved in the active combat encounter.
     * @type {boolean}
     */
    get inCombat(): boolean;
    /**
     * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.
     * @type {Combatant|null}
     */
    get combatant(): Function;
    /**
     * An indicator for whether the Token is currently targeted by the active game User
     * @type {boolean}
     */
    get isTargeted(): boolean;
    /**
     * Return a reference to the detection modes array.
     * @type {[object]}
     */
    get detectionModes(): [any];
    /**
     * Determine whether the Token is visible to the calling user's perspective.
     * Hidden Tokens are only displayed to GM Users.
     * Non-hidden Tokens are always visible if Token Vision is not required.
     * Controlled tokens are always visible.
     * All Tokens are visible to a GM user if no Token is controlled.
     *
     * @see {CanvasVisibility#testVisibility}
     * @type {boolean}
     */
    get isVisible(): boolean;
    /**
     * The animation name used for Token movement
     * @type {string}
     */
    get animationName(): string;
    /**
     * Test whether the Token has sight (or blindness) at any radius
     * @type {boolean}
     */
    get hasSight(): boolean;
    /**
     * Does this Token actively emit light given its properties and the current darkness level of the Scene?
     * @type {boolean}
     */
    get emitsLight(): boolean;
    /**
     * Test whether the Token uses a limited angle of vision or light emission.
     * @type {boolean}
     */
    get hasLimitedSourceAngle(): boolean;
    /**
     * Translate the token's dim light distance in units into a radius in pixels.
     * @type {number}
     */
    get dimRadius(): number;
    /**
     * Translate the token's bright light distance in units into a radius in pixels.
     * @type {number}
     */
    get brightRadius(): number;
    /**
     * Translate the token's vision range in units into a radius in pixels.
     * @type {number}
     */
    get sightRange(): number;
    /**
     * Translate the token's maximum vision range that takes into account lights.
     * @type {number}
     */
    get optimalSightRange(): number;
    /**
     * Update the light and vision source objects associated with this Token.
     * @param {object} [options={}]       Options which configure how perception sources are updated
     * @param {boolean} [options.defer=false]         Defer updating perception to manually update it later
     * @param {boolean} [options.deleted=false]       Indicate that this light and vision source has been deleted
     */
    updateSource({ defer, deleted }?: {
        defer?: boolean;
        deleted?: boolean;
    }): void;
    /**
     * Update an emitted light source associated with this Token.
     * @param {object} [options={}]
     * @param {boolean} [options.defer]      Defer updating perception to manually update it later.
     * @param {boolean} [options.deleted]    Indicate that this light source has been deleted.
     */
    updateLightSource({ defer, deleted }?: {
        defer?: boolean;
        deleted?: boolean;
    }): void;
    /**
     * Update the VisionSource instance associated with this Token.
     * @param {object} [options]        Options which affect how the vision source is updated
     * @param {boolean} [options.defer]     Defer updating perception to manually update it later.
     * @param {boolean} [options.deleted]   Indicate that this vision source has been deleted.
     */
    updateVisionSource({ defer, deleted }?: {
        defer?: boolean;
        deleted?: boolean;
    }): void;
    /**
     * Test whether this Token is a viable vision source for the current User
     * @returns {boolean}
     * @protected
     */
    protected _isVisionSource(): boolean;
    /** @override */
    override render(renderer: any): void;
    /**
     * Render the bound mesh detection filter.
     * Note: this method does not verify that the detection filter exists.
     * @param {PIXI.Renderer} renderer
     * @protected
     */
    protected _renderDetectionFilter(renderer: PIXI.Renderer): void;
    /** @override */
    override clear(): void;
    texture: any;
    /** @override */
    override _draw(): Promise<void>;
    hitArea: PIXI.Rectangle;
    /** @override */
    override _applyRenderFlags(flags: any): void;
    /**
     * Refresh the visibility.
     * @protected
     */
    protected _refreshVisibility(): void;
    alpha: number;
    cursor: string;
    /**
     * Refresh the text content, position, and visibility of the Token nameplate.
     * @protected
     */
    protected _refreshNameplate(): void;
    /**
     * Refresh the token mesh.
     * @protected
     */
    protected _refreshMesh(): void;
    /**
     * Refresh the token mesh shader.
     * @protected
     */
    protected _refreshShader(): void;
    /**
     * Draw the Token border, taking into consideration the grid type and border color
     * @protected
     */
    protected _refreshBorder(): void;
    /**
     * Get the hex color that should be used to render the Token border
     * @param {object} [options]
     * @param {boolean} [options.hover]  Return a border color for this hover state, otherwise use the token's current
     *                                   state.
     * @returns {number|null}            The hex color used to depict the border color
     * @protected
     */
    protected _getBorderColor({ hover }?: {
        hover?: boolean;
    }): number | null;
    /**
     * @typedef {object} ReticuleOptions
     * @property {number} [margin=0]        The amount of margin between the targeting arrows and the token's bounding
     *                                      box, expressed as a fraction of an arrow's size.
     * @property {number} [alpha=1]         The alpha value of the arrows.
     * @property {number} [size=0.15]       The size of the arrows as a proportion of grid size.
     * @property {number} [color=0xFF6400]  The color of the arrows.
     * @property {object} [border]          The arrows' border style configuration.
     * @property {number} [border.color=0]  The border color.
     * @property {number} [border.width=2]  The border width.
     */
    /**
     * Refresh the target indicators for the Token.
     * Draw both target arrows for the primary User and indicator pips for other Users targeting the same Token.
     * @param {ReticuleOptions} [reticule]  Additional parameters to configure how the targeting reticule is drawn.
     * @protected
     */
    protected _refreshTarget(reticule?: {
        /**
         * The amount of margin between the targeting arrows and the token's bounding
         *         box, expressed as a fraction of an arrow's size.
         */
        margin?: number;
        /**
         * The alpha value of the arrows.
         */
        alpha?: number;
        /**
         * The size of the arrows as a proportion of grid size.
         */
        size?: number;
        /**
         * The color of the arrows.
         */
        color?: number;
        /**
         * The arrows' border style configuration.
         */
        border?: {
            color?: number;
            width?: number;
        };
    }): void;
    /**
     * Draw the targeting arrows around this token.
     * @param {ReticuleOptions} [reticule]  Additional parameters to configure how the targeting reticule is drawn.
     * @protected
     */
    protected _drawTarget({ margin: m, alpha, size, color, border: { width, color: lineColor } }?: {
        /**
         * The amount of margin between the targeting arrows and the token's bounding
         *         box, expressed as a fraction of an arrow's size.
         */
        margin?: number;
        /**
         * The alpha value of the arrows.
         */
        alpha?: number;
        /**
         * The size of the arrows as a proportion of grid size.
         */
        size?: number;
        /**
         * The color of the arrows.
         */
        color?: number;
        /**
         * The arrows' border style configuration.
         */
        border?: {
            color?: number;
            width?: number;
        };
    }): void;
    /**
     * Refresh the display of Token attribute bars, rendering its latest resource data.
     * If the bar attribute is valid (has a value and max), draw the bar. Otherwise hide it.
     */
    drawBars(): void;
    /**
     * Draw a single resource bar, given provided data
     * @param {number} number       The Bar number
     * @param {PIXI.Graphics} bar   The Bar container
     * @param {Object} data         Resource data for this bar
     * @protected
     */
    protected _drawBar(number: number, bar: any, data: any): boolean;
    /**
     * Return the text which should be displayed in a token's tooltip field
     * @returns {string}
     * @protected
     */
    protected _getTooltipText(): string;
    /**
     * Get the text style that should be used for this Token's tooltip.
     * @returns {string}
     * @protected
     */
    protected _getTextStyle(): string;
    /**
     * Draw the active effects and overlay effect icons which are present upon the Token
     */
    drawEffects(): Promise<void>;
    /**
     * Draw a status effect icon
     * @param {string} src
     * @param {number|null} tint
     * @returns {Promise<PIXI.Sprite|undefined>}
     * @protected
     */
    protected _drawEffect(src: string, tint: number | null): Promise<PIXI.Sprite | undefined>;
    /**
     * Draw the overlay effect icon
     * @param {string} src
     * @param {number|null} tint
     * @returns {Promise<PIXI.Sprite>}
     * @protected
     */
    protected _drawOverlay(src: string, tint: number | null): Promise<PIXI.Sprite>;
    /**
     * Refresh the display of status effects, adjusting their position for the token width and height.
     * @protected
     */
    protected _refreshEffects(): void;
    /**
     * Helper method to determine whether a token attribute is viewable under a certain mode
     * @param {number} mode   The mode from CONST.TOKEN_DISPLAY_MODES
     * @returns {boolean}      Is the attribute viewable?
     * @protected
     */
    protected _canViewMode(mode: number): boolean;
    /**
     * Animate changes to the appearance of the Token.
     * Animations are performed over differences between the TokenDocument and the current Token and TokenMesh appearance.
     * @param {object} updateData                     A record of the differential data which changed, for reference only
     * @param {CanvasAnimationOptions} [options]      Options which configure the animation behavior
     * @param {Function} [options.ontick]                 An optional function called each animation frame
     * @param {number} [options.movementSpeed]            A desired token movement speed in grid spaces per second
     * @param {TokenMeshDisplayAttributes} [options.a0]   The animation starting attributes if different from those cached.
     * @param {TokenMeshDisplayAttributes} [options.hoverInOut]   The placeable need hover/un-hover emulation.
     * @returns {Promise<void>}                       A promise which resolves once the animation is complete
     */
    animate(updateData: object, { hoverInOut, name, duration, easing, movementSpeed, ontick, a0 }?: CanvasAnimationOptions): Promise<void>;
    /**
     * Terminate animation of this particular Token.
     */
    stopAnimation(): void;
    /**
     * Check for collision when attempting a move to a new position
     * @param {Point} destination           The central destination point of the attempted movement
     * @param {object} [options={}]         Additional options forwarded to WallsLayer#checkCollision
     * @returns {boolean|object[]|object}   The result of the WallsLayer#checkCollision test
     */
    checkCollision(destination: Point, { origin, type, mode }?: object): boolean | object[] | object;
    /**
     * Get the center-point coordinate for a given grid position
     * @param {number} x    The grid x-coordinate that represents the top-left of the Token
     * @param {number} y    The grid y-coordinate that represents the top-left of the Token
     * @returns {Object}     The coordinate pair which represents the Token's center at position (x, y)
     */
    getCenter(x: number, y: number): any;
    /**
     * Set this Token as an active target for the current game User.
     * Note: If the context is set with groupSelection:true, you need to manually broadcast the activity for other users.
     * @param {boolean} targeted                        Is the Token now targeted?
     * @param {object} [context={}]                     Additional context options
     * @param {User|null} [context.user=null]           Assign the token as a target for a specific User
     * @param {boolean} [context.releaseOthers=true]    Release other active targets for the same player?
     * @param {boolean} [context.groupSelection=false]  Is this target being set as part of a group selection workflow?
     */
    setTarget(targeted?: boolean, { user, releaseOthers, groupSelection }?: {
        user?: User | null;
        releaseOthers?: boolean;
        groupSelection?: boolean;
    }): void;
    /**
     * Add or remove the currently controlled Tokens from the active combat encounter
     * @param {Combat} [combat]    A specific combat encounter to which this Token should be added
     * @returns {Promise<Token>} The Token which initiated the toggle
     */
    toggleCombat(combat?: Combat): Promise<Function>;
    /**
     * Toggle an active effect by its texture path.
     * Copy the existing Array in order to ensure the update method detects the data as changed.
     *
     * @param {string|object} effect  The texture file-path of the effect icon to toggle on the Token.
     * @param {object} [options]      Additional optional arguments which configure how the effect is handled.
     * @param {boolean} [options.active]    Force a certain active state for the effect
     * @param {boolean} [options.overlay]   Whether to set the effect as the overlay effect?
     * @returns {Promise<boolean>}   Was the texture applied (true) or removed (false)
     */
    toggleEffect(effect: string | object, { active, overlay }?: {
        active?: boolean;
        overlay?: boolean;
    }): Promise<boolean>;
    /**
     * Toggle the visibility state of any Tokens in the currently selected set
     * @returns {Promise<TokenDocument[]>}     A Promise which resolves to the updated Token documents
     */
    toggleVisibility(): Promise<TokenDocument[]>;
    /**
     * The external radius of the token in pixels.
     * @type {number}
     */
    get externalRadius(): number;
    /**
     * A generic transformation to turn a certain number of grid units into a radius in canvas pixels.
     * This function adds additional padding to the light radius equal to the external radius of the token.
     * This causes light to be measured from the outer token edge, rather than from the center-point.
     * @param {number} units  The radius in grid units
     * @returns {number}      The radius in pixels
     */
    getLightRadius(units: number): number;
    /** @override */
    override _getShiftedPosition(dx: any, dy: any): {
        x: abstract.Document;
        y: abstract.Document;
    };
    /** @override */
    override _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @override */
    override _onDelete(options: any, userId: any): void;
    /**
     * Handle changes to Token behavior when a significant status effect is applied
     * @param {string} statusId       The status effect ID being applied, from CONFIG.specialStatusEffects
     * @param {boolean} active        Is the special status effect now active?
     * @internal
     */
    _onApplyStatusEffect(statusId: string, active: boolean): void;
    /** @inheritdoc */
    _onControl({ releaseOthers, pan, ...options }?: {
        releaseOthers?: boolean;
        pan?: boolean;
    }): void;
    /** @inheritdoc */
    _onRelease(options: any): void;
    /** @override */
    override _canControl(user: any, event: any): boolean;
    /** @override */
    override _canHUD(user: any, event: any): any;
    /** @override */
    override _canConfigure(user: any, event: any): boolean;
    /** @override */
    override _canHover(user: any, event: any): boolean;
    /** @override */
    override _canView(user: any, event: any): any;
    /** @override */
    override _canDrag(user: any, event: any): any;
    /** @inheritDoc */
    _onHoverIn(event: any, options: any): boolean;
    /** @inheritDoc */
    _onHoverOut(event: any): boolean;
    /** @inheritDoc */
    _onClickLeft(event: any): void;
    /** @override */
    override _propagateLeftClick(event: any): any;
    /** @override */
    override _onClickLeft2(event: any): void;
    /** @override */
    override _onClickRight2(event: any): void;
    /** @override */
    override _onDragLeftDrop(event: any): any;
    /** @override */
    override _onDragLeftMove(event: any): void;
    /**
     * @deprecated since v10
     * @ignore
     */
    get hasLimitedVisionAngle(): boolean;
    /**
     * @deprecated since v10
     * @ignore
     */
    getSightOrigin(): {
        x: number;
        y: number;
    };
    /**
     * @deprecated since v10
     * @ignore
     */
    get icon(): TokenMesh;
    /**
     * @deprecated since v10
     * @ignore
     */
    setPosition(x: any, y: any, { animate, movementSpeed, recenter }?: {
        animate?: boolean;
        movementSpeed: any;
        recenter?: boolean;
    }): Promise<void>;
    /**
     * @deprecated since v10
     * @ignore
     */
    animateMovement(ray: any, { movementSpeed }?: {
        movementSpeed?: number;
    }): Promise<void>;
    /**
     * @deprecated since v11
     * @ignore
     */
    updatePosition(): void;
    /**
     * @deprecated since 11
     * @ignore
     */
    refreshHUD({ bars, border, effects, elevation, nameplate }?: {
        bars?: boolean;
        border?: boolean;
        effects?: boolean;
        elevation?: boolean;
        nameplate?: boolean;
    }): void;
    /**
     * @deprecated since 11
     * @ignore
     */
    getDisplayAttributes(): {
        x: number;
        y: number;
        width: number;
        height: number;
        alpha: number;
        rotation: number;
        scaleX: number;
        scaleY: number;
        tint: typeof import("../../common/utils/color.mjs").default;
    };
    #private;
}
/**
 * A "secret" global to help debug attributes of the currently controlled Token.
 * This is only for debugging, and may be removed in the future, so it's not safe to use.
 * @type {Token}
 * @ignore
 */
declare let _token: Function;
/**
 * A Wall is an implementation of PlaceableObject which represents a physical or visual barrier within the Scene.
 * Walls are used to restrict Token movement or visibility as well as to define the areas of effect for ambient lights
 * and sounds.
 * @category - Canvas
 * @see {@link WallDocument}
 * @see {@link WallsLayer}
 */
declare class Wall extends PlaceableObject {
    /** @override */
    static override RENDER_FLAGS: {
        redraw: {
            propagate: string[];
        };
        refresh: {
            propagate: string[];
            alias: boolean;
        };
        refreshState: {
            propagate: string[];
        };
        refreshLine: {
            propagate: string[];
        };
        refreshEndpoints: {};
        refreshDirection: {};
        refreshHighlight: {};
    };
    /**
     * Adapt the width that the wall should be rendered based on the grid size.
     * @returns {number}
     */
    static "__#173@#getLineWidth"(): number;
    /**
     * A reference the Door Control icon associated with this Wall, if any
     * @type {DoorControl|null}
     * @protected
     */
    protected doorControl: DoorControl | null;
    /**
     * A reference to an overhead Tile that is a roof, interior to which this wall is contained
     * @type {Tile}
     */
    roof: Function;
    /**
     * A Graphics object used to highlight this wall segment. Only used when the wall is controlled.
     * @type {PIXI.Graphics}
     */
    highlight: any;
    /**
     * A set which tracks other Wall instances that this Wall intersects with (excluding shared endpoints)
     * @type {Map<Wall,LineIntersection>}
     */
    intersectsWith: Map<Wall, LineIntersection>;
    /**
     * A convenience reference to the coordinates Array for the Wall endpoints, [x0,y0,x1,y1].
     * @type {number[]}
     */
    get coords(): number[];
    /**
     * The endpoints of the wall expressed as {@link PolygonVertex} instances.
     * @type {{a: PolygonVertex, b: PolygonVertex}}
     */
    get vertices(): {
        a: PolygonVertex;
        b: PolygonVertex;
    };
    /**
     * The initial endpoint of the Wall.
     * @type {PolygonVertex}
     */
    get A(): PolygonVertex;
    /**
     * The second endpoint of the Wall.
     * @type {PolygonVertex}
     */
    get B(): PolygonVertex;
    /**
     * A set of vertex sort keys which identify this Wall's endpoints.
     * @type {Set<number>}
     */
    get wallKeys(): Set<number>;
    /** @inheritdoc */
    get bounds(): PIXI.Rectangle;
    /**
     * A boolean for whether this wall contains a door
     * @type {boolean}
     */
    get isDoor(): boolean;
    /**
     * A boolean for whether the wall contains an open door
     * @returns {boolean}
     */
    get isOpen(): boolean;
    /**
     * Is this Wall interior to a non-occluded roof Tile?
     * @type {boolean}
     */
    get hasActiveRoof(): boolean;
    /**
     * Return the coordinates [x,y] at the midpoint of the wall segment
     * @returns {Array<number>}
     */
    get midpoint(): number[];
    /**
     * Get the direction of effect for a directional Wall
     * @type {number|null}
     */
    get direction(): number;
    /**
     * This helper converts the wall segment to a Ray
     * @returns {Ray}    The wall in Ray representation
     */
    toRay(): Ray;
    /** @override */
    override _draw(): Promise<void>;
    line: any;
    directionIcon: any;
    endpoints: any;
    /**
     * Draw a control icon that is used to manipulate the door's open/closed state
     * @returns {DoorControl}
     */
    createDoorControl(): DoorControl;
    /**
     * Clear the door control if it exists.
     */
    clearDoorControl(): void;
    /**
     * Determine the orientation of this wall with respect to a reference point
     * @param {Point} point       Some reference point, relative to which orientation is determined
     * @returns {number}          An orientation in CONST.WALL_DIRECTIONS which indicates whether the Point is left,
     *                            right, or collinear (both) with the Wall
     */
    orientPoint(point: Point): number;
    /**
     * Test whether to apply a configured threshold of this wall.
     * When the proximity threshold is met, this wall is excluded as an edge in perception calculations.
     * @param {string} sourceType     Sense type for the source
     * @param {Point} sourceOrigin    The origin or position of the source on the canvas
     * @param {number} [externalRadius=0] The external radius of the source
     * @returns {boolean}             True if the wall has a threshold greater than 0 for the
     *                                source type, and the source type is within that distance.
     */
    applyThreshold(sourceType: string, sourceOrigin: Point, externalRadius?: number): boolean;
    /** @inheritDoc */
    control({ chain, ...options }?: {
        chain?: boolean;
    }): boolean;
    /**
     * Test whether the Wall direction lies between two provided angles
     * This test is used for collision and vision checks against one-directional walls
     * @param {number} lower    The lower-bound limiting angle in radians
     * @param {number} upper    The upper-bound limiting angle in radians
     * @returns {boolean}
     */
    isDirectionBetweenAngles(lower: number, upper: number): boolean;
    /**
     * A simple test for whether a Ray can intersect a directional wall
     * @param {Ray} ray     The ray to test
     * @returns {boolean}    Can an intersection occur?
     */
    canRayIntersect(ray: Ray): boolean;
    /**
     * Get an Array of Wall objects which are linked by a common coordinate
     * @returns {Object}    An object reporting ids and endpoints of the linked segments
     */
    getLinkedSegments(): any;
    /**
     * Determine whether this wall is beneath a roof tile, and is considered "interior", or not.
     * Tiles which are hidden do not count as roofs for the purposes of defining interior walls.
     */
    identifyInteriorState(): void;
    /**
     * Update any intersections with this wall.
     */
    updateIntersections(): void;
    /**
     * Record the intersection points between this wall and another, if any.
     * @param {Wall} other  The other wall.
     */
    _identifyIntersectionsWith(other: Wall): void;
    /** @override */
    override _applyRenderFlags(flags: any): void;
    alpha: number;
    /**
     * Given the properties of the wall - decide upon a color to render the wall for display on the WallsLayer
     * @returns {number}
     * @protected
     */
    protected _getWallColor(): number;
    /** @inheritdoc */
    _onCreate(data: any, options: any, userId: any): void;
    /** @override */
    override _onUpdate(data: any, options: any, userId: any): void;
    /** @inheritdoc */
    _onDelete(options: any, userId: any): void;
    /**
     * Play a door interaction sound.
     * This plays locally, each client independently applies this workflow.
     * @param {string} interaction      The door interaction: "open", "close", "lock", "unlock", or "test".
     * @protected
     * @internal
     */
    protected _playDoorSound(interaction: string): void;
    /** @inheritdoc */
    _canControl(user: any, event: any): boolean;
    /** @inheritdoc */
    _onHoverIn(event: any, options: any): boolean;
    zIndex: number;
    /** @inheritdoc */
    _onHoverOut(event: any): boolean;
    /**
     * Handle mouse-hover events on the line segment itself, pulling the Wall to the front of the container stack
     * @param {PIXI.FederatedEvent} event
     * @protected
     */
    protected _onMouseOverLine(event: PIXI.FederatedEvent): boolean;
    /** @inheritdoc */
    _onClickLeft(event: any): boolean | Promise<void>;
    /** @override */
    override _onClickLeft2(event: any): void;
    /** @override */
    override _onClickRight2(event: any): void;
    /** @inheritdoc */
    _onDragLeftStart(event: any): any;
    /** @override */
    override _onDragLeftMove(event: any): void;
    /** @override */
    override _onDragLeftDrop(event: any): Promise<any>;
    #private;
}
/**
 * Wrapper for a web worker meant to convert a pixel buffer to the specified image format
 * and quality and return a base64 image
 * @param {string} name                            The worker name to be initialized
 * @param {object} [config={}]                     Worker initialization options
 * @param {boolean} [config.debug=false]           Should the worker run in debug mode?
 */
declare class TextureCompressor extends AsyncWorker {
    constructor(name?: string, config?: {});
    /**
     * Process the non-blocking image compression to a base64 string.
     * @param {Uint8ClampedArray} buffer                      Buffer used to create the image data.
     * @param {number} width                                  Buffered image width.
     * @param {number} height                                 Buffered image height.
     * @param {object} options
     * @param {string} [options.type="image/png"]             The required image type.
     * @param {number} [options.quality=1]                    The required image quality.
     * @param {boolean} [options.debug]                       The debug option.
     * @returns {Promise<*>}
     */
    compressBufferBase64(buffer: Uint8ClampedArray, width: number, height: number, options?: {
        type?: string;
        quality?: number;
        debug?: boolean;
    }): Promise<any>;
    /**
     * Expand a buffer in RED format to a buffer in RGBA format.
     * @param {Uint8ClampedArray} buffer                      Buffer used to create the image data.
     * @param {number} width                                  Buffered image width.
     * @param {number} height                                 Buffered image height.
     * @param {object} options
     * @param {boolean} [options.debug]                       The debug option.
     * @returns {Promise<*>}
     */
    expandBufferRedToBufferRGBA(buffer: Uint8ClampedArray, width: number, height: number, options?: {
        debug?: boolean;
    }): Promise<any>;
    /**
     * Reduce a buffer in RGBA format to a buffer in RED format.
     * @param {Uint8ClampedArray} buffer                      Buffer used to create the image data.
     * @param {number} width                                  Buffered image width.
     * @param {number} height                                 Buffered image height.
     * @param {object} options
     * @param {boolean} [options.debug]                       The debug option.
     * @returns {Promise<*>}
     */
    reduceBufferRGBAToBufferRED(buffer: Uint8ClampedArray, width: number, height: number, options?: {
        debug?: boolean;
    }): Promise<any>;
    #private;
}
/**
 * A special subclass of PIXI.Container used to represent a Drawing in the PrimaryCanvasGroup.
 */
declare class DrawingShape {
    /**
     * Sorting values to deal with ties.
     * @type {number}
     */
    static PRIMARY_SORT_ORDER: number;
    /**
     * @typedef {Object} PrimaryCanvasObjectDrawingShapeData
     * @property {object} shape               The shape
     * @property {number} x                   The x-coordinate of the PCO location
     * @property {number} y                   The y-coordinate of the PCO location
     * @property {number} z                   The z-index of the PCO
     * @property {number} bezierFactor        The bezier factor
     * @property {number} fillType            The fill type
     * @property {number} fillColor           The fill color
     * @property {number} fillAlpha           The fill alpha
     * @property {number} strokeWidth         The stroke width
     * @property {number} strokeColor         The stroke color
     * @property {number} strokeAlpha         The stroke alpha
     * @property {string} text                The text
     * @property {string} fontFamily          The text font family
     * @property {number} fontSize            The font size
     * @property {number} textColor           The text color
     * @property {number} textAlpha           The text alpha
     * @property {number} rotation            The rotation of this PCO
     * @property {boolean} hidden             The PCO is hidden?
     * @property {number} elevation           The elevation of the PCO
     * @property {number} sort                The sort key that resolves ties among the same elevation
     * @property {boolean} roof               The PCO is considered as a roof?
     * @property {boolean} overhead           The PCO is considered as overhead?
     * @property {object} occlusion           The occlusion object for this PCO
     * @property {object} texture             The data texture values
     */
    static get defaultData(): any;
    /**
     * Attribution: The equations for how to calculate the bezier control points are derived from Rob Spencer's article:
     * http://scaledinnovation.com/analytics/splines/aboutSplines.html
     * @param {number} factor       The smoothing factor
     * @param {number[]} previous   The prior point
     * @param {number[]} point      The current point
     * @param {number[]} next       The next point
     * @returns {{cp1: Point, nextCP: Point}} The bezier control points
     * @private
     */
    private static "__#175@#getBezierControlPoints";
    /** @inheritDoc */
    refresh(): void;
    alpha: number;
    visible: any;
    /** @inheritDoc */
    setPosition(): void;
    zIndex: any;
    angle: any;
    /** @inheritDoc */
    _getCanvasDocumentData(data: any): any;
    /**
     * Draw rectangular shapes.
     * @protected
     */
    protected _drawRectangle(): void;
    /**
     * Draw ellipsoid shapes.
     * @protected
     */
    protected _drawEllipse(): void;
    /**
     * Draw polygonal shapes.
     * @protected
     */
    protected _drawPolygon(): any;
    /**
     * Draw freehand shapes with bezier spline smoothing.
     * @protected
     */
    protected _drawFreehand(): any;
}
/**
 * A SpriteMesh which visualizes a Tile object in the PrimaryCanvasGroup.
 */
declare class TileMesh {
    /** @inheritDoc */
    refresh(): void;
    width: any;
    height: any;
    alpha: any;
    tint: number | import("../../common/utils/color.mjs").default;
    /** @inheritDoc */
    setPosition(x: any, y: any): void;
    angle: any;
    zIndex: any;
    /** @inheritDoc */
    updateBounds(): void;
    /** @inheritDoc */
    _getCanvasDocumentData(data: any): any;
}
/**
 * A special case subclass of PIXI.TilingSprite which is used in cases where the tile texture needs to repeat.
 * This should eventually be refactored in favor of a more generalized TilingMesh.
 * FIXME: Workaround until we have our custom TilingMesh class.
 */
declare class TileSprite {
    constructor(...args: any[]);
    /** @override */
    override setShaderClass(): void;
    /** @override */
    override renderDepthData(): void;
    /** @override */
    override get isOccludable(): boolean;
    /** @override */
    override get shouldRenderDepth(): boolean;
    /** @override */
    override set shader(arg: {});
    /** @override */
    override get shader(): {};
    refresh: any;
    setPosition: any;
}
/**
 * A SpriteMesh which visualizes a Token object in the PrimaryCanvasGroup.
 */
declare class TokenMesh {
    /**
     * Sorting values to deal with ties.
     * @type {number}
     */
    static PRIMARY_SORT_ORDER: number;
    /**
     * @typedef {Object} TokenMeshData
     * @property {boolean} lockRotation       Is this TokenMesh rotation locked?
     */
    static get defaultData(): any;
    /** @inheritDoc */
    refresh(): void;
    alpha: number;
    tint: typeof import("../../common/utils/color.mjs").default;
    /** @inheritDoc */
    setPosition(x: any, y: any): void;
    angle: any;
    zIndex: any;
    /** @inheritDoc */
    updateBounds(): void;
    /** @override */
    override _getTextureCoordinate(testX: any, testY: any): {
        x: any;
        y: any;
    };
    /**
     * @typedef {object} TokenMeshDisplayAttributes
     * @property {number} x
     * @property {number} y
     * @property {number} width
     * @property {number} height
     * @property {number} alpha
     * @property {number} rotation
     * @property {number} scaleX
     * @property {number} scaleY
     * @property {Color} tint
     */
    /**
     * Get the attributes for this TokenMesh which configure the display of this TokenMesh and are compatible
     * with CanvasAnimation.
     * @returns {TokenMeshDisplayAttributes}
     */
    getDisplayAttributes(): {
        x: number;
        y: number;
        width: number;
        height: number;
        alpha: number;
        rotation: number;
        scaleX: number;
        scaleY: number;
        tint: typeof import("../../common/utils/color.mjs").default;
    };
    #private;
}
/**
 * Provide the necessary methods to get a snapshot of the framebuffer into a render texture.
 * Class meant to be used as a singleton.
 * Created with the precious advices of dev7355608.
 */
declare class FramebufferSnapshot {
    /**
     * Create a render texture, provide a render method and an optional clear color.
     * @returns {PIXI.RenderTexture}              A reference to the created render texture.
     */
    static "__#177@#createRenderTexture"(): PIXI.RenderTexture;
    /**
     * The RenderTexture that is the render destination for the framebuffer snapshot.
     * @type {PIXI.RenderTexture}
     */
    framebufferTexture: PIXI.RenderTexture;
    /**
     * Get the framebuffer texture snapshot.
     * @param {PIXI.Renderer} renderer    The renderer for this context.
     * @returns {PIXI.RenderTexture}      The framebuffer snapshot.
     */
    getFramebufferTexture(renderer: PIXI.Renderer): PIXI.RenderTexture;
    #private;
}
/**
 * A smooth noise generator for one-dimensional values.
 * @param {object} options                        Configuration options for the noise process.
 * @param {number} [options.amplitude=1]          The generated noise will be on the range [0, amplitude].
 * @param {number} [options.scale=1]              An adjustment factor for the input x values which place them on an
 *                                                appropriate range.
 * @param {number} [options.maxReferences=256]    The number of pre-generated random numbers to generate.
 */
declare class SmoothNoise {
    constructor({ amplitude, scale, maxReferences }?: {
        amplitude?: number;
        scale?: number;
        maxReferences?: number;
    });
    set amplitude(arg: number[]);
    /**
     * Amplitude of the generated noise output
     * The noise output is multiplied by this value
     * @type {number[]}
     */
    get amplitude(): number[];
    set scale(arg: number[]);
    /**
     * Scale factor of the random indices
     * @type {number[]}
     */
    get scale(): number[];
    _amplitude: any;
    _scale: any;
    /**
     * Generate the noise value corresponding to a provided numeric x value.
     * @param {number} x      Any finite number
     * @return {number}       The corresponding smoothed noise value
     */
    generate(x: number): number;
}
/**
 * A class or interface that provide support for WebGL async read pixel/texture data extraction.
 */
declare class TextureExtractor {
    /**
     * List of compression that could be applied with extraction
     * @enum {number}
     */
    static COMPRESSION_MODES: {
        NONE: number;
        BASE64: number;
    };
    constructor(renderer: any, { callerName, controlHash, format }?: {
        callerName: any;
        controlHash: any;
        format?: any;
    });
    /**
     * Debug flag.
     * @type {boolean}
     */
    debug: boolean;
    /**
     * The reference to the pixel buffer.
     * @type {Uint8ClampedArray}
     */
    pixelBuffer: Uint8ClampedArray;
    /**
     * @typedef {Object} TextureExtractionOptions
     * @property {PIXI.Texture|PIXI.RenderTexture|null} [texture]   The texture the pixels are extracted from.
     *                                                              Otherwise, extract from the renderer.
     * @property {PIXI.Rectangle} [frame]                           The rectangle which the pixels are extracted from.
     * @property {TextureExtractor.COMPRESSION_MODES} [compression] The compression mode to apply, or NONE
     * @property {string}         [type]                            The optional image mime type.
     * @property {string}         [quality]                         The optional image quality.
     * @property {boolean} [debug]                                  The optional debug flag to use.
     */
    /**
     * Extract a rectangular block of pixels from the texture (without un-pre-multiplying).
     * @param {TextureExtractionOptions} options                    Options which configure extraction behavior
     * @returns {Promise}
     */
    extract(options?: {
        /**
         * The texture the pixels are extracted from.
         *    Otherwise, extract from the renderer.
         */
        texture?: PIXI.Texture | PIXI.RenderTexture | null;
        /**
         * The rectangle which the pixels are extracted from.
         */
        frame?: PIXI.Rectangle;
        /**
         * The compression mode to apply, or NONE
         */
        compression?: {
            NONE: number;
            BASE64: number;
        };
        /**
         * The optional image mime type.
         */
        type?: string;
        /**
         * The optional image quality.
         */
        quality?: string;
        /**
         * The optional debug flag to use.
         */
        debug?: boolean;
    }): Promise<any>;
    /**
     * Free all the bound objects.
     */
    reset(): void;
    /**
     * Called by the renderer contextChange runner.
     */
    contextChange(): void;
    #private;
}
/**
 * @typedef {Object} ShaderTechnique
 * @property {number} id                      The numeric identifier of the technique
 * @property {string} label                   The localization string that labels the technique
 * @property {string|undefined} coloration    The coloration shader fragment when the technique is used
 * @property {string|undefined} illumination  The illumination shader fragment when the technique is used
 * @property {string|undefined} background    The background shader fragment when the technique is used
 */
/**
 * This class defines an interface which all adaptive lighting shaders extend.
 * @extends {AbstractBaseShader}
 * @interface
 */
declare class AdaptiveLightingShader extends AbstractBaseShader {
    /**
     * Construct adaptive shader according to shader type
     * @param {string} shaderType  shader type to construct : coloration, illumination, background, etc.
     * @returns {string}           the constructed shader adaptive block
     */
    static getShaderTechniques(shaderType: string): string;
    /**
     * The coloration technique coloration shader fragment
     * @type {string}
     */
    static get COLORATION_TECHNIQUES(): string;
    /**
     * The coloration technique illumination shader fragment
     * @type {string}
     */
    static get ILLUMINATION_TECHNIQUES(): string;
    /**
     * The coloration technique background shader fragment
     * @type {string}
     */
    static get BACKGROUND_TECHNIQUES(): string;
    /**
     * The adjustments made into fragment shaders
     * @type {string}
     */
    static get ADJUSTMENTS(): string;
    /**
     * Contrast adjustment
     * @type {string}
     */
    static CONTRAST: string;
    /**
     * Saturation adjustment
     * @type {string}
     */
    static SATURATION: string;
    /**
     * Exposure adjustment
     * @type {string}
     */
    static EXPOSURE: string;
    /**
     * Switch between an inner and outer color, by comparing distance from center to ratio
     * Apply a strong gradient between the two areas if attenuation uniform is set to true
     * @type {string}
     */
    static SWITCH_COLOR: string;
    /**
     * Shadow adjustment
     * @type {string}
     */
    static SHADOW: string;
    /**
     * Transition between bright and dim colors, if requested
     * @type {string}
     */
    static TRANSITION: string;
    /**
     * Incorporate falloff if a attenuation uniform is requested
     * @type {string}
     */
    static FALLOFF: string;
    /**
     * Initialize fragment with common properties
     * @type {string}
     */
    static FRAGMENT_BEGIN: string;
    /**
     * Shader final
     * @type {string}
     */
    static FRAGMENT_END: string;
    /**
     * A mapping of available shader techniques
     * @type {Object<string, ShaderTechnique>}
     */
    static SHADER_TECHNIQUES: {
        [x: string]: ShaderTechnique;
    };
    /**
     * Determine the correct penalty to apply for a given darkness level and luminosity
     * @param {number} darknessLevel      The current darkness level on [0,1]
     * @param {number} luminosity         The light source luminosity on [-1,1]
     * @returns {number}                  The amount of penalty to apply on [0,1]
     */
    getDarknessPenalty(darknessLevel: number, luminosity: number): number;
}
/**
 * The default coloration shader used by standard rendering and animations
 * A fragment shader which creates a solid light source.
 * @implements {AdaptiveLightingShader}
 */
declare class AdaptiveBackgroundShader extends AdaptiveLightingShader implements AdaptiveLightingShader {
    /**
     * Memory allocations for the Adaptive Background Shader
     * @type {string}
     */
    static SHADER_HEADER: string;
    /** @inheritdoc */
    static defaultUniforms: {
        technique: any;
        contrast: any;
        shadows: any;
        saturation: any;
        intensity: any;
        attenuation: any;
        exposure: number;
        ratio: number;
        darkness: boolean;
        color: number[];
        colorBackground: number[];
        screenDimensions: number[];
        time: number;
        useSampler: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
    /**
     * Flag whether the background shader is currently required.
     * Check vision modes requirements first, then
     * if key uniforms are at their default values, we don't need to render the background container.
     * @type {boolean}
     */
    get isRequired(): boolean;
}
/**
 * The default coloration shader used by standard rendering and animations
 * A fragment shader which creates a solid light source.
 * @implements {AdaptiveLightingShader}
 */
declare class AdaptiveIlluminationShader extends AdaptiveLightingShader implements AdaptiveLightingShader {
    /**
     * Memory allocations for the Adaptive Illumination Shader
     * @type {string}
     */
    static SHADER_HEADER: string;
    /** @inheritdoc */
    static defaultUniforms: {
        technique: any;
        shadows: any;
        saturation: any;
        intensity: any;
        attenuation: any;
        contrast: any;
        exposure: number;
        ratio: number;
        darkness: boolean;
        darknessLevel: number;
        color: number[];
        colorBackground: number[];
        colorDim: number[];
        colorBright: number[];
        screenDimensions: number[];
        time: number;
        useSampler: boolean;
        primaryTexture: any;
        framebufferTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
    /**
     * Flag whether the illumination shader is currently required.
     * @type {boolean}
     */
    get isRequired(): boolean;
}
/**
 * The default coloration shader used by standard rendering and animations.
 * A fragment shader which creates a light source.
 * @implements {AdaptiveLightingShader}
 */
declare class AdaptiveColorationShader extends AdaptiveLightingShader implements AdaptiveLightingShader {
    /**
     * Memory allocations for the Adaptive Coloration Shader
     * @type {string}
     */
    static SHADER_HEADER: string;
    /** @inheritdoc */
    static defaultUniforms: {
        technique: any;
        shadows: any;
        saturation: any;
        colorationAlpha: number;
        intensity: any;
        attenuation: any;
        ratio: number;
        color: number[];
        time: number;
        darkness: boolean;
        hasColor: boolean;
        screenDimensions: number[];
        useSampler: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
    /**
     * Flag whether the coloration shader is currently required.
     * @type {boolean}
     */
    get isRequired(): boolean;
}
/**
 * Allow coloring of illumination
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class TorchIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Torch animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class TorchColorationShader extends AdaptiveColorationShader {
    /** @inheritdoc */
    static defaultUniforms: {
        ratio: number;
        brightnessPulse: number;
        technique: any;
        shadows: any;
        saturation: any;
        colorationAlpha: number;
        intensity: any;
        attenuation: any;
        color: number[];
        time: number;
        darkness: boolean;
        hasColor: boolean;
        screenDimensions: number[];
        useSampler: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * Pulse animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class PulseIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Pulse animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class PulseColorationShader extends AdaptiveColorationShader {
    /** @inheritdoc */
    static defaultUniforms: {
        pulse: number;
        technique: any;
        shadows: any;
        saturation: any;
        colorationAlpha: number;
        intensity: any;
        attenuation: any;
        ratio: number;
        color: number[];
        time: number;
        darkness: boolean;
        hasColor: boolean;
        screenDimensions: number[];
        useSampler: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * Energy field animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class EnergyFieldColorationShader extends AdaptiveColorationShader {
}
/**
 * Chroma animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class ChromaColorationShader extends AdaptiveColorationShader {
}
/**
 * Wave animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class WaveIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Wave animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class WaveColorationShader extends AdaptiveColorationShader {
}
/**
 * Bewitching Wave animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class BewitchingWaveIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Bewitching Wave animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class BewitchingWaveColorationShader extends AdaptiveColorationShader {
}
/**
 * Fog animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class FogColorationShader extends AdaptiveColorationShader {
}
/**
 * Sunburst animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class SunburstIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Sunburst animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class SunburstColorationShader extends AdaptiveColorationShader {
}
/**
 * Light dome animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class LightDomeColorationShader extends AdaptiveColorationShader {
}
/**
 * Emanation animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class EmanationColorationShader extends AdaptiveColorationShader {
}
/**
 * Ghost light animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class GhostLightIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Ghost light animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class GhostLightColorationShader extends AdaptiveColorationShader {
}
/**
 * Hexagonal dome animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class HexaDomeColorationShader extends AdaptiveColorationShader {
}
/**
 * Roling mass illumination shader - intended primarily for darkness
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class RoilingIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Black Hole animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class BlackHoleIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Vortex animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class VortexColorationShader extends AdaptiveColorationShader {
}
/**
 * Vortex animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class VortexIlluminationShader extends AdaptiveColorationShader {
}
/**
 * Swirling rainbow animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class SwirlingRainbowColorationShader extends AdaptiveColorationShader {
}
/**
 * Radial rainbow animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class RadialRainbowColorationShader extends AdaptiveColorationShader {
}
/**
 * Fairy light animation coloration shader
 * @extends {AdaptiveColorationShader}
 * @author SecretFire
 */
declare class FairyLightColorationShader extends AdaptiveColorationShader {
}
/**
 * Fairy light animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 * @author SecretFire
 */
declare class FairyLightIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Alternative torch illumination shader
 * @extends {AdaptiveIlluminationShader}
 */
declare class FlameIlluminationShader extends AdaptiveIlluminationShader {
    /** @inheritdoc */
    static defaultUniforms: {
        brightnessPulse: number;
        technique: any;
        shadows: any;
        saturation: any;
        intensity: any;
        attenuation: any;
        contrast: any;
        exposure: number;
        ratio: number;
        darkness: boolean;
        darknessLevel: number;
        color: number[];
        colorBackground: number[];
        colorDim: number[];
        colorBright: number[];
        screenDimensions: number[];
        time: number;
        useSampler: boolean;
        primaryTexture: any;
        framebufferTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * Alternative torch coloration shader
 * @extends {AdaptiveColorationShader}
 */
declare class FlameColorationShader extends AdaptiveColorationShader {
    /** @inheritdoc */
    static defaultUniforms: {
        brightnessPulse: number;
        technique: any;
        shadows: any;
        saturation: any;
        colorationAlpha: number;
        intensity: any;
        attenuation: any;
        ratio: number;
        color: number[];
        time: number;
        darkness: boolean;
        hasColor: boolean;
        screenDimensions: number[];
        useSampler: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * A futuristic Force Grid animation.
 * @extends {AdaptiveColorationShader}
 */
declare class ForceGridColorationShader extends AdaptiveColorationShader {
}
/**
 * A disco like star light.
 * @extends {AdaptiveColorationShader}
 */
declare class StarLightColorationShader extends AdaptiveColorationShader {
}
/**
 * A patch of smoke
 * @extends {AdaptiveColorationShader}
 */
declare class SmokePatchColorationShader extends AdaptiveColorationShader {
}
/**
 * A patch of smoke
 * @extends {AdaptiveIlluminationShader}
 */
declare class SmokePatchIlluminationShader extends AdaptiveIlluminationShader {
}
/**
 * Revolving animation coloration shader
 * @extends {AdaptiveColorationShader}
 */
declare class RevolvingColorationShader extends AdaptiveColorationShader {
    /** @inheritdoc */
    static defaultUniforms: {
        angle: number;
        gradientFade: number;
        beamLength: number;
        technique: any;
        shadows: any;
        saturation: any;
        colorationAlpha: number;
        intensity: any;
        attenuation: any;
        ratio: number;
        color: number[];
        time: number;
        darkness: boolean;
        hasColor: boolean;
        screenDimensions: number[];
        useSampler: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * Siren light animation coloration shader
 * @extends {AdaptiveColorationShader}
 */
declare class SirenColorationShader extends AdaptiveColorationShader {
    /** @inheritdoc */
    static defaultUniforms: {
        ratio: number;
        brightnessPulse: number;
        angle: number;
        gradientFade: number;
        beamLength: number;
        technique: any;
        shadows: any;
        saturation: any;
        colorationAlpha: number;
        intensity: any;
        attenuation: any;
        color: number[];
        time: number;
        darkness: boolean;
        hasColor: boolean;
        screenDimensions: number[];
        useSampler: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * Siren light animation illumination shader
 * @extends {AdaptiveIlluminationShader}
 */
declare class SirenIlluminationShader extends AdaptiveIlluminationShader {
    /** @inheritdoc */
    static defaultUniforms: {
        angle: number;
        gradientFade: number;
        beamLength: number;
        technique: any;
        shadows: any;
        saturation: any;
        intensity: any;
        attenuation: any;
        contrast: any;
        exposure: number;
        ratio: number;
        darkness: boolean;
        darknessLevel: number;
        color: number[];
        colorBackground: number[];
        colorDim: number[];
        colorBright: number[];
        screenDimensions: number[];
        time: number;
        useSampler: boolean;
        primaryTexture: any;
        framebufferTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * This class defines an interface which all adaptive vision shaders extend.
 * @extends {AdaptiveLightingShader}
 * @interface
 */
declare class AdaptiveVisionShader extends AdaptiveLightingShader {
}
/**
 * The default background shader used for vision sources
 * @implements {AdaptiveVisionShader}
 */
declare class BackgroundVisionShader extends AdaptiveVisionShader implements AdaptiveVisionShader {
    /**
     * Memory allocations for the Adaptive Background Shader
     * @type {string}
     */
    static SHADER_HEADER: string;
    /** @inheritdoc */
    static defaultUniforms: {
        technique: number;
        saturation: number;
        contrast: number;
        attenuation: number;
        exposure: number;
        darknessLevel: number;
        colorVision: number[];
        colorTint: number[];
        colorBackground: number[];
        screenDimensions: number[];
        time: number;
        useSampler: boolean;
        linkedToDarknessLevel: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
    /**
     * Flag whether the background shader is currently required.
     * If key uniforms are at their default values, we don't need to render the background container.
     * @type {boolean}
     */
    get isRequired(): boolean;
}
/**
 * The default illumination shader used for vision sources
 * @implements {AdaptiveVisionShader}
 */
declare class IlluminationVisionShader extends AdaptiveVisionShader implements AdaptiveVisionShader {
    /**
     * Transition between bright and dim colors, if requested
     * @type {string}
     */
    static VISION_COLOR: string;
    /**
     * Memory allocations for the Adaptive Illumination Shader
     * @type {string}
     */
    static SHADER_HEADER: string;
    /** @inheritdoc */
    static defaultUniforms: {
        technique: any;
        attenuation: number;
        exposure: number;
        saturation: number;
        darknessLevel: number;
        colorVision: number[];
        colorTint: number[];
        colorBackground: number[];
        screenDimensions: number[];
        time: number;
        useSampler: boolean;
        linkedToDarknessLevel: boolean;
        primaryTexture: any;
        framebufferTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * The default coloration shader used for vision sources.
 * @implements {AdaptiveLightingShader}
 */
declare class ColorationVisionShader extends AdaptiveVisionShader implements AdaptiveLightingShader {
    /**
     * Memory allocations for the Adaptive Coloration Shader
     * @type {string}
     */
    static SHADER_HEADER: string;
    /** @inheritdoc */
    static defaultUniforms: {
        technique: number;
        saturation: number;
        attenuation: number;
        colorEffect: number[];
        colorBackground: number[];
        colorTint: number[];
        time: number;
        screenDimensions: number[];
        useSampler: boolean;
        primaryTexture: any;
        linkedToDarknessLevel: boolean;
        depthTexture: any;
        depthElevation: number;
    };
    /**
     * Flag whether the coloration shader is currently required.
     * If key uniforms are at their default values, we don't need to render the coloration container.
     * @type {boolean}
     */
    get isRequired(): boolean;
}
/**
 * Shader specialized in wave like senses (tremorsenses)
 * @implements {BackgroundVisionShader}
 */
declare class WaveBackgroundVisionShader extends BackgroundVisionShader implements BackgroundVisionShader {
}
/**
 * The wave vision shader, used to create waves emanations (ex: tremorsense)
 * @implements {ColorationVisionShader}
 */
declare class WaveColorationVisionShader extends ColorationVisionShader implements ColorationVisionShader {
}
/**
 * Shader specialized in light amplification
 * @implements {BackgroundVisionShader}
 */
declare class AmplificationBackgroundVisionShader extends BackgroundVisionShader implements BackgroundVisionShader {
    /** @inheritdoc */
    static defaultUniforms: {
        colorTint: number[];
        brightness: number;
        technique: number;
        saturation: number;
        contrast: number;
        attenuation: number;
        exposure: number;
        darknessLevel: number;
        colorVision: number[];
        colorBackground: number[];
        screenDimensions: number[];
        time: number;
        useSampler: boolean;
        linkedToDarknessLevel: boolean;
        primaryTexture: any;
        depthTexture: any;
        depthElevation: number;
    };
}
/**
 * Apply a vertical or horizontal gaussian blur going inward by using alpha as the penetrating channel.
 * @param {boolean} horizontal      If the pass is horizontal (true) or vertical (false).
 * @param {number} [strength=8]     Strength of the blur (distance of sampling).
 * @param {number} [quality=4]      Number of passes to generate the blur. More passes = Higher quality = Lower Perf.
 * @param {number} [resolution=PIXI.Filter.defaultResolution]  Resolution of the filter.
 * @param {number} [kernelSize=5]   Number of kernels to use. More kernels = Higher quality = Lower Perf.
 */
declare class AlphaBlurFilterPass {
    /**
     * The kernels containing the gaussian constants.
     * @type {Object<number, number[]>}
     */
    static GAUSSIAN_VALUES: {
        [x: number]: number[];
    };
    /**
     * The fragment template generator
     * @param {number} kernelSize   The number of kernels to use.
     * @returns {string}            The generated fragment shader.
     */
    static fragTemplate(kernelSize: number): string;
    /**
     * The vertex template generator
     * @param {number} kernelSize   The number of kernels to use.
     * @param {boolean} horizontal  If the vertex should handle horizontal or vertical pass.
     * @returns {string}            The generated vertex shader.
     */
    static vertTemplate(kernelSize: number, horizontal: boolean): string;
    /**
     * Generating the dynamic part of the blur in the fragment
     * @param {number} kernelSize   The number of kernels to use.
     * @returns {string}            The dynamic blur part.
     */
    static generateBlurFragSource(kernelSize: number): string;
    /**
     * Generating the dynamic part of the blur in the vertex
     * @param {number} kernelSize   The number of kernels to use.
     * @param {boolean} horizontal  If the vertex should handle horizontal or vertical pass.
     * @returns {string}            The dynamic blur part.
     */
    static generateBlurVertSource(kernelSize: number, horizontal: boolean): string;
    constructor(horizontal: any, strength?: number, quality?: number, resolution?: any, kernelSize?: number);
    /**
     * If the pass is horizontal (true) or vertical (false).
     * @type {boolean}
     */
    horizontal: boolean;
    /**
     * Strength of the blur (distance of sampling).
     * @type {number}
     */
    strength: number;
    /**
     * The number of passes to generate the blur.
     * @type {number}
     */
    passes: number;
    resolution: any;
    set quality(arg: number);
    /**
     * The quality of the filter is defined by its number of passes.
     * @returns {number}
     */
    get quality(): number;
    set blur(arg: number);
    /**
     * The strength of the blur filter in pixels.
     * @returns {number}
     */
    get blur(): number;
    padding: number;
    /** @override */
    override apply(filterManager: any, input: any, output: any, clearMode: any): any;
}
/**
 * Apply a gaussian blur going inward by using alpha as the penetrating channel.
 * @param {number} [strength=8]     Strength of the blur (distance of sampling).
 * @param {number} [quality=4]      Number of passes to generate the blur. More passes = Higher quality = Lower Perf.
 * @param {number} [resolution=PIXI.Filter.defaultResolution]  Resolution of the filter.
 * @param {number} [kernelSize=5]   Number of kernels to use. More kernels = Higher quality = Lower Perf.
 */
declare class AlphaBlurFilter {
    constructor(strength?: number, quality?: number, resolution?: any, kernelSize?: number);
    blurXFilter: AlphaBlurFilterPass;
    blurYFilter: AlphaBlurFilterPass;
    resolution: any;
    _repeatEdgePixels: boolean;
    set quality(arg: number);
    /**
     * The quality of blur defines the number of passes used by subsidiary filters.
     * @type {number}
     */
    get quality(): number;
    set blur(arg: number);
    /**
     * The amount of blur is forwarded to the X and Y filters.
     * @type {number}
     */
    get blur(): number;
    /** @override */
    override apply(filterManager: any, input: any, output: any, clearMode: any): void;
    /**
     * Update the filter padding according to the blur strength value (0 if _repeatEdgePixels is active)
     */
    updatePadding(): void;
    padding: number;
    set repeatEdgePixels(arg: boolean);
    /**
     * Whether to repeat edge pixels, adding padding to the filter area.
     * @type {boolean}
     */
    get repeatEdgePixels(): boolean;
    set blurX(arg: number);
    /**
     * Provided for completeness with PIXI.filters.BlurFilter
     * @type {number}
     */
    get blurX(): number;
    set blurY(arg: number);
    /**
     * Provided for completeness with PIXI.filters.BlurFilter
     * @type {number}
     */
    get blurY(): number;
    set blendMode(arg: number);
    /**
     * Provided for completeness with PIXI.filters.BlurFilter
     * @type {number}
     */
    get blendMode(): number;
}
/**
 * This class defines an interface for masked custom filters
 * @interface
 */
declare class AbstractBaseMaskFilter extends AbstractBaseFilter {
    /** @override */
    override apply(filterManager: any, input: any, output: any, clear: any, currentState: any): void;
}
/**
 * A filter used to control channels intensity using an externally provided mask texture.
 * The mask channel used must be provided at filter creation.
 */
declare class InverseOcclusionMaskFilter {
    /** @override */
    static override adaptiveFragmentShader(channel: any): string;
    /** @override */
    static override defaultUniforms: {
        uMaskSampler: any;
        alphaOcclusion: number;
        alpha: number;
        depthElevation: number;
    };
}
/**
 * A filter used to apply a reverse mask on the target display object.
 * The caller must choose a channel to use (alpha is a good candidate).
 */
declare class ReverseMaskFilter {
    /** @override */
    static override adaptiveFragmentShader(channel: any): string;
    /** @override */
    static override defaultUniforms: {
        uMaskSampler: any;
    };
}
/**
 * A minimalist filter (just used for blending)
 */
declare class VoidFilter extends AbstractBaseFilter {
}
/**
 * This filter handles masking and post-processing for visual effects.
 */
declare class VisualEffectsMaskingFilter extends AbstractBaseMaskFilter {
    /** @override */
    static override create({ filterMode, postProcessModes, ...uniforms }?: {
        filterMode: any;
        postProcessModes: any;
    }): VisualEffectsMaskingFilter;
    /**
     * Masking modes.
     * @enum {number}
     */
    static FILTER_MODES: {
        BACKGROUND: string;
        ILLUMINATION: string;
        COLORATION: string;
    };
    /** @override */
    static override defaultUniforms: {
        replacementColor: number[];
        tint: number[];
        screenDimensions: number[];
        enableVisionMasking: boolean;
        uVisionSampler: any;
        exposure: number;
        contrast: number;
        saturation: number;
    };
    /**
     * Filter post-process techniques.
     * @enum {{id: string, glsl: string}}
     */
    static POST_PROCESS_TECHNIQUES: {
        EXPOSURE: {
            id: string;
            glsl: string;
        };
        CONTRAST: {
            id: string;
            glsl: string;
        };
        SATURATION: {
            id: string;
            glsl: string;
        };
    };
    /**
     * Assign the replacement color according to the filter mode.
     * @param {number} filterMode    Filter mode.
     * @returns {string}             The replacement color.
     */
    static replacementColor(filterMode: number): string;
    /**
     * Memory allocations and headers for the VisualEffectsMaskingFilter
     * @param {number} filterMode          Filter mode.
     * @returns {string}                   The filter header according to the filter mode.
     */
    static fragmentHeader(filterMode: number): string;
    /**
     * The fragment core code.
     * @type {string}
     */
    static fragmentCore: string;
    /**
     * Construct filter post-processing code according to provided value.
     * @param {string[]} postProcessModes  Post-process modes to construct techniques.
     * @returns {string}                   The constructed shader code for post-process techniques.
     */
    static fragmentPostProcess(postProcessModes?: string[]): string;
    /**
     * Specify the fragment shader to use according to mode
     * @param {number} filterMode
     * @param {string[]} postProcessModes
     * @returns {string}
     * @override
     */
    static override fragmentShader(filterMode?: number, postProcessModes?: string[]): string;
    constructor(vertex: any, fragment: any, uniforms: any, filterMode: any);
    /**
     * The filter mode.
     * @type {string}
     */
    filterMode: string;
    /**
     * Update the filter shader with new post-process modes.
     * @param {string[]} [postProcessModes=[]]   New modes to apply.
     * @param {object} [uniforms={}]             Uniforms value to update.
     */
    updatePostprocessModes(postProcessModes?: string[], uniforms?: object): void;
    program: any;
    /**
     * Remove all post-processing modes and reset some key uniforms.
     */
    reset(): void;
    #private;
}
/**
 * Apply visibility coloration according to the baseLine color.
 * Uses very lightweight gaussian vertical and horizontal blur filter passes.
 * @extends {AbstractBaseFilter}
 */
declare class VisibilityFilter extends AbstractBaseFilter {
    /** @override */
    static override defaultUniforms: {
        exploredColor: number[];
        unexploredColor: number[];
        screenDimensions: number[];
        visionTexture: any;
        primaryTexture: any;
        overlayTexture: any;
        overlayMatrix: any;
        hasOverlayTexture: boolean;
    };
    constructor(...args: any[]);
    /**
     * Set the blur strength
     * @param {number} value    blur strength
     */
    set blur(arg: number);
    get blur(): number;
    /** @override */
    override apply(filterManager: any, input: any, output: any, clear: any): void;
    /**
     * Calculate the fog overlay sprite matrix.
     * @param {PIXI.FilterManager} filterManager
     */
    calculateMatrix(filterManager: PIXI.FilterManager): void;
    #private;
}
/**
 * A filter which forces all non-transparent pixels to a specific color and transparency.
 * @extends {AbstractBaseFilter}
 */
declare class ForceColorFilter extends AbstractBaseFilter {
    static defaultUniforms: {
        color: number[];
        alpha: number;
    };
}
/**
 * This filter turns pixels with an alpha channel < alphaThreshold in transparent pixels
 * Then, optionally, it can turn the result in the chosen color (default: pure white).
 * The alpha [threshold,1] is re-mapped to [0,1] with an hermite interpolation slope to prevent pixelation.
 * @extends {PIXI.Filter}
 */
declare class RoofMaskFilter {
    static defaultUniforms: {
        alphaThreshold: number;
        turnToColor: boolean;
        color: number[];
    };
    static fragmentShader: string;
}
/**
 * A filter which implements an inner or outer glow around the source texture.
 * Inspired from https://github.com/pixijs/filters/tree/main/filters/glow
 * @license MIT
 */
declare class GlowOverlayFilter extends AbstractBaseFilter {
    /** @inheritdoc */
    static defaultUniforms: {
        distance: number;
        glowColor: number[];
        quality: number;
        time: number;
        knockout: boolean;
        alpha: number;
    };
    /** @inheritdoc */
    static createFragmentShader(quality: any, distance: any): string;
    /** @inheritdoc */
    static create(uniforms?: {}): GlowOverlayFilter;
    /** @override */
    override padding: number;
    /**
     * The inner strength of the glow.
     * @type {number}
     */
    innerStrength: number;
    /**
     * The outer strength of the glow.
     * @type {number}
     */
    outerStrength: number;
    /**
     * Should this filter auto-animate?
     * @type {number}
     */
    animated: number;
    /** @override */
    override apply(filterManager: any, input: any, output: any, clear: any): void;
}
/**
 * A filter which implements an outline.
 * Inspired from https://github.com/pixijs/filters/tree/main/filters/outline
 * @license MIT
 */
declare class OutlineOverlayFilter extends AbstractBaseFilter {
    /** @inheritdoc */
    static defaultUniforms: {
        outlineColor: number[];
        thickness: number[];
        alphaThreshold: number;
        knockout: boolean;
        wave: boolean;
    };
    /** @inheritdoc */
    static createFragmentShader(): string;
    /**
     * Quality of the outline according to performance mode.
     * @returns {number}
     */
    static get "__#181@#quality"(): number;
    /** @inheritdoc */
    static create(uniforms?: {}): OutlineOverlayFilter;
    /** @override */
    override padding: number;
    /** @override */
    override autoFit: boolean;
    /**
     * If the filter is animated or not.
     * @type {boolean}
     */
    animate: boolean;
    set thickness(arg: number);
    /**
     * The thickness of the outline.
     * @type {number}
     */
    get thickness(): number;
    /** @override */
    override apply(filterManager: any, input: any, output: any, clear: any): void;
    #private;
}
/**
 * The filter used by the weather layer to mask weather above occluded roofs.
 * @see {@link WeatherEffects}
 */
declare class WeatherOcclusionMaskFilter extends AbstractBaseMaskFilter {
    /** @override */
    static override defaultUniforms: {
        depthElevation: number;
        useOcclusion: boolean;
        occlusionTexture: any;
        reverseOcclusion: boolean;
        occlusionWeights: number[];
        useTerrain: boolean;
        terrainTexture: any;
        reverseTerrain: boolean;
        terrainWeights: number[];
        sceneDimensions: number[];
        sceneAnchor: number[];
    };
    /**
     * Elevation of this weather occlusion mask filter.
     * @type {number}
     */
    elevation: number;
}
/**
 * A FXAA filter based on PIXI.FXAA and slightly improved.
 * In brief: The FXAA filter is computing the luma of neighbour pixels and apply correction according to the
 * difference. A high luma reduction is reducing correction while a low luma reduction is reinforcing it.
 * @param {string} [vertex=AdaptiveFXAAFilter.vertexShader]       Optional vertex shader
 * @param {string} [fragment=AdaptiveFXAAFilter.fragmentShader]   Optional fragment shader
 * @param {object} [uniforms=AdaptiveFXAAFilter.defaultUniforms]  Optional uniforms
 * @param {object} [options={}]                                   Additional options (token knockout, ...)
 */
declare class AdaptiveFXAAFilter extends AbstractBaseFilter {
    /** @override */
    static override defaultUniforms: {
        lumaMinimum: number;
        lumaReduction: number;
        spanMax: number;
        tokenKnockout: boolean;
        tokenTexture: any;
        screenDimensions: number[];
    };
    constructor(vertex: any, fragment: any, uniforms: any, options?: {});
    /** @override */
    override apply(filterManager: any, input: any, output: any, clear: any, currentState: any): void;
    /**
     * Compute the luma reduction according to the stage zoom level (worldTransform.d)
     * The zoom level is converted to a range [0.xxx => max zoom out , 1 => max zoom in]
     * With zoom out, the reduction tends to high value, the antialias is discrete to avoid blurring side effect.
     * With zoom in, the reduction tends to low value, the antialias is important.
     * FXAA checks local contrast to avoid processing non-edges (high contrast difference === edge):
     * 0.6 and 0.02 are factors applied to the "contrast range", to apply or not a contrast blend.
     * With small values, the contrast blend is applied more often than with high values.
     * @returns {number} The luma reduction
     * @protected
     */
    protected _computeLumaReduction(): number;
}
/**
 * A color adjustment shader.
 */
declare class ColorAdjustmentsSamplerShader extends BaseSamplerShader {
    /** @override */
    static override classPluginName: any;
    /** @inheritdoc */
    static defaultUniforms: {
        tintAlpha: number[];
        tint: number[];
        contrast: number;
        saturation: number;
        exposure: number;
        sampler: any;
        linkedToDarknessLevel: boolean;
        darknessLevel: number;
    };
    set linkedToDarknessLevel(arg: any);
    get linkedToDarknessLevel(): any;
    set darknessLevel(arg: any);
    get darknessLevel(): any;
    set contrast(arg: any);
    get contrast(): any;
    set exposure(arg: any);
    get exposure(): any;
    set saturation(arg: any);
    get saturation(): any;
}
/**
 * A light amplification shader.
 */
declare class AmplificationSamplerShader extends ColorAdjustmentsSamplerShader {
    /** @inheritdoc */
    static defaultUniforms: {
        tintAlpha: number[];
        tint: number[];
        brightness: number;
        darknessLevel: number;
        enable: boolean;
    };
    set darknessLevel(arg: number);
    /**
     * Level of natural brightness (opposed to darkness level).
     * @type {number}
     */
    get darknessLevel(): number;
    set brightness(arg: number);
    /**
     * Brightness controls the luminosity.
     * @type {number}
     */
    get brightness(): number;
    set colorTint(arg: number[]);
    /**
     * Tint color applied to Light Amplification.
     * @type {number[]}       Light Amplification tint (default: [0.48, 1.0, 0.48]).
     */
    get colorTint(): number[];
}
/**
 * A simple shader which purpose is to make the original texture red channel the alpha channel,
 * and still keeping channel informations. Used in cunjunction with the AlphaBlurFilterPass and Fog of War.
 */
declare class FogSamplerShader extends BaseSamplerShader {
    /** @override */
    static override classPluginName: any;
}
/**
 * A shader used to control channels intensity using an externally provided mask texture.
 */
declare class InverseOcclusionSamplerShader extends BaseSamplerShader {
    /** @override */
    static override classPluginName: any;
    /** @inheritdoc */
    static defaultUniforms: {
        roof: boolean;
        vision: boolean;
        tintAlpha: number[];
        depthElevation: number;
        sampler: any;
        maskSampler: any;
        alpha: number;
        alphaOcclusion: number;
        screenDimensions: number[];
        pixelRatio: number[];
    };
    /** @inheritdoc */
    static fragmentShader(sampleSize: any): string;
    /** @override */
    override _preRender(mesh: any): void;
}
/**
 * A shader that alters the source to adopt a translucent color to simulate invisibility.
 */
declare class TokenInvisibilitySamplerShader extends BaseSamplerShader {
    /** @override */
    static override classPluginName: any;
    /** @inheritdoc */
    static defaultUniforms: {
        tintAlpha: number[];
        sampler: any;
        color: number[];
        alpha: number;
    };
}
/**
 * A monochromatic shader
 */
declare class MonochromaticSamplerShader extends BaseSamplerShader {
}
/**
 * An occlusion shader to reveal certain area with elevation comparisons.
 * This shader is also working as a batched plugin.
 */
declare class OcclusionSamplerShader extends BaseSamplerShader {
    /** @override */
    static override batchDefaultUniforms(maxTex: any): {
        screenDimensions: number[];
        occlusionTexture: any;
    };
    /** @override */
    static override _preRenderBatch(batchRenderer: any): void;
    /** @override */
    static override _packInterleavedGeometry(element: any, attributeBuffer: any, indexBuffer: any, aIndex: any, iIndex: any): void;
    /** @inheritdoc */
    static defaultUniforms: {
        tintAlpha: number[];
        sampler: any;
        occlusionTexture: any;
        occlusionMode: number;
        screenDimensions: number[];
    };
    /** @override */
    override _preRender(mesh: any): void;
}
/**
 * @typedef {object} ContextMenuEntry
 * @property {string} name               The context menu label. Can be localized.
 * @property {string} icon               A string containing an HTML icon element for the menu item
 * @property {function(jQuery)} callback The function to call when the menu item is clicked. Receives the HTML element
 *                                       of the entry that this context menu is for.
 * @property {function(jQuery):boolean} [condition] A function to call to determine if this item appears in the menu.
 *                                                  Receives the HTML element of the entry that this context menu is
 *                                                  for.
 */
/**
 * @callback ContextMenuCallback
 * @param {HTMLElement} target  The element that the context menu has been triggered for.
 */
/**
 * Display a right-click activated Context Menu which provides a dropdown menu of options
 * A ContextMenu is constructed by designating a parent HTML container and a target selector
 * An Array of menuItems defines the entries of the menu which is displayed
 */
declare class ContextMenu {
    /**
     * Create a ContextMenu for this Application and dispatch hooks.
     * @param {Application} app                           The Application this ContextMenu belongs to.
     * @param {jQuery} html                               The Application's rendered HTML.
     * @param {string} selector                           The target CSS selector which activates the menu.
     * @param {ContextMenuEntry[]} menuItems              The array of menu items being rendered.
     * @param {object} [options]                          Additional options to configure context menu initialization.
     * @param {string} [options.hookName="EntryContext"]  The name of the hook to call.
     * @returns {ContextMenu}
     */
    static create(app: Application, html: JQueryStatic, selector: string, menuItems: ContextMenuEntry[], { hookName, ...options }?: {
        hookName?: string;
    }): ContextMenu;
    /**
     * Global listeners which apply once only to the document.
     */
    static eventListeners(): void;
    /**
     * @param {HTMLElement|jQuery} element                The containing HTML element within which the menu is positioned
     * @param {string} selector                           A CSS selector which activates the context menu.
     * @param {ContextMenuEntry[]} menuItems              An Array of entries to display in the menu
     * @param {object} [options]                          Additional options to configure the context menu.
     * @param {string} [options.eventName="contextmenu"]  Optionally override the triggering event which can spawn the
     *                                                    menu
     * @param {ContextMenuCallback} [options.onOpen]      A function to call when the context menu is opened.
     * @param {ContextMenuCallback} [options.onClose]     A function to call when the context menu is closed.
     */
    constructor(element: HTMLElement | JQueryStatic, selector: string, menuItems: ContextMenuEntry[], { eventName, onOpen, onClose }?: {
        eventName?: string;
        onOpen?: ContextMenuCallback;
        onClose?: ContextMenuCallback;
    });
    /**
     * The target HTMLElement being selected
     * @type {HTMLElement|jQuery}
     */
    element: HTMLElement | JQueryStatic;
    /**
     * The target CSS selector which activates the menu
     * @type {string}
     */
    selector: string;
    /**
     * An interaction event name which activates the menu
     * @type {string}
     */
    eventName: string;
    /**
     * The array of menu items being rendered
     * @type {ContextMenuEntry[]}
     */
    menuItems: ContextMenuEntry[];
    /**
     * A function to call when the context menu is opened.
     * @type {Function}
     */
    onOpen: Function;
    /**
     * A function to call when the context menu is closed.
     * @type {Function}
     */
    onClose: Function;
    /**
     * Track which direction the menu is expanded in
     * @type {boolean}
     */
    _expandUp: boolean;
    /**
     * A convenience accessor to the context menu HTML object
     * @returns {*|jQuery.fn.init|jQuery|HTMLElement}
     */
    get menu(): any;
    /**
     * Attach a ContextMenu instance to an HTML selector
     */
    bind(): void;
    /**
     * Closes the menu and removes it from the DOM.
     * @param {object} [options]                Options to configure the closing behavior.
     * @param {boolean} [options.animate=true]  Animate the context menu closing.
     * @returns {Promise<void>}
     */
    close({ animate }?: {
        animate?: boolean;
    }): Promise<void>;
    _close(): void;
    _animateOpen(menu: any): Promise<any>;
    _animateClose(menu: any): Promise<any>;
    /**
     * Render the Context Menu by iterating over the menuItems it contains.
     * Check the visibility of each menu item, and only render ones which are allowed by the item's logical condition.
     * Attach a click handler to each item which is rendered.
     * @param {jQuery} target     The target element to which the context menu is attached
     */
    render(target: JQueryStatic): Promise<any>;
    /**
     * Set the position of the context menu, taking into consideration whether the menu should expand upward or downward
     * @private
     */
    private _setPosition;
    /**
     * Local listeners which apply to each ContextMenu instance which is created.
     * @param {jQuery} html
     */
    activateListeners(html: JQueryStatic): void;
    #private;
}
/**
 * @typedef {ApplicationOptions} DialogOptions
 * @property {boolean} [jQuery=true]  Whether to provide jQuery objects to callback functions (if true) or plain
 *                                    HTMLElement instances (if false). This is currently true by default but in the
 *                                    future will become false by default.
 */
/**
 * @typedef {Object} DialogButton
 * @property {string} icon                  A Font Awesome icon for the button
 * @property {string} label                 The label for the button
 * @property {boolean} disabled             Whether the button is disabled
 * @property {function(jQuery)} [callback]  A callback function that fires when the button is clicked
 */
/**
 * @typedef {object} DialogData
 * @property {string} title                 The window title displayed in the dialog header
 * @property {string} content               HTML content for the dialog form
 * @property {Object<DialogButton>} buttons The buttons which are displayed as action choices for the dialog
 * @property {string} [default]             The name of the default button which should be triggered on Enter keypress
 * @property {function(jQuery)} [render]    A callback function invoked when the dialog is rendered
 * @property {function(jQuery)} [close]     Common callback operations to perform when the dialog is closed
 */
/**
 * Create a dialog window displaying a title, a message, and a set of buttons which trigger callback functions.
 * @param {DialogData} data          An object of dialog data which configures how the modal window is rendered
 * @param {DialogOptions} [options]  Dialog rendering options, see {@link Application}.
 *
 * @example Constructing a custom dialog instance
 * ```js
 * let d = new Dialog({
 *  title: "Test Dialog",
 *  content: "<p>You must choose either Option 1, or Option 2</p>",
 *  buttons: {
 *   one: {
 *    icon: '<i class="fas fa-check"></i>',
 *    label: "Option One",
 *    callback: () => console.log("Chose One")
 *   },
 *   two: {
 *    icon: '<i class="fas fa-times"></i>',
 *    label: "Option Two",
 *    callback: () => console.log("Chose Two")
 *   }
 *  },
 *  default: "two",
 *  render: html => console.log("Register interactivity in the rendered dialog"),
 *  close: html => console.log("This always is logged no matter which option is chosen")
 * });
 * d.render(true);
 * ```
 */
declare class Dialog extends Application {
    /**
     * A helper factory method to create simple confirmation dialog windows which consist of simple yes/no prompts.
     * If you require more flexibility, a custom Dialog instance is preferred.
     *
     * @param {DialogData} config                   Confirmation dialog configuration
     * @param {Function} [config.yes]               Callback function upon yes
     * @param {Function} [config.no]                Callback function upon no
     * @param {boolean} [config.defaultYes=true]    Make "yes" the default choice?
     * @param {boolean} [config.rejectClose=false]  Reject the Promise if the Dialog is closed without making a choice.
     * @param {DialogOptions} [config.options={}]   Additional rendering options passed to the Dialog
     *
     * @returns {Promise<any>}                      A promise which resolves once the user makes a choice or closes the
     *                                              window.
     *
     * @example Prompt the user with a yes or no question
     * ```js
     * let d = Dialog.confirm({
     *  title: "A Yes or No Question",
     *  content: "<p>Choose wisely.</p>",
     *  yes: () => console.log("You chose ... wisely"),
     *  no: () => console.log("You chose ... poorly"),
     *  defaultYes: false
     * });
     * ```
     */
    static confirm({ title, content, yes, no, render, defaultYes, rejectClose, options }?: DialogData): Promise<any>;
    /**
     * A helper factory method to display a basic "prompt" style Dialog with a single button
     * @param {DialogData} config                  Dialog configuration options
     * @param {Function} [config.callback]         A callback function to fire when the button is clicked
     * @param {boolean} [config.rejectClose=true]  Reject the promise if the dialog is closed without confirming the
     *                                             choice, otherwise resolve as null
     * @param {DialogOptions} [config.options]     Additional dialog options
     * @returns {Promise<any>}                     The returned value from the provided callback function, if any
     */
    static prompt({ title, content, label, callback, render, rejectClose, options }?: DialogData): Promise<any>;
    /**
     * Wrap the Dialog with an enclosing Promise which resolves or rejects when the client makes a choice.
     * @param {DialogData} [data]        Data passed to the Dialog constructor.
     * @param {DialogOptions} [options]  Options passed to the Dialog constructor.
     * @param {object} [renderOptions]   Options passed to the Dialog render call.
     * @returns {Promise<any>}           A Promise that resolves to the chosen result.
     */
    static wait(data?: DialogData, options?: DialogOptions, renderOptions?: object): Promise<any>;
    constructor(data: any, options: any);
    data: any;
    /** @inheritdoc */
    get title(): any;
    /** @inheritdoc */
    getData(options?: {}): {
        content: any;
        buttons: {};
    };
    /** @inheritdoc */
    activateListeners(html: any): void;
    /**
     * Handle a left-mouse click on one of the dialog choice buttons
     * @param {MouseEvent} event    The left-mouse click event
     * @private
     */
    private _onClickButton;
    /**
     * Handle a keydown event while the dialog is active
     * @param {KeyboardEvent} event   The keydown event
     * @private
     */
    private _onKeyDown;
    /**
     * Submit the Dialog by selecting one of its buttons
     * @param {Object} button         The configuration of the chosen button
     * @param {PointerEvent} event    The originating click event
     * @private
     */
    private submit;
    /** @inheritdoc */
    close(options?: {}): Promise<void>;
    #private;
}
/**
 * A UI utility to make an element draggable.
 * @param {Application} app             The Application that is being made draggable.
 * @param {jQuery} element              A JQuery reference to the Application's outer-most element.
 * @param {HTMLElement|boolean} handle  The element that acts as a drag handle. Supply false to disable dragging.
 * @param {boolean|object} resizable    Is the application resizable? Supply an object to configure resizing behaviour
 *                                      or true to have it automatically configured.
 * @param {string} [resizable.selector]       A selector for the resize handle.
 * @param {boolean} [resizable.resizeX=true]  Enable resizing in the X direction.
 * @param {boolean} [resizable.resizeY=true]  Enable resizing in the Y direction.
 * @param {boolean} [resizable.rtl]           Modify the resizing direction to be right-to-left.
 */
declare class Draggable {
    constructor(app: any, element: any, handle: any, resizable: any);
    app: any;
    element: any;
    handle: any;
    resizable: any;
    /**
     * Duplicate the application's starting position to track differences
     * @type {Object}
     */
    position: any;
    /**
     * Remember event handlers associated with this Draggable class so they may be later unregistered
     * @type {Object}
     */
    handlers: any;
    /**
     * Throttle mousemove event handling to 60fps
     * @type {number}
     */
    _moveTime: number;
    /**
     * Activate event handling for a Draggable application
     * Attach handlers for floating, dragging, and resizing
     */
    activateListeners(): void;
    /**
     * Attach handlers for dragging and floating.
     * @protected
     */
    protected _activateDragListeners(): void;
    /**
     * Attach handlers for resizing.
     * @protected
     */
    protected _activateResizeListeners(): void;
    /**
     * Handle the initial mouse click which activates dragging behavior for the application
     * @private
     */
    private _onDragMouseDown;
    _initial: {
        x: any;
        y: any;
    } | {
        x: any;
        y: any;
    };
    /**
     * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
     * @private
     */
    private _onDragMouseMove;
    /**
     * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
     * @private
     */
    private _onDragMouseUp;
    /**
     * Handle the initial mouse click which activates dragging behavior for the application
     * @private
     */
    private _onResizeMouseDown;
    /**
     * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
     * @private
     */
    private _onResizeMouseMove;
    /**
     * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
     * @private
     */
    private _onResizeMouseUp;
}
/**
 * @typedef {object} DragDropConfiguration
 * @property {string} dragSelector     The CSS selector used to target draggable elements.
 * @property {string} dropSelector     The CSS selector used to target viable drop targets.
 * @property {Object<string,Function>} permissions    An object of permission test functions for each action
 * @property {Object<string,Function>} callbacks      An object of callback functions for each action
 */
/**
 * A controller class for managing drag and drop workflows within an Application instance.
 * The controller manages the following actions: dragstart, dragover, drop
 * @see {@link Application}
 *
 * @param {DragDropConfiguration}
 * @example Activate drag-and-drop handling for a certain set of elements
 * ```js
 * const dragDrop = new DragDrop({
 *   dragSelector: ".item",
 *   dropSelector: ".items",
 *   permissions: { dragstart: this._canDragStart.bind(this), drop: this._canDragDrop.bind(this) },
 *   callbacks: { dragstart: this._onDragStart.bind(this), drop: this._onDragDrop.bind(this) }
 * });
 * dragDrop.bind(html);
 * ```
 */
declare class DragDrop {
    static createDragImage(img: any, width: any, height: any): HTMLElement;
    constructor({ dragSelector, dropSelector, permissions, callbacks }?: {
        dragSelector: any;
        dropSelector: any;
        permissions?: {};
        callbacks?: {};
    });
    /**
     * The HTML selector which identifies draggable elements
     * @type {string}
     */
    dragSelector: string;
    /**
     * The HTML selector which identifies drop targets
     * @type {string}
     */
    dropSelector: string;
    /**
     * A set of permission checking functions for each action of the Drag and Drop workflow
     * @type {Object}
     */
    permissions: any;
    /**
     * A set of callback functions for each action of the Drag and Drop workflow
     * @type {Object}
     */
    callbacks: any;
    /**
     * Bind the DragDrop controller to an HTML application
     * @param {HTMLElement} html    The HTML element to which the handler is bound
     */
    bind(html: HTMLElement): this;
    /**
     * Execute a callback function associated with a certain action in the workflow
     * @param {DragEvent} event   The drag event being handled
     * @param {string} action     The action being attempted
     */
    callback(event: DragEvent, action: string): any;
    /**
     * Test whether the current user has permission to perform a step of the workflow
     * @param {string} action     The action being attempted
     * @param {string} selector   The selector being targeted
     * @return {boolean}          Can the action be performed?
     */
    can(action: string, selector: string): boolean;
    /**
     * Handle the start of a drag workflow
     * @param {DragEvent} event   The drag event being handled
     * @private
     */
    private _handleDragStart;
    /**
     * Handle a dragged element over a droppable target
     * @param {DragEvent} event   The drag event being handled
     * @private
     */
    private _handleDragOver;
    /**
     * Handle a dragged element dropped on a droppable target
     * @param {DragEvent} event   The drag event being handled
     * @private
     */
    private _handleDrop;
}
/**
 * A collection of helper functions and utility methods related to the rich text editor
 */
declare class TextEditor {
    static "__#70@#decoder": HTMLTextAreaElement;
    static create({ engine, ...options }?: {
        engine?: string;
    }, content?: string): Promise<any>;
    /**
     * Create a Rich Text Editor. The current implementation uses TinyMCE
     * @param {object} options                   Configuration options provided to the Editor init
     * @param {string} [options.engine=tinymce]  Which rich text editor engine to use, "tinymce" or "prosemirror". TinyMCE
     *                                           is deprecated and will be removed in a later version.
     * @param {string} content                   Initial HTML or text content to populate the editor with
     * @returns {Promise<TinyMCE.Editor|ProseMirrorEditor>}  The editor instance.
     */
    static create({ engine, ...options }?: {
        engine?: string;
    }, content?: string): Promise<TinyMCE.Editor | ProseMirrorEditor>;
    private static _PARAGRAPH_ELEMENTS;
    protected static _createTinyMCE(options?: any, content?: string): Promise<TinyMCE.Editor>;
    /**
     * Create a TinyMCE editor instance.
     * @param {object} [options]           Configuration options passed to the editor.
     * @param {string} [content=""]        Initial HTML or text content to populate the editor with.
     * @returns {Promise<TinyMCE.Editor>}  The TinyMCE editor instance.
     * @protected
     */
    protected static _createTinyMCE(options?: object, content?: string): Promise<TinyMCE.Editor>;
    static decodeHTML(html: string): string;
    /**
     * Safely decode an HTML string, removing invalid tags and converting entities back to unicode characters.
     * @param {string} html     The original encoded HTML string
     * @returns {string}        The decoded unicode string
     */
    static decodeHTML(html: string): string;
    static enrichHTML(content: string, options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): string | Promise<string>;
    /**
     * @typedef {object} EnrichmentOptions
     * @property {boolean} [secrets=false]      Include unrevealed secret tags in the final HTML? If false, unrevealed
     *                                          secret blocks will be removed.
     * @property {boolean} [documents=true]     Replace dynamic document links?
     * @property {boolean} [links=true]         Replace hyperlink content?
     * @property {boolean} [rolls=true]         Replace inline dice rolls?
     * @property {object|Function} [rollData]   The data object providing context for inline rolls, or a function that
     *                                          produces it.
     * @property {boolean} [async=true]         Perform the operation asynchronously returning a Promise
     * @property {ClientDocument} [relativeTo]  A document to resolve relative UUIDs against.
     */
    /**
     * Enrich HTML content by replacing or augmenting components of it
     * @param {string} content        The original HTML content (as a string)
     * @param {EnrichmentOptions} [options={}]       Additional options which configure how HTML is enriched
     * @returns {string|Promise<string>}             The enriched HTML content
     */
    static enrichHTML(content: string, options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): string | Promise<string>;
    protected static _enrichContentLinks(text: Text[], { async, relativeTo }?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): boolean | Promise<boolean>;
    /**
     * Convert text of the form @UUID[uuid]{name} to anchor elements.
     * @param {Text[]} text                          The existing text content
     * @param {EnrichmentOptions} [options]          Options provided to customize text enrichment
     * @param {boolean} [options.async]              Whether to resolve UUIDs asynchronously
     * @param {ClientDocument} [options.relativeTo]  A document to resolve relative UUIDs against.
     * @returns {Promise<boolean>|boolean}           Whether any content links were replaced and the text nodes need to be
     *                                               updated.
     * @protected
     */
    protected static _enrichContentLinks(text: Text[], { async, relativeTo }?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): Promise<boolean> | boolean;
    protected static _enrichHyperlinks(text: Text[], options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): boolean;
    /**
     * Convert URLs into anchor elements.
     * @param {Text[]} text                 The existing text content
     * @param {EnrichmentOptions} [options] Options provided to customize text enrichment
     * @returns {boolean}                   Whether any hyperlinks were replaced and the text nodes need to be updated
     * @protected
     */
    protected static _enrichHyperlinks(text: Text[], options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): boolean;
    protected static _enrichInlineRolls(rollData: any, text: Text[], { async }?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): boolean | Promise<boolean>;
    /**
     * Convert text of the form [[roll]] to anchor elements.
     * @param {object|Function} rollData    The data object providing context for inline rolls.
     * @param {Text[]} text                 The existing text content.
     * @param {EnrichmentOptions} [options] Options provided to customize text enrichment
     * @param {boolean} [options.async]     Whether to resolve immediate inline rolls asynchronously.
     * @returns {Promise<boolean>|boolean}  Whether any inline rolls were replaced and the text nodes need to be updated.
     * @protected
     */
    protected static _enrichInlineRolls(rollData: object | Function, text: Text[], { async }?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): Promise<boolean> | boolean;
    protected static _applyCustomEnrichers(pattern: RegExp, enricher: (match: RegExpMatchArray, options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }) => Promise<HTMLElement>, text: Text[], options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): Promise<boolean>;
    /**
     * Match any custom registered regex patterns and apply their replacements.
     * @param {RegExp} pattern               The pattern to match against.
     * @param {TextEditorEnricher} enricher  The function that will be run for each match.
     * @param {Text[]} text                  The existing text content.
     * @param {EnrichmentOptions} [options]  Options provided to customize text enrichment
     * @returns {Promise<boolean>}           Whether any replacements were made, requiring the text nodes to be updated.
     * @protected
     */
    protected static _applyCustomEnrichers(pattern: RegExp, enricher: (match: RegExpMatchArray, options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }) => Promise<HTMLElement>, text: Text[], options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }): Promise<boolean>;
    static previewHTML(content: string, length?: number): string;
    /**
     * Preview an HTML fragment by constructing a substring of a given length from its inner text.
     * @param {string} content    The raw HTML to preview
     * @param {number} length     The desired length
     * @returns {string}          The previewed HTML
     */
    static previewHTML(content: string, length?: number): string;
    static truncateHTML(html: HTMLElement): HTMLElement;
    /**
     * Sanitises an HTML fragment and removes any non-paragraph-style text.
     * @param {HTMLElement} html       The root HTML element.
     * @returns {HTMLElement}
     */
    static truncateHTML(html: HTMLElement): HTMLElement;
    static truncateText(text: string, { maxLength, splitWords, suffix }?: {
        maxLength?: number;
        splitWords?: boolean;
        suffix?: string;
    }): string;
    /**
     * Truncate a fragment of text to a maximum number of characters.
     * @param {string} text           The original text fragment that should be truncated to a maximum length
     * @param {object} [options]      Options which affect the behavior of text truncation
     * @param {number} [options.maxLength]    The maximum allowed length of the truncated string.
     * @param {boolean} [options.splitWords]  Whether to truncate by splitting on white space (if true) or breaking words.
     * @param {string|null} [options.suffix]  A suffix string to append to denote that the text was truncated.
     * @returns {string}              The truncated text string
     */
    static truncateText(text: string, { maxLength, splitWords, suffix }?: {
        maxLength?: number;
        splitWords?: boolean;
        suffix?: string | null;
    }): string;
    private static _getTextNodes;
    private static _replaceTextContent;
    private static _replaceTextNode;
    protected static _createContentLink(match: RegExpMatchArray, { async, relativeTo }?: {
        async?: boolean;
        relativeTo?: ClientDocument;
    }): HTMLAnchorElement | Promise<HTMLAnchorElement>;
    /**
     * Create a dynamic document link from a regular expression match
     * @param {RegExpMatchArray} match                          The regular expression match
     * @param {object} [options]                                Additional options to configure enrichment behaviour
     * @param {boolean} [options.async=false]                   If asynchronous evaluation is enabled, fromUuid will be
     *                                                          called, allowing comprehensive UUID lookup, otherwise
     *                                                          fromUuidSync will be used.
     * @param {ClientDocument} [options.relativeTo]             A document to resolve relative UUIDs against.
     * @returns {HTMLAnchorElement|Promise<HTMLAnchorElement>}  An HTML element for the document link, returned as a
     *                                                          Promise if async was true and the message contained a
     *                                                          UUID link.
     * @protected
     */
    protected static _createContentLink(match: RegExpMatchArray, { async, relativeTo }?: {
        async?: boolean;
        relativeTo?: ClientDocument;
    }): HTMLAnchorElement | Promise<HTMLAnchorElement>;
    private static _createLegacyContentLink;
    private static _createHyperlink;
    static _createInlineRoll(match: RegExpMatchArray, rollData: any, options?: any): HTMLAnchorElement | Promise<HTMLAnchorElement>;
    /**
     * Replace an inline roll formula with a rollable &lt;a> element or an eagerly evaluated roll result
     * @param {RegExpMatchArray} match      The regular expression match array
     * @param {object} rollData             Provided roll data for use in roll evaluation
     * @param {object} [options]            Additional options to configure enrichment behaviour
     * @returns {HTMLAnchorElement|null|Promise<HTMLAnchorElement|null>}  The replaced match, returned as a Promise if
     *                                                                    async was true and the message contained an
     *                                                                    immediate inline roll.
     */
    static _createInlineRoll(match: RegExpMatchArray, rollData: object, options?: object): HTMLAnchorElement | null | Promise<HTMLAnchorElement | null>;
    static activateListeners(): void;
    /**
     * Activate interaction listeners for the interior content of the editor frame.
     */
    static activateListeners(): void;
    private static _onClickContentLink;
    private static _onClickInlineRoll; /**
     * Composite a canvas object by rendering it to a single texture
     *
     * @param {PIXI.DisplayObject} object   The object to render to a texture
     * @param {object} [options]            Options which configure the resulting texture
     * @param {number} [options.width]        The desired width of the output texture
     * @param {number} [options.height]       The desired height of the output texture
     * @param {number} [options.tx]           A horizontal translation to apply to the object
     * @param {number} [options.ty]           A vertical translation to apply to the object
     * @param {boolean} [options.center]      Center the texture in the rendered frame?
     *
     * @returns {PIXI.Texture}              The composite Texture object
     */
    private static _onDragContentLink;
    private static _onDropEditorData;
    static getDragEventData(event: DragEvent): any;
    /**
     * Extract JSON data from a drag/drop event.
     * @param {DragEvent} event       The drag event which contains JSON data.
     * @returns {object}              The extracted JSON data. The object will be empty if the DragEvent did not contain
     *                                JSON-parseable data.
     */
    static getDragEventData(event: DragEvent): object;
    static getContentLink(eventData: any, options?: {
        relativeTo?: ClientDocument;
        label?: string;
    }): Promise<string>;
    /**
     * Given a Drop event, returns a Content link if possible such as @Actor[ABC123], else null
     * @param {object} eventData                     The parsed object of data provided by the transfer event
     * @param {object} [options]                     Additional options to configure link creation.
     * @param {ClientDocument} [options.relativeTo]  A document to generate the link relative to.
     * @param {string} [options.label]               A custom label to use instead of the document's name.
     * @returns {Promise<string|null>}
     */
    static getContentLink(eventData: object, options?: {
        relativeTo?: ClientDocument;
        label?: string;
    }): Promise<string | null>;
    static _uploadImage(uuid: string, file: File): Promise<string>;
    /**
     * Upload an image to a document's asset path.
     * @param {string} uuid        The document's UUID.
     * @param {File} file          The image file to upload.
     * @returns {Promise<string>}  The path to the uploaded image.
     * @internal
     */
    static _uploadImage(uuid: string, file: File): Promise<string>;
    /**
     * A singleton text area used for HTML decoding.
     * @type {HTMLTextAreaElement}
     */
    static "__#184@#decoder": HTMLTextAreaElement;
}
/**
 * @typedef {ApplicationOptions} FilePickerOptions
 * @property {string} [type="any"]         A type of file to target, in "audio", "image", "video", "imagevideo",
 *                                         "folder", "font", "graphics", "text", or "any"
 * @property {string} [current]            The current file path being modified, if any
 * @property {string} [activeSource=data]  A current file source in "data", "public", or "s3"
 * @property {Function} [callback]         A callback function to trigger once a file has been selected
 * @property {boolean} [allowUpload=true]  A flag which permits explicitly disallowing upload, true by default
 * @property {HTMLElement} [field]         An HTML form field that the result of this selection is applied to
 * @property {HTMLButtonElement} [button]  An HTML button element which triggers the display of this picker
 * @property {Map<string, FavoriteFolder>} [favorites] The picker display mode in FilePicker.DISPLAY_MODES
 * @property {string} [displayMode]        The picker display mode in FilePicker.DISPLAY_MODES
 * @property {boolean} [tileSize=false]    Display the tile size configuration.
 * @property {string[]} [redirectToRoot]   Redirect to the root directory rather than starting in the source directory
 *                                         of one of these files.
 */
/**
 * The FilePicker application renders contents of the server-side public directory.
 * This app allows for navigating and uploading files to the public path.
 *
 * @param {FilePickerOptions} [options={}]  Options that configure the behavior of the FilePicker
 */
declare class FilePicker extends Application {
    /**
     * Record the last-browsed directory path so that re-opening a different FilePicker instance uses the same target
     * @type {string}
     */
    static LAST_BROWSED_DIRECTORY: string;
    /**
     * Record the last-configured tile size which can automatically be applied to new FilePicker instances
     * @type {number|null}
     */
    static LAST_TILE_SIZE: number | null;
    /**
     * Record the last-configured display mode so that re-opening a different FilePicker instance uses the same mode.
     * @type {string}
     */
    static LAST_DISPLAY_MODE: string;
    /**
     * Enumerate the allowed FilePicker display modes
     * @type {string[]}
     */
    static DISPLAY_MODES: string[];
    /**
     * Cache the names of S3 buckets which can be used
     * @type {Array|null}
     */
    static S3_BUCKETS: any[] | null;
    /**
     * Set favorite folders for quick access
     * @param {Map<string, FavoriteFolder>} favorites  An object of Favorite Folders
    */
    static set favorites(arg: string[]);
    /**
     * @typedef FavoriteFolder
     * @property {string} source        The source of the folder (e.g. "data", "public")
     * @property {string} path          The full path to the folder
     * @property {string} label         The label for the path
     */
    /**
     * Get favorite folders for quick access
     * @type {string[]}
     * @return {Map<string, FavoriteFolder>}
     */
    static get favorites(): string[];
    /**
     * Add the given path for the source to the favorites
     * @param {string} source     The source of the folder (e.g. "data", "public")
     * @param {string} path       The path to a folder
     */
    static setFavorite(source: string, path: string): Promise<any>;
    /**
     * Remove the given path from the favorites
     * @param {string} source     The source of the folder (e.g. "data", "public")
     * @param {string} path       The path to a folder
     */
    static removeFavorite(source: string, path: string): Promise<void>;
    /**
     * Test a URL to see if it matches a well known s3 key pattern
     * @param {string} url          An input URL to test
     * @returns {RegExpMatchArray|null}  A regular expression match
     */
    static matchS3URL(url: string): RegExpMatchArray | null;
    /**
     * Return the upload URL to which the FilePicker should post uploaded files
     * @type {string}
     */
    static get uploadURL(): string;
    /**
     * Browse files for a certain directory location
     * @param {string} source     The source location in which to browse. See FilePicker#sources for details
     * @param {string} target     The target within the source location
     * @param {object} options                Optional arguments
     * @param {string} [options.bucket]       A bucket within which to search if using the S3 source
     * @param {string[]} [options.extensions] An Array of file extensions to filter on
     * @param {boolean} [options.wildcard]    The requested dir represents a wildcard path
     *
     * @returns {Promise}          A Promise which resolves to the directories and files contained in the location
     */
    static browse(source: string, target: string, options?: {
        bucket?: string;
        extensions?: string[];
        wildcard?: boolean;
    }): Promise<any>;
    /**
     * Configure metadata settings regarding a certain file system path
     * @param {string} source     The source location in which to browse. See FilePicker#sources for details
     * @param {string} target     The target within the source location
     * @param {object} options    Optional arguments which modify the request
     * @returns {Promise<object>}
     */
    static configurePath(source: string, target: string, options?: object): Promise<object>;
    /**
     * Create a subdirectory within a given source. The requested subdirectory path must not already exist.
     * @param {string} source     The source location in which to browse. See FilePicker#sources for details
     * @param {string} target     The target within the source location
     * @param {object} options    Optional arguments which modify the request
     * @returns {Promise<object>}
     */
    static createDirectory(source: string, target: string, options?: object): Promise<object>;
    /**
     * General dispatcher method to submit file management commands to the server
     * @param {object} data         Request data dispatched to the server
     * @param {object} options      Options dispatched to the server
     * @returns {Promise<object>}   The server response
     * @private
     */
    private static _manageFiles;
    /**
     * Dispatch a POST request to the server containing a directory path and a file to upload
     * @param {string} source   The data source to which the file should be uploaded
     * @param {string} path     The destination path
     * @param {File} file       The File object to upload
     * @param {object} [body={}]  Additional file upload options sent in the POST body
     * @param {object} [options]  Additional options to configure how the method behaves
     * @param {boolean} [options.notify=true] Display a UI notification when the upload is processed
     * @returns {Promise<object>}  The response object
     */
    static upload(source: string, path: string, file: File, body?: object, { notify }?: {
        notify?: boolean;
    }): Promise<object>;
    /**
     * A convenience function that uploads a file to a given package's persistent /storage/ directory
     * @param {string} packageId                The id of the package to which the file should be uploaded. Only supports Systems and Modules.
     * @param {string} path                     The relative path in the package's storage directory the file should be uploaded to
     * @param {File} file                       The File object to upload
     * @param {object} [body={}]                Additional file upload options sent in the POST body
     * @param {object} [options]                Additional options to configure how the method behaves
     * @param {boolean} [options.notify=true]   Display a UI notification when the upload is processed
     * @returns {Promise<object>}               The response object
     */
    static uploadPersistent(packageId: string, path: string, file: File, body?: object, { notify }?: {
        notify?: boolean;
    }): Promise<object>;
    /**
     * Bind the file picker to a new target field.
     * Assumes the user will provide a HTMLButtonElement which has the data-target and data-type attributes
     * The data-target attribute should provide the name of the input field which should receive the selected file
     * The data-type attribute is a string in ["image", "audio"] which sets the file extensions which will be accepted
     *
     * @param {HTMLButtonElement} button     The button element
     */
    static fromButton(button: HTMLButtonElement): FilePicker;
    /**
     * @deprecated since v10
     * @ignore
     */
    static parseS3URL(key: any): {
        bucket: string;
        keyPrefix: string;
    };
    /**
     * The full requested path given by the user
     * @type {string}
     */
    request: string;
    /**
     * The file sources which are available for browsing
     * @type {object}
     */
    sources: object;
    /**
     * Track the active source tab which is being browsed
     * @type {string}
     */
    activeSource: string;
    /**
     * A callback function to trigger once a file has been selected
     * @type {Function}
     */
    callback: Function;
    /**
     * The latest set of results browsed from the server
     * @type {object}
     */
    results: object;
    /**
     * The general file type which controls the set of extensions which will be accepted
     * @type {string}
     */
    type: string;
    /**
     * The target HTML element this file picker is bound to
     * @type {HTMLElement}
     */
    field: HTMLElement;
    /**
     * A button which controls the display of the picker UI
     * @type {HTMLElement}
     */
    button: HTMLElement;
    /**
     * The display mode of the FilePicker UI
     * @type {string}
     */
    displayMode: string;
    /**
     * The current set of file extensions which are being filtered upon
     * @type {string[]}
     */
    extensions: string[];
    _loaded: boolean;
    /**
     * Given a current file path, determine the directory it belongs to
     * @param {string} target   The currently requested target path
     * @returns {string[]}      An array of the inferred source and target directory path
     */
    _inferCurrentDirectory(target: string): string[];
    /**
     * Get the valid file extensions for a given named file picker type
     * @param {string} type
     * @returns {string[]}
     * @private
     */
    private _getExtensions;
    /** @override */
    override get title(): any;
    /**
     * Return the source object for the currently active source
     * @type {object}
     */
    get source(): any;
    /**
     * Return the target directory for the currently active source
     * @type {string}
     */
    get target(): string;
    /**
     * Return a flag for whether the current user is able to upload file content
     * @type {boolean}
     */
    get canUpload(): boolean;
    /** @override */
    override getData(options?: {}): Promise<{
        bucket: any;
        canGoBack: boolean;
        canUpload: boolean;
        canSelect: boolean;
        cssClass: string;
        dirs: any;
        displayMode: string;
        extensions: string[];
        files: any;
        isS3: boolean;
        noResults: boolean;
        selected: string;
        source: any;
        sources: any;
        target: string;
        tileSize: any;
        user: User;
        submitText: string;
        favorites: string[];
    }>;
    /** @inheritdoc */
    setPosition(pos?: {}): void | {
        left: number;
        top: number;
        width: number;
        height: number;
        scale: number;
    };
    /**
     * Browse to a specific location for this FilePicker instance
     * @param {string} [target]   The target within the currently active source location.
     * @param {object} [options]  Browsing options
     */
    browse(target?: string, options?: object): Promise<any>;
    result: any;
    /** @inheritDoc */
    render(force: any, options: any): Application | this;
    /** @inheritdoc */
    activateListeners(html: any): void;
    /**
     * Handle a click event to change the display mode of the File Picker
     * @param {MouseEvent} event    The triggering click event
     * @private
     */
    private _onChangeDisplayMode;
    /** @override */
    override _onChangeTab(event: any, tabs: any, active: any): void;
    /** @override */
    override _canDragStart(selector: any): boolean;
    /** @override */
    override _canDragDrop(selector: any): boolean;
    /** @override */
    override _onDragStart(event: any): void;
    /** @override */
    override _onDrop(event: any): Promise<any>;
    /**
     * Handle user submission of the address bar to request an explicit target
     * @param {KeyboardEvent} event     The originating keydown event
     * @private
     */
    private _onRequestTarget;
    /**
     * Handle user interaction with the favorites
     * @param {MouseEvent} event     The originating click event
     * @private
     */
    private _onClickFavorite;
    /**
     * Handle requests from the IntersectionObserver to lazily load an image file
     * @param {...any} args
     * @private
     */
    private _onLazyLoadImages;
    /**
     * Handle file or folder selection within the file picker
     * @param {Event} event     The originating click event
     * @private
     */
    private _onPick;
    /**
     * Handle backwards navigation of the folder structure.
     * @param {PointerEvent} event    The triggering click event
     * @private
     */
    private _onClickDirectoryControl;
    /**
     * Present the user with a dialog to create a subdirectory within their currently browsed file storage location.
     * @param {object} source     The data source being browsed
     * @private
     */
    private _createDirectoryDialog;
    /**
     * Handle changes to the bucket selector
     * @param {Event} event     The S3 bucket select change event
     * @private
     */
    private _onChangeBucket;
    /**
     * Handle changes to the tile size.
     * @param {Event} event  The triggering event.
     * @protected
     */
    protected _onChangeTileSize(event: Event): void;
    /** @override */
    override _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
    /** @inheritdoc */
    _onSubmit(ev: any): any;
    /**
     * Handle file upload
     * @param {Event} ev      The file upload event
     * @private
     */
    private _onUpload;
}
/**
 * @typedef {object} SearchFilterConfiguration
 * @property {object} options          Options which customize the behavior of the filter
 * @property {string} options.inputSelector    The CSS selector used to target the text input element.
 * @property {string} options.contentSelector  The CSS selector used to target the content container for these tabs.
 * @property {Function} options.callback       A callback function which executes when the filter changes.
 * @property {string} [options.initial]        The initial value of the search query.
 * @property {number} [options.delay=200]      The number of milliseconds to wait for text input before processing.
 */
/**
 * @typedef {object} FieldFilter
 * @property {string} field                                     The dot-delimited path to the field being filtered
 * @property {string} [operator=SearchFilter.OPERATORS.EQUALS]  The search operator, from CONST.OPERATORS
 * @property {boolean} negate                                   Negate the filter, returning results which do NOT match the filter criteria
 * @property {*} value                                          The value against which to test
 */
/**
 * A controller class for managing a text input widget that filters the contents of some other UI element
 * @see {@link Application}
 *
 * @param {SearchFilterConfiguration}
 */
declare class SearchFilter {
    /**
     * The allowed Filter Operators which can be used to define a search filter
     * @enum {string}
     */
    static OPERATORS: Readonly<{
        EQUALS: "equals";
        CONTAINS: "contains";
        STARTS_WITH: "starts_with";
        ENDS_WITH: "ends_with";
        LESS_THAN: "lt";
        LESS_THAN_EQUAL: "lte";
        GREATER_THAN: "gt";
        GREATER_THAN_EQUAL: "gte";
        BETWEEN: "between";
        IS_EMPTY: "is_empty";
    }>;
    /**
     * Test whether a given object matches a provided filter
     * @param {object} obj          An object to test against
     * @param {FieldFilter} filter  The filter to test
     * @returns {boolean}           Whether the object matches the filter
     */
    static evaluateFilter(obj: object, filter: FieldFilter): boolean;
    /**
     * Clean a query term to standardize it for matching.
     * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
     * @param {string} query    An input string which may contain leading/trailing spaces or diacritics
     * @returns {string}        A cleaned string of ASCII characters for comparison
     */
    static cleanQuery(query: string): string;
    constructor({ inputSelector, contentSelector, initial, callback, delay }?: {
        inputSelector: any;
        contentSelector: any;
        initial?: string;
        callback: any;
        delay?: number;
    });
    /**
     * The value of the current query string
     * @type {string}
     */
    query: string;
    /**
     * A callback function to trigger when the tab is changed
     * @type {Function|null}
     */
    callback: Function | null;
    /**
     * The regular expression corresponding to the query that should be matched against
     * @type {RegExp}
     */
    rgx: RegExp;
    /**
     * The CSS selector used to target the tab navigation element
     * @type {string}
     */
    _inputSelector: string;
    /**
     * A reference to the HTML navigation element the tab controller is bound to
     * @type {HTMLElement|null}
     */
    _input: HTMLElement | null;
    /**
     * The CSS selector used to target the tab content element
     * @type {string}
     */
    _contentSelector: string;
    /**
     * A reference to the HTML container element of the tab content
     * @type {HTMLElement|null}
     */
    _content: HTMLElement | null;
    /**
     * A debounced function which applies the search filtering
     * @type {Function}
     */
    _filter: Function;
    /**
     * Bind the SearchFilter controller to an HTML application
     * @param {HTMLElement} html
     */
    bind(html: HTMLElement): void;
    /**
     * Perform a filtering of the content by invoking the callback function
     * @param {KeyboardEvent} event   The triggering keyboard event
     * @param {string} query          The input search string
     */
    filter(event: KeyboardEvent, query: string): void;
}
/**
 * An extension of the native FormData implementation.
 *
 * This class functions the same way that the default FormData does, but it is more opinionated about how
 * input fields of certain types should be evaluated and handled.
 *
 * It also adds support for certain Foundry VTT specific concepts including:
 *  Support for defined data types and type conversion
 *  Support for TinyMCE editors
 *  Support for editable HTML elements
 *
 * @extends {FormData}
 *
 * @param {HTMLFormElement} form          The form being processed
 * @param {object} options                Options which configure form processing
 * @param {Object<object>} [options.editors]      A record of TinyMCE editor metadata objects, indexed by their update key
 * @param {Object<string>} [options.dtypes]       A mapping of data types for form fields
 * @param {boolean} [options.disabled=false]      Include disabled fields?
 * @param {boolean} [options.readonly=false]      Include readonly fields?
 */
declare class FormDataExtended extends FormData {
    constructor(form: any, { dtypes, editors, disabled, readonly }?: {
        dtypes?: {};
        editors?: {};
        disabled?: boolean;
        readonly?: boolean;
    });
    /**
     * A mapping of data types requested for each form field.
     * @type {{string, string}}
     */
    dtypes: {
        string;
        string;
    };
    /**
     * A record of TinyMCE editors which are linked to this form.
     * @type {Object<string, object>}
     */
    editors: {
        [x: string]: object;
    };
    /**
     * Process the HTML form element to populate the FormData instance.
     * @param {HTMLFormElement} form    The HTML form being processed
     * @param {object} options          Options forwarded from the constructor
     */
    process(form: HTMLFormElement, options: object): void;
    /**
     * Assign a value to the FormData instance which always contains JSON strings.
     * Also assign the cast value in its preferred data type to the parsed object representation of the form data.
     * @param {string} name     The field name
     * @param {any} value       The raw extracted value from the field
     * @inheritDoc
     */
    set(name: string, value: any): void;
    /**
     * Append values to the form data, adding them to an array.
     * @param {string} name     The field name to append to the form
     * @param {any} value       The value to append to the form data
     * @inheritDoc
     */
    append(name: string, value: any): void;
    /**
     * @deprecated since v10
     * @ignore
     */
    toObject(): any;
    #private;
}
/**
 * A common framework for displaying notifications to the client.
 * Submitted notifications are added to a queue, and up to 3 notifications are displayed at once.
 * Each notification is displayed for 5 seconds at which point further notifications are pulled from the queue.
 *
 * @extends {Application}
 *
 * @example Displaying Notification Messages
 * ```js
 * ui.notifications.info("This is an info message");
 * ui.notifications.warn("This is a warning message");
 * ui.notifications.error("This is an error message");
 * ui.notifications.info("This is a 4th message which will not be shown until the first info message is done");
 * ```
 */
declare class Notifications extends Application {
    /** @override */
    static override get defaultOptions(): any;
    constructor(options: any);
    /**
     * Submitted notifications which are queued for display
     * @type {object[]}
     */
    queue: object[];
    /**
     * Notifications which are currently displayed
     * @type {object[]}
     */
    active: object[];
    /**
     * Initialize the Notifications system by displaying any system-generated messages which were passed from the server.
     */
    initialize(): void;
    /** @override */
    override _renderInner(...args: any[]): Promise<JQuery<HTMLElement>>;
    /** @override */
    override _render(...args: any[]): Promise<void>;
    /**
     * @typedef {Object} NotifyOptions
     * @property {boolean} [permanent=false]      Should the notification be permanently displayed until dismissed
     * @property {boolean} [localize=false]       Whether to localize the message content before displaying it
     * @property {boolean} [console=true]         Whether to log the message to the console
     */
    /**
     * Push a new notification into the queue
     * @param {string} message                   The content of the notification message
     * @param {string} type                      The type of notification, "info", "warning", and "error" are supported
     * @param {NotifyOptions} [options={}]       Additional options which affect the notification
     * @returns {number}                         The ID of the notification
     */
    notify(message: string, type?: string, { localize, permanent, console }?: {
        /**
         * Should the notification be permanently displayed until dismissed
         */
        permanent?: boolean;
        /**
         * Whether to localize the message content before displaying it
         */
        localize?: boolean;
        /**
         * Whether to log the message to the console
         */
        console?: boolean;
    }): number;
    /**
     * Display a notification with the "info" type
     * @param {string} message           The content of the notification message
     * @param {NotifyOptions} options    Notification options passed to the notify function
     * @returns {number}                 The ID of the notification
     */
    info(message: string, options: {
        /**
         * Should the notification be permanently displayed until dismissed
         */
        permanent?: boolean;
        /**
         * Whether to localize the message content before displaying it
         */
        localize?: boolean;
        /**
         * Whether to log the message to the console
         */
        console?: boolean;
    }): number;
    /**
     * Display a notification with the "warning" type
     * @param {string} message           The content of the notification message
     * @param {NotifyOptions} options    Notification options passed to the notify function
     * @returns {number}                 The ID of the notification
     */
    warn(message: string, options: {
        /**
         * Should the notification be permanently displayed until dismissed
         */
        permanent?: boolean;
        /**
         * Whether to localize the message content before displaying it
         */
        localize?: boolean;
        /**
         * Whether to log the message to the console
         */
        console?: boolean;
    }): number;
    /**
     * Display a notification with the "error" type
     * @param {string} message           The content of the notification message
     * @param {NotifyOptions} options    Notification options passed to the notify function
     * @returns {number}                 The ID of the notification
     */
    error(message: string, options: {
        /**
         * Should the notification be permanently displayed until dismissed
         */
        permanent?: boolean;
        /**
         * Whether to localize the message content before displaying it
         */
        localize?: boolean;
        /**
         * Whether to log the message to the console
         */
        console?: boolean;
    }): number;
    /**
     * Remove the notification linked to the ID.
     * @param {number} id                 The ID of the notification
     */
    remove(id: number): void;
    /**
     * Clear all notifications.
     */
    clear(): void;
    /**
     * Retrieve a pending notification from the queue and display it
     * @private
     * @returns {void}
     */
    private fetch;
    #private;
}
/**
 * @typedef {object} ProseMirrorHistory
 * @property {string} userId  The ID of the user who submitted the step.
 * @property {Step} step      The step that was submitted.
 */
/**
 * A class responsible for managing state and collaborative editing of a single ProseMirror instance.
 */
declare class ProseMirrorEditor {
    /**
     * A list of active editor instances by their UUIDs.
     * @type {Map<string, ProseMirrorEditor>}
     */
    static "__#187@#editors": Map<string, ProseMirrorEditor>;
    /**
     * Create a ProseMirror editor instance.
     * @param {HTMLElement} target                     An HTML element to mount the editor to.
     * @param {string} [content=""]                    Content to populate the editor with.
     * @param {object} [options]                       Additional options to configure the ProseMirror instance.
     * @param {string} [options.uuid]                  A string to uniquely identify this ProseMirror instance. Ignored
     *                                                 for a collaborative editor.
     * @param {ClientDocument} [options.document]      A Document whose content is being edited. Required for
     *                                                 collaborative editing and relative UUID generation.
     * @param {string} [options.fieldName]             The field within the Document that is being edited. Required for
     *                                                 collaborative editing.
     * @param {Object<Plugin>} [options.plugins]       Plugins to include with the editor.
     * @param {boolean} [options.relativeLinks=false]  Whether to generate relative UUID links to Documents that are
     *                                                 dropped on the editor.
     * @param {boolean} [options.collaborate=false]    Whether to enable collaborative editing for this editor.
     * @returns {Promise<ProseMirrorEditor>}
     */
    static create(target: HTMLElement, content?: string, { uuid, document, fieldName, plugins, collaborate, relativeLinks }?: {
        uuid?: string;
        document?: ClientDocument;
        fieldName?: string;
        plugins?: any;
        relativeLinks?: boolean;
        collaborate?: boolean;
    }): Promise<ProseMirrorEditor>;
    /**
     * Create an EditorView with collaborative editing enabled.
     * @param {string} uuid         The ProseMirror instance UUID.
     * @param {HTMLElement} target  An HTML element to mount the editor view to.
     * @param {EditorState} state   The ProseMirror editor state.
     * @param {Plugin[]} plugins    The editor plugins to load.
     * @returns {Promise<EditorView>}
     * @protected
     */
    protected static _createCollaborativeEditorView(uuid: string, target: HTMLElement, state: EditorState, plugins: Plugin[]): Promise<EditorView>;
    /**
     * Create a plain EditorView without collaborative editing.
     * @param {HTMLElement} target  An HTML element to mount the editor view to.
     * @param {EditorState} state   The ProseMirror editor state.
     * @param {Plugin[]} plugins    The editor plugins to load.
     * @returns {EditorView}
     * @protected
     */
    protected static _createLocalEditorView(target: HTMLElement, state: EditorState, plugins: Plugin[]): EditorView;
    /**
     * Handle new editing steps supplied by the server.
     * @param {string} uuid                   The UUID that uniquely identifies the ProseMirror instance.
     * @param {number} offset                 The offset into the history, representing the point at which it was last
     *                                        truncated.
     * @param {ProseMirrorHistory[]} history  The entire edit history.
     * @protected
     */
    protected static _onNewSteps(uuid: string, offset: number, history: ProseMirrorHistory[]): void;
    /**
     * Our client is too far behind the central authority's state and must be re-synced.
     * @param {string} uuid  The UUID that uniquely identifies the ProseMirror instance.
     * @protected
     */
    protected static _onResync(uuid: string): void;
    /**
     * Handle users joining or leaving collaborative editing.
     * @param {string} uuid       The UUID that uniquely identifies the ProseMirror instance.
     * @param {string[]} users    The IDs of the users editing (including ourselves).
     * @protected
     */
    protected static _onUsersEditing(uuid: string, users: string[]): void;
    /**
     * Update client state when the editor contents are autosaved server-side.
     * @param {string} uuid  The UUID that uniquely identifies the ProseMirror instance.
     * @param {string} html  The updated editor contents.
     * @protected
     */
    protected static _onAutosave(uuid: string, html: string): Promise<void>;
    /**
     * Listen for ProseMirror collaboration events.
     * @param {Socket} socket  The open websocket.
     * @internal
     */
    static _activateSocketListeners(socket: Socket): void;
    /**
     * @param {string} uuid                        A string that uniquely identifies this ProseMirror instance.
     * @param {EditorView} view                    The ProseMirror EditorView.
     * @param {Plugin} isDirtyPlugin               The plugin to track the dirty state of the editor.
     * @param {boolean} collaborate                Whether this is a collaborative editor.
     * @param {object} [options]                   Additional options.
     * @param {ClientDocument} [options.document]  A document associated with this editor.
     */
    constructor(uuid: string, view: EditorView, isDirtyPlugin: Plugin, collaborate: boolean, options?: {
        document?: ClientDocument;
    });
    options: {
        document?: ClientDocument;
    };
    /**
     * Retire this editor instance and clean up.
     */
    destroy(): void;
    /**
     * Have the contents of the editor been edited by the user?
     * @returns {boolean}
     */
    isDirty(): boolean;
    /**
     * Handle new editing steps supplied by the server.
     * @param {string} offset                 The offset into the history, representing the point at which it was last
     *                                        truncated.
     * @param {ProseMirrorHistory[]} history  The entire edit history.
     * @protected
     */
    protected _onNewSteps(offset: string, history: ProseMirrorHistory[]): void;
    /**
     * Disable source code editing if the user was editing it when new steps arrived.
     * @protected
     */
    protected _disableSourceCodeEditing(): void;
    /**
     * The state of this ProseMirror editor has fallen too far behind the central authority's and must be re-synced.
     * @protected
     */
    protected _resync(): void;
    /**
     * Handle users joining or leaving collaborative editing.
     * @param {string[]} users  The IDs of users currently editing (including ourselves).
     * @protected
     */
    protected _updateUserDisplay(users: string[]): void;
    /**
     * Handle an autosave update for an already-open editor.
     * @param {string} html  The updated editor contents.
     * @protected
     */
    protected _handleAutosave(html: string): void;
    #private;
}
/**
 * @callback HTMLSecretContentCallback
 * @param {HTMLElement} secret  The secret element whose surrounding content we wish to retrieve.
 * @returns {string}            The content where the secret is housed.
 */
/**
 * @callback HTMLSecretUpdateCallback
 * @param {HTMLElement} secret         The secret element that is being manipulated.
 * @param {string} content             The content block containing the updated secret element.
 * @returns {Promise<ClientDocument>}  The updated Document.
 */
/**
 * @typedef {object} HTMLSecretConfiguration
 * @property {string} parentSelector      The CSS selector used to target content that contains secret blocks.
 * @property {{
 *   content: HTMLSecretContentCallback,
 *   update: HTMLSecretUpdateCallback
 * }} callbacks                           An object of callback functions for each operation.
 */
/**
 * A composable class for managing functionality for secret blocks within DocumentSheets.
 * {@see DocumentSheet}
 * @example Activate secret revealing functionality within a certain block of content.
 * ```js
 * const secrets = new HTMLSecret({
 *   selector: "section.secret[id]",
 *   callbacks: {
 *     content: this._getSecretContent.bind(this),
 *     update: this._updateSecret.bind(this)
 *   }
 * });
 * secrets.bind(html);
 * ```
 */
declare class HTMLSecret {
    /**
     * @param {HTMLSecretConfiguration} config  Configuration options.
     */
    constructor({ parentSelector, callbacks }?: HTMLSecretConfiguration);
    /**
     * Add event listeners to the targeted secret blocks.
     * @param {HTMLElement} html  The HTML content to select secret blocks from.
     */
    bind(html: HTMLElement): void;
    /**
     * Handle toggling a secret's revealed state.
     * @param {MouseEvent} event           The triggering click event.
     * @returns {Promise<ClientDocument>}  The Document whose content was modified.
     * @protected
     */
    protected _onToggleSecret(event: MouseEvent): Promise<ClientDocument>;
}
/**
 * @typedef {object} TabsConfiguration
 * @property {string} [group]            The name of the tabs group
 * @property {string} navSelector        The CSS selector used to target the navigation element for these tabs
 * @property {string} contentSelector    The CSS selector used to target the content container for these tabs
 * @property {string} initial            The tab name of the initially active tab
 * @property {Function|null} [callback]  An optional callback function that executes when the active tab is changed
 */
/**
 * A controller class for managing tabbed navigation within an Application instance.
 * @see {@link Application}
 * @param {TabsConfiguration} config    The Tabs Configuration to use for this tabbed container
 *
 * @example Configure tab-control for a set of HTML elements
 * ```html
 * <!-- Example HTML -->
 * <nav class="tabs" data-group="primary-tabs">
 *   <a class="item" data-tab="tab1" data-group="primary-tabs">Tab 1</li>
 *   <a class="item" data-tab="tab2" data-group="primary-tabs">Tab 2</li>
 * </nav>
 *
 * <section class="content">
 *   <div class="tab" data-tab="tab1" data-group="primary-tabs">Content 1</div>
 *   <div class="tab" data-tab="tab2" data-group="primary-tabs">Content 2</div>
 * </section>
 * ```
 * Activate tab control in JavaScript
 * ```js
 * const tabs = new Tabs({navSelector: ".tabs", contentSelector: ".content", initial: "tab1"});
 * tabs.bind(html);
 * ```
 */
declare class Tabs {
    constructor({ group, navSelector, contentSelector, initial, callback }?: {
        group: any;
        navSelector: any;
        contentSelector: any;
        initial: any;
        callback: any;
    });
    /**
     * The name of the tabs group
     * @type {string}
     */
    group: string;
    /**
     * The value of the active tab
     * @type {string}
     */
    active: string;
    /**
     * A callback function to trigger when the tab is changed
     * @type {Function|null}
     */
    callback: Function | null;
    /**
     * The CSS selector used to target the tab navigation element
     * @type {string}
     */
    _navSelector: string;
    /**
     * A reference to the HTML navigation element the tab controller is bound to
     * @type {HTMLElement|null}
     */
    _nav: HTMLElement | null;
    /**
     * The CSS selector used to target the tab content element
     * @type {string}
     */
    _contentSelector: string;
    /**
     * A reference to the HTML container element of the tab content
     * @type {HTMLElement|null}
     */
    _content: HTMLElement | null;
    /**
     * Bind the Tabs controller to an HTML application
     * @param {HTMLElement} html
     */
    bind(html: HTMLElement): void;
    /**
     * Activate a new tab by name
     * @param {string} tabName
     * @param {boolean} triggerCallback
     */
    activate(tabName: string, { triggerCallback }?: boolean): void;
    /**
     * Handle click events on the tab navigation entries
     * @param {MouseEvent} event    A left click event
     * @private
     */
    private _onClickNav;
}
declare const TabsV2: typeof Tabs;
/**
 * An abstract pattern followed by the different tabs of the sidebar
 * @abstract
 * @interface
 */
declare class SidebarTab extends Application {
    /** @override */
    static override get defaultOptions(): any;
    constructor(...args: any[]);
    /**
     * A reference to the pop-out variant of this SidebarTab, if one exists
     * @type {SidebarTab}
     * @protected
     */
    protected _popout: SidebarTab;
    /**
     * Denote whether this is the original version of the sidebar tab, or a pop-out variant
     * @type {SidebarTab}
     */
    _original: SidebarTab;
    /**
     * The base name of this sidebar tab
     * @type {string}
     */
    get tabName(): string;
    /** @override */
    override getData(options?: {}): Promise<{
        cssId: string;
        cssClass: any;
        tabName: string;
        user: User;
    }>;
    /** @override */
    override _render(force?: boolean, options?: {}): Promise<void>;
    /** @override */
    override _renderInner(data: any): Promise<JQueryStatic>;
    /**
     * Activate this SidebarTab, switching focus to it
     */
    activate(): void;
    /**
     * Create a second instance of this SidebarTab class which represents a singleton popped-out container
     * @returns {SidebarTab}   The popped out sidebar tab instance
     */
    createPopout(): SidebarTab;
    /**
     * Render the SidebarTab as a pop-out container
     */
    renderPopout(): void;
    /**
     * Handle lazy loading for sidebar images to only load them once they become observed
     * @param {HTMLElement[]} entries               The entries which are now observed
     * @param {IntersectionObserver} observer       The intersection observer instance
     */
    _onLazyLoadImage(entries: HTMLElement[], observer: IntersectionObserver): void;
}
/**
 * @typedef {ApplicationOptions} DocumentDirectoryOptions
 * @property {string[]} [renderUpdateKeys]   A list of data property keys that will trigger a rerender of the tab if
 *                                           they are updated on a Document that this tab is responsible for.
 * @property {string} [contextMenuSelector]  The CSS selector that activates the context menu for displayed Documents.
 * @property {string} [entryClickSelector]   The CSS selector for the clickable area of an entry in the tab.
 */
/**
 * A shared pattern for the sidebar directory which Actors, Items, and Scenes all use
 * @extends {SidebarTab}
 * @abstract
 * @interface
 *
 * @param {DocumentDirectoryOptions} [options]  Application configuration options.
 */
declare class DocumentDirectory extends SidebarTab {
    /**
     * A reference to the named Document type that this Sidebar Directory instance displays
     * @type {string}
     */
    static documentName: string;
    /** @override */
    static override entryPartial: string;
    /**
     * @override
     * @returns {DocumentDirectoryOptions}
     */
    static override get defaultOptions(): ApplicationOptions;
    /**
     * The WorldCollection instance which this Sidebar Directory displays.
     * @type {WorldCollection}
     */
    static get collection(): WorldCollection;
    constructor(options?: {});
    /**
     * References to the set of Documents which are displayed in the Sidebar
     * @type {ClientDocument[]}
     */
    documents: ClientDocument[];
    /**
     * Reference the set of Folders which exist in this Sidebar
     * @type {Folder[]}
     */
    folders: Folder[];
    /** @override */
    override get entryType(): any;
    /** @inheritDoc */
    get tabName(): any;
    /**
     * The collection of Documents which are displayed in this Sidebar Directory
     * @type {DocumentCollection}
     */
    get collection(): DocumentCollection;
    /**
     * Initialize the content of the directory by categorizing folders and documents into a hierarchical tree structure.
     */
    initialize(): void;
    /** @inheritdoc */
    _render(force: any, context?: {}): Promise<void | this>;
    /** @override */
    override get canCreateEntry(): any;
    /** @override */
    override get canCreateFolder(): any;
    /** @override */
    override getData(options?: {}): Promise<any>;
    /** @inheritDoc */
    activateListeners(html: any): void;
    /** @override */
    override _onClickEntryName(event: any): Promise<void>;
    /** @override */
    override _onCreateEntry(event: any, { _skipDeprecated }?: {
        _skipDeprecated?: boolean;
    }): any;
    /** @override */
    override _onDrop(event: any): any;
    /** @inheritdoc */
    _handleDroppedEntry(target: any, data: any, { _skipDeprecated }?: {
        _skipDeprecated?: boolean;
    }): any;
    /** @override */
    override _getDroppedEntryFromData(data: any): Promise<any>;
    /** @override */
    override _sortRelative(entry: any, sortData: any): Promise<any>;
    /** @override */
    override _createDroppedEntry(document: any, folderId: any): Promise<any>;
    /** @override */
    override _handleDroppedForeignFolder(folder: any, closestFolderId: any, sortData: any): Promise<{
        sortNeeded: boolean;
        folder: any;
    }>;
    /**
     * Create a dropped Folder and its children in this Collection, if they do not already exist
     * @param {Folder} folder                  The Folder being dropped
     * @param {Folder} targetFolder            The Folder to which the Folder should be added
     * @returns {Promise<Array<Folder>>}       The created Folders
     * @protected
     */
    protected _createDroppedFolderContent(folder: Folder, targetFolder: Folder): Promise<Array<Folder>>;
    /**
     * Organize a dropped Folder and its children into a list of folders to create and documents to create
     * @param {Folder} folder                  The Folder being dropped
     * @param {Folder} targetFolder            The Folder to which the Folder should be added
     * @returns {Promise<{foldersToCreate: Array<Folder>, documentsToCreate: Array<Document>}>}
     * @private
     */
    private _organizeDroppedFoldersAndDocuments;
    /**
     * Create a list of documents in a dropped Folder
     * @param {Folder} folder                  The Folder being dropped
     * @param {Array<Document>} documentsToCreate   The documents to create
     * @returns {Promise<void>}
     * @protected
     */
    protected _createDroppedFolderDocuments(folder: Folder, documentsToCreate: Array<Document>): Promise<void>;
    /**
     * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
     * @returns {object[]}   The Array of context options passed to the ContextMenu instance
     * @protected
     */
    protected _getFolderContextOptions(): object[];
    /**
     * Get the set of ContextMenu options which should be used for Documents in a SidebarDirectory
     * @returns {object[]}   The Array of context options passed to the ContextMenu instance
     * @protected
     */
    protected _getEntryContextOptions(): object[];
    /**
     * @deprecated since v11
     * @ignore
     */
    _onCreateDocument(event: any): any;
    /**
     * @deprecated since v11
     * @ignore
     */
    _handleDroppedDocument(target: any, data: any): any;
    #private;
}
/**
 * An application for configuring data across all installed and active packages.
 */
declare class PackageConfiguration extends FormApplication {
    static get categoryOrder(): string[];
    /** @override */
    static override get defaultOptions(): any;
    /**
     * The name of the currently active tab.
     * @type {string}
     */
    get activeCategory(): string;
    /** @override */
    override getData(options?: {}): {
        categories: any[];
        total: number;
    };
    /**
     * Prepare the structure of category data which is rendered in this configuration form.
     * @abstract
     * @protected
     */
    protected _prepareCategoryData(): {
        categories: any[];
        total: number;
    };
    /**
     * Classify what Category an Action belongs to
     * @param {string} namespace                The entry to classify
     * @returns {{id: string, title: string}}   The category the entry belongs to
     * @protected
     */
    protected _categorizeEntry(namespace: string): {
        id: string;
        title: string;
    };
    /**
     * Reusable logic for how categories are sorted in relation to each other.
     * @param {object} a
     * @param {object} b
     * @protected
     */
    protected _sortCategories(a: object, b: object): any;
    /** @inheritDoc */
    _render(force: any, { activeCategory, ...options }?: {
        activeCategory: any;
    }): Promise<void>;
    /** @override */
    override _onChangeTab(event: any, tabs: any, active: any): void;
    /** @override */
    override _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
    /**
     * Handle button click to reset default settings
     * @param {Event} event   The initial button click event
     * @abstract
     * @protected
     */
    protected _onResetDefaults(event: Event): void;
}
/**
 * Render the Sidebar container, and after rendering insert Sidebar tabs.
 */
declare class Sidebar extends Application {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * Singleton application instances for each sidebar tab
     * @type {Object<SidebarTab>}
     */
    tabs: any;
    /**
     * Track whether the sidebar container is currently collapsed
     * @type {boolean}
     */
    _collapsed: boolean;
    /**
     * Return the name of the active Sidebar tab
     * @type {string}
     */
    get activeTab(): string;
    /**
     * Singleton application instances for each popout tab
     * @type {Object<SidebarTab>}
     */
    get popouts(): any;
    /** @override */
    override getData(options?: {}): {
        tabs: {
            chat: {
                tooltip: any;
                icon: any;
                notification: string;
            };
            combat: {
                tooltip: any;
                icon: any;
            };
            scenes: {
                tooltip: any;
                icon: any;
            };
            actors: {
                tooltip: any;
                icon: any;
            };
            items: {
                tooltip: any;
                icon: any;
            };
            journal: {
                tooltip: string;
                icon: any;
            };
            tables: {
                tooltip: any;
                icon: any;
            };
            cards: {
                tooltip: any;
                icon: any;
            };
            playlists: {
                tooltip: any;
                icon: any;
            };
            compendium: {
                tooltip: string;
                icon: string;
            };
            settings: {
                tooltip: string;
                icon: string;
            };
        };
    };
    /** @inheritdoc */
    _render(force: any, options: any): Promise<void>;
    /**
     * Expand the Sidebar container from a collapsed state.
     * Take no action if the sidebar is already expanded.
     */
    expand(): void;
    /**
     * Collapse the sidebar to a minimized state.
     * Take no action if the sidebar is already collapsed.
     */
    collapse(): void;
    /** @inheritdoc */
    activateListeners(html: any): void;
    /** @override */
    override _onChangeTab(event: any, tabs: any, active: any): void;
    /**
     * Handle the special case of left-clicking a tab when the sidebar is collapsed.
     * @param {MouseEvent} event  The originating click event
     * @private
     */
    private _onLeftClickTab;
    /**
     * Handle right-click events on tab controls to trigger pop-out containers for each tab
     * @param {Event} event     The originating contextmenu event
     * @private
     */
    private _onRightClickTab;
    /**
     * Handle toggling of the Sidebar container's collapsed or expanded state
     * @param {Event} event
     * @private
     */
    private _onToggleCollapse;
}
/**
 * The Application responsible for displaying and editing a single Actor document.
 * This Application is responsible for rendering an actor's attributes and allowing the actor to be edited.
 * @extends {DocumentSheet}
 * @category - Applications
 * @param {Actor} actor                     The Actor instance being displayed within the sheet.
 * @param {DocumentSheetOptions} [options]  Additional application configuration options.
 */
declare class ActorSheet extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    get title(): any;
    /**
     * A convenience reference to the Actor document
     * @type {Actor}
     */
    get actor(): Actor;
    /**
     * If this Actor Sheet represents a synthetic Token actor, reference the active Token
     * @type {Token|null}
     */
    get token(): Function;
    /** @inheritdoc */
    close(options: any): Promise<void>;
    /** @inheritdoc */
    _getSubmitData(updateData?: {}): any;
    /**
     * Handle requests to configure the Token for the Actor
     * @param {PointerEvent} event      The originating click event
     * @private
     */
    private _onConfigureToken;
    /** @inheritdoc */
    _canDragStart(selector: any): any;
    /** @inheritdoc */
    _canDragDrop(selector: any): any;
    /** @inheritdoc */
    _onDragStart(event: any): void;
    /** @inheritdoc */
    _onDrop(event: any): Promise<any>;
    /**
     * Handle the dropping of ActiveEffect data onto an Actor Sheet
     * @param {DragEvent} event                  The concluding DragEvent which contains drop data
     * @param {object} data                      The data transfer extracted from the event
     * @returns {Promise<ActiveEffect|boolean>}  The created ActiveEffect object or false if it couldn't be created.
     * @protected
     */
    protected _onDropActiveEffect(event: DragEvent, data: object): Promise<ActiveEffect | boolean>;
    /**
     * Handle dropping of an Actor data onto another Actor sheet
     * @param {DragEvent} event            The concluding DragEvent which contains drop data
     * @param {object} data                The data transfer extracted from the event
     * @returns {Promise<object|boolean>}  A data object which describes the result of the drop, or false if the drop was
     *                                     not permitted.
     * @protected
     */
    protected _onDropActor(event: DragEvent, data: object): Promise<object | boolean>;
    /**
     * Handle dropping of an item reference or item data onto an Actor Sheet
     * @param {DragEvent} event            The concluding DragEvent which contains drop data
     * @param {object} data                The data transfer extracted from the event
     * @returns {Promise<Item[]|boolean>}  The created or updated Item instances, or false if the drop was not permitted.
     * @protected
     */
    protected _onDropItem(event: DragEvent, data: object): Promise<Item[] | boolean>;
    /**
     * Handle dropping of a Folder on an Actor Sheet.
     * The core sheet currently supports dropping a Folder of Items to create all items as owned items.
     * @param {DragEvent} event     The concluding DragEvent which contains drop data
     * @param {object} data         The data transfer extracted from the event
     * @returns {Promise<Item[]>}
     * @protected
     */
    protected _onDropFolder(event: DragEvent, data: object): Promise<Item[]>;
    /**
     * Handle the final creation of dropped Item data on the Actor.
     * This method is factored out to allow downstream classes the opportunity to override item creation behavior.
     * @param {object[]|object} itemData     The item data requested for creation
     * @returns {Promise<Item[]>}
     * @private
     */
    private _onDropItemCreate;
    /**
     * Handle a drop event for an existing embedded Item to sort that Item relative to its siblings
     * @param {Event} event
     * @param {Object} itemData
     * @private
     */
    private _onSortItem;
}
/**
 * An interface for packaging Adventure content and loading it to a compendium pack.
 * // TODO - add a warning if you are building the adventure with any missing content
 * // TODO - add a warning if you are building an adventure that sources content from a different package' compendium
 */
declare class AdventureExporter extends DocumentSheet {
    /** @inheritDoc */
    static get defaultOptions(): any;
    constructor(document: any, options?: {});
    /**
     * An alias for the Adventure document
     * @type {Adventure}
     */
    adventure: Adventure;
    /**
     * @typedef {Object} AdventureContentTreeNode
     * @property {string} id        An alias for folder.id
     * @property {string} name      An alias for folder.name
     * @property {Folder} folder    The Folder at this node level
     * @property {string} state     The modification state of the Folder
     * @property {AdventureContentTreeNode[]} children  An array of child nodes
     * @property {{id: string, name: string, document: ClientDocument, state: string}[]} documents  An array of documents
     */
    /**
     * @typedef {AdventureContentTreeNode} AdventureContentTreeRoot
     * @property {null} id                The folder ID is null at the root level
     * @property {string} documentName    The Document name contained in this tree
     * @property {string} collection      The Document collection name of this tree
     * @property {string} name            The name displayed at the root level of the tree
     * @property {string} icon            The icon displayed at the root level of the tree
     * @property {string} collapseIcon    The icon which represents the current collapsed state of the tree
     * @property {string} cssClass        CSS classes which describe the display of the tree
     * @property {number} documentCount   The number of documents which are present in the tree
     */
    /**
     * The prepared document tree which is displayed in the form.
     * @type {Object<AdventureContentTreeRoot>}
     */
    contentTree: any;
    /** @override */
    override getData(options?: {}): Promise<{
        adventure: Adventure;
        contentTree: any;
    }>;
    /** @inheritdoc */
    _onDrop(event: any): Promise<any>;
    /**
     * Stage a document for addition to the Adventure.
     * This adds the document locally, the change is not yet submitted to the database.
     * @param {Folder|ClientDocument} document    Some document to be added to the Adventure.
     */
    addContent(document: Folder | ClientDocument): void;
    /**
     * Remove a single Document from the Adventure.
     * @param {ClientDocument} document       The Document being removed from the Adventure.
     */
    removeContent(document: ClientDocument): any;
    #private;
}
/**
 * An interface for importing an adventure from a compendium pack.
 */
declare class AdventureImporter extends DocumentSheet {
    /** @inheritDoc */
    static get defaultOptions(): any;
    /**
     * An alias for the Adventure document
     * @type {Adventure}
     */
    adventure: Adventure;
    /** @override */
    override getData(options?: {}): Promise<{
        adventure: Adventure;
        contents: {
            icon: string;
            label: string;
            count: number;
        }[];
        imported: boolean;
    }>;
    /**
     * Handle toggling the import all checkbox.
     * @param {Event} event  The change event.
     * @protected
     */
    protected _onToggleImportAll(event: Event): void;
    /**
     * Prepare a list of content types provided by this adventure.
     * @returns {{icon: string, label: string, count: number}[]}
     * @protected
     */
    protected _getContentList(): {
        icon: string;
        label: string;
        count: number;
    }[];
    /** @override */
    override _updateObject(event: any, formData: any): Promise<void | AdventureImportResult>;
    /**
     * Mirror Adventure#import but call AdventureImporter#_importContent and AdventureImport#_prepareImportData
     * @deprecated since v11
     * @ignore
     */
    _importLegacy(formData: any): Promise<void>;
    /**
     * @deprecated since v11
     * @ignore
     */
    _prepareImportData(formData: any): Promise<AdventureImportData>;
    /**
     * @deprecated since v11
     * @ignore
     */
    _importContent(toCreate: any, toUpdate: any, documentCount: any): Promise<AdventureImportResult>;
}
/**
 * The Application responsible for displaying a basic sheet for any Document sub-types that do not have a sheet
 * registered.
 * @extends {DocumentSheet}
 */
declare class BaseSheet extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    getData(options?: {}): Promise<{
        cssClass: string;
        editable: any;
        document: ClientDocument;
        data: any;
        limited: any;
        options: any;
        owner: any;
        title: string;
    }>;
}
/**
 * A DocumentSheet application responsible for displaying and editing a single embedded Card document.
 * @extends {DocumentSheet}
 * @param {Card} object                     The {@link Card} object being configured.
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class CardConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    getData(options?: {}): any;
    /**
     * Handle card face control actions which modify single cards on the sheet.
     * @param {PointerEvent} event          The originating click event
     * @returns {Promise}                   A Promise which resolves once the handler has completed
     * @protected
     */
    protected _onFaceControl(event: PointerEvent): Promise<any>;
}
/**
 * A DocumentSheet application responsible for displaying and editing a single Cards stack.
 */
declare class CardsConfig extends DocumentSheet {
    /**
     * The allowed sorting methods which can be used for this sheet
     * @enum {string}
     */
    static SORT_TYPES: {
        STANDARD: string;
        SHUFFLED: string;
    };
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * The CardsConfig sheet is constructed by providing a Cards document and sheet-level options.
     * @param {Cards} object                    The {@link Cards} object being configured.
     * @param {DocumentSheetOptions} [options]  Application configuration options.
     */
    constructor(object: Cards, options?: DocumentSheetOptions);
    /** @inheritdoc */
    getData(options?: {}): any;
    /**
     * Handle card control actions which modify single cards on the sheet.
     * @param {PointerEvent} event          The originating click event
     * @returns {Promise}                   A Promise which resolves once the handler has completed
     * @protected
     */
    protected _onCardControl(event: PointerEvent): Promise<any>;
    /**
     * Handle lazy-loading card face images.
     * See {@link SidebarTab#_onLazyLoadImage}
     * @param {IntersectionObserverEntry[]} entries   The entries which are now in the observer frame
     * @param {IntersectionObserver} observer         The intersection observer instance
     * @protected
     */
    protected _onLazyLoadImage(entries: IntersectionObserverEntry[], observer: IntersectionObserver): any;
    /** @inheritdoc */
    _canDragStart(selector: any): any;
    /** @inheritdoc */
    _onDragStart(event: any): void;
    /** @inheritdoc */
    _canDragDrop(selector: any): any;
    /** @inheritdoc */
    _onDrop(event: any): Promise<any>;
    /**
     * Handle sorting a Card relative to other siblings within this document
     * @param {Event} event     The drag drop event
     * @param {Card} card       The card being dragged
     * @private
     */
    private _onSortCard;
}
/**
 * A subclass of CardsConfig which provides a sheet representation for Cards documents with the "hand" type.
 */
declare class CardsHand extends CardsConfig {
}
/**
 * A subclass of CardsConfig which provides a sheet representation for Cards documents with the "pile" type.
 */
declare class CardsPile extends CardsConfig {
}
/**
 * The Application responsible for configuring the CombatTracker and its contents.
 * @extends {FormApplication}
 */
declare class CombatTrackerConfig extends FormApplication {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @override */
    override getData(options?: {}): Promise<{
        settings: any;
        attributeChoices: any;
        combatTheme: any;
        selectedTheme: any;
        user: User;
    }>;
    /** @override */
    override _updateObject(event: any, formData: any): Promise<any>;
    /** @override */
    override _onChangeInput(event: any): Promise<any>;
    #private;
}
/**
 * The Application responsible for configuring a single Combatant document within a parent Combat.
 * @extends {DocumentSheet}
 */
declare class CombatantConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @override */
    override get title(): any;
}
/**
 * An Application responsible for allowing GMs to configure the default sheets that are used for the Documents in their
 * world.
 */
declare class DefaultSheetsConfig extends PackageConfiguration {
    /** @inheritdoc */
    _prepareCategoryData(): {
        categories: {
            title: any;
            id: any;
            count: any;
            subTypes: any;
        }[];
        total: number;
    };
    /** @inheritdoc */
    _updateObject(event: any, formData: any): Promise<any>;
    /** @inheritdoc */
    _onResetDefaults(event: any): Promise<void>;
}
/**
 * The Application responsible for configuring a single ActiveEffect document within a parent Actor or Item.
 * @extends {DocumentSheet}
 *
 * @param {ActiveEffect} object             The target active effect being configured
 * @param {DocumentSheetOptions} [options]  Additional options which modify this application instance
 */
declare class ActiveEffectConfig extends DocumentSheet {
    /** @override */
    static override get defaultOptions(): any;
    /** @override */
    override getData(options?: {}): Promise<any>;
    /**
     * Provide centralized handling of mouse clicks on control buttons.
     * Delegate responsibility out to action-specific handlers depending on the button action.
     * @param {MouseEvent} event      The originating click event
     * @private
     */
    private _onEffectControl;
    /**
     * Handle adding a new change to the changes array.
     * @private
     */
    private _addEffectChange;
    /** @inheritdoc */
    _getSubmitData(updateData?: {}): any;
}
/**
 * The Application responsible for configuring a single Folder document.
 * @extends {DocumentSheet}
 * @param {Folder} object                   The {@link Folder} object to configure.
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class FolderConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @override */
    override get title(): any;
    /** @override */
    override getData(options?: {}): Promise<{
        folder: any;
        name: any;
        newName: any;
        safeColor: any;
        sortingModes: {
            a: string;
            m: string;
        };
        submitText: any;
    }>;
}
/**
 * @typedef {object} NewFontDefinition
 * @property {string} [family]          The font family.
 * @property {number} [weight=400]      The font weight.
 * @property {string} [style="normal"]  The font style.
 * @property {string} [src=""]          The font file.
 * @property {string} [preview]         The text to preview the font.
 */
/**
 * A class responsible for configuring custom fonts for the world.
 * @extends {FormApplication}
 */
declare class FontConfig extends FormApplication {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * Whether a font is distributed to connected clients or found on their OS.
     * @enum {string}
     */
    static FONT_TYPES: {
        FILE: string;
        SYSTEM: string;
    };
    /**
     * Define the setting key where this world's font information will be stored.
     * @type {string}
     */
    static SETTING: string;
    /**
     * A list of fonts that were correctly loaded and are available for use.
     * @type {Set<string>}
     * @private
     */
    private static "__#191@#available";
    /**
     * Get the list of fonts that successfully loaded.
     * @returns {string[]}
     */
    static getAvailableFonts(): string[];
    /**
     * Get the list of fonts formatted for display with selectOptions.
     * @returns {Object<string>}
     */
    static getAvailableFontChoices(): any;
    /**
     * Load a font definition.
     * @param {string} family                    The font family name (case-sensitive).
     * @param {FontFamilyDefinition} definition  The font family definition.
     * @returns {Promise<boolean>}               Returns true if the font was successfully loaded.
     */
    static loadFont(family: string, definition: {
        /**
         * Whether the font is available in the rich text editor. This will also enable it
         * for notes and drawings.
         */
        editor: boolean;
        /**
         * Individual font face definitions for this font family. If this is empty, the
         * font family may only be loaded from the client's OS-installed fonts.
         */
        fonts: FontFaceDescriptors[];
    }): Promise<boolean>;
    /**
     * Ensure that fonts have loaded and are ready for use.
     * Enforce a maximum timeout in milliseconds.
     * Proceed after that point even if fonts are not yet available.
     * @param {number} [ms=4500]  The maximum time to spend loading fonts before proceeding.
     * @returns {Promise<void>}
     * @internal
     */
    static _loadFonts(ms?: number): Promise<void>;
    /**
     * Collect all the font definitions and combine them.
     * @returns {Object<FontFamilyDefinition>[]}
     * @protected
     */
    protected static _collectDefinitions(): any[];
    /**
     * Create FontFace object from a FontDefinition.
     * @param {string} family        The font family name.
     * @param {FontDefinition} font  The font definition.
     * @returns {FontFace}
     * @protected
     */
    protected static _createFontFace(family: string, font: FontFaceDescriptors): FontFace;
    /**
     * Format a font definition for display.
     * @param {string} family              The font family.
     * @param {FontDefinition} definition  The font definition.
     * @returns {string}                   The formatted definition.
     * @private
     */
    private static _formatFont;
    /**
     * An application for configuring custom world fonts.
     * @param {NewFontDefinition} [object]  The default settings for new font definition creation.
     * @param {object} [options]            Additional options to configure behaviour.
     */
    constructor(object?: NewFontDefinition, options?: object);
    /** @inheritdoc */
    getData(options?: {}): {
        fonts: any[];
        selected: any;
        font: any;
        family: string;
        weights: {
            value: number;
            label: string;
        }[];
    };
    /**
     * Template data for a given font definition.
     * @param {string} family                    The font family.
     * @param {FontFamilyDefinition} definition  The font family definition.
     * @returns {object[]}
     * @protected
     */
    protected _getDataForDefinition(family: string, definition: {
        /**
         * Whether the font is available in the rich text editor. This will also enable it
         * for notes and drawings.
         */
        editor: boolean;
        /**
         * Individual font face definitions for this font family. If this is empty, the
         * font family may only be loaded from the client's OS-installed fonts.
         */
        fonts: FontFaceDescriptors[];
    }): object[];
    /** @inheritdoc */
    _updateObject(event: any, formData: any): Promise<void>;
    /**
     * Handle application controls.
     * @param {MouseEvent} event  The click event.
     * @protected
     */
    protected _onClickControl(event: MouseEvent): void | Promise<void>;
    /** @inheritdoc */
    _onChangeInput(event: any): Promise<any>;
    /**
     * Update available font fields based on the font type selected.
     * @protected
     */
    protected _updateFontFields(): void;
    /**
     * Add a new custom font definition.
     * @protected
     */
    protected _onAddFont(): Promise<void>;
    /**
     * Delete a font.
     * @param {MouseEvent} event  The click event.
     * @protected
     */
    protected _onDeleteFont(event: MouseEvent): Promise<void>;
    /**
     * Select a font to preview.
     * @param {MouseEvent} event  The click event.
     * @protected
     */
    protected _onSelectFont(event: MouseEvent): void;
    #private;
}
/**
 * A tool for fine-tuning the grid in a Scene
 * @param {Scene} scene                       The scene whose grid is being configured.
 * @param {SceneConfig} sheet                 The Scene Configuration sheet that spawned this dialog.
 * @param {FormApplicationOptions} [options]  Application configuration options.
 */
declare class GridConfig extends FormApplication {
    /** @override */
    static override get defaultOptions(): any;
    constructor(scene: any, sheet: any, ...args: any[]);
    /**
     * Track the Scene Configuration sheet reference
     * @type {SceneConfig}
     */
    sheet: SceneConfig;
    /** @override */
    override getData(options?: {}): {
        gridTypes: any;
        scale: number;
        scene: any;
    };
    /** @override */
    override _getSubmitData(updateData?: {}): any;
    /**
     * Handle keyboard events.
     * @param {KeyboardEvent} event    The original keydown event
     * @private
     */
    private _onKeyDown;
    /**
     * Handle mousewheel events.
     * @param {WheelEvent} event    The original wheel event
     * @private
     */
    private _onWheel;
    /** @override */
    override _onChangeInput(event: any): Promise<void>;
    /** @override */
    override _updateObject(event: any, formData: any): Promise<any>;
    /**
     * Temporarily refresh the display of the BackgroundLayer and GridLayer for the new pending dimensions
     * @param {object} options          Options which define how the refresh is performed
     * @param {boolean} [options.background]      Refresh the background display?
     * @param {object} [options.grid]             Refresh the grid display?
     * @private
     */
    private _refresh;
    /**
     * Reset the scene back to its original settings
     * @private
     */
    private _reset;
    /**
     * Scale the background size relative to the grid size
     * @param {number} delta          The directional change in background size
     * @private
     */
    private _scaleBackgroundSize;
    /**
     * Scale the grid size relative to the background image.
     * When scaling the grid size in this way, constrain the allowed values between 50px and 300px.
     * @param {number} delta          The grid size in pixels
     * @private
     */
    private _scaleGridSize;
    /**
     * Shift the background image relative to the grid layer
     * @param {object} position       The position configuration to preview
     * @param {number} position.deltaX    The number of pixels to shift in the x-direction
     * @param {number} position.deltaY    The number of pixels to shift in the y-direction
     * @private
     */
    private _shiftBackground;
    #private;
}
/**
 * @typedef {FormApplicationOptions} ImagePopoutOptions
 * @property {string} [caption]           Caption text to display below the image.
 * @property {string|null} [uuid=null]    The UUID of some related {@link Document}.
 * @property {boolean} [showTitle]        Force showing or hiding the title.
 */
/**
 * An Image Popout Application which features a single image in a lightbox style frame.
 * Furthermore, this application allows for sharing the display of an image with other connected players.
 * @param {string} src                    The image URL.
 * @param {ImagePopoutOptions} [options]  Application configuration options.
 *
 * @example Creating an Image Popout
 * ```js
 * // Construct the Application instance
 * const ip = new ImagePopout("path/to/image.jpg", {
 *   title: "My Featured Image",
 *   uuid: game.actors.getName("My Hero").uuid
 * });
 *
 * // Display the image popout
 * ip.render(true);
 *
 * // Share the image with other connected players
 * ip.share();
 * ```
 */
declare class ImagePopout extends FormApplication {
    /**
     * Determine the correct position and dimensions for the displayed image
     * @param {string} img  The image URL.
     * @returns {Object}    The positioning object which should be used for rendering
     */
    static getPosition(img: string): any;
    /**
     * Determine the Image dimensions given a certain path
     * @param {string} path  The image source.
     * @returns {Promise<[number, number]>}
     */
    static getImageSize(path: string): Promise<[number, number]>;
    /**
     * Determine the dimensions of the given video file.
     * @param {string} src  The URL to the video.
     * @returns {Promise<[number, number]>}
     */
    static getVideoSize(src: string): Promise<[number, number]>;
    /**
     * Handle a received request to display an image.
     * @param {ShareImageConfig} config  The image configuration data.
     * @returns {ImagePopout}
     * @internal
     */
    static _handleShareImage({ image, title, caption, uuid, showTitle }?: {
        /**
         * The image URL to share.
         */
        image: string;
        /**
         * The image title.
         */
        title: string;
        /**
         * The UUID of a Document related to the image, used to determine permission to see
         *         the image title.
         */
        uuid?: string;
        /**
         * If this is provided, the permissions of the related Document will be ignored and
         *   the title will be shown based on this parameter.
         */
        showTitle?: boolean;
        /**
         * A list of user IDs to show the image to.
         */
        users?: string[];
    }): ImagePopout;
    /**
     * Whether the application should display video content.
     * @type {boolean}
     */
    get isVideo(): boolean;
    /** @override */
    override getData(options?: {}): Promise<{
        image: any;
        options: any;
        title: string;
        caption: any;
        showTitle: boolean;
        isVideo: boolean;
    }>;
    /**
     * Test whether the title of the image popout should be visible to the user
     * @returns {boolean}
     */
    isTitleVisible(): boolean;
    /**
     * Provide a reference to the Document referenced by this popout, if one exists
     * @returns {Promise<ClientDocument>}
     */
    getRelatedObject(): Promise<ClientDocument>;
    /** @override */
    override _render(...args: any[]): Promise<void>;
    /**
     * @typedef {object} ShareImageConfig
     * @property {string} image         The image URL to share.
     * @property {string} title         The image title.
     * @property {string} [uuid]        The UUID of a Document related to the image, used to determine permission to see
     *                                  the image title.
     * @property {boolean} [showTitle]  If this is provided, the permissions of the related Document will be ignored and
     *                                  the title will be shown based on this parameter.
     * @property {string[]} [users]     A list of user IDs to show the image to.
     */
    /**
     * Share the displayed image with other connected Users
     * @param {ShareImageConfig} [options]
     */
    shareImage(options?: {
        /**
         * The image URL to share.
         */
        image: string;
        /**
         * The image title.
         */
        title: string;
        /**
         * The UUID of a Document related to the image, used to determine permission to see
         *         the image title.
         */
        uuid?: string;
        /**
         * If this is provided, the permissions of the related Document will be ignored and
         *   the title will be shown based on this parameter.
         */
        showTitle?: boolean;
        /**
         * A list of user IDs to show the image to.
         */
        users?: string[];
    }): void;
    #private;
}
/**
 * The Application responsible for displaying and editing a single Item document.
 * @param {Item} item                       The Item instance being displayed within the sheet.
 * @param {DocumentSheetOptions} [options]  Additional application configuration options.
 */
declare class ItemSheet extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    get title(): any;
    /**
     * A convenience reference to the Item document
     * @type {Item}
     */
    get item(): Item;
    /**
     * The Actor instance which owns this item. This may be null if the item is unowned.
     * @type {Actor}
     */
    get actor(): Actor;
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage document.
 * @extends {DocumentSheet}
 * @param {JournalEntryPage} object         The JournalEntryPage instance which is being edited.
 * @param {DocumentSheetOptions} [options]  Application options.
 */
declare class JournalPageSheet extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    get title(): any;
    /**
     * The table of contents for this JournalTextPageSheet.
     * @type {Object<JournalEntryPageHeading>}
     */
    toc: any;
    /** @inheritdoc */
    getData(options?: {}): any;
    /** @inheritdoc */
    _getSecretContent(secret: any): any;
    /** @inheritdoc */
    _updateSecret(secret: any, content: any): any;
    /**
     * Update the parent sheet if it is open when the server autosaves the contents of this editor.
     * @param {string} html  The updated editor contents.
     */
    onAutosave(html: string): void;
    /**
     * Update the UI appropriately when receiving new steps from another client.
     */
    onNewSteps(): void;
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage text document.
 * @extends {JournalPageSheet}
 */
declare class JournalTextPageSheet extends JournalPageSheet {
    /**
     * Bi-directional HTML <-> Markdown converter.
     * @type {showdown.Converter}
     * @protected
     */
    protected static _converter: showdown.Converter;
    /**
     * Declare the format that we edit text content in for this sheet so we can perform conversions as necessary.
     * @type {number}
     */
    static get format(): number;
    /** @inheritdoc */
    getData(options?: {}): Promise<any>;
    /**
     * Determine if any editors are dirty.
     * @returns {boolean}
     */
    isEditorDirty(): boolean;
    /**
     * Lazily convert text formats if we detect the document being saved in a different format.
     * @param {object} renderData  Render data.
     * @protected
     */
    protected _convertFormats(renderData: object): void;
    #private;
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage image document.
 * @extends {JournalPageSheet}
 */
declare class JournalImagePageSheet extends JournalPageSheet {
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage video document.
 * @extends {JournalPageSheet}
 */
declare class JournalVideoPageSheet extends JournalPageSheet {
    /**
     * Get the YouTube player parameters depending on whether the sheet is being viewed or edited.
     * @returns {object}
     * @protected
     */
    protected _getYouTubeVars(): object;
    /** @inheritdoc */
    _getSubmitData(updateData?: {}): any;
    /**
     * Convert time components to a timestamp in seconds.
     * @param {{[h]: number, [m]: number, [s]: number}} components  The time components.
     * @returns {number}                                            The timestamp, in seconds.
     * @protected
     */
    protected _timeComponentsToTimestamp({ h, m, s }?: {
        [h]: number;
        [m]: number;
        [s]: number;
    }): number;
    /**
     * Convert a timestamp in seconds into separate time components.
     * @param {number} timestamp                           The timestamp, in seconds.
     * @returns {{[h]: number, [m]: number, [s]: number}}  The individual time components.
     * @protected
     */
    protected _timestampToTimeComponents(timestamp: number): {};
}
/**
 * The Application responsible for displaying and editing a single JournalEntryPage PDF document.
 * @extends {JournalPageSheet}
 */
declare class JournalPDFPageSheet extends JournalPageSheet {
    /**
     * Maintain a cache of PDF sizes to avoid making HEAD requests every render.
     * @type {Object<number>}
     * @protected
     */
    protected static _sizes: any;
    /**
     * Handle a request to load a PDF.
     * @param {MouseEvent} event  The triggering event.
     * @protected
     */
    protected _onLoadPDF(event: MouseEvent): void;
    /**
     * Retrieve parameters to pass to the PDF viewer.
     * @returns {URLSearchParams}
     * @protected
     */
    protected _getViewerParams(): URLSearchParams;
}
/**
 * A subclass of {@link JournalTextPageSheet} that implements a markdown editor for editing the text content.
 * @extends {JournalTextPageSheet}
 */
declare class MarkdownJournalPageSheet extends JournalTextPageSheet {
    /**
     * Store the dirty flag for this editor.
     * @type {boolean}
     * @protected
     */
    protected _isDirty: boolean;
    /** @inheritdoc */
    _onDrop(event: any): Promise<void>;
    /**
     * Handle dropping a content link onto the editor.
     * @param {object} eventData  The parsed event data.
     * @protected
     */
    protected _onDropContentLink(eventData: object): Promise<void>;
}
/**
 * A subclass of {@link JournalTextPageSheet} that implements a TinyMCE editor.
 * @extends {JournalTextPageSheet}
 */
declare class JournalTextTinyMCESheet extends JournalTextPageSheet {
    /** @inheritdoc */
    close(options?: {}): Promise<any>;
    /** @inheritdoc */
    _render(force: any, options: any): Promise<any>;
}
/**
 * @typedef {DocumentSheetOptions} JournalSheetOptions
 * @property {string|null} [sheetMode]  The current display mode of the journal. Either 'text' or 'image'.
 */
/**
 * The Application responsible for displaying and editing a single JournalEntry document.
 * @extends {DocumentSheet}
 * @param {JournalEntry} object            The JournalEntry instance which is being edited
 * @param {JournalSheetOptions} [options]  Application options
 */
declare class JournalSheet extends DocumentSheet {
    /**
     * Available view modes for journal entries.
     * @enum {number}
     */
    static VIEW_MODES: {
        SINGLE: number;
        MULTIPLE: number;
    };
    /**
     * The minimum amount of content that must be visible before the next page is marked as in view. Cannot be less than
     * 25% without also modifying the IntersectionObserver threshold.
     * @type {number}
     */
    static INTERSECTION_RATIO: number;
    /**
     * Icons for page ownership.
     * @enum {string}
     */
    static OWNERSHIP_ICONS: {
        [x: number]: string;
    };
    /**
     * The cached list of processed page entries.
     * This array is populated in the getData method.
     * @type {object[]}
     * @protected
     */
    protected _pages: object[];
    /**
     * Get the journal entry's current view mode.
     * @see {@link JournalSheet.VIEW_MODES}
     * @returns {number}
     */
    get mode(): number;
    /**
     * The current search mode for this journal
     * @type {string}
     */
    get searchMode(): string;
    /**
     * Toggle the search mode for this journal between "name" and "full" text search
     */
    toggleSearchMode(): void;
    /**
     * The pages that are currently scrolled into view and marked as 'active' in the sidebar.
     * @type {HTMLElement[]}
     */
    get pagesInView(): HTMLElement[];
    /**
     * The index of the currently viewed page.
     * @type {number}
     */
    get pageIndex(): number;
    /**
     * The currently active IntersectionObserver.
     * @type {IntersectionObserver}
     */
    get observer(): IntersectionObserver;
    /**
     * Is the table-of-contents sidebar currently collapsed?
     * @type {boolean}
     */
    get sidebarCollapsed(): boolean;
    /**
     * Prepare pages for display.
     * @returns {JournalEntryPage[]}  The sorted list of pages.
     * @protected
     */
    protected _getPageData(): JournalEntryPage[];
    /**
     * Identify which page of the journal sheet should be currently rendered.
     * This can be controlled by options passed into the render method or by a subclass override.
     * @param {object} options    Sheet rendering options
     * @param {number} [options.pageIndex]    A numbered index of page to render
     * @param {string} [options.pageId]       The ID of a page to render
     * @returns {number}      The currently displayed page index
     * @protected
     */
    protected _getCurrentPage({ pageIndex, pageId }?: {
        pageIndex?: number;
        pageId?: string;
    }): number;
    /**
     * Activate listeners after page content has been injected.
     * @protected
     */
    protected _activatePageListeners(): void;
    /**
     * @inheritdoc
     * @param {number} [options.mode]       Render the sheet in a given view mode, see {@link JournalSheet.VIEW_MODES}.
     * @param {string} [options.pageId]     Render the sheet with the page with the given ID in view.
     * @param {number} [options.pageIndex]  Render the sheet with the page at the given index in view.
     * @param {string} [options.anchor]     Render the sheet with the given anchor for the given page in view.
     * @param {boolean} [options.tempOwnership]  Whether the journal entry or one of its pages is being shown to players
     *                                           who might otherwise not have permission to view it.
     * @param {boolean} [options.collapsed] Render the sheet with the TOC sidebar collapsed?
     */
    _render(force: any, options?: {}): Promise<void>;
    /**
     * Update child views inside the main sheet.
     * @returns {Promise<void>}
     * @protected
     */
    protected _renderPageViews(): Promise<void>;
    /**
     * Add headings to the table of contents for the given page node.
     * @param {HTMLElement} pageNode                 The HTML node of the page's rendered contents.
     * @param {Object<JournalEntryPageHeading>} toc  The page's table of contents.
     * @protected
     */
    protected _renderHeadings(pageNode: HTMLElement, toc: any): Promise<void>;
    /**
     * Create an intersection observer to maintain a list of headings that are in view. This is much more performant than
     * calling getBoundingClientRect on all headings whenever we want to determine this list.
     * @protected
     */
    protected _observeHeadings(): void;
    /**
     * Handle clicking the previous and next page buttons.
     * @param {JQuery.TriggeredEvent} event  The button click event.
     * @protected
     */
    protected _onAction(event: JQuery.TriggeredEvent): any;
    /**
     * Prompt the user with a Dialog for creation of a new JournalEntryPage
     */
    createPage(): any;
    /**
     * Turn to the previous page.
     */
    previousPage(): any;
    /**
     * Turn to the next page.
     */
    nextPage(): any;
    /**
     * Turn to a specific page.
     * @param {string} pageId    The ID of the page to turn to.
     * @param {string} [anchor]  Optionally an anchor slug to focus within that page.
     */
    goToPage(pageId: string, anchor?: string): any;
    /**
     * Retrieve the sheet instance for rendering this page inline.
     * @param {string} pageId  The ID of the page.
     * @returns {JournalPageSheet}
     */
    getPageSheet(pageId: string): JournalPageSheet;
    /**
     * Determine whether a page is visible to the current user.
     * @param {JournalEntryPage} page  The page.
     * @returns {boolean}
     */
    isPageVisible(page: JournalEntryPage): boolean;
    /**
     * Toggle the collapsed or expanded state of the Journal Entry table-of-contents sidebar.
     */
    toggleSidebar(): void;
    /**
     * Update the disabled state of the previous and next page buttons.
     * @protected
     */
    protected _updateButtonState(): void;
    /**
     * Edit one of this JournalEntry's JournalEntryPages.
     * @param {JQuery.TriggeredEvent} event  The originating page edit event.
     * @protected
     */
    protected _onEditPage(event: JQuery.TriggeredEvent): any;
    /**
     * Handle clicking an entry in the sidebar to scroll that heading into view.
     * @param {JQuery.TriggeredEvent} event  The originating click event.
     * @protected
     */
    protected _onClickPageLink(event: JQuery.TriggeredEvent): void;
    /**
     * Handle clicking an image to pop it out for fullscreen view.
     * @param {MouseEvent} event  The click event.
     * @protected
     */
    protected _onClickImage(event: MouseEvent): void;
    /**
     * Handle new pages scrolling into view.
     * @param {IntersectionObserverEntry[]} entries  An Array of elements that have scrolled into or out of view.
     * @param {IntersectionObserver} observer        The IntersectionObserver that invoked this callback.
     * @protected
     */
    protected _onPageScroll(entries: IntersectionObserverEntry[], observer: IntersectionObserver): void;
    /**
     * Highlights the currently viewed page in the sidebar.
     * @protected
     */
    protected _activatePagesInView(): void;
    /**
     * If the set of active pages has changed, various elements in the sidebar will expand and collapse. For particularly
     * long ToCs, this can leave the scroll position of the sidebar in a seemingly random state. We try to do our best to
     * sync the sidebar scroll position with the current journal viewport.
     * @protected
     */
    protected _synchronizeSidebar(): void;
    /** @inheritdoc */
    _contextMenu(html: any): void;
    /**
     * Handle opening the context menu.
     * @param {HTMLElement} target  The element the context menu has been triggered for.
     * @protected
     */
    protected _onContextMenuOpen(target: HTMLElement): void;
    /**
     * Handle closing the context menu.
     * @param {HTMLElement} target  The element the context menu has been triggered for.
     * @protected
     */
    protected _onContextMenuClose(target: HTMLElement): void;
    /**
     * Get the set of ContextMenu options which should be used for JournalEntryPages in the sidebar.
     * @returns {ContextMenuEntry[]}  The Array of context options passed to the ContextMenu instance.
     * @protected
     */
    protected _getEntryContextOptions(): ContextMenuEntry[];
    /**
     * Handle requests to show the referenced Journal Entry to other Users
     * Save the form before triggering the show request, in case content has changed
     * @param {Event} event   The triggering click event
     */
    _onShowPlayers(event: Event): Promise<void | JournalEntry | JournalEntryPage>;
    /** @inheritdoc */
    _canDragStart(selector: any): any;
    /** @inheritdoc */
    _canDragDrop(selector: any): any;
    /** @inheritdoc */
    _onDragStart(event: any): void;
    /** @inheritdoc */
    _onDrop(event: any): Promise<any>;
    /** @inheritdoc */
    _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
    #private;
}
/**
 * A Macro configuration sheet
 * @extends {DocumentSheet}
 *
 * @param {Macro} object                    The Macro Document which is being configured
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class MacroConfig extends DocumentSheet {
    /** @override */
    static override get defaultOptions(): any;
    /** @inheritdoc */
    _disableFields(form: any): void;
    /**
     * Save and execute the macro using the button on the configuration sheet
     * @param {MouseEvent} event      The originating click event
     * @return {Promise<void>}
     * @private
     */
    private _onExecute;
}
/**
 * The Application responsible for configuring a single MeasuredTemplate document within a parent Scene.
 * @param {MeasuredTemplate} object         The {@link MeasuredTemplate} being configured.
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class MeasuredTemplateConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    getData(): any;
}
/**
 * A generic application for configuring permissions for various Document types
 * @extends {DocumentSheet}
 */
declare class DocumentOwnershipConfig extends DocumentSheet {
    /** @override */
    static override get defaultOptions(): any;
    /** @override */
    override getData(options?: {}): {
        currentDefault: any;
        instructions: any;
        defaultLevels: any;
        playerLevels: {
            level: number;
            label: any;
        }[];
        isFolder: boolean;
        users: any;
    };
}
/**
 * @deprecated since v10
 * @ignore
 */
declare class PermissionControl extends DocumentOwnershipConfig {
    constructor(...args: any[]);
}
/**
 * The Application responsible for configuring a single Playlist document.
 * @extends {DocumentSheet}
 * @param {Playlist} object                 The {@link Playlist} to configure.
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class PlaylistConfig extends DocumentSheet {
    /** @inheritdoc */
    _getFilePickerOptions(event: any): any;
    /** @inheritdoc */
    _onSelectFile(selection: any, filePicker: any): Promise<any>;
}
/**
 * The Application responsible for configuring a single PlaylistSound document within a parent Playlist.
 * @extends {DocumentSheet}
 *
 * @param {PlaylistSound} sound             The PlaylistSound document being configured
 * @param {DocumentSheetOptions} [options]  Additional application rendering options
 */
declare class PlaylistSoundConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    activateListeners(html: any): any;
    /**
     * Auto-populate the track name using the provided filename, if a name is not already set
     * @param {Event} event
     * @private
     */
    private _onSourceChange;
}
/**
 * The Application responsible for displaying and editing a single RollTable document.
 * @param {RollTable} table                 The RollTable document being configured
 * @param {DocumentSheetOptions} [options]  Additional application configuration options
 */
declare class RollTableConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    getData(options?: {}): Promise<any>;
    /**
     * Handle creating a TableResult in the RollTable document
     * @param {MouseEvent} event        The originating mouse event
     * @param {object} [resultData]     An optional object of result data to use
     * @returns {Promise}
     * @private
     */
    private _onCreateResult;
    /**
     * Submit the entire form when a table result type is changed, in case there are other active changes
     * @param {Event} event
     * @private
     */
    private _onChangeResultType;
    /**
     * Handle deleting a TableResult from the RollTable document
     * @param {MouseEvent} event        The originating click event
     * @returns {Promise<TableResult>}   The deleted TableResult document
     * @private
     */
    private _onDeleteResult;
    /** @inheritdoc */
    _onDrop(event: any): Promise<any>;
    /**
     * Handle changing the actor profile image by opening a FilePicker
     * @param {Event} event
     * @private
     */
    private _onEditImage;
    /**
     * Handle a button click to re-normalize dice result ranges across all RollTable results
     * @param {Event} event
     * @private
     */
    private _onNormalizeResults;
    /**
     * Handle toggling the drawn status of the result in the table
     * @param {Event} event
     * @private
     */
    private _onLockResult;
    /**
     * Reset the Table to it's original composition with all options unlocked
     * @param {Event} event
     * @private
     */
    private _onResetTable;
    /**
     * Handle drawing a result from the RollTable
     * @param {Event} event
     * @private
     */
    private _onRollTable;
    /**
     * Configure the update object workflow for the Roll Table configuration sheet
     * Additional logic is needed here to reconstruct the results array from the editable fields on the sheet
     * @param {Event} event            The form submission event
     * @param {Object} formData        The validated FormData translated into an Object for submission
     * @returns {Promise}
     * @private
     */
    private _updateObject;
    /**
     * Display a roulette style animation when a Roll Table result is drawn from the sheet
     * @param {TableResult[]} results     An Array of drawn table results to highlight
     * @returns {Promise}                  A Promise which resolves once the animation is complete
     * @protected
     */
    protected _animateRoll(results: TableResult[]): Promise<any>;
    /**
     * Animate a "roulette" through the table until arriving at the final loop and a drawn result
     * @param {HTMLOListElement} ol     The list element being iterated
     * @param {Set<string>} drawnIds    The result IDs which have already been drawn
     * @param {number} nLoops           The number of times to loop through the animation
     * @param {number} animTime         The desired animation time in milliseconds
     * @param {number} animOffset       The desired pixel offset of the result within the list
     * @returns {Promise}               A Promise that resolves once the animation is complete
     * @protected
     */
    protected _animateRoulette(ol: HTMLOListElement, drawnIds: Set<string>, nLoops: number, animTime: number, animOffset: number): Promise<any>;
    /**
     * Display a flashing animation on the selected result to emphasize the draw
     * @param {HTMLElement} item      The HTML &lt;li> item of the winning result
     * @returns {Promise}              A Promise that resolves once the animation is complete
     * @protected
     */
    protected _flashResult(item: HTMLElement): Promise<any>;
}
/**
 * The Application responsible for configuring a single Scene document.
 * @extends {DocumentSheet}
 * @param {Scene} object                    The Scene Document which is being configured
 * @param {DocumentSheetOptions} [options]  Application configuration options.
 */
declare class SceneConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * Get an enumeration of the available grid types which can be applied to this Scene
     * @returns {object}
     * @internal
     */
    static _getGridTypes(): object;
    /**
     * Indicates if width / height should change together to maintain aspect ratio
     * @type {boolean}
     */
    linkedDimensions: boolean;
    /** @inheritdoc */
    render(force: any, options?: {}): any;
    /**
     * Get the available weather effect types which can be applied to this Scene
     * @returns {object}
     * @private
     */
    private _getWeatherTypes;
    /**
     * Get the alphabetized Documents which can be chosen as a configuration for the Scene
     * @param {WorldCollection} collection
     * @returns {object[]}
     * @private
     */
    private _getDocuments;
    /**
     * Capture the current Scene position and zoom level as the initial view in the Scene config
     * @param {Event} event   The originating click event
     * @private
     */
    private _onCapturePosition;
    /**
     * Handle click events to open the grid configuration application
     * @param {Event} event   The originating click event
     * @private
     */
    private _onGridConfig;
    /**
     * Handle click events to link or unlink the scene dimensions
     * @param {Event} event
     * @returns {Promise<void>}
     * @private
     */
    private _onLinkDimensions;
    /** @override */
    override _onChangeInput(event: any): Promise<any>;
    /** @override */
    override _onChangeColorPicker(event: any): void;
    /** @override */
    override _onChangeRange(event: any): void;
    /**
     * Live update the scene as certain properties are changed.
     * @param {string} changed  The changed property.
     * @private
     */
    private _previewScene;
    /**
     * Reset the previewed darkness level, background color, grid alpha, and grid color back to their true values.
     * @private
     */
    private _resetScenePreview;
    /**
     * Handle updating the select menu of PlaylistSound options when the Playlist is changed
     * @param {Event} event   The initiating select change event
     * @private
     */
    private _onChangePlaylist;
    /**
     * Handle updating the select menu of JournalEntryPage options when the JournalEntry is changed.
     * @param {Event} event  The initiating select change event.
     * @protected
     */
    protected _onChangeJournal(event: Event): void;
    /**
     * Handle updating the select menu of JournalEntryPage options when the JournalEntry is changed.
     * @param event
     * @private
     */
    private _onChangeDimensions;
}
/**
 * Document Sheet Configuration Application
 */
declare class DocumentSheetConfig extends FormApplication {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * An array of pending sheet assignments which are submitted before other elements of the framework are ready.
     * @type {object[]}
     * @private
     */
    private static "__#196@#pending";
    /**
     * Marshal information on the available sheet classes for a given document type and sub-type, and format it for
     * display.
     * @param {string} documentName  The Document type.
     * @param {string} subType       The Document sub-type.
     * @returns {{sheetClasses: object, defaultClasses: object, defaultClass: string}}
     */
    static getSheetClassesForSubType(documentName: string, subType: string): {
        sheetClasses: object;
        defaultClasses: object;
        defaultClass: string;
    };
    /**
     * Initialize the configured Sheet preferences for Documents which support dynamic Sheet assignment
     * Create the configuration structure for supported documents
     * Process any pending sheet registrations
     * Update the default values from settings data
     */
    static initializeSheets(): void;
    static _getDocumentTypes(cls: any, types?: any[]): any;
    /**
     * Register a sheet class as a candidate which can be used to display documents of a given type
     * @param {typeof ClientDocument} documentClass  The Document class for which to register a new Sheet option
     * @param {string} scope                         Provide a unique namespace scope for this sheet
     * @param {typeof DocumentSheet} sheetClass      A defined Application class used to render the sheet
     * @param {object} [config]                      Additional options used for sheet registration
     * @param {string|Function} [config.label]       A human-readable label for the sheet name, which will be localized
     * @param {string[]} [config.types]              An array of document types for which this sheet should be used
     * @param {boolean} [config.makeDefault=false]   Whether to make this sheet the default for provided types
     * @param {boolean} [config.canBeDefault=true]   Whether this sheet is available to be selected as a default sheet for
     *                                               all Documents of that type.
     * @param {boolean} [config.canConfigure=true]   Whether this sheet appears in the sheet configuration UI for users.
     */
    static registerSheet(documentClass: any, scope: string, sheetClass: typeof DocumentSheet, { label, types, makeDefault, canBeDefault, canConfigure }?: {
        label?: string | Function;
        types?: string[];
        makeDefault?: boolean;
        canBeDefault?: boolean;
        canConfigure?: boolean;
    }): void;
    /**
     * Perform the sheet registration.
     * @param {object} config                               Configuration for how the sheet should be registered
     * @param {typeof ClientDocument} config.documentClass  The Document class being registered
     * @param {string} config.id                            The sheet ID being registered
     * @param {string} config.label                         The human-readable sheet label
     * @param {typeof DocumentSheet} config.sheetClass      The sheet class definition being registered
     * @param {object[]} config.types                       An array of types for which this sheet is added
     * @param {boolean} config.makeDefault                  Make this sheet the default for provided types?
     * @param {boolean} config.canBeDefault                 Whether this sheet is available to be selected as a default
     *                                                      sheet for all Documents of that type.
     * @param {boolean} config.canConfigure                 Whether the sheet appears in the sheet configuration UI for
     *                                                      users.
     */
    static "__#196@#registerSheet"({ documentClass, id, label, sheetClass, types, makeDefault, canBeDefault, canConfigure }?: {
        documentClass: typeof ClientDocument;
        id: string;
        label: string;
        sheetClass: typeof DocumentSheet;
        types: object[];
        makeDefault: boolean;
        canBeDefault: boolean;
        canConfigure: boolean;
    }): void;
    /**
     * Unregister a sheet class, removing it from the list of available Applications to use for a Document type
     * @param {typeof ClientDocument} documentClass  The Document class for which to register a new Sheet option
     * @param {string} scope                         Provide a unique namespace scope for this sheet
     * @param {typeof DocumentSheet} sheetClass      A defined DocumentSheet subclass used to render the sheet
     * @param {object} [config]
     * @param {object[]} [config.types]              An Array of types for which this sheet should be removed
     */
    static unregisterSheet(documentClass: any, scope: string, sheetClass: typeof DocumentSheet, { types }?: {
        types?: object[];
    }): void;
    /**
     * Perform the sheet de-registration.
     * @param {object} config                               Configuration for how the sheet should be un-registered
     * @param {typeof ClientDocument} config.documentClass  The Document class being unregistered
     * @param {string} config.id                            The sheet ID being unregistered
     * @param {object[]} config.types                       An array of types for which this sheet is removed
     */
    static "__#196@#unregisterSheet"({ documentClass, id, types }?: {
        documentClass: typeof ClientDocument;
        id: string;
        types: object[];
    }): void;
    /**
     * Update the current default Sheets using a new core world setting.
     * @param {object} setting
     */
    static updateDefaultSheets(setting?: object): void;
    /**
     * Initialize default sheet configurations for all document types.
     * @private
     */
    private static _registerDefaultSheets;
    /** @inheritDoc */
    getData(options?: {}): {
        isGM: any;
        object: any;
        options: any;
        sheetClass: any;
        blankLabel: any;
        sheetClasses: any;
        defaultClass: any;
        defaultClasses: any;
    };
    /** @inheritdoc */
    _updateObject(event: any, formData: any): Promise<any>;
}
/**
 * The Application responsible for configuring a single User document.
 * @extends {DocumentSheet}
 *
 * @param {User} user                       The User document being configured.
 * @param {DocumentSheetOptions} [options]  Additional rendering options which modify the behavior of the form.
 */
declare class UserConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    getData(options?: {}): {
        user: any;
        actors: any;
        options: any;
    };
    /**
     * Handle changing the user avatar image by opening a FilePicker
     * @private
     */
    private _onEditAvatar;
}
/**
 * @typedef {Option} ChatBubbleOptions
 * @property {string[]} [cssClasses]    An optional array of CSS classes to apply to the resulting bubble
 * @property {boolean} [pan=true]       Pan to the token speaker for this bubble, if allowed by the client
 * @property {boolean} [requireVisible=false] Require that the token be visible in order for the bubble to be rendered
 */
/**
 * The Chat Bubble Class
 * This application displays a temporary message sent from a particular Token in the active Scene.
 * The message is displayed on the HUD layer just above the Token.
 */
declare class ChatBubbles {
    /**
     * Activate Socket event listeners which apply to the ChatBubbles UI.
     * @param {Socket} socket     The active web socket connection
     * @internal
     */
    static _activateSocketListeners(socket: Socket): void;
    template: string;
    /**
     * Track active Chat Bubbles
     * @type {object}
     */
    bubbles: object;
    /**
     * Track which Token was most recently panned to highlight
     * Use this to avoid repeat panning
     * @type {Token}
     * @private
     */
    private _panned;
    /**
     * A reference to the chat bubbles HTML container in which rendered bubbles should live
     * @returns {jQuery}
     */
    get container(): JQueryStatic;
    /**
     * Create a chat bubble message for a certain token which is synchronized for display across all connected clients.
     * @param {TokenDocument} token           The speaking Token Document
     * @param {string} message                The spoken message text
     * @param {ChatBubbleOptions} [options]   Options which affect the bubble appearance
     * @returns {Promise<jQuery|null>}        A promise which resolves with the created bubble HTML, or null
     */
    broadcast(token: TokenDocument, message: string, options?: ChatBubbleOptions): Promise<JQueryStatic | null>;
    /**
     * Speak a message as a particular Token, displaying it as a chat bubble
     * @param {Token} token                   The speaking Token
     * @param {string} message                The spoken message text
     * @param {ChatBubbleOptions} [options]   Options which affect the bubble appearance
     * @returns {Promise<jQuery|null>}        A Promise which resolves to the created bubble HTML element, or null
     */
    say(token: Function, message: string, { cssClasses, requireVisible, pan }?: ChatBubbleOptions): Promise<JQueryStatic | null>;
    /**
     * Clear any existing chat bubble for a certain Token
     * @param {Token} token
     * @private
     */
    private _clearBubble;
    /**
     * Render the HTML template for the chat bubble
     * @param {object} data         Template data
     * @returns {Promise<string>}   The rendered HTML
     * @private
     */
    private _renderHTML;
    /**
     * Before displaying the chat message, determine it's constrained and unconstrained dimensions
     * @param {string} message    The message content
     * @returns {object}          The rendered message dimensions
     * @private
     */
    private _getMessageDimensions;
    /**
     * Assign styling parameters to the chat bubble, toggling either a left or right display (randomly)
     * @param {Token} token             The speaking Token
     * @param {JQuery} html             Chat bubble content
     * @param {Rectangle} dimensions    Positioning data
     * @private
     */
    private _setPosition;
    /**
     * Determine the length of time for which to display a chat bubble.
     * Research suggests that average reading speed is 200 words per minute.
     * Since these are short-form messages, we multiply reading speed by 1.5.
     * Clamp the result between 1 second (minimum) and 20 seconds (maximum)
     * @param {jQuery} html     The HTML message
     * @returns {number}        The number of milliseconds for which to display the message
     */
    _getDuration(html: JQueryStatic): number;
}
/**
 * Render the HUD container
 * @type {Application}
 */
declare class HeadsUpDisplay extends Application {
    constructor(...args: any[]);
    /**
     * Token HUD
     * @type {TokenHUD}
     */
    token: TokenHUD;
    /**
     * Tile HUD
     * @type {TileHUD}
     */
    tile: TileHUD;
    /**
     * Drawing HUD
     * @type {DrawingHUD}
     */
    drawing: DrawingHUD;
    /**
     * Chat Bubbles
     * @type {ChatBubbles}
     */
    bubbles: ChatBubbles;
    /** @inheritdoc */
    getData(options?: {}): {
        width?: undefined;
        height?: undefined;
    } | {
        width: any;
        height: any;
    };
    /** @inheritdoc */
    _render(force: any, options: any): Promise<void>;
    /**
     * Align the position of the HUD layer to the current position of the canvas
     */
    align(): void;
}
/**
 * @typedef {Object} SceneControlTool
 * @property {string} name
 * @property {string} title
 * @property {string} icon
 * @property {boolean} visible
 * @property {boolean} toggle
 * @property {boolean} active
 * @property {boolean} button
 * @property {Function} onClick
 * @property {ToolclipConfiguration} toolclip  Configuration for rendering the tool's toolclip.
 */
/**
 * @typedef {Object} SceneControl
 * @property {string} name
 * @property {string} title
 * @property {string} layer
 * @property {string} icon
 * @property {boolean} visible
 * @property {SceneControlTool[]} tools
 * @property {string} activeTool
 */
/**
 * @typedef {object} ToolclipConfiguration
 * @property {string} src                         The filename of the toolclip video.
 * @property {string} heading                     The heading string.
 * @property {ToolclipConfigurationItem[]} items  The items in the toolclip body.
 */
/**
 * @typedef {object} ToolclipConfigurationItem
 * @property {string} [paragraph]  A plain paragraph of content for this item.
 * @property {string} [heading]    A heading for the item.
 * @property {string} [content]    Content for the item.
 * @property {string} [reference]  If the item is a single key reference, use this instead of content.
 */
/**
 * Scene controls navigation menu
 * @extends {Application}
 */
declare class SceneControls extends Application {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * The Array of Scene Control buttons which are currently rendered
     * @type {SceneControl[]}
     */
    controls: SceneControl[];
    /**
     * The currently active control set
     * @type {string}
     */
    get activeControl(): string;
    /**
     * The currently active tool in the control palette
     * @type {string}
     */
    get activeTool(): string;
    /**
     * Return the active control set
     * @type {SceneControl|null}
     */
    get control(): SceneControl;
    /**
     * Return the actively controlled tool
     * @type {SceneControlTool|null}
     */
    get tool(): SceneControlTool;
    /**
     * Initialize the Scene Controls by obtaining the set of control buttons and rendering the HTML
     * @param {object} options      Options which modify how the controls UI is initialized
     * @param {string} [options.control]      An optional control set to set as active
     * @param {string} [options.layer]        An optional layer name to target as the active control
     * @param {string} [options.tool]         A specific named tool to set as active for the palette
     */
    initialize({ control, layer, tool }?: {
        control?: string;
        layer?: string;
        tool?: string;
    }): void;
    /** @inheritdoc */
    getData(options?: {}): Promise<{
        controls: any[];
        active: boolean;
        cssClass: string;
    }>;
    /** @inheritdoc */
    activateListeners(html: any): void;
    /**
     * Handle click events on a Control set
     * @param {Event} event   A click event on a tool control
     * @private
     */
    private _onClickLayer;
    /**
     * Handle click events on Tool controls
     * @param {Event} event   A click event on a tool control
     * @private
     */
    private _onClickTool;
    /**
     * Get the set of Control sets and tools that are rendered as the Scene Controls.
     * These controls may be extended using the "getSceneControlButtons" Hook.
     * @returns {SceneControl[]}
     * @private
     */
    private _getControlButtons;
    /**
     * @deprecated since v10
     * @ignore
     */
    get isRuler(): boolean;
    #private;
}
/**
 * The global action bar displayed at the bottom of the game view.
 * The Hotbar is a UI element at the bottom of the screen which contains Macros as interactive buttons.
 * The Hotbar supports 5 pages of global macros which can be dragged and dropped to organize as you wish.
 *
 * Left-clicking a Macro button triggers its effect.
 * Right-clicking the button displays a context menu of Macro options.
 * The number keys 1 through 0 activate numbered hotbar slots.
 * Pressing the delete key while hovering over a Macro will remove it from the bar.
 *
 * @see {@link Macros}
 * @see {@link Macro}
 */
declare class Hotbar extends Application {
    /** @override */
    static override get defaultOptions(): any;
    /**
     * Handle toggling a document sheet.
     * @param {string} uuid     The Document UUID to display
     * @returns {Promise<void>|Application|*}
     */
    static toggleDocumentSheet(uuid: string): Promise<void> | Application | any;
    constructor(options: any);
    /**
     * The currently viewed macro page
     * @type {number}
     */
    page: number;
    /**
     * The currently displayed set of macros
     * @type {Macro[]}
     */
    macros: Macro[];
    /**
     * Track collapsed state
     * @type {boolean}
     */
    _collapsed: boolean;
    /**
     * Track which hotbar slot is the current hover target, if any
     * @type {number|null}
     */
    _hover: number | null;
    /**
     * Whether the hotbar is locked.
     * @returns {boolean}
     */
    get locked(): boolean;
    /** @override */
    override getData(options?: {}): {
        page: number;
        macros: Macro[];
        barClass: string;
        locked: boolean;
    };
    /**
     * Get the Array of Macro (or null) values that should be displayed on a numbered page of the bar
     * @param {number} page
     * @returns {Macro[]}
     * @private
     */
    private _getMacrosByPage;
    /**
     * Collapse the Hotbar, minimizing its display.
     * @returns {Promise}    A promise which resolves once the collapse animation completes
     */
    collapse(): Promise<any>;
    /**
     * Expand the Hotbar, displaying it normally.
     * @returns {Promise}    A promise which resolves once the expand animation completes
     */
    expand(): Promise<any>;
    /**
     * Change to a specific numbered page from 1 to 5
     * @param {number} page     The page number to change to.
     */
    changePage(page: number): void;
    /**
     * Change the page of the hotbar by cycling up (positive) or down (negative)
     * @param {number} direction    The direction to cycle
     */
    cyclePage(direction: number): void;
    /** @override */
    override activateListeners(html: any): void;
    /** @inheritdoc */
    _contextMenu(html: any): void;
    /**
     * Get the Macro entry context options
     * @returns {object[]}  The Macro entry context options
     * @private
     */
    private _getEntryContextOptions;
    /**
     * Handle left-click events to
     * @param {MouseEvent} event    The originating click event
     * @protected
     */
    protected _onClickMacro(event: MouseEvent): Promise<any>;
    /**
     * Handle pagination controls
     * @param {Event} event   The originating click event
     * @private
     */
    private _onClickPageControl;
    /** @override */
    override _canDragStart(selector: any): boolean;
    /** @override */
    override _onDragStart(event: any): boolean;
    /** @override */
    override _canDragDrop(selector: any): boolean;
    /** @override */
    override _onDrop(event: any): Promise<any>;
    /**
     * Create a Macro which rolls a RollTable when executed
     * @param {Document} table    The RollTable document
     * @returns {Promise<Macro>}  A created Macro document to add to the bar
     * @private
     */
    private _createRollTableRollMacro;
    /**
     * Create a Macro document which can be used to toggle display of a Journal Entry.
     * @param {Document} doc          A Document which should be toggled
     * @returns {Promise<Macro>}      A created Macro document to add to the bar
     * @protected
     */
    protected _createDocumentSheetToggle(doc: Document): Promise<Macro>;
    /**
     * Handle click events to toggle display of the macro bar
     * @param {Event} event
     * @private
     */
    private _onToggleBar;
    /**
     * Toggle the hotbar's lock state.
     * @returns {Promise<Hotbar>}
     * @protected
     */
    protected _toggleHotbarLock(): Promise<Hotbar>;
}
/**
 * An abstract base class for displaying a heads-up-display interface bound to a Placeable Object on the canvas
 * @type {Application}
 * @abstract
 * @interface
 * @param {PlaceableObject} object        The {@link PlaceableObject} this HUD is bound to.
 * @param {ApplicationOptions} [options]  Application configuration options.
 */
declare class BasePlaceableHUD extends Application {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * Reference a PlaceableObject this HUD is currently bound to
     * @type {PlaceableObject}
     */
    object: PlaceableObject;
    /**
     * Convenience access for the canvas layer which this HUD modifies
     * @type {PlaceablesLayer}
     */
    get layer(): PlaceablesLayer;
    /**
     * Bind the HUD to a new PlaceableObject and display it
     * @param {PlaceableObject} object    A PlaceableObject instance to which the HUD should be bound
     */
    bind(object: PlaceableObject): void;
    /**
     * Clear the HUD by fading out it's active HTML and recording the new display state
     */
    clear(): void;
    /** @override */
    override _render(...args: any[]): Promise<void>;
    /** @override */
    override getData(options?: {}): any;
    /** @override */
    override setPosition({ left, top, width, height, scale }?: {
        left: any;
        top: any;
        width: any;
        height: any;
        scale: any;
    }): void;
    /** @override */
    override activateListeners(html: any): void;
    /**
     * Handle mouse clicks to control a HUD control button
     * @param {PointerEvent} event    The originating click event
     * @protected
     */
    protected _onClickControl(event: PointerEvent): Promise<any>;
    /**
     * Toggle the visible state of all controlled objects in the Layer
     * @param {PointerEvent} event    The originating click event
     * @private
     */
    private _onToggleVisibility;
    /**
     * Toggle locked state of all controlled objects in the Layer
     * @param {PointerEvent} event    The originating click event
     * @private
     */
    private _onToggleLocked;
    /**
     * Handle sorting the z-order of the object
     * @param {boolean} up            Move the object upwards in the vertical stack?
     * @param {PointerEvent} event    The originating mouse click event
     * @returns {Promise}
     * @protected
     */
    protected _onSort(event: PointerEvent, up: boolean): Promise<any>;
}
/**
 * The main menu application which is toggled via the ESC key.
 * @extends {Application}
 */
declare class MainMenu extends Application {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * The structure of menu items
     * @returns {Object<{label: string, icon: string, enabled: boolean, onClick: Function}>}
     */
    get items(): any;
    /** @inheritdoc */
    getData(options?: {}): {
        items: any;
    };
    /** @inheritdoc */
    activateListeners(html: any): void;
    /**
     * Toggle display of the menu (or render it in the first place)
     */
    toggle(): void;
}
/**
 * The UI element which displays the Scene documents which are currently enabled for quick navigation.
 */
declare class SceneNavigation extends Application {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * Display progress of some major operation like loading Scene textures.
     * @param {object} options    Options for how the progress bar is displayed
     * @param {string} options.label  A text label to display
     * @param {number} options.pct    A percentage of progress between 0 and 100
     */
    static displayProgressBar({ label, pct }?: {
        label: string;
        pct: number;
    }): void;
    constructor(options: any);
    /**
     * Navigation collapsed state
     * @type {boolean}
     */
    _collapsed: boolean;
    /**
     * Return an Array of Scenes which are displayed in the Navigation bar
     * @returns {Scene[]}
     */
    get scenes(): Scene[];
    /** @inheritdoc */
    render(force: any, context?: {}): any;
    /** @inheritdoc */
    _render(force: any, options: any): Promise<void>;
    /** @inheritdoc */
    getData(options?: {}): {
        collapsed: boolean;
        scenes: {
            id: any;
            active: any;
            name: string;
            tooltip: any;
            users: any;
            visible: any;
            css: any;
        }[];
    };
    /**
     * A hook event that fires when the SceneNavigation menu is expanded or collapsed.
     * @function collapseSceneNavigation
     * @memberof hookEvents
     * @param {SceneNavigation} sceneNavigation The SceneNavigation application
     * @param {boolean} collapsed               Whether the SceneNavigation is now collapsed or not
     */
    /**
     * Expand the SceneNavigation menu, sliding it down if it is currently collapsed
     */
    expand(): true | Promise<any>;
    /**
     * Collapse the SceneNavigation menu, sliding it up if it is currently expanded
     * @returns {Promise<boolean>}
     */
    collapse(): Promise<boolean>;
    /** @inheritdoc */
    activateListeners(html: any): void;
    /**
     * Get the set of ContextMenu options which should be applied for Scenes in the menu
     * @returns {object[]}   The Array of context options passed to the ContextMenu instance
     * @private
     */
    private _getContextMenuOptions;
    /**
     * Handle left-click events on the scenes in the navigation menu
     * @param {PointerEvent} event
     * @private
     */
    private _onClickScene;
    /** @override */
    override _onDragStart(event: any): void;
    /** @override */
    override _onDrop(event: any): Promise<any>;
    /**
     * Handle navigation menu toggle click events
     * @param {Event} event
     * @private
     */
    private _onToggleNav;
}
/**
 * Pause notification in the HUD
 * @extends {Application}
 */
declare class Pause extends Application {
    /** @override */
    override getData(options?: {}): {
        paused: boolean;
    };
}
/**
 * The UI element which displays the list of Users who are currently playing within the active World.
 * @extends {Application}
 */
declare class PlayerList extends Application {
    /** @override */
    static override get defaultOptions(): any;
    constructor(options: any);
    /**
     * An internal toggle for whether to show offline players or hide them
     * @type {boolean}
     * @private
     */
    private _showOffline;
    /**
     * Whether the players list is in a configuration where it is hidden.
     * @returns {boolean}
     */
    get isHidden(): boolean;
    /** @override */
    override render(force: any, context?: {}): any;
    /** @override */
    override getData(options?: {}): {
        users: any;
        hide: boolean;
        showOffline: boolean;
    };
    /**
     * Prepare a displayed name string for the User which includes their name, pronouns, character, or GM tag.
     * @returns {string}
     * @protected
     */
    protected _getDisplayName(user: any): string;
    /**
     * Position this Application in the main DOM appropriately.
     * @protected
     */
    protected _positionInDOM(): void;
    /** @override */
    override activateListeners(html: any): void;
    /**
     * Return the default context options available for the Players application
     * @returns {object[]}
     * @private
     */
    private _getUserContextOptions;
    /**
     * Toggle display of the Players hud setting for whether to display offline players
     * @param {Event} event   The originating click event
     * @private
     */
    private _onToggleOfflinePlayers;
    #private;
}
/**
 * Audio/Video Conferencing Configuration Sheet
 * @extends {FormApplication}
 *
 * @param {AVMaster} object                   The {@link AVMaster} instance being configured.
 * @param {FormApplicationOptions} [options]  Application configuration options.
 */
declare class AVConfig extends FormApplication {
    /** @override */
    static override get defaultOptions(): any;
    constructor(object: any, options: any);
    /** @override */
    override getData(options?: {}): Promise<{
        user: User;
        modes: {
            [x: number]: string;
        };
        voiceModes: {};
        serverTypes: {
            FVTT: string;
            custom: string;
        };
        turnTypes: {
            server: string;
            custom: string;
        };
        settings: any;
        canSelectMode: boolean;
        noSSL: boolean;
        videoSources: any;
        audioSources: any;
        audioSinks: any;
        videoSrcUnavailable: boolean;
        audioSrcUnavailable: boolean;
        audioSinkUnavailable: boolean;
        audioDisabled: boolean;
        videoDisabled: boolean;
        nameplates: {
            [x: number]: string;
        };
        nameplateSetting: any;
        dockPositions: {
            [k: string]: any;
        };
    }>;
    /**
     * Set a section's input to enabled or disabled
     * @param {string} selector    Selector for the section to enable or disable
     * @param {boolean} enabled    Whether to enable or disable this section
     * @private
     */
    private _setConfigSectionEnabled;
    /**
     * Determine whether a given video or audio source, or audio sink has become
     * unavailable since the last time it was set.
     * @param {object} sources The available devices
     * @param {string} source  The selected device
     * @private
     */
    private _isSourceUnavailable;
    /**
     * Callback when the turn server type changes
     * Will enable or disable the turn section based on whether the user selected a custom turn or not
     * @param {Event} event   The event that triggered the turn server type change
     * @private
     */
    private _onTurnTypeChanged;
    /** @override */
    override _updateObject(event: any, formData: any): Promise<void>;
}
/**
 * Abstraction of the Application interface to be used with the Draggable class as a substitute for the app
 * This class will represent one popout feed window and handle its positioning and draggability
 * @param {CameraViews} view      The CameraViews application that this popout belongs to
 * @param {string} userId         ID of the user this popout belongs to
 * @param {jQuery} element        The div element of this specific popout window
 */
declare class CameraPopoutAppWrapper {
    constructor(view: any, userId: any, element: any);
    view: any;
    element: any;
    userId: any;
    popOut: boolean;
    options: {};
    /**
     * Get the current position of this popout window
     */
    get position(): any;
    /** @override */
    override setPosition(options?: {}): any;
    _onResize(event: any): void;
    /** @override */
    override bringToTop(): void;
}
/**
 * The Camera UI View that displays all the camera feeds as individual video elements.
 * @type {Application}
 *
 * @param {WebRTC} webrtc                 The WebRTC Implementation to display
 * @param {ApplicationOptions} [options]  Application configuration options.
 */
declare class CameraViews extends Application {
    /** @override */
    static override get defaultOptions(): any;
    /**
     * A custom sorting function that orders/arranges the user display frames
     * @return {number}
     * @private
     */
    private static _sortUsers;
    /**
     * A reference to the master AV orchestrator instance
     * @type {AVMaster}
     */
    get webrtc(): AVMaster;
    /**
     * If all camera views are popped out, hide the dock.
     * @type {boolean}
     */
    get hidden(): boolean;
    /**
     * Obtain a reference to the div.camera-view which is used to portray a given Foundry User.
     * @param {string} userId     The ID of the User document
     * @return {HTMLElement|null}
     */
    getUserCameraView(userId: string): HTMLElement | null;
    /**
     * Obtain a reference to the video.user-camera which displays the video channel for a requested Foundry User.
     * If the user is not broadcasting video this will return null.
     * @param {string} userId     The ID of the User document
     * @return {HTMLVideoElement|null}
     */
    getUserVideoElement(userId: string): HTMLVideoElement | null;
    /**
     * Sets whether a user is currently speaking or not
     *
     * @param {string} userId     The ID of the user
     * @param {boolean} speaking  Whether the user is speaking
     */
    setUserIsSpeaking(userId: string, speaking: boolean): void;
    /**
     * Extend the render logic to first check whether a render is necessary based on the context
     * If a specific context was provided, make sure an update to the navigation is necessary before rendering
     */
    render(force: any, context?: {}): any;
    /** @override */
    override _render(force?: boolean, options?: {}): Promise<void>;
    /** @inheritdoc */
    setPosition({ left, top, width, scale }?: {
        left: any;
        top: any;
        width: any;
        scale: any;
    }): void | {
        left: number;
        top: number;
        width: number;
        height: number;
        scale: number;
    };
    /** @override */
    override getData(options?: {}): {
        self: User;
        muteAll: any;
        borderColors: any;
        dockClass: string;
        hidden: boolean;
        users: any[];
        nameplates: {
            cssClass: any;
            playerName: boolean;
            charname: boolean;
        };
    };
    maxZ: number;
    /**
     * Prepare rendering data for a single user
     * @private
     */
    private _getDataForUser;
    /** @override */
    override activateListeners(html: any): void;
    /**
     * On hover in a camera container, show/hide the controls.
     * @event {Event} event   The original mouseover or mouseout hover event
     * @private
     */
    private _onCameraViewHover;
    /**
     * On clicking on a toggle, disable/enable the audio or video stream.
     * @event {MouseEvent} event   The originating click event
     * @private
     */
    private _onClickControl;
    /**
     * Change volume control for a stream
     * @param {Event} event   The originating change event from interaction with the range input
     * @private
     */
    private _onVolumeChange;
    /**
     * Dynamically refresh the state of a single camera view
     * @param {string} userId  The ID of the user whose view we want to refresh.
     * @protected
     */
    protected _refreshView(userId: string): void;
    /**
     * Render changes needed to the PlayerList ui.
     * Show/Hide players depending on option.
     * @private
     */
    private _setPlayerListVisibility;
    /**
     * Get the icon class that should be used for various action buttons with different toggled states.
     * The returned icon should represent the visual status of the NEXT state (not the CURRENT state).
     *
     * @param {string} action     The named av-control button action
     * @param {boolean} state     The CURRENT action state.
     * @returns {string}          The icon that represents the NEXT action state.
     * @protected
     */
    protected _getToggleIcon(action: string, state: boolean): string;
    /**
     * Get the text title that should be used for various action buttons with different toggled states.
     * The returned title should represent the tooltip of the NEXT state (not the CURRENT state).
     *
     * @param {string} action     The named av-control button action
     * @param {boolean} state     The CURRENT action state.
     * @returns {string}          The icon that represents the NEXT action state.
     * @protected
     */
    protected _getToggleTooltip(action: string, state: boolean): string;
    /**
     * Show or hide UI control elements
     * This replaces the use of jquery.show/hide as it simply adds a class which has display:none
     * which allows us to have elements with display:flex which can be hidden then shown without
     * breaking their display style.
     * This will show/hide the toggle buttons, volume controls and overlay sidebars
     * @param {jQuery} container    The container for which to show/hide control elements
     * @param {boolean} show        Whether to show or hide the controls
     * @param {string} selector     Override selector to specify which controls to show or hide
     * @private
     */
    private _toggleControlVisibility;
}
/**
 * An abstract base class designed to standardize the behavior for a multi-select UI component.
 * Multi-select components return an array of values as part of form submission.
 * Different implementations may provide different experiences around how inputs are presented to the user.
 * @abstract
 * @internal
 * @category - Custom HTML Elements
 * @fires change
 */
declare class AbstractMultiSelectElement extends HTMLElement {
    /**
     * The "change" event is emitted when the values of the multi-select element are changed.
     * @param {Event} event     A "change" event passed to event listeners.
     * @event change
     */
    static onChange: any;
    /**
     * Predefined <option> and <optgroup> elements which were defined in the original HTML.
     * @type {(HTMLOptionElement|HTMLOptgroupElement)[]}
     * @protected
     */
    protected _options: (HTMLOptionElement | HTMLOptgroupElement)[];
    /**
     * An object which maps option values to displayed labels.
     * @type {Object<string, string>}
     * @protected
     */
    protected _choices: {
        [x: string]: string;
    };
    /**
     * An array of identifiers which have been chosen.
     * @type {Set<string>}
     * @protected
     */
    protected _chosen: Set<string>;
    /**
     * The form this custom element belongs to, if any.
     * @type {HTMLFormElement|null}
     */
    form: HTMLFormElement | null;
    /**
     * Preserve existing <option> and <optgroup> elements which are defined in the original HTML.
     * @protected
     */
    protected _initializeOptions(): void;
    set name(arg: string);
    /**
     * The name of the multi-select input element.
     * @type {string}
     */
    get name(): string;
    set value(arg: string[]);
    /**
     * The values of the multi-select input are expressed as an array of strings.
     * @type {string[]}
     */
    get value(): string[];
    /**
     * Activate the custom element when it is attached to the DOM.
     * @inheritDoc
     */
    connectedCallback(): void;
    /**
     * Deactivate the custom element when it is detached from the DOM.
     * @inheritDoc
     */
    disconnectedCallback(): void;
    /**
     * Mark a choice as selected.
     * @param {string} value      The value to add to the chosen set
     */
    select(value: string): void;
    /**
     * Mark a choice as un-selected.
     * @param {string} value      The value to delete from the chosen set
     */
    unselect(value: string): void;
    /**
     * Create the HTML elements that should be included in this custom element.
     * Elements are returned as an array of ordered children.
     * @returns {HTMLElement[]}
     * @protected
     */
    protected _buildElements(): HTMLElement[];
    /**
     * Refresh the active state of the custom element by reflecting changes to the _chosen set.
     * @protected
     */
    protected _refresh(): void;
    /**
     * Activate event listeners which add dynamic behavior to the custom element.
     * @protected
     */
    protected _activateListeners(): void;
    #private;
}
/**
 * Provide a multi-select workflow using a select element as the input mechanism.
 * @internal
 * @category - Custom HTML Elements
 *
 * @example Multi-Select HTML Markup
 * ```html
 * <multi-select name="select-many-things">
 *   <optgroup label="Basic Options">
 *     <option value="foo">Foo</option>
 *     <option value="bar">Bar</option>
 *     <option value="baz">Baz</option>
 *   </optgroup>
 *   <optgroup label="Advanced Options">
 *    <option value="fizz">Fizz</option>
 *     <option value="buzz">Buzz</option>
 *   </optgroup>
 * </multi-select>
 * ```
 */
declare class HTMLMultiSelectElement extends AbstractMultiSelectElement {
    /** @override */
    override _buildElements(): (HTMLDivElement | HTMLSelectElement)[];
    #private;
}
/**
 * Provide a multi-select workflow as a grid of input checkbox elements.
 * @internal
 * @category - Custom HTML Elements
 *
 * @example Multi-Checkbox HTML Markup
 * ```html
 * <multi-checkbox name="check-many-boxes">
 *   <optgroup label="Basic Options">
 *     <option value="foo">Foo</option>
 *     <option value="bar">Bar</option>
 *     <option value="baz">Baz</option>
 *   </optgroup>
 *   <optgroup label="Advanced Options">
 *    <option value="fizz">Fizz</option>
 *     <option value="buzz">Buzz</option>
 *   </optgroup>
 * </multi-checkbox>
 * ```
 */
declare class HTMLMultiCheckboxElement extends AbstractMultiSelectElement {
    /** @override */
    override _buildElements(): (HTMLFieldSetElement | HTMLLabelElement)[];
    #private;
}
/**
 * A Dialog subclass which allows the user to configure export options for a Folder
 * @extends {Dialog}
 */
declare class FolderExport extends Dialog {
    /**
     * Handle changing the selected pack by updating the dropdown of folders available.
     * @param {Event} event   The input change event
     */
    _onPackChange(event: Event): void;
}
/**
 * @typedef {FormApplicationOptions} DrawingConfigOptions
 * @property {boolean} [configureDefault=false]  Configure the default drawing settings, instead of a specific Drawing
 */
/**
 * The Application responsible for configuring a single Drawing document within a parent Scene.
 * @extends {DocumentSheet}
 *
 * @param {Drawing} drawing               The Drawing object being configured
 * @param {DrawingConfigOptions} options  Additional application rendering options
 */
declare class DrawingConfig extends DocumentSheet {
    /** @override */
    override get title(): any;
    /** @override */
    override getData(options?: {}): {
        author: any;
        isDefault: any;
        fillTypes: {};
        scaledBezierFactor: number;
        fontFamilies: any;
        object: any;
        options: any;
        submitText: string;
    };
    /** @override */
    override close(options: any): Promise<void>;
    preview: any;
    /**
     * Reset the user Drawing configuration settings to their default values
     * @param {PointerEvent} event      The originating mouse-click event
     * @protected
     */
    protected _onResetDefaults(event: PointerEvent): void;
}
/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Drawing objects.
 * @extends {BasePlaceableHUD}
 * @param {Drawing} object                The {@link Drawing} this HUD is bound to.
 * @param {ApplicationOptions} [options]  Application configuration options.
 */
declare class DrawingHUD extends BasePlaceableHUD {
    /** @inheritdoc */
    setPosition(options: any): void;
}
/**
 * The Application responsible for configuring a single AmbientLight document within a parent Scene.
 * @param {AmbientLight} light              The AmbientLight object for which settings are being configured
 * @param {DocumentSheetOptions} [options]  Additional application configuration options
 */
declare class AmbientLightConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /**
     * Maintain a copy of the original to show a real-time preview of changes.
     * @type {AmbientLightDocument}
     */
    preview: AmbientLightDocument;
    /** @inheritdoc */
    getData(options?: {}): any;
    /** @inheritdoc */
    _onChangeInput(event: any): Promise<void>;
    /**
     * Reset the values of advanced attributes to their default state.
     * @param {PointerEvent} event    The originating click event
     * @private
     */
    private _onResetForm;
    /**
     * Preview changes to the AmbientLight document as if they were true document updates.
     * @param {object} [change]  A change to preview.
     * @protected
     */
    protected _previewChanges(change?: object): void;
    /**
     * Restore the true data for the AmbientLight document when the form is submitted or closed.
     * @protected
     */
    protected _resetPreview(): void;
    /** @inheritdoc */
    _onChangeTab(event: any, tabs: any, active: any): void;
    /** @inheritdoc */
    _getSubmitData(updateData?: {}): any;
}
/**
 * The Application responsible for configuring a single Note document within a parent Scene.
 * @param {NoteDocument} note               The Note object for which settings are being configured
 * @param {DocumentSheetOptions} [options]  Additional Application configuration options
 */
declare class NoteConfig extends DocumentSheet {
    /** @override */
    static override get defaultOptions(): any;
    /** @override */
    override getData(options?: {}): any;
    /** @inheritdoc */
    _onChangeInput(event: any): Promise<any>;
    /**
     * Update disabled state of the custom icon field.
     * @protected
     */
    protected _updateCustomIcon(): void;
    /**
     * Update the list of pages.
     * @protected
     */
    protected _updatePageList(): void;
    /** @inheritdoc */
    _getSubmitData(updateData?: {}): any;
    /** @override */
    override close(options: any): Promise<void>;
}
/**
 * The Application responsible for configuring a single AmbientSound document within a parent Scene.
 * @extends {DocumentSheet}
 *
 * @param {AmbientSound} sound              The sound object being configured
 * @param {DocumentSheetOptions} [options]  Additional application rendering options
 */
declare class AmbientSoundConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    get title(): any;
    /** @inheritdoc */
    close(options: any): Promise<void>;
}
/**
 * The Application responsible for configuring a single Tile document within a parent Scene.
 * @param {Tile} tile                    The Tile object being configured
 * @param {DocumentSheetOptions} [options]  Additional application rendering options
 */
declare class TileConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    _onChangeInput(event: any): Promise<void>;
}
/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Tile objects.
 * @extends {BasePlaceableHUD}
 */
declare class TileHUD extends BasePlaceableHUD {
    /**
     * @inheritdoc
     * @type {Tile}
     */
    object: Function;
    /** @inheritdoc */
    setPosition(options: any): void;
    /** @inheritdoc */
    _onClickControl(event: any): any;
    /**
     * Handle toggling the overhead state of the Tile.
     * @param {PointerEvent} event      The triggering click event
     * @param {boolean} overhead        Should the Tile be overhead?
     * @private
     */
    private _onToggleOverhead;
    /**
     * Control video playback by toggling play or paused state for a video Tile.
     * @param {object} event
     * @private
     */
    private _onControlVideo;
}
/**
 * The Application responsible for configuring a single Token document within a parent Scene.
 * @param {TokenDocument|Actor} object          The {@link TokenDocument} being configured or an {@link Actor} for whom
 *                                              to configure the {@link PrototypeToken}
 * @param {FormApplicationOptions} [options]    Application configuration options.
 */
declare class TokenConfig extends DocumentSheet {
    /** @inheritdoc */
    static get defaultOptions(): any;
    constructor(object: any, options: any);
    /**
     * The placed Token object in the Scene
     * @type {TokenDocument}
     */
    token: TokenDocument;
    /**
     * A reference to the Actor which the token depicts
     * @type {Actor}
     */
    actor: Actor;
    /**
     * Maintain a copy of the original to show a real-time preview of changes.
     * @type {TokenDocument|PrototypeToken}
     */
    preview: TokenDocument | PrototypeToken;
    /**
     * A convenience accessor to test whether we are configuring the prototype Token for an Actor.
     * @type {boolean}
     */
    get isPrototype(): boolean;
    /** @inheritdoc */
    _render(force: any, options?: {}): Promise<void>;
    /**
     * Handle preview with a token.
     * @param {boolean} force
     * @param {object} options
     * @returns {Promise<void>}
     * @protected
     */
    protected _handleTokenPreview(force: boolean, options?: object): Promise<void>;
    /** @inheritDoc */
    _canUserView(user: any): any;
    /** @inheritdoc */
    getData(options?: {}): Promise<{
        cssClasses: string;
        isPrototype: boolean;
        hasAlternates: boolean;
        alternateImages: any;
        object: any;
        options: any;
        gridUnits: any;
        barAttributes: any;
        bar1: any;
        bar2: any;
        colorationTechniques: {
            [x: string]: ShaderTechnique;
        };
        visionModes: any[];
        detectionModes: any[];
        basicDetection: any;
        displayModes: {};
        actors: any;
        dispositions: {};
        lightAnimations: {
            "": any;
        };
        isGM: any;
        randomImgEnabled: any;
        scale: number;
        mirrorX: boolean;
        mirrorY: boolean;
    }>;
    /**
     * Get an Object of image paths and filenames to display in the Token sheet
     * @returns {Promise<object>}
     * @private
     */
    private _getAlternateTokenImages;
    /** @inheritDoc */
    _getSubmitData(updateData?: {}): any;
    /** @inheritDoc */
    _onChangeInput(event: any): Promise<void>;
    /**
     * Mimic changes to the Token document as if they were true document updates.
     * @param {object} [change]  The change to preview.
     * @protected
     */
    protected _previewChanges(change?: object): void;
    /**
     * Reset the temporary preview of the Token when the form is submitted or closed.
     * @protected
     */
    protected _resetPreview(): any;
    /**
     * Handle Token assignment requests to update the default prototype Token
     * @param {MouseEvent} event  The left-click event on the assign token button
     * @private
     */
    private _onAssignToken;
    /**
     * Handle changing the attribute bar in the drop-down selector to update the default current and max value
     * @param {Event} event  The select input change event
     * @private
     */
    private _onBarChange;
    /**
     * Handle click events on a token configuration sheet action button
     * @param {PointerEvent} event    The originating click event
     * @protected
     */
    protected _onClickActionButton(event: PointerEvent): void;
    /**
     * Handle adding a detection mode.
     * @param {object[]} modes  The existing detection modes.
     * @protected
     */
    protected _onAddDetectionMode(modes: object[]): void;
    /**
     * Handle removing a detection mode.
     * @param {number} index    The index of the detection mode to remove.
     * @param {object[]} modes  The existing detection modes.
     * @protected
     */
    protected _onRemoveDetectionMode(index: number, modes: object[]): void;
    /**
     * Disable the user's ability to edit the token image field if wildcard images are enabled and that user does not have
     * file browser permissions.
     * @private
     */
    private _disableEditImage;
}
/**
 * A sheet that alters the values of the default Token configuration used when new Token documents are created.
 * @extends {TokenConfig}
 */
declare class DefaultTokenConfig extends TokenConfig {
    /**
     * The named world setting that stores the default Token configuration
     * @type {string}
     */
    static SETTING: string;
    /** @inheritdoc */
    get title(): any;
    /** @override */
    override getData(options?: {}): Promise<{
        cssClasses: string;
        isPrototype: boolean;
        hasAlternates: boolean;
        alternateImages: any;
        object: any;
        options: any;
        gridUnits: any;
        barAttributes: any;
        /**
         * Perform a breadth-first search starting from the given node and retrieving any entries along the way, until we
         * reach the limit.
         * @param {WordTreeNode} node          The starting node.
         * @param {WordTreeEntry[]} entries    The accumulated entries.
         * @param {WordTreeNode[]} queue       The working queue of nodes to search.
         * @param {object} [options]           Additional options for the search.
         * @param {number} [options.limit=10]  The maximum number of entries to retrieve before stopping.
         * @protected
         */
        bar1: any;
        bar2: any;
        colorationTechniques: {
            [x: string]: ShaderTechnique;
        };
        visionModes: any[];
        detectionModes: any[];
        basicDetection: any;
        displayModes: {};
        actors: any;
        dispositions: {};
        lightAnimations: {
            "": any;
        };
        isGM: any;
        randomImgEnabled: any;
        scale: number;
        mirrorX: boolean;
        mirrorY: boolean;
    } & {
        object: any;
        isDefault: boolean;
        barAttributes: any;
        bar1: any;
        bar2: any;
    }>;
    /**
     * Reset the form to default values
     * @returns {Promise<void>}
     */
    reset(): Promise<void>;
    /** @inheritdoc */
    _onBarChange(): Promise<void>;
    /** @inheritdoc */
    _onAddDetectionMode(modes: any): void;
    /** @inheritdoc */
    _onRemoveDetectionMode(index: any, modes: any): void;
}
/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Token objects.
 * This interface provides controls for visibility, attribute bars, elevation, status effects, and more.
 * @type {BasePlaceableHUD}
 */
declare class TokenHUD extends BasePlaceableHUD {
    /**
     * Track whether the status effects control palette is currently expanded or hidden
     * @type {boolean}
     * @private
     */
    private _statusEffects;
    /** @override */
    override bind(object: any): void;
    /**
     * Refresh the currently active state of all status effect icons in the Token HUD selector.
     */
    refreshStatusIcons(): void;
    /** @override */
    override setPosition(_position: any): void;
    /**
     * Get an array of icon paths which represent valid status effect choices
     * @private
     */
    private _getStatusEffectChoices;
    /** @inheritdoc */
    _onClickControl(event: any): void | Promise<any>;
    /**
     * Handle initial click to focus an attribute update field
     * @private
     */
    private _onAttributeClick;
    /**
     * Force field handling on an Enter keypress even if the value of the field did not change.
     * This is important to suppose use cases with negative number values.
     * @param {KeyboardEvent} event     The originating keydown event
     * @private
     */
    private _onAttributeKeydown;
    /**
     * Handle attribute bar update
     * @private
     */
    private _onAttributeUpdate;
    /**
     * Toggle Token combat state
     * @private
     */
    private _onToggleCombat;
    /**
     * Handle Token configuration button click
     * @private
     */
    private _onTokenConfig;
    /**
     * Handle left-click events to toggle the displayed state of the status effect selection palette
     * @param {MouseEvent }event
     * @private
     */
    private _onToggleStatusEffects;
    /**
     * Assign css selectors for the active state of the status effects selection palette
     * @param {boolean} active      Should the effects menu be active?
     * @private
     */
    private _toggleStatusEffects;
    /**
     * Handle toggling a token status effect icon
     * @param {PointerEvent} event      The click event to toggle the effect
     * @param {object} [options]        Options which modify the toggle
     * @param {boolean} [options.overlay]   Toggle the overlay effect?
     * @private
     */
    private _onToggleEffect;
    /**
     * Handle toggling the target state for this Token
     * @param {PointerEvent} event      The click event to toggle the target
     * @private
     */
    private _onToggleTarget;
    #private;
}
/**
 * The Application responsible for configuring a single Wall document within a parent Scene.
 * @param {Wall} object                       The Wall object for which settings are being configured
 * @param {FormApplicationOptions} [options]  Additional options which configure the rendering of the configuration
 *                                            sheet.
 */
declare class WallConfig extends DocumentSheet {
    /**
     * An array of Wall ids that should all be edited when changes to this config form are submitted
     * @type {string[]}
     */
    editTargets: string[];
    /** @inheritdoc */
    get title(): any;
    /** @inheritdoc */
    render(force: any, options: any): any;
    /** @inheritDoc */
    _onChangeInput(event: any): Promise<any>;
    /** @inheritdoc */
    _getSubmitData(updateData?: {}): any;
    #private;
}
/**
 * A simple application which supports popping a ChatMessage out to a separate UI window.
 * @extends {Application}
 * @param {ChatMessage} object            The {@link ChatMessage} object that is being popped out.
 * @param {ApplicationOptions} [options]  Application configuration options.
 */
declare class ChatPopout extends Application {
    /** @inheritdoc */
    static get defaultOptions(): any;
    constructor(message: any, options: any);
    /**
     * The displayed Chat Message document
     * @type {ChatMessage}
     */
    message: ChatMessage;
    /** @inheritdoc */
    _renderInner(data: any, options: any): Promise<JQueryStatic>;
}
/**
 * The Application responsible for displaying and editing the client and world settings for this world.
 * This form renders the settings defined via the game.settings.register API which have config = true
 */
declare class SettingsConfig extends PackageConfiguration {
    /**
     * Confirm if the user wishes to reload the application.
     * @param {object} [options]               Additional options to configure the prompt.
     * @param {boolean} [options.world=false]  Whether to reload all connected clients as well.
     * @returns {Promise<void>}
     */
    static reloadConfirm({ world }?: {
        world?: boolean;
    }): Promise<void>;
    /** @inheritDoc */
    _prepareCategoryData(): {
        categories: Map<any, any>;
        total: number;
        user: User;
        canConfigure: any;
    };
    /**
     * Handle activating the button to configure User Role permissions
     * @param {Event} event   The initial button click event
     * @private
     */
    private _onClickSubmenu;
    /**
     * Preview font scaling as the setting is changed.
     * @param {Event} event  The triggering event.
     * @private
     */
    private _previewFontScaling;
    /** @override */
    override _updateObject(event: any, formData: any): Promise<void>;
}
/**
 * An interface for displaying the content of a CompendiumCollection.
 * @param {CompendiumCollection} collection  The {@link CompendiumCollection} object represented by this interface.
 * @param {ApplicationOptions} [options]     Application configuration options.
 */
declare class Compendium extends DocumentDirectory {
    /** @inheritdoc */
    static get defaultOptions(): any;
    constructor(...args: any[]);
    /** @inheritdoc */
    get title(): any;
    /** @inheritdoc */
    get tabName(): string;
    /**
     * A convenience redirection back to the metadata object of the associated CompendiumCollection
     * @returns {object}
     */
    get metadata(): any;
    /** @inheritDoc */
    render(force: any, options: any): Application | this;
    /** @override */
    override _entryAlreadyExists(document: any): any;
    /** @override */
    override _getEntryDragData(entryId: any): {
        type: any;
        uuid: any;
    };
    /** @override */
    override _onCreateEntry(event: any): any;
    /**
     * Handle clicks on a footer button
     * @param {PointerEvent} event    The originating pointer event
     * @private
     */
    private _onClickFooterButton;
    /** @override */
    override _getDocumentDragData(documentId: any): {
        type: any;
        uuid: any;
    };
    /** @override */
    override _getFolderDragData(folderId: any): {
        type: string;
        uuid: any;
    };
    /** @override */
    override _getEntryContextOptions(): {
        name: string;
        icon: string;
        condition: () => any;
        callback: (li: any) => any;
    }[];
}
/**
 * Game Invitation Links Reference
 * @extends {Application}
 */
declare class InvitationLinks extends Application {
    /** @inheritdoc */
    static get defaultOptions(): any;
    /** @inheritdoc */
    getData(options?: {}): Promise<any>;
    /** @inheritdoc */
    activateListeners(html: any): void;
}
/**
 * Allows for viewing and editing of Keybinding Actions
 */
declare class KeybindingsConfig extends PackageConfiguration {
    /**
     * Transforms a Binding into a human-readable string representation
     * @param {KeybindingActionBinding} binding   The Binding
     * @returns {string}                           A human readable string
     * @private
     */
    private static _humanizeBinding;
    /** @inheritDoc */
    _categorizeEntry(namespace: any): {
        id: string;
        title: string;
    };
    /** @inheritDoc */
    _prepareCategoryData(): {
        categories: object[];
        total: number;
    } | {
        categories: Map<any, any>;
        total: number;
    };
    /**
     * Add faux-keybind actions that represent the possible Mouse Controls
     * @param {Map} categories    The current Map of Categories to add to
     * @returns {number}           The number of Actions added
     * @private
     */
    private _addMouseControlsReference;
    /**
     * Given an Binding and its parent Action, detects other Actions that might conflict with that binding
     * @param {string} actionId                   The namespaced Action ID the Binding belongs to
     * @param {KeybindingActionConfig} action     The Action config
     * @param {KeybindingActionBinding} binding   The Binding
     * @returns {KeybindingAction[]}
     * @private
     */
    private _detectConflictingActions;
    /** @override */
    override _onResetDefaults(event: any): Promise<any>;
    /**
     * Handle Control clicks
     * @param {MouseEvent} event
     * @private
     */
    private _onClickBindingControl;
    /**
     * Handle left-click events to show / hide a certain category
     * @param {MouseEvent} event
     * @private
     */
    private _onClickAdd;
    /**
     * Handle left-click events to show / hide a certain category
     * @param {MouseEvent} event
     * @private
     */
    private _onClickDelete;
    /**
     * Inserts a Binding into the Pending Edits object, creating a new Map entry as needed
     * @param {string} namespace
     * @param {string} action
     * @param {number} bindingIndex
     * @param {KeybindingActionBinding} binding
     * @private
     */
    private _addPendingEdit;
    /**
     * Toggle visibility of the Edit / Save UI
     * @param {MouseEvent} event
     * @private
     */
    private _onClickEditableBinding;
    /**
     * Toggle visibility of the Edit UI
     * @param {MouseEvent} event
     * @private
     */
    private _onDoubleClickKey;
    /**
     * Save the new Binding value and update the display of the UI
     * @param {MouseEvent} event
     * @private
     */
    private _onClickSaveBinding;
    /**
     * Given a clicked Action element, finds the parent Action
     * @param {MouseEvent|KeyboardEvent} event
     * @returns {{namespace: string, action: string, actionHtml: *}}
     * @private
     */
    private _getParentAction;
    /**
     * Given a Clicked binding control element, finds the parent Binding
     * @param {MouseEvent|KeyboardEvent} event
     * @returns {{bindingHtml: *, bindingId: string}}
     * @private
     */
    private _getParentBinding;
    /**
     * Iterates over all Pending edits, merging them in with unedited Bindings and then saving and resetting the UI
     * @returns {Promise<void>}
     * @private
     */
    private _savePendingEdits;
    /**
     * Processes input from the keyboard to form a list of pending Binding edits
     * @param {KeyboardEvent} event   The keyboard event
     * @private
     */
    private _onKeydownBindingInput;
    #private;
}
/**
 * The Module Management Application.
 * This application provides a view of which modules are available to be used and allows for configuration of the
 * set of modules which are active within the World.
 */
declare class ModuleManagement extends FormApplication {
    /**
     * The named game setting which persists module configuration.
     * @type {string}
     */
    static CONFIG_SETTING: string;
    /** @inheritdoc */
    static get defaultOptions(): any;
    constructor(...args: any[]);
    _filter: string;
    _expanded: boolean;
    /** @inheritdoc */
    get isEditable(): any;
    /** @inheritdoc */
    getData(options?: {}): {
        editable: any;
        filters: {
            id: string;
            label: any;
            count: any;
        }[];
        modules: any;
        expanded: boolean;
    };
    /**
     * Given a module, determines if it meets minimum and maximum compatibility requirements of its dependencies.
     * If not, it is marked as being unable to be activated.
     * If the package does not meet verified requirements, it is marked with a warning instead.
     * @param {object} module  The module.
     * @protected
     */
    protected _evaluateDependencies(module: object): void;
    /**
     * Given a module, determine if it meets the minimum and maximum system compatibility requirements.
     * @param {object} module  The module.
     * @protected
     */
    protected _evaluateSystemCompatibility(module: object): void;
    /** @inheritdoc */
    _getSubmitData(updateData?: {}): any;
    /** @inheritdoc */
    _updateObject(event: any, formData: any): Promise<any>;
    /**
     * Handle changes to a module checkbox to prompt for whether to enable dependencies.
     * @param {Event} event  The change event.
     * @protected
     */
    protected _onChangeCheckbox(event: Event): Promise<any>;
    /**
     * Indicate if any Documents would become unavailable if the module were disabled, and confirm if the user wishes to
     * proceed.
     * @param {Module} module       The module being disabled.
     * @returns {Promise<boolean>}  A Promise which resolves to true if disabling should continue.
     * @protected
     */
    protected _confirmDocumentsUnavailable(module: Module): Promise<boolean>;
    /**
     * Handle a button-click to deactivate all modules
     * @private
     */
    private _onDeactivateAll;
    /**
     * Handle expanding or collapsing the display of descriptive elements
     * @private
     */
    private _onExpandCollapse;
    /**
     * Handle switching the module list filter.
     * @private
     */
    private _onFilterList;
    /** @inheritdoc */
    _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
    /**
     * Format a document count collection for display.
     * @param {ModuleSubTypeCounts} counts  An object of sub-type counts.
     * @param {boolean} isActive            Whether the module is active.
     * @protected
     */
    protected _formatDocumentSummary(counts: ModuleSubTypeCounts, isActive: boolean): string;
    #private;
}
/**
 * An application for configuring the permissions which are available to each User role.
 */
declare class PermissionConfig extends FormApplication {
    /** @override */
    static override get defaultOptions(): any;
    /** @override */
    override getData(options?: {}): Promise<{
        roles: {};
        permissions: any[];
    }>;
    /**
     * Prepare the permissions object used to render the configuration template
     * @param {object} current      The current permission configuration
     * @returns {object[]}          Permission data for sheet rendering
     * @private
     */
    private _getPermissions;
    /**
     * Handle button click to reset default settings
     * @param {Event} event   The initial button click event
     * @private
     */
    private _onResetDefaults;
    /** @override */
    override _onSubmit(event: any, options: any): Promise<any>;
    /** @override */
    override _updateObject(event: any, formData: any): Promise<void>;
}
/**
 * Support Info and Report
 * @type {Application}
 */
declare class SupportDetails extends Application {
    /**
     * A bundle of metrics for Support
     * @typedef {Object} SupportReportData
     * @property {number} coreVersion
     * @property {string} systemVersion
     * @property {number} activeModuleCount
     * @property {string} os
     * @property {string} client
     * @property {string} gpu
     * @property {number|string} maxTextureSize
     * @property {string} sceneDimensions
     * @property {number} grid
     * @property {float} padding
     * @property {number} walls
     * @property {number} lights
     * @property {number} sounds
     * @property {number} tiles
     * @property {number} tokens
     * @property {number} actors
     * @property {number} items
     * @property {number} journals
     * @property {number} tables
     * @property {number} playlists
     * @property {number} packs
     * @property {number} messages
     */
    /**
     * Collects a number of metrics that is useful for Support
     * @returns {SupportReportData}
     */
    static generateSupportReport(): {
        coreVersion: number;
        systemVersion: string;
        activeModuleCount: number;
        os: string;
        client: string;
        gpu: string;
        maxTextureSize: string | number;
        sceneDimensions: string;
        grid: number;
        padding: float;
        walls: number;
        lights: number;
        sounds: number;
        tiles: number;
        tokens: number;
        actors: number;
        items: number;
        journals: number;
        tables: number;
        playlists: number;
        packs: number;
        messages: number;
    };
    /**
     * Get a WebGL renderer information string
     * @param {WebGLRenderingContext} gl    The rendering context
     * @returns {string}                    The unmasked renderer string
     */
    static getWebGLRendererInfo(gl: WebGLRenderingContext): string;
    /** @inheritdoc */
    getData(options?: {}): any;
    /** @inheritdoc */
    activateListeners(html: any): void;
    /** @inheritdoc */
    _render(force?: boolean, options?: {}): Promise<void>;
    /** @inheritdoc */
    _renderInner(data: any): Promise<JQueryStatic>;
    /**
     * Handle a button click action.
     * @param {MouseEvent} event  The click event.
     * @protected
     */
    protected _onClickAction(event: MouseEvent): void;
    /**
     * Copy the support details report to clipboard.
     * @protected
     */
    protected _copyReport(): void;
    /**
     * Marshal information on Documents that failed validation and format it for display.
     * @returns {object[]}
     * @protected
     */
    protected _getDocumentValidationErrors(): object[];
    /**
     * Marshal package-related warnings and errors and format it for display.
     * @returns {object[]}
     * @protected
     */
    protected _getModuleIssues(): object[];
}
/**
 * A management app for configuring which Tours are available or have been completed.
 */
declare class ToursManagement extends PackageConfiguration {
    /** @override */
    override _prepareCategoryData(): {
        categories: Map<any, any>;
        total: number;
    };
    /** @override */
    override _onResetDefaults(event: any): Promise<any>;
    /**
     * Handle Control clicks
     * @param {MouseEvent} event
     * @private
     */
    private _onClickControl;
}
/**
 * @typedef {FormApplicationOptions} WorldConfigOptions
 * @property {boolean} [create=false]  Whether the world is being created or updated.
 */
/**
 * The World Management setup application
 * @param {World} object                      The world being configured.
 * @param {WorldConfigOptions} [options]      Application configuration options.
 */
declare class WorldConfig extends FormApplication {
    /**
     * The website knowledge base URL.
     * @type {string}
     * @private
     */
    private static "__#206@#WORLD_KB_URL";
    /**
     * A semantic alias for the World object which is being configured by this form.
     * @type {World}
     */
    get world(): World;
    /** @override */
    override get title(): any;
    /** @override */
    override getData(options?: {}): {
        world: World;
        isCreate: any;
        submitText: any;
        nextDate: any;
        nextTime: any;
        worldKbUrl: any;
        inWorld: boolean;
        themes: {
            default: string;
            minimal: string;
        };
    };
    /** @inheritDoc */
    _getSubmitData(updateData?: {}): any;
    /** @override */
    override _updateObject(event: any, formData: any): Promise<any>;
    /** @inheritDoc */
    activateEditor(name: any, options?: {}, initialContent?: string): Promise<any>;
    #private;
}
/**
 * The sidebar directory which organizes and displays world-level Actor documents.
 */
declare class ActorDirectory extends DocumentDirectory {
    constructor(...args: any[]);
    /** @override */
    override _canDragStart(selector: any): any;
    /** @override */
    override _onDragStart(event: any): boolean;
    /** @override */
    override _canDragDrop(selector: any): any;
    /** @override */
    override _getEntryContextOptions(): {
        name: string;
        icon: string;
        condition: (li: any) => boolean;
        callback: (li: any) => void;
    }[];
}
/**
 * The sidebar directory which organizes and displays world-level Cards documents.
 * @extends {DocumentDirectory}
 */
declare class CardsDirectory extends DocumentDirectory {
}
/**
 * @typedef {ApplicationOptions} ChatLogOptions
 * @property {boolean} [stream]  Is this chat log being rendered as part of the stream view?
 */
/**
 * The sidebar directory which organizes and displays world-level ChatMessage documents.
 * @extends {SidebarTab}
 * @see {Sidebar}
 * @param {ChatLogOptions} [options]  Application configuration options.
 */
declare class ChatLog extends SidebarTab {
    /**
     * @override
     * @returns {ChatLogOptions}
     */
    static override get defaultOptions(): ApplicationOptions;
    /**
     * An enumeration of regular expression patterns used to match chat messages.
     * @enum {RegExp}
     */
    static MESSAGE_PATTERNS: {
        roll: RegExp;
        gmroll: RegExp;
        blindroll: RegExp;
        selfroll: RegExp;
        publicroll: RegExp;
        ic: RegExp;
        ooc: RegExp;
        emote: RegExp;
        whisper: RegExp;
        reply: RegExp;
        gm: RegExp;
        players: RegExp;
        macro: RegExp;
        invalid: RegExp;
    };
    /**
     * The set of commands that can be processed over multiple lines.
     * @type {Set<string>}
     */
    static MULTILINE_COMMANDS: Set<string>;
    /**
     * Parse a chat string to identify the chat command (if any) which was used
     * @param {string} message    The message to match
     * @returns {string[]}        The identified command and regex match
     */
    static parse(message: string): string[];
    /**
     * Handle dropping of transferred data onto the chat editor
     * @param {DragEvent} event     The originating drop event which triggered the data transfer
     * @private
     */
    private static _onDropTextAreaData;
    /**
     * Update roll mode select dropdowns when the setting is changed
     * @param {string} mode     The new roll mode setting
     */
    static _setRollMode(mode: string): void;
    constructor(options: any);
    /**
     * Track any pending text which the user has submitted in the chat log textarea
     * @type {string}
     * @private
     */
    private _pendingText;
    /**
     * Track the history of the past 5 sent messages which can be accessed using the arrow keys
     * @type {object[]}
     * @private
     */
    private _sentMessages;
    /**
     * Track which remembered message is being currently displayed to cycle properly
     * @type {number}
     * @private
     */
    private _sentMessageIndex;
    /**
     * Track the time when the last message was sent to avoid flooding notifications
     * @type {number}
     * @private
     */
    private _lastMessageTime;
    /**
     * Track the id of the last message displayed in the log
     * @type {string|null}
     * @private
     */
    private _lastId;
    /**
     * Track the last received message which included the user as a whisper recipient.
     * @type {ChatMessage|null}
     * @private
     */
    private _lastWhisper;
    /**
     * A reference to the chat text entry bound key method
     * @type {Function|null}
     * @private
     */
    private _onChatKeyDownBinding;
    /**
     * Returns if the chat log is currently scrolled to the bottom
     * @returns {boolean}
     */
    get isAtBottom(): boolean;
    /**
     * A reference to the Messages collection that the chat log displays
     * @type {Messages}
     */
    get collection(): Messages;
    /** @override */
    override getData(options?: {}): Promise<any>;
    /** @inheritdoc */
    _render(force: any, options: any): Promise<void>;
    /**
     * Render a batch of additional messages, prepending them to the top of the log
     * @param {jQuery} html     The rendered jQuery HTML object
     * @param {number} size     The batch size to include
     * @returns {Promise<void>}
     * @private
     */
    private _renderBatch;
    /**
     * Delete a single message from the chat log
     * @param {string} messageId    The ChatMessage document to remove from the log
     * @param {boolean} [deleteAll] Is this part of a flush operation to delete all messages?
     */
    deleteMessage(messageId: string, { deleteAll }?: boolean): void;
    /**
     * Trigger a notification that alerts the user visually and audibly that a new chat log message has been posted
     * @param {ChatMessage} message         The message generating a notification
     */
    notify(message: ChatMessage): void;
    /**
     * Post a single chat message to the log
     * @param {ChatMessage} message   A ChatMessage document instance to post to the log
     * @param {object} [options={}]   Additional options for how the message is posted to the log
     * @param {string} [options.before] An existing message ID to append the message before, by default the new message is
     *                                  appended to the end of the log.
     * @param {boolean} [options.notify] Trigger a notification which shows the log as having a new unread message.
     * @returns {Promise<void>}       A Promise which resolves once the message is posted
     */
    postOne(message: ChatMessage, { before, notify }?: {
        before?: string;
        notify?: boolean;
    }): Promise<void>;
    /**
     * Scroll the chat log to the bottom
     * @param {object} [options]
     * @param {boolean} [options.popout=false]                 If a popout exists, scroll it to the bottom too.
     * @param {boolean} [options.waitImages=false]             Wait for any images embedded in the chat log to load first
     *                                                         before scrolling?
     * @param {ScrollIntoViewOptions} [options.scrollOptions]  Options to configure scrolling behaviour.
     */
    scrollBottom({ popout, waitImages, scrollOptions }?: {
        popout?: boolean;
        waitImages?: boolean;
        scrollOptions?: ScrollIntoViewOptions;
    }): Promise<void>;
    /**
     * Update the content of a previously posted message after its data has been replaced
     * @param {ChatMessage} message   The ChatMessage instance to update
     * @param {boolean} notify        Trigger a notification which shows the log as having a new unread message
     */
    updateMessage(message: ChatMessage, notify?: boolean): Promise<void>;
    /**
     * Update the displayed timestamps for every displayed message in the chat log.
     * Timestamps are displayed in a humanized "timesince" format.
     */
    updateTimestamps(): void;
    /** @inheritdoc */
    activateListeners(html: any): void;
    /**
     * Prepare the data object of chat message data depending on the type of message being posted
     * @param {string} message         The original string of the message content
     * @returns {Promise<Object|void>} The prepared chat data object, or void if we were executing a macro instead
     */
    processMessage(message: string): Promise<any | void>;
    /**
     * Process messages which are posted using a dice-roll command
     * @param {string} command          The chat command type
     * @param {RegExpMatchArray[]} matches Multi-line matched roll expressions
     * @param {Object} chatData         The initial chat data
     * @param {Object} createOptions    Options used to create the message
     * @private
     */
    private _processDiceCommand;
    /**
     * Process messages which are posted using a chat whisper command
     * @param {string} command          The chat command type
     * @param {RegExpMatchArray} match  The matched RegExp expressions
     * @param {Object} chatData         The initial chat data
     * @param {Object} createOptions    Options used to create the message
     * @private
     */
    private _processWhisperCommand;
    /**
     * Process messages which are posted using a chat whisper command
     * @param {string} command          The chat command type
     * @param {RegExpMatchArray} match  The matched RegExp expressions
     * @param {Object} chatData         The initial chat data
     * @param {Object} createOptions    Options used to create the message
     * @private
     */
    private _processChatCommand;
    /**
     * Process messages which execute a macro.
     * @param {string} command  The chat command typed.
     * @param {RegExpMatchArray} match  The RegExp matches.
     * @private
     */
    private _processMacroCommand;
    /**
     * Add a sent message to an array of remembered messages to be re-sent if the user pages up with the up arrow key
     * @param {string} message    The message text being remembered
     * @private
     */
    private _remember;
    /**
     * Recall a previously sent message by incrementing up (1) or down (-1) through the sent messages array
     * @param {number} direction    The direction to recall, positive for older, negative for more recent
     * @return {string}             The recalled message, or an empty string
     * @private
     */
    private _recall;
    /** @inheritdoc */
    _contextMenu(html: any): void;
    /**
     * Get the ChatLog entry context options
     * @return {object[]}   The ChatLog entry context options
     * @private
     */
    private _getEntryContextOptions;
    /**
     * Handle keydown events in the chat entry textarea
     * @param {KeyboardEvent} event
     * @private
     */
    private _onChatKeyDown;
    /**
     * Handle setting the preferred roll mode
     * @param {Event} event
     * @private
     */
    private _onChangeRollMode;
    /**
     * Handle single message deletion workflow
     * @param {Event} event
     * @private
     */
    private _onDeleteMessage;
    /**
     * Handle clicking of dice tooltip buttons
     * @param {Event} event
     * @private
     */
    private _onDiceRollClick;
    /**
     * Handle click events to export the chat log
     * @param {Event} event
     * @private
     */
    private _onExportLog;
    /**
     * Handle click events to flush the chat log
     * @param {Event} event
     * @private
     */
    private _onFlushLog;
    /**
     * Handle scroll events within the chat log container
     * @param {UIEvent} event   The initial scroll event
     * @private
     */
    private _onScrollLog;
    #private;
}
/**
 * The sidebar directory which organizes and displays world-level Combat documents.
 */
declare class CombatTracker extends SidebarTab {
    constructor(options: any);
    /**
     * Record a reference to the currently highlighted Token
     * @type {Token|null}
     * @private
     */
    private _highlighted;
    /**
     * Record the currently tracked Combat encounter
     * @type {Combat|null}
     */
    viewed: Combat | null;
    /**
     * Return an array of Combat encounters which occur within the current Scene.
     * @type {Combat[]}
     */
    get combats(): Combat[];
    /**
     * Initialize the combat tracker to display a specific combat encounter.
     * If no encounter is provided, the tracker will be initialized with the first encounter in the viewed scene.
     * @param {object} [options]                   Additional options to configure behavior.
     * @param {Combat|null} [options.combat=null]  The combat encounter to initialize
     * @param {boolean} [options.render=true]      Whether to re-render the sidebar after initialization
     */
    initialize({ combat, render }?: {
        combat?: Combat | null;
        render?: boolean;
    }): void;
    /**
     * Scroll the combat log container to ensure the current Combatant turn is centered vertically
     */
    scrollToTurn(): void;
    /** @inheritdoc */
    getData(options?: {}): Promise<any>;
    /**
     * Retrieve a source image for a combatant.
     * @param {Combatant} combatant         The combatant queried for image.
     * @returns {Promise<string>}           The source image attributed for this combatant.
     * @protected
     */
    protected _getCombatantThumbnail(combatant: Function): Promise<string>;
    /** @inheritdoc */
    activateListeners(html: any): void;
    /**
     * Handle new Combat creation request
     * @param {Event} event
     * @private
     */
    private _onCombatCreate;
    /**
     * Handle a Combat cycle request
     * @param {Event} event
     * @private
     */
    private _onCombatCycle;
    /**
     * Handle click events on Combat control buttons
     * @private
     * @param {Event} event   The originating mousedown event
     */
    private _onCombatControl;
    /**
     * Handle a Combatant control toggle
     * @private
     * @param {Event} event   The originating mousedown event
     */
    private _onCombatantControl;
    /**
     * Handle toggling the defeated status effect on a combatant Token
     * @param {Combatant} combatant     The combatant data being modified
     * @returns {Promise}                A Promise that resolves after all operations are complete
     * @private
     */
    private _onToggleDefeatedStatus;
    /**
     * Handle pinging a combatant Token
     * @param {Combatant} combatant     The combatant data
     * @returns {Promise}
     * @protected
     */
    protected _onPingCombatant(combatant: Function): Promise<any>;
    /**
     * Handle mouse-down event on a combatant name in the tracker
     * @param {Event} event   The originating mousedown event
     * @returns {Promise}     A Promise that resolves once the pan is complete
     * @private
     */
    private _onCombatantMouseDown;
    _clickTime: number;
    /**
     * Handle mouse-hover events on a combatant in the tracker
     * @private
     */
    private _onCombatantHoverIn;
    /**
     * Handle mouse-unhover events for a combatant in the tracker
     * @private
     */
    private _onCombatantHoverOut;
    /**
     * Highlight a hovered combatant in the tracker.
     * @param {Combatant} combatant The Combatant
     * @param {boolean} hover       Whether they are being hovered in or out.
     */
    hoverCombatant(combatant: Function, hover: boolean): void;
    /** @inheritdoc */
    _contextMenu(html: any): void;
    /**
     * Get the Combatant entry context options
     * @returns {object[]}   The Combatant entry context options
     * @private
     */
    private _getEntryContextOptions;
    /**
     * Display a dialog which prompts the user to enter a new initiative value for a Combatant
     * @param {jQuery} li
     * @private
     */
    private _onConfigureCombatant;
}
/**
 * A compendium of knowledge arcane and mystical!
 * Renders the sidebar directory of compendium packs
 * @extends {SidebarTab}
 * @mixes {DirectoryApplication}
 */
declare class CompendiumDirectory extends SidebarTab {
    /** @override */
    static override entryPartial: string;
    get activeFilters(): string[];
    /** @override */
    override entryType: string;
    /** @override */
    override _entryAlreadyExists(entry: any): any;
    /** @override */
    override _getEntryDragData(entryId: any): {
        type: string;
        id: any;
    };
    /** @override */
    override _entryIsSelf(entry: any, otherEntry: any): boolean;
    /** @override */
    override _sortRelative(entry: any, sortData: any): Promise<void>;
    /** @override */
    override activateListeners(html: any): void;
    /**
     * Display a menu of compendium types to filter by
     * @param {PointerEvent} event    The originating pointer event
     * @returns {Promise<void>}
     * @protected
     */
    protected _displayFilterCompendiumMenu(event: PointerEvent): Promise<void>;
    /**
     * Handle toggling a compendium type filter
     * @param {PointerEvent} event    The originating pointer event
     * @param {string|null} type      The compendium type to filter by. If null, clear all filters.
     * @protected
     */
    protected _onToggleCompendiumFilterType(event: PointerEvent, type: string | null): void;
    /**
     * The collection of Compendium Packs which are displayed in this Directory
     * @returns {CompendiumPacks<string, CompendiumCollection>}
     */
    get collection(): any;
    /**
     * Get the dropped Entry from the drop data
     * @param {object} data         The data being dropped
     * @returns {Promise<object>}   The dropped Entry
     * @protected
     */
    protected _getDroppedEntryFromData(data: object): Promise<object>;
    /** @override */
    override _createDroppedEntry(document: any, folder: any): Promise<void>;
    /** @override */
    override _getEntryName(entry: any): any;
    /** @override */
    override _getEntryId(entry: any): any;
    /** @override */
    override render(force?: boolean, options?: {}): Promise<Application>;
    /** @override */
    override _getEntryContextOptions(): ({
        name: string;
        icon: string;
        callback: (li: any) => any;
        condition?: undefined;
    } | {
        name: string;
        icon: string;
        condition: (header: any) => boolean;
        callback: (header: any) => void;
    })[];
    /** @override */
    override _onClickEntryName(event: any): Promise<void>;
    /** @override */
    override _onCreateEntry(event: any): Promise<any>;
    /**
     * Handle a Compendium Pack deletion request
     * @param {object} pack   The pack object requested for deletion
     * @private
     */
    private _onDeleteCompendium;
    #private;
}
/**
 * The sidebar directory which organizes and displays world-level Item documents.
 */
declare class ItemDirectory extends DocumentDirectory {
    /** @override */
    override _canDragDrop(selector: any): any;
    /** @override */
    override _getEntryContextOptions(): {
        name: string;
        icon: string;
        condition: (li: any) => boolean;
        callback: (li: any) => void;
    }[];
}
/**
 * The sidebar directory which organizes and displays world-level JournalEntry documents.
 * @extends {DocumentDirectory}
 */
declare class JournalDirectory extends DocumentDirectory {
}
/**
 * The directory, not displayed in the sidebar, which organizes and displays world-level Macro documents.
 * @extends {DocumentDirectory}
 *
 * @see {@link Macros}        The WorldCollection of Macro Documents
 * @see {@link Macro}         The Macro Document
 * @see {@link MacroConfig}   The Macro Configuration Sheet
 */
declare class MacroDirectory extends DocumentDirectory {
}
/**
 * The sidebar directory which organizes and displays world-level Playlist documents.
 * @extends {DocumentDirectory}
 */
declare class PlaylistDirectory extends DocumentDirectory {
    /**
     * Converts a volume level to a human-friendly % value
     * @param {number} volume         Value between [0, 1] of the volume level
     * @returns {string}
     */
    static volumeToTooltip(volume: number): string;
    constructor(options: any);
    /**
     * Track the playlist IDs which are currently expanded in their display
     * @type {Set<string>}
     */
    _expanded: Set<string>;
    /**
     * Are the global volume controls currently expanded?
     * @type {boolean}
     * @private
     */
    private _volumeExpanded;
    /**
     * Cache the set of Playlist documents that are displayed as playing when the directory is rendered
     * @type {Playlist[]}
     */
    _playingPlaylists: Playlist[];
    /**
     * Cache the set of PlaylistSound documents that are displayed as playing when the directory is rendered
     * @type {PlaylistSound[]}
     */
    _playingSounds: PlaylistSound[];
    /**
     * Initialize the set of Playlists which should be displayed in an expanded form
     * @returns {Set<string>}
     * @private
     */
    private _createExpandedSet;
    /**
     * Return an Array of the Playlist documents which are currently playing
     * @type {Playlist[]}
     */
    get playing(): Playlist[];
    /**
     * Whether the 'currently playing' element is pinned to the top or bottom of the display.
     * @type {string}
     * @private
     */
    private get _playingLocation();
    _playingSoundsData: any[];
    /**
     * Augment the tree directory structure with playlist-level data objects for rendering
     * @param {object} node   The tree leaf node being prepared
     * @private
     */
    private _prepareTreeData;
    /**
     * Create an object of rendering data for each Playlist document being displayed
     * @param {Playlist} playlist   The playlist to display
     * @returns {object}            The data for rendering
     * @private
     */
    private _preparePlaylistData;
    /**
     * Get the icon used to represent the "play/stop" icon for the PlaylistSound
     * @param {PlaylistSound} sound   The sound being rendered
     * @returns {string}              The icon that should be used
     * @private
     */
    private _getPlayIcon;
    /**
     * Get the icon used to represent the pause/loading icon for the PlaylistSound
     * @param {PlaylistSound} sound   The sound being rendered
     * @returns {string}              The icon that should be used
     * @private
     */
    private _getPauseIcon;
    /**
     * Given a constant playback mode, provide the FontAwesome icon used to display it
     * @param {number} mode
     * @returns {string}
     * @private
     */
    private _getModeIcon;
    /**
     * Given a constant playback mode, provide the string tooltip used to describe it
     * @param {number} mode
     * @returns {string}
     * @private
     */
    private _getModeTooltip;
    /**
     * Handle global volume change for the playlist sidebar
     * @param {MouseEvent} event   The initial click event
     * @private
     */
    private _onGlobalVolume;
    /** @inheritdoc */
    collapseAll(): void;
    /** @override */
    override _onClickEntryName(event: any): void;
    /**
     * Handle global volume control collapse toggle
     * @param {MouseEvent} event   The initial click event
     * @private
     */
    private _onVolumeCollapse;
    /**
     * Helper method to render the expansion or collapse of playlists
     * @private
     */
    private _collapse;
    /**
     * Handle Playlist playback state changes
     * @param {MouseEvent} event    The initial click event
     * @param {boolean} playing     Is the playlist now playing?
     * @private
     */
    private _onPlaylistPlay;
    /**
     * Handle advancing the playlist to the next (or previous) sound
     * @param {MouseEvent} event    The initial click event
     * @param {string} action       The control action requested
     * @private
     */
    private _onPlaylistSkip;
    /**
     * Handle cycling the playback mode for a Playlist
     * @param {MouseEvent} event   The initial click event
     * @private
     */
    private _onPlaylistToggleMode;
    /**
     * Handle Playlist track addition request
     * @param {MouseEvent} event   The initial click event
     * @private
     */
    private _onSoundCreate;
    /**
     * Modify the playback state of a Sound within a Playlist
     * @param {MouseEvent} event    The initial click event
     * @param {string} action       The sound control action performed
     * @private
     */
    private _onSoundPlay;
    /**
     * Handle volume adjustments to sounds within a Playlist
     * @param {Event} event   The initial change event
     * @private
     */
    private _onSoundVolume;
    /**
     * Handle changes to the sound playback mode
     * @param {Event} event   The initial click event
     * @private
     */
    private _onSoundToggleMode;
    _onPlayingPin(): any;
    /** @inheritdoc */
    _onSearchFilter(event: any, query: any, rgx: any, html: any): void;
    /**
     * Update the displayed timestamps for all currently playing audio sources.
     * Runs on an interval every 1000ms.
     * @private
     */
    private _updateTimestamps;
    /**
     * Format the displayed timestamp given a number of seconds as input
     * @param {number} seconds    The current playback time in seconds
     * @returns {string}          The formatted timestamp
     * @private
     */
    private _formatTimestamp;
    /** @inheritdoc */
    _contextMenu(html: any): void;
    /**
     * Get context menu options for individual sound effects
     * @returns {Object}   The context options for each sound
     * @private
     */
    private _getSoundContextOptions;
    /** @inheritdoc */
    _onDragStart(event: any): void;
    /** @inheritdoc */
    _onDrop(event: any): Promise<any>;
}
/**
 * The sidebar directory which organizes and displays world-level RollTable documents.
 * @extends {DocumentDirectory}
 */
declare class RollTableDirectory extends DocumentDirectory {
}
/**
 * The sidebar directory which organizes and displays world-level Scene documents.
 * @extends {DocumentDirectory}
 */
declare class SceneDirectory extends DocumentDirectory {
    /** @inheritdoc */
    _render(force: any, options: any): Promise<void | this>;
}
/**
 * The sidebar tab which displays various game settings, help messages, and configuration options.
 * The Settings sidebar is the furthest-to-right using a triple-cogs icon.
 * @extends {SidebarTab}
 */
declare class Settings extends SidebarTab {
    /** @override */
    override getData(options?: {}): Promise<any>;
    /** @override */
    override activateListeners(html: any): void;
    /**
     * Delegate different actions for different settings buttons
     * @param {MouseEvent} event    The originating click event
     * @private
     */
    private _onSettingsButton;
    /**
     * Executes with the update notification pip is clicked
     * @param {MouseEvent} event    The originating click event
     * @private
     */
    private _onUpdateNotificationClick;
}
/**
 * A simple window application which shows the built documentation pages within an iframe
 * @type {Application}
 */
declare class FrameViewer extends Application {
    constructor(url: any, options: any);
    url: any;
    /** @override */
    override getData(options?: {}): Promise<{
        src: any;
    }>;
}
/**
 * An interface for an Audio/Video client which is extended to provide broadcasting functionality.
 * @interface
 * @param {AVMaster} master           The master orchestration instance
 * @param {AVSettings} settings       The audio/video settings being used
 */
declare class AVClient {
    constructor(master: any, settings: any);
    /**
     * The master orchestration instance
     * @type {AVMaster}
     */
    master: AVMaster;
    /**
     * The active audio/video settings being used
     * @type {AVSettings}
     */
    settings: AVSettings;
    /**
     * Is audio broadcasting push-to-talk enabled?
     * @returns {boolean}
     */
    get isVoicePTT(): boolean;
    /**
     * Is audio broadcasting always enabled?
     * @returns {boolean}
     */
    get isVoiceAlways(): boolean;
    /**
     * Is audio broadcasting voice-activation enabled?
     * @returns {boolean}
     */
    get isVoiceActivated(): boolean;
    /**
     * Is the current user muted?
     * @returns {boolean}
     */
    get isMuted(): boolean;
    /**
     * One-time initialization actions that should be performed for this client implementation.
     * This will be called only once when the Game object is first set-up.
     * @returns {Promise<void>}
     */
    initialize(): Promise<void>;
    /**
     * Connect to any servers or services needed in order to provide audio/video functionality.
     * Any parameters needed in order to establish the connection should be drawn from the settings object.
     * This function should return a boolean for whether the connection attempt was successful.
     * @returns {Promise<boolean>}   Was the connection attempt successful?
     */
    connect(): Promise<boolean>;
    /**
     * Disconnect from any servers or services which are used to provide audio/video functionality.
     * This function should return a boolean for whether a valid disconnection occurred.
     * @returns {Promise<boolean>}   Did a disconnection occur?
     */
    disconnect(): Promise<boolean>;
    /**
     * Provide an Object of available audio sources which can be used by this implementation.
     * Each object key should be a device id and the key should be a human-readable label.
     * @returns {Promise<{object}>}
     */
    getAudioSinks(): Promise<{
        object;
    }>;
    /**
     * Provide an Object of available audio sources which can be used by this implementation.
     * Each object key should be a device id and the key should be a human-readable label.
     * @returns {Promise<{object}>}
     */
    getAudioSources(): Promise<{
        object;
    }>;
    /**
     * Provide an Object of available video sources which can be used by this implementation.
     * Each object key should be a device id and the key should be a human-readable label.
     * @returns {Promise<{object}>}
     */
    getVideoSources(): Promise<{
        object;
    }>;
    /**
     * Obtain a mapping of available device sources for a given type.
     * @param {string} kind       The type of device source being requested
     * @returns {Promise<{object}>}
     * @private
     */
    private _getSourcesOfType;
    /**
     * Return an array of Foundry User IDs which are currently connected to A/V.
     * The current user should also be included as a connected user in addition to all peers.
     * @returns {string[]}          The connected User IDs
     */
    getConnectedUsers(): string[];
    /**
     * Provide a MediaStream instance for a given user ID
     * @param {string} userId        The User id
     * @returns {MediaStream|null}   The MediaStream for the user, or null if the user does not have one
     */
    getMediaStreamForUser(userId: string): MediaStream | null;
    /**
     * Provide a MediaStream for monitoring a given user's voice volume levels.
     * @param {string} userId       The User ID.
     * @returns {MediaStream|null}  The MediaStream for the user, or null if the user does not have one.
     */
    getLevelsStreamForUser(userId: string): MediaStream | null;
    /**
     * Is outbound audio enabled for the current user?
     * @returns {boolean}
     */
    isAudioEnabled(): boolean;
    /**
     * Is outbound video enabled for the current user?
     * @returns {boolean}
     */
    isVideoEnabled(): boolean;
    /**
     * Set whether the outbound audio feed for the current game user is enabled.
     * This method should be used when the user marks themselves as muted or if the gamemaster globally mutes them.
     * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
     */
    toggleAudio(enable: boolean): void;
    /**
     * Set whether the outbound audio feed for the current game user is actively broadcasting.
     * This can only be true if audio is enabled, but may be false if using push-to-talk or voice activation modes.
     * @param {boolean} broadcast      Whether outbound audio should be sent to connected peers or not?
     */
    toggleBroadcast(broadcast: boolean): void;
    /**
     * Set whether the outbound video feed for the current game user is enabled.
     * This method should be used when the user marks themselves as hidden or if the gamemaster globally hides them.
     * @param {boolean} enable        Whether the outbound video track should be enabled (true) or disabled (false)
     */
    toggleVideo(enable: boolean): void;
    /**
     * Set the Video Track for a given User ID to a provided VideoElement
     * @param {string} userId                   The User ID to set to the element
     * @param {HTMLVideoElement} videoElement   The HTMLVideoElement to which the video should be set
     */
    setUserVideo(userId: string, videoElement: HTMLVideoElement): Promise<void>;
    /**
     * Handle changes to A/V configuration settings.
     * @param {object} changed      The settings which have changed
     */
    onSettingsChanged(changed: object): void;
    /**
     * Replace the local stream for each connected peer with a re-generated MediaStream.
     */
    updateLocalStream(): Promise<void>;
}
/**
 * The master Audio/Video controller instance.
 * This is available as the singleton game.webrtc
 *
 * @param {AVSettings} settings     The Audio/Video settings to use
 */
declare class AVMaster {
    settings: AVSettings;
    config: AVConfig;
    /**
     * The Audio/Video client class
     * @type {AVClient}
     */
    client: AVClient;
    /**
     * A flag to track whether the current user is actively broadcasting their microphone.
     * @type {boolean}
     */
    broadcasting: boolean;
    /**
     * Flag to determine if we are connected to the signalling server or not.
     * This is required for synchronization between connection and reconnection attempts.
     * @type {boolean}
     */
    _connected: boolean;
    /**
     * The cached connection promise.
     * This is required to prevent re-triggering a connection while one is already in progress.
     * @type {Promise<boolean>|null}
     * @private
     */
    private _connecting;
    /**
     * A flag to track whether the A/V system is currently in the process of reconnecting.
     * This occurs if the connection is lost or interrupted.
     * @type {boolean}
     * @private
     */
    private _reconnecting;
    _speakingData: {
        speaking: boolean;
        volumeHistories: any[];
    };
    _pttMuteTimeout: number;
    get mode(): any;
    /**
     * Connect to the Audio/Video client.
     * @return {Promise<boolean>}     Was the connection attempt successful?
     */
    connect(): Promise<boolean>;
    /**
     * Disconnect from the Audio/Video client.
     * @return {Promise<boolean>}     Whether an existing connection was terminated?
     */
    disconnect(): Promise<boolean>;
    /**
     * Callback actions to take when the user becomes disconnected from the server.
     * @return {Promise<void>}
     */
    reestablish(): Promise<void>;
    /**
     * Initialize the local broadcast state.
     * @private
     */
    private _initialize;
    /**
     * A user can broadcast audio if the AV mode is compatible and if they are allowed to broadcast.
     * @param {string} userId
     * @return {boolean}
     */
    canUserBroadcastAudio(userId: string): boolean;
    /**
     * A user can share audio if they are allowed to broadcast and if they have not muted themselves or been blocked.
     * @param {string} userId
     * @return {boolean}
     */
    canUserShareAudio(userId: string): boolean;
    /**
     * A user can broadcast video if the AV mode is compatible and if they are allowed to broadcast.
     * @param {string} userId
     * @return {boolean}
     */
    canUserBroadcastVideo(userId: string): boolean;
    /**
     * A user can share video if they are allowed to broadcast and if they have not hidden themselves or been blocked.
     * @param {string} userId
     * @return {boolean}
     */
    canUserShareVideo(userId: string): boolean;
    /**
     * Trigger a change in the audio broadcasting state when using a push-to-talk workflow.
     * @param {boolean} intent        The user's intent to broadcast. Whether an actual broadcast occurs will depend
     *                                on whether or not the user has muted their audio feed.
     */
    broadcast(intent: boolean): any;
    /**
     * Set up audio level listeners to handle voice activation detection workflow.
     * @param {string} mode           The currently selected voice broadcasting mode
     * @private
     */
    private _initializeUserVoiceDetection;
    /**
     * Activate voice detection tracking for a userId on a provided MediaStream.
     * Currently only a MediaStream is supported because MediaStreamTrack processing is not yet supported cross-browser.
     * @param {MediaStream} stream    The MediaStream which corresponds to that User
     * @param {number} [ms]           A number of milliseconds which represents the voice activation volume interval
     */
    activateVoiceDetection(stream: MediaStream, ms?: number): void;
    /**
     * Actions which the orchestration layer should take when a peer user disconnects from the audio/video service.
     */
    deactivateVoiceDetection(): void;
    /**
     * Periodic notification of user audio level
     *
     * This function uses the audio level (in dB) of the audio stream to determine if the user is speaking or not and
     * notifies the UI of such changes.
     *
     * The User is considered speaking if they are above the decibel threshold in any of the history values.
     * This marks them as speaking as soon as they have a high enough volume, and marks them as not speaking only after
     * they drop below the threshold in all histories (last 4 volumes = for 200 ms).
     *
     * There can be more optimal ways to do this and which uses whether the user was already considered speaking before
     * or not, in order to eliminate short bursts of audio (coughing for example).
     *
     * @param {number} dbLevel         The audio level in decibels of the user within the last 50ms
     * @private
     */
    private _onAudioLevel;
    /**
     * Resets the speaking history of a user
     * If the user was considered speaking, then mark them as not speaking
     */
    _resetSpeakingHistory(): void;
    /**
     * Handle activation of a push-to-talk key or button.
     * @param {KeyboardEventContext} context    The context data of the event
     */
    _onPTTStart(context: KeyboardEventContext): boolean;
    /**
     * Handle deactivation of a push-to-talk key or button.
     * @param {KeyboardEventContext} context    The context data of the event
     */
    _onPTTEnd(context: KeyboardEventContext): boolean;
    render(): any;
    /**
     * Render the audio/video streams to the CameraViews UI.
     * Assign each connected user to the correct video frame element.
     */
    onRender(): void;
    /**
     * Respond to changes which occur to AV Settings.
     * Changes are handled in descending order of impact.
     * @param {object} changed       The object of changed AV settings
     */
    onSettingsChanged(changed: object): Promise<boolean>;
    debug(message: any): void;
}
/**
 * @typedef {object} AVSettingsData
 * @property {boolean} [muted]     Whether this user has muted themselves.
 * @property {boolean} [hidden]    Whether this user has hidden their video.
 * @property {boolean} [speaking]  Whether the user is broadcasting audio.
 */
declare class AVSettings {
    /**
     * WebRTC Mode, Disabled, Audio only, Video only, Audio & Video
     * @enum {number}
     */
    static AV_MODES: {
        DISABLED: number;
        AUDIO: number;
        VIDEO: number;
        AUDIO_VIDEO: number;
    };
    /**
     * Voice modes: Always-broadcasting, voice-level triggered, push-to-talk.
     * @enum {string}
     */
    static VOICE_MODES: {
        ALWAYS: string;
        ACTIVITY: string;
        PTT: string;
    };
    /**
     * Displayed nameplate options: Off entirely, animate between player and character name, player name only, character
     * name only.
     * @enum {number}
     */
    static NAMEPLATE_MODES: {
        OFF: number;
        BOTH: number;
        PLAYER_ONLY: number;
        CHAR_ONLY: number;
    };
    /**
     * AV dock positions.
     * @enum {string}
     */
    static DOCK_POSITIONS: {
        TOP: string;
        RIGHT: string;
        BOTTOM: string;
        LEFT: string;
    };
    /**
     * Default client AV settings.
     * @type {object}
     */
    static DEFAULT_CLIENT_SETTINGS: object;
    /**
     * Default world-level AV settings.
     * @type {object}
     */
    static DEFAULT_WORLD_SETTINGS: object;
    /**
     * Default client settings for each connected user.
     * @type {object}
     */
    static DEFAULT_USER_SETTINGS: object;
    _set: any;
    _change: any;
    /**
     * Stores the transient AV activity data received from other users.
     * @type {Object<string, AVSettingsData>}
     */
    activity: {
        [x: string]: AVSettingsData;
    };
    initialize(): void;
    client: any;
    world: any;
    _original: any;
    changed(): any;
    get(scope: any, setting: any): any;
    getUser(userId: any): any;
    set(scope: any, setting: any, value: any): void;
    /**
     * Return a mapping of AV settings for each game User.
     * @type {object}
     */
    get users(): any;
    /**
     * A helper to determine if the dock is configured in a vertical position.
     */
    get verticalDock(): boolean;
    /**
     * Prepare a standardized object of user settings data for a single User
     * @private
     */
    private _getUserSettings;
    /**
     * Handle setting changes to either rctClientSettings or rtcWorldSettings.
     * @private
     */
    private _onSettingsChanged;
    /**
     * Handle another connected user changing their AV settings.
     * @param {string} userId
     * @param {AVSettingsData} settings
     */
    handleUserActivity(userId: string, settings: AVSettingsData): void;
}
/**
 * An implementation of the AVClient which uses the simple-peer library and the Foundry socket server for signaling.
 * Credit to bekit#4213 for identifying simple-peer as a viable technology and providing a POC implementation.
 * @extends {AVClient}
 */
declare class SimplePeerAVClient extends AVClient {
    /**
     * The local Stream which captures input video and audio
     * @type {MediaStream}
     */
    localStream: MediaStream;
    /**
     * The dedicated audio stream used to measure volume levels for voice activity detection.
     * @type {MediaStream}
     */
    levelsStream: MediaStream;
    /**
     * A mapping of connected peers
     * @type {Map}
     */
    peers: Map<any, any>;
    /**
     * A mapping of connected remote streams
     * @type {Map}
     */
    remoteStreams: Map<any, any>;
    /**
     * Has the client been successfully initialized?
     * @type {boolean}
     * @private
     */
    private _initialized;
    /**
     * Is outbound broadcast of local audio enabled?
     * @type {boolean}
     */
    audioBroadcastEnabled: boolean;
    /**
     * The polling interval ID for connected users that might have unexpectedly dropped out of our peer network.
     * @type {number|null}
     */
    _connectionPoll: number | null;
    /**
     * Try to establish a peer connection with each user connected to the server.
     * @private
     */
    private _connect;
    /** @override */
    override getConnectedUsers(): any[];
    /** @override */
    override getMediaStreamForUser(userId: any): any;
    /** @override */
    override getLevelsStreamForUser(userId: any): any;
    /** @override */
    override toggleAudio(enabled: any): void;
    /** @override */
    override toggleBroadcast(enabled: any): void;
    /** @override */
    override toggleVideo(enabled: any): void;
    /** @override */
    override setUserVideo(userId: any, videoElement: any): Promise<void>;
    /**
     * Initialize a local media stream for the current user
     * @returns {Promise<MediaStream>}
     */
    initializeLocalStream(): Promise<MediaStream>;
    /**
     * Attempt to create local media streams.
     * @param {{video: object, audio: object}} params       Parameters for the getUserMedia request.
     * @returns {Promise<MediaStream|Error>}                The created MediaStream or an error.
     * @private
     */
    private _createMediaStream;
    /**
     * Listen for Audio/Video updates on the av socket to broker connections between peers
     */
    activateSocketListeners(): void;
    /**
     * Initialize a stream connection with a new peer
     * @param {string} userId           The Foundry user ID for which the peer stream should be established
     * @returns {Promise<SimplePeer>}   A Promise which resolves once the peer stream is initialized
     */
    initializePeerStream(userId: string): Promise<SimplePeer>;
    /**
     * Receive a request to establish a peer signal with some other User id
     * @param {string} userId           The Foundry user ID who is requesting to establish a connection
     * @param {object} data             The connection details provided by SimplePeer
     */
    receiveSignal(userId: string, data: object): void;
    /**
     * Connect to a peer directly, either as the initiator or as the receiver
     * @param {string} userId           The Foundry user ID with whom we are connecting
     * @param {boolean} isInitiator     Is the current user initiating the connection, or responding to it?
     * @returns {SimplePeer}            The constructed and configured SimplePeer instance
     */
    connectPeer(userId: string, isInitiator?: boolean): SimplePeer;
    /**
     * Create the SimplePeer instance for the desired peer connection.
     * Modules may implement more advanced connection strategies by overriding this method.
     * @param {string} userId           The Foundry user ID with whom we are connecting
     * @param {boolean} isInitiator     Is the current user initiating the connection, or responding to it?
     * @private
     */
    private _createPeerConnection;
    /**
     * Setup the custom TURN relay to be used in subsequent calls if there is one configured.
     * TURN credentials are mandatory in WebRTC.
     * @param {object} options The SimplePeer configuration object.
     * @private
     */
    private _setupCustomTURN;
    /**
     * Disconnect from a peer by stopping current stream tracks and destroying the SimplePeer instance
     * @param {string} userId           The Foundry user ID from whom we are disconnecting
     * @returns {Promise<void>}         A Promise which resolves once the disconnection is complete
     */
    disconnectPeer(userId: string): Promise<void>;
    /**
     * Disconnect from all current peer streams
     * @returns {Promise<Array>}       A Promise which resolves once all peers have been disconnected
     */
    disconnectAll(): Promise<any[]>;
    /** @override */
    override onSettingsChanged(changed: any): Promise<void>;
}
/**
 * Runtime configuration settings for Foundry VTT which exposes a large number of variables which determine how
 * aspects of the software behaves.
 *
 * Unlike the CONST analog which is frozen and immutable, the CONFIG object may be updated during the course of a
 * session or modified by system and module developers to adjust how the application behaves.
 *
 * @type {object}
 */
declare const CONFIG: object;
/**
 * A helper class to provide common functionality for working with the Web Audio API.
 * https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 * A singleton instance of this class is available as game#audio.
 * @see Game#audio
 */
declare class AudioHelper {
    /**
     * The Native interval for the AudioHelper to analyse audio levels from streams
     * Any interval passed to startLevelReports() would need to be a multiple of this value.
     * @type {number}
     */
    static levelAnalyserNativeInterval: number;
    /**
     * The cache size threshold after which audio buffers will be expired from the cache to make more room.
     * 1 gigabyte, by default.
     */
    static THRESHOLD_CACHE_SIZE_BYTES: number;
    /**
     * Register client-level settings for global volume overrides
     */
    static registerSettings(): void;
    /**
     * Test whether a source file has a supported audio extension type
     * @param {string} src      A requested audio source path
     * @returns {boolean}       Does the filename end with a valid audio extension?
     */
    static hasAudioExtension(src: string): boolean;
    /**
     * Given an input file path, determine a default name for the sound based on the filename
     * @param {string} src      An input file path
     * @returns {string}        A default sound name for the path
     */
    static getDefaultSoundName(src: string): string;
    /**
     * Open socket listeners which transact ChatMessage data
     * @param socket
     */
    static _activateSocketListeners(socket: any): void;
    /**
     * Play a one-off sound effect which is not part of a Playlist
     *
     * @param {Object} data           An object configuring the audio data to play
     * @param {string} data.src       The audio source file path, either a public URL or a local path relative to the public directory
     * @param {number} data.volume    The volume level at which to play the audio, between 0 and 1.
     * @param {boolean} data.autoplay Begin playback of the audio effect immediately once it is loaded.
     * @param {boolean} data.loop     Loop the audio effect and continue playing it until it is manually stopped.
     * @param {object|boolean} socketOptions  Options which only apply when emitting playback over websocket.
     *                                As a boolean, emits (true) or does not emit (false) playback to all other clients
     *                                As an object, can configure which recipients should receive the event.
     * @param {string[]} [socketOptions.recipients] An array of user IDs to push audio playback to. All users by default.
     *
     * @returns {Sound}               A Sound instance which controls audio playback.
     *
     * @example Play the sound of a locked door for all players
     * ```js
     * AudioHelper.play({src: "sounds/lock.wav", volume: 0.8, loop: false}, true);
     * ```
     */
    static play(data: {
        src: string;
        volume: number;
        autoplay: boolean;
        loop: boolean;
    }, socketOptions: object | boolean): Sound;
    /**
     * Begin loading the sound for a provided source URL adding its
     * @param {string} src            The audio source path to preload
     * @returns {Promise<Sound>}      The created and loaded Sound ready for playback
     */
    static preloadSound(src: string): Promise<Sound>;
    /**
     * Returns the volume value based on a range input volume control's position.
     * This is using an exponential approximation of the logarithmic nature of audio level perception
     * @param {number|string} value   Value between [0, 1] of the range input
     * @param {number} [order=1.5]    The exponent of the curve
     * @returns {number}
     */
    static inputToVolume(value: number | string, order?: number): number;
    /**
     * Counterpart to inputToVolume()
     * Returns the input range value based on a volume
     * @param {number} volume         Value between [0, 1] of the volume level
     * @param {number} [order=1.5]    The exponent of the curve
     * @returns {number}
     */
    static volumeToInput(volume: number, order?: number): number;
    /**
     * The primary Audio Context used to play client-facing sounds.
     * The context is undefined until the user's first gesture is observed.
     * @type {AudioContext}
     */
    context: AudioContext;
    /**
     * The set of AudioBuffer objects which are cached for different audio paths
     * @type {Map<string,{buffer: AudioBuffer, lastAccessed: number, playing: boolean, size: number}>}
     */
    buffers: Map<string, {
        buffer: AudioBuffer;
        lastAccessed: number;
        playing: boolean;
        size: number;
    }>;
    /**
     * The set of singleton Sound instances which are cached for different audio paths
     * @type {Map<string,Sound>}
     */
    sounds: Map<string, Sound>;
    /**
     * Get a map of the Sound objects which are currently playing.
     * @type {Map<number,Sound>}
     */
    playing: Map<number, Sound>;
    /**
     * A user gesture must be registered before audio can be played.
     * This Array contains the Sound instances which are requested for playback prior to a gesture.
     * Once a gesture is observed, we begin playing all elements of this Array.
     * @type {Function[]}
     * @see Sound
     */
    pending: Function[];
    /**
     * A flag for whether video playback is currently locked by awaiting a user gesture
     * @type {boolean}
     */
    locked: boolean;
    /**
     * Audio Context singleton used for analysing audio levels of each stream
     * Only created if necessary to listen to audio streams.
     *
     * @type {AudioContext}
     * @private
     */
    private _audioContext;
    /**
     * Map of all streams that we listen to for determining the decibel levels.
     * Used for analyzing audio levels of each stream.
     * Format of the object stored is :
     * {id:
     *   {
     *     stream: MediaStream,
     *     analyser: AudioAnalyser,
     *     interval: Number,
     *     callback: Function
     *   }
     * }
     *
     * @type {Object}
     * @private
     */
    private _analyserStreams;
    /**
     * Interval ID as returned by setInterval for analysing the volume of streams
     * When set to 0, means no timer is set.
     * @type {number}
     * @private
     */
    private _analyserInterval;
    /**
     * Fast Fourier Transform Array.
     * Used for analysing the decibel level of streams. The array is allocated only once
     * then filled by the analyser repeatedly. We only generate it when we need to listen to
     * a stream's level, so we initialize it to null.
     * @type {Float32Array}
     * @private
     */
    private _fftArray;
    /**
     * A Promise which resolves once the game audio API is unlocked and ready to use.
     * @type {Promise<AudioContext>}
     */
    unlock: Promise<AudioContext>;
    /**
     * Create a Sound instance for a given audio source URL
     * @param {object} options      Audio creation options
     * @param {string} options.src                  The source URL for the audio file
     * @param {boolean} [options.singleton=true]    Reuse an existing Sound for this source?
     * @param {boolean} [options.preload=false]     Begin loading the audio immediately?
     * @param {boolean} [options.autoplay=false]    Begin playing the audio as soon as it is ready?
     * @param {object} [options.autoplayOptions={}] Additional options passed to the play method if autoplay is true
     * @returns {Sound}
     */
    create({ src, singleton, preload, autoplay, autoplayOptions }?: {
        src: string;
        singleton?: boolean;
        preload?: boolean;
        autoplay?: boolean;
        autoplayOptions?: object;
    }): Sound;
    /**
     * Play a single Sound by providing its source.
     * @param {string} src            The file path to the audio source being played
     * @param {object} [options]       Additional options passed to Sound#play
     * @returns {Promise<Sound>}      The created Sound which is now playing
     */
    play(src: string, options?: object): Promise<Sound>;
    /**
     * Register an event listener to await the first mousemove gesture and begin playback once observed.
     * @returns {Promise<AudioContext>}       The unlocked audio context
     */
    awaitFirstGesture(): Promise<AudioContext>;
    /**
     * Request that other connected clients begin preloading a certain sound path.
     * @param {string} src          The source file path requested for preload
     * @returns {Promise<Sound>}    A Promise which resolves once the preload is complete
     */
    preload(src: string): Promise<Sound>;
    /**
     * Retrieve an AudioBuffer from the buffers cache, if it is available
     * @param {string} src          The buffer audio source path
     * @returns {AudioBuffer}       The AudioBuffer instance if cached, otherwise undefined
     */
    getCache(src: string): AudioBuffer;
    /**
     * Update the last accessed time and playing status of a cached buffer.
     * @param {string} src          The buffer audio source path
     * @param {boolean} playing     Is the buffer currently playing?
     */
    updateCache(src: string, playing?: boolean): void;
    /**
     * Insert an AudioBuffer into the buffers cache.
     * See https://padenot.github.io/web-audio-perf/#memory-profiling
     * @param {string} src          The buffer audio source path
     * @param {AudioBuffer} buffer  The AudioBuffer instance
     */
    setCache(src: string, buffer: AudioBuffer): number;
    /**
     * Returns a singleton AudioContext if one can be created.
     * An audio context may not be available due to limited resources or browser compatibility
     * in which case null will be returned
     *
     * @returns {AudioContext}  A singleton AudioContext or null if one is not available
     */
    getAudioContext(): AudioContext;
    /**
     * Registers a stream for periodic reports of audio levels.
     * Once added, the callback will be called with the maximum decibel level of
     * the audio tracks in that stream since the last time the event was fired.
     * The interval needs to be a multiple of AudioHelper.levelAnalyserNativeInterval which defaults at 50ms
     *
     * @param {string} id             An id to assign to this report. Can be used to stop reports
     * @param {MediaStream} stream    The MediaStream instance to report activity on.
     * @param {Function} callback     The callback function to call with the decibel level. `callback(dbLevel)`
     * @param {number} interval       (optional) The interval at which to produce reports.
     * @param {number} smoothing      (optional) The smoothingTimeConstant to set on the audio analyser. Refer to AudioAnalyser API docs.
     * @returns {boolean}              Returns whether or not listening to the stream was successful
     */
    startLevelReports(id: string, stream: MediaStream, callback: Function, interval?: number, smoothing?: number): boolean;
    /**
     * Stop sending audio level reports
     * This stops listening to a stream and stops sending reports.
     * If we aren't listening to any more streams, cancel the global analyser timer.
     * @param {string} id      The id of the reports that passed to startLevelReports.
     */
    stopLevelReports(id: string): void;
    /**
     * Ensures the global analyser timer is started
     *
     * We create only one timer that runs every 50ms and only create it if needed, this is meant to optimize things
     * and avoid having multiple timers running if we want to analyse multiple streams at the same time.
     * I don't know if it actually helps much with performance but it's expected that limiting the number of timers
     * running at the same time is good practice and with JS itself, there's a potential for a timer congestion
     * phenomenon if too many are created.
     * @private
     */
    private _ensureAnalyserTimer;
    /**
     * Cancel the global analyser timer
     * If the timer is running and has become unnecessary, stops it.
     * @private
     */
    private _cancelAnalyserTimer;
    /**
     * Capture audio level for all speakers and emit a webrtcVolumes custom event with all the volume levels
     * detected since the last emit.
     * The event's detail is in the form of {userId: decibelLevel}
     * @private
     */
    private _emitVolumes;
    /**
     * Handle the first observed user gesture
     * @param {Event} event         The mouse-move event which enables playback
     * @param {Function} resolve    The Promise resolution function
     * @private
     */
    private _onFirstGesture;
    /**
     * Additional standard callback events that occur whenever a global volume slider is adjusted
     * @param {string} key        The setting key
     * @param {number} volume     The new volume level
     * @private
     */
    private _onChangeGlobalVolume;
    #private;
}
/**
 * An AudioSourceNode container which handles the strategy of node type to use for playback.
 * Used by the Sound interface which controls playback.
 * This class is for internal use only and should not be used by external callers.
 */
declare class AudioContainer {
    /**
     * The maximum duration, in seconds, for which an AudioBuffer will be used.
     * Otherwise, a streaming media element will be used.
     * @type {number}
     */
    static MAX_BUFFER_DURATION: number;
    /**
     * The sequence of container loading states.
     * @enum {number}
     */
    static LOAD_STATES: {
        FAILED: number;
        NONE: number;
        LOADING: number;
        LOADED: number;
    };
    constructor(src: any);
    /**
     * The audio source path
     * @type {string}
     */
    src: string;
    /**
     * The Audio Node used to control this sound
     * @type {AudioBufferSourceNode|MediaElementAudioSourceNode}
     */
    sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode;
    /**
     * The GainNode used to control volume
     * @type {GainNode}
     */
    gainNode: GainNode;
    /**
     * Is this container using an AudioBuffer?
     * @type {boolean}
     */
    isBuffer: boolean;
    /**
     * Whether we have attempted to load the audio node or not, and whether it failed.
     * @see {LOAD_STATES}
     * @type {number}
     */
    loadState: number;
    /**
     * Is the audio source currently playing?
     * @type {boolean}
     */
    playing: boolean;
    /**
     * Should the audio source loop?
     * @type {boolean}
     * @private
     */
    private _loop;
    set loop(arg: boolean);
    get loop(): boolean;
    /**
     * Has the audio file been loaded either fully or for streaming.
     * @type {boolean}
     */
    get loaded(): boolean;
    /**
     * Did the audio file fail to load.
     * @type {boolean}
     */
    get failed(): boolean;
    /**
     * A reference to the AudioBuffer if the sourceNode is a AudioBufferSourceNode.
     * @returns {AudioBuffer}
     */
    get buffer(): AudioBuffer;
    /**
     * The game audio context used throughout the application.
     * @returns {AudioContext}
     */
    get context(): AudioContext;
    /**
     * The total duration of the audio source in seconds
     * @type {number}
     */
    get duration(): number;
    /**
     * A reference to the HTMLMediaElement, if the sourceNode is a MediaElementAudioSourceNode.
     * @returns {HTMLMediaElement}
     */
    get element(): HTMLMediaElement;
    /**
     * Load the source node required for playback of this audio source
     * @returns {Promise<void>}
     */
    load(): Promise<void>;
    /**
     * Create the initial audio node used for playback.
     * Determine the node type to use based on cached state and sound duration.
     * @returns {AudioBufferSourceNode|MediaElementAudioSourceNode}
     * @private
     */
    private _createNode;
    /**
     * Create an Audio source node using a buffered array.
     * @param {string} src                The source URL from which to create the buffer
     * @returns {Promise<AudioBuffer>}    The created and decoded buffer
     */
    createAudioBuffer(src: string): Promise<AudioBuffer>;
    /**
     * Create a AudioBufferSourceNode using a provided AudioBuffer
     * @private
     */
    private _createAudioBufferSourceNode;
    /**
     * Create an HTML5 Audio element which has loaded the metadata for the provided source.
     * @returns {Promise<HTMLAudioElement>}
     * @private
     */
    private _createAudioElement;
    /**
     * Create a MediaElementAudioSourceNode using a provided HTMLAudioElement
     * @private
     */
    private _createMediaElementAudioSourceNode;
    /**
     * Begin playback for the source node.
     * @param {number} [offset]       The desired start time
     * @param {Function} [onended]    A callback function for when playback concludes naturally
     */
    play(offset?: number, onended?: Function): void;
    /**
     * Terminate playback for the source node.
     */
    stop(): void;
    /**
     * Perform cleanup actions when the sound has finished playing. For
     * MediaElementAudioSourceNodes, this also means optionally restarting if
     * the sound is supposed to loop.
     * @param {Function} onended A callback provided by the owner of the container that gets fired when the sound ends.
     * @private
     */
    private _onEnd;
    /**
     * Unload the MediaElementAudioSourceNode to terminate any ongoing
     * connections.
     * @private
     */
    private _unloadMediaNode;
}
/**
 * The Sound class is used to control the playback of audio sources using the Web Audio API.
 */
declare class Sound {
    /**
     * A global audio node ID used to quickly reference a specific audio node
     * @type {number}
     * @private
     */
    private static _nodeId;
    constructor(src: any, { container }?: {
        container: any;
    });
    /**
     * The numeric identifier for accessing this node
     * @type {number}
     */
    id: number;
    /**
     * The audio source path
     * @type {string}
     */
    src: string;
    /**
     * The AudioContainer which controls playback
     * @type {AudioContainer}
     */
    container: AudioContainer;
    /**
     * The time in seconds at which playback was started
     * @type {number}
     */
    startTime: number;
    /**
     * The time in seconds at which playback was paused
     * @type {number}
     */
    pausedTime: number;
    /**
     * Registered event callbacks
     * @type {{stop: {}, start: {}, end: {}, pause: {}, load: {}}}
     */
    events: {
        stop: {};
        start: {};
        end: {};
        pause: {};
        load: {};
    };
    /**
     * The registered event handler id for this Sound.
     * Incremented each time a callback is registered.
     * @type {number}
     * @private
     */
    private _eventHandlerId;
    /**
     * If this Sound source is currently in the process of loading, this attribute contains a Promise that will resolve
     * when the loading process completes.
     * @type {Promise}
     */
    loading: Promise<any>;
    /**
     * A collection of scheduled events recorded as window timeout IDs
     * @type {Set<number>}
     * @private
     */
    private _scheduledEvents;
    /**
     * A convenience reference to the sound context used by the application
     * @returns {AudioContext}
     */
    get context(): AudioContext;
    /**
     * A reference to the audio source node being used by the AudioContainer
     * @returns {AudioBufferSourceNode|MediaElementAudioSourceNode}
     */
    get node(): AudioBufferSourceNode | MediaElementAudioSourceNode;
    /**
     * A reference to the GainNode parameter which controls volume
     * @type {AudioParam}
     */
    get gain(): AudioParam;
    /**
     * The current playback time of the sound
     * @returns {number}
     */
    get currentTime(): number;
    /**
     * The total sound duration, in seconds
     * @type {number}
     */
    get duration(): number;
    /**
     * Is the contained audio node loaded and ready for playback?
     * @type {boolean}
     */
    get loaded(): boolean;
    /**
     * Did the contained audio node fail to load?
     * @type {boolean}
     */
    get failed(): boolean;
    /**
     * Is the audio source currently playing?
     * @type {boolean}
     */
    get playing(): boolean;
    set loop(arg: boolean);
    /**
     * Is the Sound current looping?
     * @type {boolean}
     */
    get loop(): boolean;
    set volume(arg: number);
    /**
     * The volume at which the Sound is playing
     * @returns {number}
     */
    get volume(): number;
    /**
     * Fade the volume for this sound between its current level and a desired target volume
     * @param {number} volume                     The desired target volume level between 0 and 1
     * @param {object} [options={}]               Additional options that configure the fade operation
     * @param {number} [options.duration=1000]      The duration of the fade effect in milliseconds
     * @param {number} [options.from]               A volume level to start from, the current volume by default
     * @param {string} [options.type=linear]        The type of fade easing, "linear" or "exponential"
     * @returns {Promise<void>}                   A Promise that resolves after the requested fade duration
     */
    fade(volume: number, { duration, from, type }?: {
        duration?: number;
        from?: number;
        type?: string;
    }): Promise<void>;
    /**
     * Load the audio source, creating an AudioBuffer.
     * Audio loading is idempotent, it can be requested multiple times but only the first load request will be honored.
     * @param {object} [options={}]   Additional options which affect resource loading
     * @param {boolean} [options.autoplay=false]  Automatically begin playback of the audio source once loaded
     * @param {object} [options.autoplayOptions]  Additional options passed to the play method when loading is complete
     * @returns {Promise<Sound>}      The Sound once its source audio buffer is loaded
     */
    load({ autoplay, autoplayOptions }?: {
        autoplay?: boolean;
        autoplayOptions?: object;
    }): Promise<Sound>;
    /**
     * Begin playback for the sound node
     * @param {object} [options={}]   Options which configure playback
     * @param {boolean} [options.loop=false]    Whether to loop the audio automatically
     * @param {number} [options.offset]         A specific offset in seconds at which to begin playback
     * @param {number} [options.volume]         The desired volume at which to begin playback
     * @param {number} [options.fade=0]         Fade volume changes over a desired duration in milliseconds
     */
    play({ loop, offset, volume, fade }?: {
        loop?: boolean;
        offset?: number;
        volume?: number;
        fade?: number;
    }): any;
    /**
     * Pause playback, remembering the playback position in order to resume later.
     */
    pause(): void;
    /**
     * Stop playback, fully resetting the Sound to a non-playing state.
     */
    stop(): void;
    /**
     * Schedule a function to occur at the next occurrence of a specific playbackTime for this Sound.
     * @param {Function} fn           A function that will be called with this Sound as its single argument
     * @param {number} playbackTime   The desired playback time at which the function should be called
     * @returns {Promise<null>}       A Promise which resolves once the scheduled function has been called
     *
     * @example Schedule audio playback changes
     * ```js
     * sound.schedule(() => console.log("Do something exactly 30 seconds into the track"), 30);
     * sound.schedule(() => console.log("Do something next time the track loops back to the beginning"), 0);
     * sound.schedule(() => console.log("Do something 5 seconds before the end of the track"), sound.duration - 5);
     * ```
     */
    schedule(fn: Function, playbackTime: number): Promise<null>;
    /**
     * Trigger registered callback functions for a specific event name.
     * @param {string} eventName      The event name being emitted
     */
    emit(eventName: string): void;
    /**
     * Deactivate an event handler which was previously registered for a specific event
     * @param {string} eventName      The event name being deactivated
     * @param {number|Function} fn    The callback ID or callback function being un-registered
     */
    off(eventName: string, fn: number | Function): void;
    /**
     * Register an event handler to take actions for a certain Sound event.
     * @param {string} eventName      The event name being deactivated
     * @param {Function} fn           The callback function to trigger when the event occurs
     * @param {object} [options={}]   Additional options that affect callback registration
     * @param {boolean} [options.once=false]  Trigger the callback once only and automatically un-register it
     */
    on(eventName: string, fn: Function, { once }?: {
        once?: boolean;
    }): number;
    /**
     * Register a new callback function for a certain event. For internal use only.
     * @private
     */
    private _registerForEvent;
    /**
     * Cancel all pending scheduled events.
     * @private
     */
    private _clearEvents;
    /**
     * Called when playback concludes naturally
     * @protected
     */
    protected _onEnd(): void;
    /**
     * Called when the audio buffer is first loaded
     * @protected
     */
    protected _onLoad(): void;
    /**
     * Called when playback is paused
     * @protected
     */
    protected _onPause(): void;
    /**
     * Called when the sound begins playing
     * @protected
     */
    protected _onStart(): void;
    /**
     * Called when playback is stopped (prior to naturally reaching the end)
     * @protected
     */
    protected _onStop(): void;
}
/**
 * A tour for demonstrating an aspect of Canvas functionality.
 * Automatically activates a certain canvas layer or tool depending on the needs of the step.
 */
declare class CanvasTour extends Tour {
    /** @override */
    override start(): Promise<void>;
    #private;
}
/**
 * A Tour subclass that handles controlling the UI state of the Setup screen
 */
declare class SetupTour extends Tour {
    /**
     * Stores a currently open Application for future steps
     * @type {Application}
     */
    focusedApp: Application;
    /**
     * Handle Step setup for the Installing a System Tour
     * @returns {Promise<void>}
     * @private
     */
    private _installingASystem;
    /**
     * Handle Step setup for the Creating a World Tour
     * @returns {Promise<void>}
     * @private
     */
    private _creatingAWorld;
}
/**
 * A Tour subclass for the Sidebar Tour
 */
declare class SidebarTour extends Tour {
    /** @override */
    override start(): Promise<void>;
    _updateSidebarTab(): Promise<void>;
}
type PackageCompatibilityBadge = {
    /**
     * A type in "safe", "unsafe", "warning", "neutral" applied as a CSS class
     */
    type: string;
    /**
     * A tooltip string displayed when hovering over the badge
     */
    tooltip: string;
    /**
     * An optional text label displayed in the badge
     */
    label?: string;
    /**
     * An optional icon displayed in the badge
     */
    icon?: string;
};
type DirectoryMixinEntry = {
    /**
     * The unique id of the entry
     */
    id: string;
    /**
     * The folder id or folder object to which this entry belongs
     */
    folder: Folder | string;
    /**
     * An image path to display for the entry
     */
    img?: string;
    /**
     * A numeric sort value which orders this entry relative to others
     */
    sort?: string;
};
/**
 * A leaf entry in the tree.
 */
type WordTreeEntry = {
    /**
     * An object that this entry represents.
     */
    entry: Document | object;
    /**
     * The document type.
     */
    documentName: string;
    /**
     * The document's UUID.
     */
    uuid: string;
    /**
     * The pack ID.
     */
    pack?: string;
};
/**
 * A word tree node consists of zero or more 1-character keys, and a leaves property that contains any objects that
 * terminate at the current string prefix.
 */
type WordTreeNode = {
    /**
     * Any leaves at this node.
     */
    leaves: {
        /**
         * An object that this entry represents.
         */
        entry: any;
        /**
         * The document type.
         */
        documentName: string;
        /**
         * The document's UUID.
         */
        uuid: string;
        /**
         * The pack ID.
         */
        pack?: string;
    }[];
};
type HookedFunction = {
    hook: string;
    id: number;
    fn: Function;
    once: boolean;
};
type UsabilityIssue = {
    /**
     * The pre-localized message to display in relation to the usability issue.
     */
    message: string;
    /**
     * The severity of the issue, either "error", "warning", or "info".
     */
    severity: string;
    /**
     * Parameters to supply to the localization.
     */
    params?: object;
};
type BrowserTest = {
    /**
     * The minimum supported version for this browser.
     */
    minimum: number;
    /**
     * A regular expression to match the browser against the user agent string.
     */
    match: RegExp;
    /**
     * A message to display if the user's browser version does not meet the minimum.
     */
    message: string;
};
type PackageCompatibilityIssue = {
    /**
     * Error messages.
     */
    error: string[];
    /**
     * Warning messages.
     */
    warning: string[];
};
/**
 * An object structure of document types at the top level, with a count of different sub-types for that document type.
 */
type ModuleSubTypeCounts = any;
/**
 * Allowed modifier keys
 */
type MODIFIER_KEYS = string;
/**
 * Track which KeyboardEvent#code presses associate with each modifier
 */
type MODIFIER_CODES = string[];
/**
 * The directions in which a tooltip can extend, relative to its tool-tipped element.
 */
type TOOLTIP_DIRECTIONS = string;
type STATUS = string;
/**
 * A step in a Tour
 */
type TourStep = {
    /**
     * A machine-friendly id of the Tour Step
     */
    id: string;
    /**
     * The title of the step, displayed in the tooltip header
     */
    title: string;
    /**
     * Raw HTML content displayed during the step
     */
    content: string;
    /**
     * A DOM selector which denotes an element to highlight during this step.
     *             If omitted, the step is displayed in the center of the screen.
     */
    selector?: string;
    /**
     * How the tooltip for the step should be displayed
     * relative to the target element. If omitted, the best direction will be attempted to be auto-selected.
     */
    tooltipDirection?: {
        UP: string;
        DOWN: string;
        LEFT: string;
        RIGHT: string;
        CENTER: string;
    };
    /**
     * Whether the Step is restricted to the GM only. Defaults to false.
     */
    restricted?: boolean;
};
/**
 * Tour configuration data
 */
type TourConfig = {
    /**
     * The namespace this Tour belongs to. Typically, the name of the package which
     * implements the tour should be used
     */
    namespace: string;
    /**
     * A machine-friendly id of the Tour, must be unique within the provided namespace
     */
    id: string;
    /**
     * A human-readable name for this Tour. Localized.
     */
    title: string;
    /**
     * The list of Tour Steps
     */
    steps: TourStep[];
    /**
     * A human-readable description of this Tour. Localized.
     */
    description?: string;
    /**
     * A map of localizations for the Tour that should be merged into the default localizations
     */
    localization?: object;
    /**
     * Whether the Tour is restricted to the GM only. Defaults to false.
     */
    restricted?: boolean;
    /**
     * Whether the Tour should be displayed in the Manage Tours UI. Defaults to false.
     */
    display?: boolean;
    /**
     * Whether the Tour can be resumed or if it always needs to start from the beginning. Defaults to false.
     */
    canBeResumed?: boolean;
    /**
     * A list of namespaced Tours that might be suggested to the user when this Tour is completed.
     *   The first non-completed Tour in the array will be recommended.
     */
    suggestedNextTours?: string[];
};
type WorkerTask = {
    [x: string]: any;
};
/**
 * Supported worker task actions
 */
type WORKER_TASK_ACTIONS = string;
/**
 * The sequence of rendering states that track the Application life-cycle.
 */
type RENDER_STATES = number;
type ApplicationOptions = {
    /**
     * A named "base application" which generates an additional hook
     */
    baseApplication?: string | null;
    /**
     * The default pixel width for the rendered HTML
     */
    width?: number | null;
    /**
     * The default pixel height for the rendered HTML
     */
    height?: number | string | null;
    /**
     * The default offset-top position for the rendered HTML
     */
    top?: number | null;
    /**
     * The default offset-left position for the rendered HTML
     */
    left?: number | null;
    /**
     * A transformation scale for the rendered HTML
     */
    scale?: number | null;
    /**
     * Whether to display the application as a pop-out container
     */
    popOut?: boolean;
    /**
     * Whether the rendered application can be minimized (popOut only)
     */
    minimizable?: boolean;
    /**
     * Whether the rendered application can be drag-resized (popOut only)
     */
    resizable?: boolean;
    /**
     * The default CSS id to assign to the rendered HTML
     */
    id?: string;
    /**
     * An array of CSS string classes to apply to the rendered HTML
     */
    classes?: string[];
    /**
     * A default window title string (popOut only)
     */
    title?: string;
    /**
     * The default HTML template path to render for this Application
     */
    template?: string | null;
    /**
     * A list of unique CSS selectors which target containers that should have their
     *           vertical scroll positions preserved during a re-render.
     */
    scrollY?: string[];
    /**
     * An array of tabbed container configurations which should be enabled for the
     *   application.
     */
    tabs?: TabsConfiguration[];
    /**
     * An array of CSS selectors for configuring the application's
     * {@link DragDrop } behaviour.
     */
    dragDrop: DragDropConfiguration[];
    /**
     * An array of {@link SearchFilter } configuration objects.
     */
    filters: SearchFilterConfiguration[];
};
type FormApplicationOptions = ApplicationOptions;
type DocumentSheetOptions = FormApplicationOptions;
type TextEditorOptions = {
    /**
     * The named target data element
     */
    target?: string;
    /**
     * Include a button used to activate the editor later?
     */
    button?: boolean;
    /**
     * A specific CSS class to add to the editor container
     */
    class?: string;
    /**
     * Is the text editor area currently editable?
     */
    editable?: boolean;
    /**
     * The editor engine to use, see {@link TextEditor.create }.
     */
    engine?: string;
    /**
     * Whether to turn on collaborative editing features for ProseMirror.
     *
     * The below options are deprecated since v10 and should be avoided.
     */
    collaborate?: boolean;
    /**
     * Is the current user an owner of the data?
     */
    owner?: boolean;
    /**
     * Replace dynamic document links?
     */
    documents?: boolean;
    /**
     * The data object providing context for inline rolls
     */
    rollData?: any | Function;
    /**
     * The original HTML content as a string
     */
    content?: string;
};
type HotReloadData = {
    /**
     * The type of package which was modified
     */
    packageType: string;
    /**
     * The id of the package which was modified
     */
    packageId: string;
    /**
     * The updated stringified file content
     */
    content: string;
    /**
     * The relative file path which was modified
     */
    path: string;
    /**
     * The file extension which was modified, e.g. "js", "css", "html"
     */
    extension: string;
};
type DiceTermResult = {
    /**
     * The numeric result
     */
    result: number;
    /**
     * Is this result active, contributing to the total?
     */
    active?: boolean;
    /**
     * A value that the result counts as, otherwise the result is not used directly as
     */
    count?: number;
    /**
     * Does this result denote a success?
     */
    success?: boolean;
    /**
     * Does this result denote a failure?
     */
    failure?: boolean;
    /**
     * Was this result discarded?
     */
    discarded?: boolean;
    /**
     * Was this result rerolled?
     */
    rerolled?: boolean;
    /**
     * Was this result exploded?
     */
    exploded?: boolean;
};
type ManageCompendiumRequest = SocketRequest;
type ManageCompendiumResponse = SocketResponse;
type ActiveEffectDuration = EffectDurationData;
type AdventureImportData = {
    /**
     * Arrays of document data to create, organized by document name
     */
    toCreate: any;
    /**
     * Arrays of document data to update, organized by document name
     */
    toUpdate: any;
    /**
     * The total count of documents to import
     */
    documentCount: number;
};
type AdventureImportResult = {
    /**
     * Documents created as a result of the import, organized by document name
     */
    created: any;
    /**
     * Documents updated as a result of the import, organized by document name
     */
    updated: any;
};
type CombatHistoryData = {
    round: number | null;
    turn: number | null;
    tokenId: string | null;
    combatantId: string | null;
};
type JournalEntryPageHeading = {
    /**
     * The heading level, 1-6.
     */
    level: number;
    /**
     * The raw heading text with any internal tags omitted.
     */
    text: string;
    /**
     * The generated slug for this heading.
     */
    slug: string;
    /**
     * The currently rendered element for this heading, if it exists.
     */
    element?: HTMLHeadingElement;
    /**
     * Any child headings of this one.
     */
    children: string[];
};
type SceneDimensions = {
    /**
     * The width of the canvas.
     */
    width: number;
    /**
     * The height of the canvas.
     */
    height: number;
    /**
     * The grid size.
     */
    size: number;
    /**
     * The canvas rectangle.
     */
    rect: Rectangle;
    /**
     * The X coordinate of the scene rectangle within the larger canvas.
     */
    sceneX: number;
    /**
     * The Y coordinate of the scene rectangle within the larger canvas.
     */
    sceneY: number;
    /**
     * The width of the scene.
     */
    sceneWidth: number;
    /**
     * The height of the scene.
     */
    sceneHeight: number;
    /**
     * The scene rectangle.
     */
    sceneRect: Rectangle;
    /**
     * The number of distance units in a single grid space.
     */
    distance: number;
    /**
     * The aspect ratio of the scene rectangle.
     */
    ratio: number;
    /**
     * The length of the longest line that can be drawn on the canvas.
     */
    maxR: number;
};
/**
 * An object containing the executed Roll and the produced results
 */
type RollTableDraw = {
    /**
     * The Dice roll which generated the draw
     */
    roll: Roll;
    /**
     * An array of drawn TableResult documents
     */
    results: TableResult[];
};
type TrackedAttributesDescription = {
    /**
     * A list of property path arrays to attributes with both a value and a max property.
     */
    bar: string[][];
    /**
     * A list of property path arrays to attributes that have only a value property.
     */
    value: string[][];
};
type PingData = {
    /**
     * Pulls all connected clients' views to the pinged co-ordinates.
     */
    pull?: boolean;
    /**
     * The ping style, see CONFIG.Canvas.pings.
     */
    style: string;
    /**
     * The ID of the scene that was pinged.
     */
    scene: string;
    /**
     * The zoom level at which the ping was made.
     */
    zoom: number;
};
type ActivityData = {
    /**
     * The ID of the scene that the user is viewing.
     */
    sceneId?: string | null;
    /**
     * The position of the user's cursor.
     */
    cursor?: {
        x: number;
        y: number;
    };
    /**
     * The state of the user's ruler, if they are currently using one.
     */
    ruler?: {
        /**
         * The ruler measurement state.
         */
        _state: number;
        /**
         * A unique name for the ruler containing the owning user's ID.
         */
        name: string;
        /**
         * The current point the ruler has been extended to.
         */
        destination: PIXI.Point;
        /**
         * The class name of this ruler instance.
         */
        class: string;
        /**
         * Additional waypoints along the ruler's length, including the starting point.
         */
        waypoints: PIXI.Point[];
    };
    /**
     * The IDs of the tokens the user has targeted in the currently viewed
     *               scene.
     */
    targets?: string[];
    /**
     * Whether the user has an open WS connection to the server or not.
     */
    active?: boolean;
    /**
     * Is the user emitting a ping at the cursor coordinates?
     */
    ping?: {
        /**
         * Pulls all connected clients' views to the pinged co-ordinates.
         */
        pull?: boolean;
        /**
         * The ping style, see CONFIG.Canvas.pings.
         */
        style: string;
        /**
         * The ID of the scene that was pinged.
         */
        scene: string;
        /**
         * The zoom level at which the ping was made.
         */
        zoom: number;
    };
    /**
     * The state of the user's AV settings.
     */
    av?: AVSettingsData;
};
type CanvasPerformanceSettings = {
    /**
     * The performance mode in CONST.CANVAS_PERFORMANCE_MODES
     */
    mode: number;
    /**
     * Blur filter configuration
     */
    blur: {
        enabled: boolean;
        illumination: boolean;
    };
    /**
     * Whether to use mipmaps, "ON" or "OFF"
     */
    mipmap: string;
    /**
     * Whether to apply MSAA at the overall canvas level
     */
    msaa: boolean;
    /**
     * Maximum framerate which should be the render target
     */
    fps: number;
    /**
     * Whether to display token movement animation
     */
    tokenAnimation: boolean;
    /**
     * Whether to display light source animation
     */
    lightAnimation: boolean;
    /**
     * Whether to render soft edges for light sources
     */
    lightSoftEdges: boolean;
    /**
     * Texture configuration
     */
    textures: {
        enabled: boolean;
        maxSize: number;
        p2Steps: number;
        p2StepsMax: 2;
    };
};
type CanvasSupportedComponents = {
    /**
     * Is WebGL2 supported?
     */
    webGL2: boolean;
    /**
     * Is reading pixels in RED format supported?
     */
    readPixelsRED: boolean;
    /**
     * Is the OffscreenCanvas supported?
     */
    offscreenCanvas: boolean;
};
type CanvasViewPosition = {
    /**
     * The x-coordinate which becomes stage.pivot.x
     */
    x: number | null;
    /**
     * The y-coordinate which becomes stage.pivot.y
     */
    y: number | null;
    /**
     * The zoom level up to CONFIG.Canvas.maxZoom which becomes stage.scale.x and y
     */
    scale: number | null;
};
/**
 * Track objects which have pending render flags.
 */
type pendingRenderFlags = Set<RenderFlagObject>;
/**
 * A constant that enumerates the index order of the quadtree nodes from top-left to bottom-right.
 */
type INDICES = number;
type QuadtreeObject = {
    r: Rectangle;
    t: any;
    n?: Set<Quadtree>;
};
type CanvasAnimationAttribute = {
    /**
     * The attribute name being animated
     */
    attribute: string;
    /**
     * The object within which the attribute is stored
     */
    parent: any;
    /**
     * The destination value of the attribute
     */
    to: number;
    /**
     * An initial value of the attribute, otherwise parent[attribute] is used
     */
    from?: number;
    /**
     * The computed delta between to and from
     */
    delta?: number;
    /**
     * The amount of the total delta which has been animated
     */
    done?: number;
    /**
     * Is this a color animation that applies to RGB channels
     */
    color?: boolean;
};
type CanvasAnimationOptions = {
    /**
     * A DisplayObject which defines context to the PIXI.Ticker function
     */
    context?: PIXI.DisplayObject;
    /**
     * A unique name which can be used to reference the in-progress animation
     */
    name?: string;
    /**
     * A duration in milliseconds over which the animation should occur
     */
    duration?: number;
    /**
     * A priority in PIXI.UPDATE_PRIORITY which defines when the animation
     *             should be evaluated related to others
     */
    priority?: number;
    /**
     * An easing function used to translate animation time or the string name
     *      of a static member of the CanvasAnimation class
     */
    easing?: Function | string;
    /**
     * A callback function which fires after every frame
     */
    ontick?: (arg0: number, arg1: CanvasAnimationData) => any;
};
type CanvasAnimationData = CanvasAnimationOptions;
/**
 * Enumerate the states of a mouse interaction workflow.
 * 0: NONE - the object is inactive
 * 1: HOVER - the mouse is hovered over the object
 * 2: CLICKED - the object is clicked
 * 3: DRAG - the object is being dragged
 * 4: DROP - the object is being dropped
 */
type INTERACTION_STATES = number;
type PingOptions = {
    /**
     * The duration of the animation in milliseconds.
     */
    duration?: number;
    /**
     * The size of the ping graphic.
     */
    size?: number;
    /**
     * The color of the ping graphic.
     */
    color?: string;
    /**
     * The name for the ping animation to pass to {@link CanvasAnimation.animate }.
     */
    name?: string;
};
type RenderFlag = {
    /**
     * Activating this flag also sets these flags to true
     */
    propagate: string[];
    /**
     * Activating this flag resets these flags to false
     */
    reset: string[];
};
type RayIntersection = {
    /**
     * The x-coordinate of intersection
     */
    x: number;
    /**
     * The y-coordinate of intersection
     */
    y: number;
    /**
     * The proximity to the Ray origin, as a ratio of distance
     */
    t0: number;
    /**
     * The proximity to the Ray destination, as a ratio of distance
     */
    t1: number;
};
/**
 * Customize how wall direction of one-way walls is applied
 */
type WALL_DIRECTION_MODES = number;
type ClipperPoints = ClipperPoint[];
type PointSourcePolygonConfig = {
    /**
     * The type of polygon being computed
     */
    type?: string;
    /**
     * The angle of emission, if limited
     */
    angle?: number;
    /**
     * The desired density of padding rays, a number per PI
     */
    density?: number;
    /**
     * A limited radius of the resulting polygon
     */
    radius?: number;
    /**
     * The direction of facing, required if the angle is limited
     */
    rotation?: number;
    /**
     * Customize how wall direction of one-way walls is applied
     */
    wallDirectionMode?: number;
    /**
     * Compute the polygon with threshold wall constraints applied
     */
    useThreshold?: boolean;
    /**
     * Display debugging visualization and logging for the polygon
     */
    debug?: boolean;
    /**
     * The object (if any) that spawned this polygon.
     */
    source?: PointSource;
    /**
     * Limiting polygon boundary shapes
     */
    boundaryShapes?: Array<PIXI.Rectangle | PIXI.Circle | PIXI.Polygon>;
    /**
     * Does this polygon use the Scene inner or outer bounding rectangle
     */
    useInnerBounds?: Readonly<boolean>;
    /**
     * Does this polygon have a limited radius?
     */
    hasLimitedRadius?: Readonly<boolean>;
    /**
     * Does this polygon have a limited angle?
     */
    hasLimitedAngle?: Readonly<boolean>;
    /**
     * The computed bounding box for the polygon
     */
    boundingBox?: Readonly<PIXI.Rectangle>;
};
type PulsePingOptions = PingOptions;
/**
 * Creation states affected to placeables during their construction.
 */
type CREATION_STATES = number;
type CanvasHistory = {
    /**
     * The type of operation stored as history (create, update, delete)
     */
    type: string;
    /**
     * The data corresponding to the action which may later be un-done
     */
    data: any[];
};
/**
 * An enumeration of the possible Ruler measurement states.
 */
type STATES = number;
type RulerData = {
    /**
     * The ruler measurement state.
     */
    _state: number;
    /**
     * A unique name for the ruler containing the owning user's ID.
     */
    name: string;
    /**
     * The current point the ruler has been extended to.
     */
    destination: PIXI.Point;
    /**
     * The class name of this ruler instance.
     */
    class: string;
    /**
     * Additional waypoints along the ruler's length, including the starting point.
     */
    waypoints: PIXI.Point[];
};
type RulerMeasurementSegment = {
    /**
     * The Ray which represents the point-to-point line segment
     */
    ray: Ray;
    /**
     * The text object used to display a label for this segment
     */
    label: PreciseText;
    /**
     * The measured distance of the segment
     */
    distance: number;
    /**
     * The string text displayed in the label
     */
    text: string;
    /**
     * Is this segment the last one?
     */
    last: boolean;
};
type CanvasVisibilityTestConfig = {
    /**
     * The target object
     */
    object: PlaceableObject;
    /**
     * An array of visibility tests
     */
    tests: {
        point: PIXI.Point;
        los: Map<VisionSource, boolean>;
    }[];
};
type CanvasVisibilityTest = {
    point: PIXI.Point;
    los: Map<VisionSource, boolean>;
};
type VisibilityTextureConfiguration = {
    resolution: number;
    width: number;
    height: number;
    mipmap: number;
    scaleMode: number;
    multisample: number;
};
type WeatherTerrainMaskConfiguration = {
    /**
     * Enable or disable this mask.
     */
    enabled: boolean;
    /**
     * An RGBA array of channel weights applied to the mask texture.
     */
    channelWeights: number[];
    /**
     * =false                    If the mask should be reversed.
     */
    reverse: boolean;
    /**
     * A texture which defines the mask region.
     */
    texture: PIXI.Texture | PIXI.RenderTexture;
};
type WeatherOcclusionMaskConfiguration = {
    /**
     * Enable or disable this mask.
     */
    enabled: boolean;
    /**
     * An RGBA array of channel weights applied to the mask texture.
     */
    channelWeights: number[];
    /**
     * =false                    If the mask should be reversed.
     */
    reverse: boolean;
    /**
     * A texture which defines the mask region.
     */
    texture: PIXI.Texture | PIXI.RenderTexture;
};
type HexGridConfiguration = {
    /**
     * Columnar orientation?
     */
    columns: boolean;
    /**
     * Offset even rows?
     */
    even: boolean;
    /**
     * Hex size in pixels
     */
    size: number;
    /**
     * Hex width in pixels
     */
    width?: number;
    /**
     * Hex height in pixels
     */
    height?: number;
    /**
     * Legacy hex grid computation (not recommended)
     */
    legacy?: boolean;
};
type HexCubeCoordinate = {
    /**
     * Coordinate along the SW - NE axis
     */
    q: number;
    /**
     * Coordinate along the S - N axis
     */
    r: number;
    /**
     * Coordinate along the NW - SE axis
     */
    s: number;
};
type HexOffsetCoordinate = {
    /**
     * The row coordinate
     */
    row: number;
    /**
     * The column coordinate
     */
    col: number;
};
type MeasureDistancesOptions = {
    /**
     * Return the distance in grid increments rather than the co-ordinate distance.
     */
    gridSpaces?: boolean;
};
type CanvasVisionContainer = PIXI.Container;
type PointSourceData = {
    /**
     * The x-coordinate of the source location
     */
    x: number;
    /**
     * The y-coordinate of the source location
     */
    y: number;
    /**
     * The elevation of the point source
     */
    elevation: number;
    /**
     * An index for sorting the source relative to others at the same elevation
     */
    z: number | null;
    /**
     * The radius of the source
     */
    radius: number;
    /**
     * A secondary radius used for limited angles
     */
    externalRadius: number;
    /**
     * The angle of rotation for this point source
     */
    rotation: number;
    /**
     * The angle of emission for this point source
     */
    angle: number;
    /**
     * Whether or not the source is constrained by walls
     */
    walls: boolean;
    /**
     * Whether or not the source is disabled
     */
    disabled: boolean;
};
type RenderedPointSourceLayer = {
    /**
     * Is this layer actively rendered?
     */
    active: boolean;
    /**
     * Do uniforms need to be reset?
     */
    reset: boolean;
    /**
     * Is this layer temporarily suppressed?
     */
    suppressed: boolean;
    /**
     * The rendered mesh for this layer
     */
    mesh: PointSourceMesh;
    /**
     * The shader instance used for the layer
     */
    shader: AdaptiveLightingShader;
};
type RenderedPointSourceData = {
    /**
     * The x-coordinate of the source location
     */
    x: number;
    /**
     * The y-coordinate of the source location
     */
    y: number;
    /**
     * The elevation of the point source
     */
    elevation: number;
    /**
     * An index for sorting the source relative to others at the same elevation
     */
    z: number;
    /**
     * The radius of the source
     */
    radius: number;
    /**
     * A secondary radius used for limited angles
     */
    externalRadius: number;
    /**
     * The angle of rotation for this point source
     */
    rotation: number;
    /**
     * The angle of emission for this point source
     */
    angle: number;
    /**
     * Whether or not the source is constrained by walls
     */
    walls: boolean;
    /**
     * Whether or not the source is disabled
     */
    disabled: boolean;
};
type RenderedPointSourceAnimationConfig = {
    /**
     * The human-readable (localized) label for the animation
     */
    label?: string;
    /**
     * The animation function that runs every frame
     */
    animation?: Function;
    /**
     * A custom illumination shader used by this animation
     */
    illuminationShader?: AdaptiveIlluminationShader;
    /**
     * A custom coloration shader used by this animation
     */
    colorationShader?: AdaptiveColorationShader;
    /**
     * A custom background shader used by this animation
     */
    backgroundShader?: AdaptiveBackgroundShader;
    /**
     * The animation seed
     */
    seed?: number;
    /**
     * The animation time
     */
    time?: number;
};
type LightSourceData = RenderedPointSourceData;
type VisionSourceData = RenderedPointSourceData;
type ClipperPoint = {
    X: number;
    Y: number;
};
type VertexMap = Map<number, PolygonVertex>;
type EdgeSet = Set<PolygonEdge>;
type PolygonRay = Ray;
/**
 * Colors exposed by the manager.
 */
type colors = typeof import("../../common/utils/color.mjs").default;
/**
 * Weights used by the manager to compute colors.
 */
type weights = number;
/**
 * The type of the detection mode. If its sight based, sound based, etc.
 * It is related to wall's WALL_RESTRICTION_TYPES
 */
type DETECTION_TYPES = number;
type PerceptionManagerFlags = RenderFlags;
/**
 * A shim mapping which supports backwards compatibility for old-style (V9 and before) perception manager flags.
 */
type COMPATIBILITY_MAPPING = string;
/**
 * The lighting illumination levels which are supported.
 */
type LIGHTING_LEVELS = number;
/**
 * Flags for how each lighting channel should be rendered for the currently active vision modes:
 * - Disabled: this lighting layer is not rendered, the shaders does not decide.
 * - Enabled: this lighting layer is rendered normally, and the shaders can choose if they should be rendered or not.
 * - Required: the lighting layer is rendered, the shaders does not decide.
 */
type LIGHTING_VISIBILITY = number;
/**
 * The supported clip types.
 * Values are equivalent to those in ClipperLib.ClipType.
 */
type CLIP_TYPES = number;
/**
 * The supported intersection types.
 */
type INTERSECTION_TYPES = number;
/**
 * A convenience reference to the possible shape types.
 */
type SHAPE_TYPES = string;
type TokenPosition = Point;
type ReticuleOptions = {
    /**
     * The amount of margin between the targeting arrows and the token's bounding
     *         box, expressed as a fraction of an arrow's size.
     */
    margin?: number;
    /**
     * The alpha value of the arrows.
     */
    alpha?: number;
    /**
     * The size of the arrows as a proportion of grid size.
     */
    size?: number;
    /**
     * The color of the arrows.
     */
    color?: number;
    /**
     * The arrows' border style configuration.
     */
    border?: {
        color?: number;
        width?: number;
    };
};
type PrimaryCanvasObjectDrawingShapeData = {
    /**
     * The shape
     */
    shape: object;
    /**
     * The x-coordinate of the PCO location
     */
    x: number;
    /**
     * The y-coordinate of the PCO location
     */
    y: number;
    /**
     * The z-index of the PCO
     */
    z: number;
    /**
     * The bezier factor
     */
    bezierFactor: number;
    /**
     * The fill type
     */
    fillType: number;
    /**
     * The fill color
     */
    fillColor: number;
    /**
     * The fill alpha
     */
    fillAlpha: number;
    /**
     * The stroke width
     */
    strokeWidth: number;
    /**
     * The stroke color
     */
    strokeColor: number;
    /**
     * The stroke alpha
     */
    strokeAlpha: number;
    /**
     * The text
     */
    text: string;
    /**
     * The text font family
     */
    fontFamily: string;
    /**
     * The font size
     */
    fontSize: number;
    /**
     * The text color
     */
    textColor: number;
    /**
     * The text alpha
     */
    textAlpha: number;
    /**
     * The rotation of this PCO
     */
    rotation: number;
    /**
     * The PCO is hidden?
     */
    hidden: boolean;
    /**
     * The elevation of the PCO
     */
    elevation: number;
    /**
     * The sort key that resolves ties among the same elevation
     */
    sort: number;
    /**
     * The PCO is considered as a roof?
     */
    roof: boolean;
    /**
     * The PCO is considered as overhead?
     */
    overhead: boolean;
    /**
     * The occlusion object for this PCO
     */
    occlusion: object;
    /**
     * The data texture values
     */
    texture: object;
};
type TokenMeshData = {
    /**
     * Is this TokenMesh rotation locked?
     */
    lockRotation: boolean;
};
type TokenMeshDisplayAttributes = {
    x: number;
    y: number;
    width: number;
    height: number;
    alpha: number;
    rotation: number;
    scaleX: number;
    scaleY: number;
    tint: typeof import("../../common/utils/color.mjs").default;
};
/**
 * List of compression that could be applied with extraction
 */
type COMPRESSION_MODES = number;
type TextureExtractionOptions = {
    /**
     * The texture the pixels are extracted from.
     *    Otherwise, extract from the renderer.
     */
    texture?: PIXI.Texture | PIXI.RenderTexture | null;
    /**
     * The rectangle which the pixels are extracted from.
     */
    frame?: PIXI.Rectangle;
    /**
     * The compression mode to apply, or NONE
     */
    compression?: {
        NONE: number;
        BASE64: number;
    };
    /**
     * The optional image mime type.
     */
    type?: string;
    /**
     * The optional image quality.
     */
    quality?: string;
    /**
     * The optional debug flag to use.
     */
    debug?: boolean;
};
type ShaderTechnique = {
    /**
     * The numeric identifier of the technique
     */
    id: number;
    /**
     * The localization string that labels the technique
     */
    label: string;
    /**
     * The coloration shader fragment when the technique is used
     */
    coloration: string | undefined;
    /**
     * The illumination shader fragment when the technique is used
     */
    illumination: string | undefined;
    /**
     * The background shader fragment when the technique is used
     */
    background: string | undefined;
};
/**
 * Masking modes.
 */
type FILTER_MODES = number;
/**
 * Filter post-process techniques.
 */
type POST_PROCESS_TECHNIQUES = {
    id: string;
    glsl: string;
};
type ContextMenuEntry = {
    /**
     * The context menu label. Can be localized.
     */
    name: string;
    /**
     * A string containing an HTML icon element for the menu item
     */
    icon: string;
    /**
     * The function to call when the menu item is clicked. Receives the HTML element
     * of the entry that this context menu is for.
     */
    callback: (arg0: JQueryStatic) => any;
    /**
     * A function to call to determine if this item appears in the menu.
     *  Receives the HTML element of the entry that this context menu is
     *  for.
     */
    condition?: (arg0: JQueryStatic) => boolean;
};
type ContextMenuCallback = (target: HTMLElement) => any;
type DialogOptions = ApplicationOptions;
type DialogButton = {
    /**
     * A Font Awesome icon for the button
     */
    icon: string;
    /**
     * The label for the button
     */
    label: string;
    /**
     * Whether the button is disabled
     */
    disabled: boolean;
    /**
     * A callback function that fires when the button is clicked
     */
    callback?: (arg0: JQueryStatic) => any;
};
type DialogData = {
    /**
     * The window title displayed in the dialog header
     */
    title: string;
    /**
     * HTML content for the dialog form
     */
    content: string;
    /**
     * The buttons which are displayed as action choices for the dialog
     */
    buttons: any;
    /**
     * The name of the default button which should be triggered on Enter keypress
     */
    default?: string;
    /**
     * A callback function invoked when the dialog is rendered
     */
    render?: (arg0: JQueryStatic) => any;
    /**
     * Common callback operations to perform when the dialog is closed
     */
    close?: (arg0: JQueryStatic) => any;
};
type DragDropConfiguration = {
    /**
     * The CSS selector used to target draggable elements.
     */
    dragSelector: string;
    /**
     * The CSS selector used to target viable drop targets.
     */
    dropSelector: string;
    /**
     * An object of permission test functions for each action
     */
    permissions: {
        [x: string]: Function;
    };
    /**
     * An object of callback functions for each action
     */
    callbacks: {
        [x: string]: Function;
    };
};
type EnrichmentOptions = {
    /**
     * Include unrevealed secret tags in the final HTML? If false, unrevealed
     *       secret blocks will be removed.
     */
    secrets?: boolean;
    /**
     * Replace dynamic document links?
     */
    documents?: boolean;
    /**
     * Replace hyperlink content?
     */
    links?: boolean;
    /**
     * Replace inline dice rolls?
     */
    rolls?: boolean;
    /**
     * The data object providing context for inline rolls, or a function that
     *    produces it.
     */
    rollData?: object | Function;
    /**
     * Perform the operation asynchronously returning a Promise
     */
    async?: boolean;
    /**
     * A document to resolve relative UUIDs against.
     */
    relativeTo?: ClientDocument;
};
type FavoriteFolder = {
    /**
     * The source of the folder (e.g. "data", "public")
     */
    source: string;
    /**
     * The full path to the folder
     */
    path: string;
    /**
     * The label for the path
     */
    label: string;
};
type FilePickerOptions = ApplicationOptions;
/**
 * The allowed Filter Operators which can be used to define a search filter
 */
type OPERATORS = string;
type SearchFilterConfiguration = {
    /**
     * Options which customize the behavior of the filter
     */
    options: {
        inputSelector: string;
        contentSelector: string;
        callback: Function;
        initial?: string;
        delay?: number;
    };
};
type FieldFilter = {
    /**
     * The dot-delimited path to the field being filtered
     */
    field: string;
    /**
     * The search operator, from CONST.OPERATORS
     */
    operator?: string;
    /**
     * Negate the filter, returning results which do NOT match the filter criteria
     */
    negate: boolean;
    /**
     * The value against which to test
     */
    value: any;
};
type NotifyOptions = {
    /**
     * Should the notification be permanently displayed until dismissed
     */
    permanent?: boolean;
    /**
     * Whether to localize the message content before displaying it
     */
    localize?: boolean;
    /**
     * Whether to log the message to the console
     */
    console?: boolean;
};
type ProseMirrorHistory = {
    /**
     * The ID of the user who submitted the step.
     */
    userId: string;
    /**
     * The step that was submitted.
     */
    step: Step;
};
type HTMLSecretContentCallback = (secret: HTMLElement) => string;
type HTMLSecretUpdateCallback = (secret: HTMLElement, content: string) => Promise<ClientDocument>;
type HTMLSecretConfiguration = {
    /**
     * The CSS selector used to target content that contains secret blocks.
     */
    parentSelector: string;
    /**
     * An object of callback functions for each operation.
     */
    callbacks: {
        content: HTMLSecretContentCallback;
        update: HTMLSecretUpdateCallback;
    };
};
type TabsConfiguration = {
    /**
     * The name of the tabs group
     */
    group?: string;
    /**
     * The CSS selector used to target the navigation element for these tabs
     */
    navSelector: string;
    /**
     * The CSS selector used to target the content container for these tabs
     */
    contentSelector: string;
    /**
     * The tab name of the initially active tab
     */
    initial: string;
    /**
     * An optional callback function that executes when the active tab is changed
     */
    callback?: Function | null;
};
type DocumentDirectoryOptions = ApplicationOptions;
type AdventureContentTreeNode = {
    /**
     * An alias for folder.id
     */
    id: string;
    /**
     * An alias for folder.name
     */
    name: string;
    /**
     * The Folder at this node level
     */
    folder: Folder;
    /**
     * The modification state of the Folder
     */
    state: string;
    /**
     * An array of child nodes
     */
    children: {
        /**
         * An alias for folder.id
         */
        id: string;
        /**
         * An alias for folder.name
         */
        name: string;
        /**
         * The Folder at this node level
         */
        folder: Folder;
        /**
         * The modification state of the Folder
         */
        state: string;
        /**
         * An array of child nodes
         */
        children: any[];
        /**
         * An array of documents
         */
        documents: {
            id: string;
            name: string;
            document: ClientDocument;
            state: string;
        }[];
    }[];
    /**
     * An array of documents
     */
    documents: {
        id: string;
        name: string;
        document: ClientDocument;
        state: string;
    }[];
};
type AdventureContentTreeRoot = {
    /**
     * An alias for folder.id
     */
    id: string;
    /**
     * An alias for folder.name
     */
    name: string;
    /**
     * The Folder at this node level
     */
    folder: Folder;
    /**
     * The modification state of the Folder
     */
    state: string;
    /**
     * An array of child nodes
     */
    children: any[];
    /**
     * An array of documents
     */
    documents: {
        id: string;
        name: string;
        document: ClientDocument;
        state: string;
    }[];
};
/**
 * The allowed sorting methods which can be used for this sheet
 */
type SORT_TYPES = string;
/**
 * Whether a font is distributed to connected clients or found on their OS.
 */
type FONT_TYPES = string;
type NewFontDefinition = {
    /**
     * The font family.
     */
    family?: string;
    /**
     * The font weight.
     */
    weight?: number;
    /**
     * The font style.
     */
    style?: string;
    /**
     * The font file.
     */
    src?: string;
    /**
     * The text to preview the font.
     */
    preview?: string;
};
type ShareImageConfig = {
    /**
     * The image URL to share.
     */
    image: string;
    /**
     * The image title.
     */
    title: string;
    /**
     * The UUID of a Document related to the image, used to determine permission to see
     *         the image title.
     */
    uuid?: string;
    /**
     * If this is provided, the permissions of the related Document will be ignored and
     *   the title will be shown based on this parameter.
     */
    showTitle?: boolean;
    /**
     * A list of user IDs to show the image to.
     */
    users?: string[];
};
type ImagePopoutOptions = FormApplicationOptions;
/**
 * Available view modes for journal entries.
 */
type VIEW_MODES = number;
/**
 * Icons for page ownership.
 */
type OWNERSHIP_ICONS = string;
type JournalSheetOptions = DocumentSheetOptions;
type ChatBubbleOptions = new (text?: string, value?: string, defaultSelected?: boolean, selected?: boolean) => HTMLOptionElement;
type SceneControlTool = {
    name: string;
    title: string;
    icon: string;
    visible: boolean;
    toggle: boolean;
    active: boolean;
    button: boolean;
    onClick: Function;
    /**
     * Configuration for rendering the tool's toolclip.
     */
    toolclip: ToolclipConfiguration;
};
type SceneControl = {
    name: string;
    title: string;
    layer: string;
    icon: string;
    visible: boolean;
    tools: SceneControlTool[];
    activeTool: string;
};
type ToolclipConfiguration = {
    /**
     * The filename of the toolclip video.
     */
    src: string;
    /**
     * The heading string.
     */
    heading: string;
    /**
     * The items in the toolclip body.
     */
    items: ToolclipConfigurationItem[];
};
type ToolclipConfigurationItem = {
    /**
     * A plain paragraph of content for this item.
     */
    paragraph?: string;
    /**
     * A heading for the item.
     */
    heading?: string;
    /**
     * Content for the item.
     */
    content?: string;
    /**
     * If the item is a single key reference, use this instead of content.
     */
    reference?: string;
};
type DrawingConfigOptions = FormApplicationOptions;
type ImpactedDependency = {
    /**
     * The dependency ID
     */
    id: string;
    /**
     * The dependency title
     */
    title: string;
    /**
     * The reason the dependency is related to this package
     */
    reason: string;
    /**
     * Whether the dependency is required
     */
    required: boolean;
    /**
     * A note to display to the user
     */
    note: string;
};
/**
 * A bundle of metrics for Support
 */
type SupportReportData = {
    coreVersion: number;
    systemVersion: string;
    activeModuleCount: number;
    os: string;
    client: string;
    gpu: string;
    maxTextureSize: number | string;
    sceneDimensions: string;
    grid: number;
    padding: float;
    walls: number;
    lights: number;
    sounds: number;
    tiles: number;
    tokens: number;
    actors: number;
    items: number;
    journals: number;
    tables: number;
    playlists: number;
    packs: number;
    messages: number;
};
type WorldConfigOptions = FormApplicationOptions;
/**
 * An enumeration of regular expression patterns used to match chat messages.
 */
type MESSAGE_PATTERNS = RegExp;
type ChatLogOptions = ApplicationOptions;
/**
 * WebRTC Mode, Disabled, Audio only, Video only, Audio & Video
 */
type AV_MODES = number;
/**
 * Voice modes: Always-broadcasting, voice-level triggered, push-to-talk.
 */
type VOICE_MODES = string;
/**
 * Displayed nameplate options: Off entirely, animate between player and character name, player name only, character
 * name only.
 */
type NAMEPLATE_MODES = number;
/**
 * AV dock positions.
 */
type DOCK_POSITIONS = string;
type AVSettingsData = {
    /**
     * Whether this user has muted themselves.
     */
    muted?: boolean;
    /**
     * Whether this user has hidden their video.
     */
    hidden?: boolean;
    /**
     * Whether the user is broadcasting audio.
     */
    speaking?: boolean;
};
/**
 * Configured roll terms and the classes they map to.
 */
type terms = typeof DiceTerm;
type polygonBackends = typeof PointSourcePolygon;
/**
 * Available Weather Effects implementations
 */
type WeatherAmbienceConfiguration = any;
/**
 * Available Weather Effects implementations
 */
type WeatherEffectConfiguration = any;
type FontDefinition = FontFaceDescriptors;
type FontFamilyDefinition = {
    /**
     * Whether the font is available in the rich text editor. This will also enable it
     * for notes and drawings.
     */
    editor: boolean;
    /**
     * Individual font face definitions for this font family. If this is empty, the
     * font family may only be loaded from the client's OS-installed fonts.
     */
    fonts: FontFaceDescriptors[];
};
/**
 * A mapping of status effect IDs which provide some additional mechanical integration.
 */
type specialStatusEffects = string;
type WallDoorSound = {
    /**
     * A localization string label
     */
    label: string;
    /**
     * A sound path when the door is closed
     */
    close: string;
    /**
     * A sound path when the door becomes locked
     */
    lock: string;
    /**
     * A sound path when opening the door
     */
    open: string;
    /**
     * A sound path when attempting to open a locked door
     */
    test: string;
    /**
     * A sound path when the door becomes unlocked
     */
    unlock: string;
};
type TextEditorEnricher = (match: RegExpMatchArray, options?: {
    /**
     * Include unrevealed secret tags in the final HTML? If false, unrevealed
     *       secret blocks will be removed.
     */
    secrets?: boolean;
    /**
     * Replace dynamic document links?
     */
    documents?: boolean;
    /**
     * Replace hyperlink content?
     */
    links?: boolean;
    /**
     * Replace inline dice rolls?
     */
    rolls?: boolean;
    /**
     * The data object providing context for inline rolls, or a function that
     *    produces it.
     */
    rollData?: any;
    /**
     * Perform the operation asynchronously returning a Promise
     */
    async?: boolean;
    /**
     * A document to resolve relative UUIDs against.
     */
    relativeTo?: ClientDocument;
}) => Promise<HTMLElement | null>;
type TextEditorEnricherConfig = {
    /**
     * The string pattern to match. Must be flagged as global.
     */
    pattern: RegExp;
    /**
     * The function that will be called on each match. It is expected that this
     * returns an HTML element to be inserted into the final enriched content.
     */
    enricher: (match: RegExpMatchArray, options?: {
        /**
         * Include unrevealed secret tags in the final HTML? If false, unrevealed
         *       secret blocks will be removed.
         */
        secrets?: boolean;
        /**
         * Replace dynamic document links?
         */
        documents?: boolean;
        /**
         * Replace hyperlink content?
         */
        links?: boolean;
        /**
         * Replace inline dice rolls?
         */
        rolls?: boolean;
        /**
         * The data object providing context for inline rolls, or a function that
         *    produces it.
         */
        rollData?: any;
        /**
         * Perform the operation asynchronously returning a Promise
         */
        async?: boolean;
        /**
         * A document to resolve relative UUIDs against.
         */
        relativeTo?: ClientDocument;
    }) => Promise<HTMLElement>;
};
/**
 * The sequence of container loading states.
 */
type LOAD_STATES = number;
declare namespace PIXI {
    export { Graphics as LegacyGraphics, Graphics, utils, loadVideo, Circle, Polygon, Rectangle };
}
declare var Graphics: any;
declare namespace utils {
    function detectVideoAlphaMode(): Promise<any>;
}
declare namespace loadVideo {
    let name_1: string;
    export { name_1 as name };
    export namespace extension {
        let type: any;
        let priority: any;
    }
    export namespace config {
        let defaultAutoPlay: boolean;
    }
    export function test(url: any): any;
    export function load(url: any, asset: any, loader: any): Promise<any>;
    export function unload(texture: any): Promise<any>;
}
declare class Circle {
    /**
     * Intersect this PIXI.Circle with a PIXI.Polygon.
     * @param {PIXI.Polygon} polygon      A PIXI.Polygon
     * @param {object} [options]          Options which configure how the intersection is computed
     * @param {number} [options.density]              The number of points which defines the density of approximation
     * @param {number} [options.clipType]             The clipper clip type
     * @param {string} [options.weilerAtherton=true]  Use the Weiler-Atherton algorithm. Otherwise, use Clipper.
     * @returns {PIXI.Polygon}            The intersected polygon
     */
    intersectPolygon(polygon: PIXI.Polygon, { density, clipType, weilerAtherton, ...options }?: {
        density?: number;
        clipType?: number;
        weilerAtherton?: string;
    }): PIXI.Polygon;
    /**
     * Intersect this PIXI.Circle with an array of ClipperPoints.
     * Convert the circle to a Polygon approximation and use intersectPolygon.
     * In the future we may replace this with more specialized logic which uses the line-circle intersection formula.
     * @param {ClipperPoint[]} clipperPoints  Array of ClipperPoints generated by PIXI.Polygon.toClipperPoints()
     * @param {object} [options]              Options which configure how the intersection is computed
     * @param {number} [options.density]      The number of points which defines the density of approximation
     * @returns {PIXI.Polygon}                The intersected polygon
     */
    intersectClipper(clipperPoints: ClipperPoint[], { density, ...options }?: {
        density?: number;
    }): PIXI.Polygon;
}
declare namespace Circle {
    /**
     * The recommended vertex density for the regular polygon approximation of a circle of a given radius.
     * Small radius circles have fewer vertices. The returned value will be rounded up to the nearest integer.
     * See the formula described at:
     * https://math.stackexchange.com/questions/4132060/compute-number-of-regular-polgy-sides-to-approximate-circle-to-defined-precision
     * @param {number} radius     Circle radius
     * @param {number} [epsilon]  The maximum tolerable distance between an approximated line segment and the true radius.
     *                            A larger epsilon results in fewer points for a given radius.
     * @returns {number}          The number of points for the approximated polygon
     */
    function approximateVertexDensity(radius: number, epsilon?: number): number;
}
declare class Polygon {
    /**
     * Convert a PIXI.Polygon into an array of clipper points [{X,Y}, ...].
     * Note that clipper points must be rounded to integers.
     * In order to preserve some amount of floating point precision, an optional scaling factor may be provided.
     * @param {object} [options]                  Options which affect how clipper points are generated
     * @param {number} [options.scalingFactor=1]    A scaling factor used to preserve floating point precision
     * @returns {ClipperPoint[]}                  An array of points to be used by clipper
     */
    toClipperPoints({ scalingFactor }?: {
        scalingFactor?: number;
    }): ClipperPoint[];
    get isClosed(): boolean;
    /**
     * Intersect this PIXI.Polygon with another PIXI.Polygon using the clipper library.
     * @param {PIXI.Polygon} other        Another PIXI.Polygon
     * @param {object} [options]          Options which configure how the intersection is computed
     * @param {number} [options.clipType]       The clipper clip type
     * @param {number} [options.scalingFactor]  A scaling factor passed to Polygon#toClipperPoints to preserve precision
     * @returns {PIXI.Polygon|null}       The intersected polygon or null if no solution was present
     */
    intersectPolygon(other: PIXI.Polygon, { clipType, scalingFactor }?: {
        clipType?: number;
        scalingFactor?: number;
    }): PIXI.Polygon | null;
    /**
     * Intersect this PIXI.Polygon with an array of ClipperPoints.
     * @param {ClipperPoint[]} clipperPoints    Array of clipper points generated by PIXI.Polygon.toClipperPoints()
     * @param {object} [options]                Options which configure how the intersection is computed
     * @param {number} [options.clipType]         The clipper clip type
     * @param {number} [options.scalingFactor]    A scaling factor passed to Polygon#toClipperPoints to preserve precision
     * @returns {ClipperPoint[]}                The resulting ClipperPaths
     */
    intersectClipper(clipperPoints: ClipperPoint[], { clipType, scalingFactor }?: {
        clipType?: number;
        scalingFactor?: number;
    }): ClipperPoint[];
    /**
     * Intersect this PIXI.Polygon with a PIXI.Circle.
     * For now, convert the circle to a Polygon approximation and use intersectPolygon.
     * In the future we may replace this with more specialized logic which uses the line-circle intersection formula.
     * @param {PIXI.Circle} circle        A PIXI.Circle
     * @param {object} [options]          Options which configure how the intersection is computed
     * @param {number} [options.density]    The number of points which defines the density of approximation
     * @returns {PIXI.Polygon}            The intersected polygon
     */
    intersectCircle(circle: PIXI.Circle, options?: {
        density?: number;
    }): PIXI.Polygon;
    /**
     * Intersect this PIXI.Polygon with a PIXI.Rectangle.
     * For now, convert the rectangle to a Polygon and use intersectPolygon.
     * In the future we may replace this with more specialized logic which uses the line-line intersection formula.
     * @param {PIXI.Rectangle} rect       A PIXI.Rectangle
     * @param {object} [options]          Options which configure how the intersection is computed
     * @returns {PIXI.Polygon}            The intersected polygon
     */
    intersectRectangle(rect: PIXI.Rectangle, options?: object): PIXI.Polygon;
}
declare namespace Polygon {
    /**
     * @typedef {Object} ClipperPoint
     * @property {number} X
     * @property {number} Y
     */
    /**
     * Construct a PIXI.Polygon instance from an array of clipper points [{X,Y}, ...].
     * @param {ClipperPoint[]} points                 An array of points returned by clipper
     * @param {object} [options]                      Options which affect how canvas points are generated
     * @param {number} [options.scalingFactor=1]        A scaling factor used to preserve floating point precision
     * @returns {PIXI.Polygon}                        The resulting PIXI.Polygon
     */
    function fromClipperPoints(points: ClipperPoint[], { scalingFactor }?: {
        scalingFactor?: number;
    }): PIXI.Polygon;
}
declare class Rectangle {
    get center(): {
        x: any;
        y: any;
    };
    /**
     * Return the bounding box for a PIXI.Rectangle.
     * The bounding rectangle is normalized such that the width and height are non-negative.
     * @returns {PIXI.Rectangle}
     */
    getBounds(): PIXI.Rectangle;
    /**
     * Determine if a point is on or nearly on this rectangle.
     * @param {Point} p           Point to test
     * @returns {boolean}         Is the point on the rectangle boundary?
     */
    pointIsOn(p: Point): boolean;
    /**
     * Calculate the rectangle Zone for a given point located around, on, or in the rectangle.
     * See https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm
     * This differs from _getZone in how points on the edge are treated: they are not considered inside.
     * @param {Point} point                   A point to test for location relative to the rectangle
     * @returns {PIXI.Rectangle.CS_ZONES}     Which edge zone does the point belong to?
     */
    _getEdgeZone(point: Point): PIXI.Rectangle.CS_ZONES;
    /**
     * Get all the points (corners) for a polygon approximation of a rectangle between two points on the rectangle.
     * The two points can be anywhere in 2d space on or outside the rectangle.
     * The starting and ending side are based on the zone of the corresponding a and b points.
     * (See PIXI.Rectangle.CS_ZONES.)
     * This is the rectangular version of PIXI.Circle.prototype.pointsBetween, and is similarly used
     * to draw the portion of the shape between two intersection points on that shape.
     * @param { Point } a   A point on or outside the rectangle, representing the starting position.
     * @param { Point } b   A point on or outside the rectangle, representing the starting position.
     * @returns { Point[]}  Points returned are clockwise from start to end.
     */
    pointsBetween(a: Point, b: Point): Point[];
    /**
     * Get all intersection points for a segment A|B
     * Intersections are sorted from A to B.
     * @param {Point} a   Endpoint A of the segment
     * @param {Point} b   Endpoint B of the segment
     * @returns {Point[]} Array of intersections or empty if no intersection.
     *  If A|B is parallel to an edge of this rectangle, returns the two furthest points on
     *  the segment A|B that are on the edge.
     */
    segmentIntersections(a: Point, b: Point): Point[];
    /**
     * Compute the intersection of this Rectangle with some other Rectangle.
     * @param {PIXI.Rectangle} other      Some other rectangle which intersects this one
     * @returns {PIXI.Rectangle}          The intersected rectangle
     */
    intersection(other: PIXI.Rectangle): PIXI.Rectangle;
    /**
     * Convert this PIXI.Rectangle into a PIXI.Polygon
     * @returns {PIXI.Polygon}      The Rectangle expressed as a PIXI.Polygon
     */
    toPolygon(): PIXI.Polygon;
    get leftEdge(): {
        A: {
            x: any;
            y: any;
        };
        B: {
            x: any;
            y: any;
        };
    };
    get rightEdge(): {
        A: {
            x: any;
            y: any;
        };
        B: {
            x: any;
            y: any;
        };
    };
    get topEdge(): {
        A: {
            x: any;
            y: any;
        };
        B: {
            x: any;
            y: any;
        };
    };
    get bottomEdge(): {
        A: {
            x: any;
            y: any;
        };
        B: {
            x: any;
            y: any;
        };
    };
    /**
     * Calculate the rectangle Zone for a given point located around or in the rectangle.
     * https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm
     *
     * @param {Point} p     Point to test for location relative to the rectangle
     * @returns {PIXI.Rectangle.CS_ZONES}
     */
    _getZone(p: Point): PIXI.Rectangle.CS_ZONES;
    /**
     * Test whether a line segment AB intersects this rectangle.
     * @param {Point} a                       The first endpoint of segment AB
     * @param {Point} b                       The second endpoint of segment AB
     * @param {object} [options]              Options affecting the intersect test.
     * @param {boolean} [options.inside]      If true, a line contained within the rectangle will
     *                                        return true.
     * @returns {boolean} True if intersects.
     */
    lineSegmentIntersects(a: Point, b: Point, { inside }?: {
        inside?: boolean;
    }): boolean;
    /**
     * Intersect this PIXI.Rectangle with a PIXI.Polygon.
     * Currently uses the clipper library.
     * In the future we may replace this with more specialized logic which uses the line-line intersection formula.
     * @param {PIXI.Polygon} polygon      A PIXI.Polygon
     * @param {object} [options]          Options which configure how the intersection is computed
     * @param {number} [options.clipType]             The clipper clip type
     * @param {number} [options.scalingFactor]        A scaling factor passed to Polygon#toClipperPoints for precision
     * @param {string} [options.weilerAtherton=true]  Use the Weiler-Atherton algorithm. Otherwise, use Clipper.
     * @returns {PIXI.Polygon|null}       The intersected polygon or null if no solution was present
     */
    intersectPolygon(polygon: PIXI.Polygon, { clipType, scalingFactor, canMutate, weilerAtherton }?: {
        clipType?: number;
        scalingFactor?: number;
        weilerAtherton?: string;
    }): PIXI.Polygon | null;
    /**
     * Intersect this PIXI.Rectangle with an array of ClipperPoints. Currently, uses the clipper library.
     * In the future we may replace this with more specialized logic which uses the line-line intersection formula.
     * @param {ClipperPoint[]} clipperPoints An array of ClipperPoints generated by PIXI.Polygon.toClipperPoints()
     * @param {object} [options]            Options which configure how the intersection is computed
     * @param {number} [options.clipType]       The clipper clip type
     * @param {number} [options.scalingFactor]  A scaling factor passed to Polygon#toClipperPoints to preserve precision
     * @returns {PIXI.Polygon|null}         The intersected polygon or null if no solution was present
     */
    intersectClipper(clipperPoints: ClipperPoint[], { clipType, scalingFactor }?: {
        clipType?: number;
        scalingFactor?: number;
    }): PIXI.Polygon | null;
    /**
     * Determine whether some other Rectangle overlaps with this one.
     * This check differs from the parent class Rectangle#intersects test because it is true for adjacency (zero area).
     * @param {PIXI.Rectangle} other  Some other rectangle against which to compare
     * @returns {boolean}             Do the rectangles overlap?
     */
    overlaps(other: PIXI.Rectangle): boolean;
    /**
     * Normalize the width and height of the rectangle in-place, enforcing that those dimensions be positive.
     * @returns {PIXI.Rectangle}
     */
    normalize(): PIXI.Rectangle;
    /**
     * Generate a new rectangle by rotating this one clockwise about its center by a certain number of radians
     * @param {number} radians        The angle of rotation
     * @returns {PIXI.Rectangle}      A new rotated rectangle
     */
    rotate(radians: number): PIXI.Rectangle;
}
declare namespace Rectangle {
    export namespace CS_ZONES {
        let INSIDE: number;
        let LEFT: number;
        let RIGHT: number;
        let TOP: number;
        let BOTTOM: number;
        let TOPLEFT: number;
        let TOPRIGHT: number;
        let BOTTOMRIGHT: number;
        let BOTTOMLEFT: number;
    }
    /**
     * Bit code labels splitting a rectangle into zones, based on the Cohen-Sutherland algorithm.
     * See https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm
     *          left    central   right
     * top      1001    1000      1010
     * central  0001    0000      0010
     * bottom   0101    0100      0110
     */
    type CS_ZONES = number;
    /**
     * Create normalized rectangular bounds given a rectangle shape and an angle of central rotation.
     * @param {number} x              The top-left x-coordinate of the un-rotated rectangle
     * @param {number} y              The top-left y-coordinate of the un-rotated rectangle
     * @param {number} width          The width of the un-rotated rectangle
     * @param {number} height         The height of the un-rotated rectangle
     * @param {number} radians        The angle of rotation about the center
     * @returns {PIXI.Rectangle}      The constructed rotated rectangle bounds
     */
    export function fromRotation(x: number, y: number, width: number, height: number, radians: number): PIXI.Rectangle;
}
