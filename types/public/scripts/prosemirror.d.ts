declare const AllSelection_base: {
    new ($anchor: any, $head: any, ranges: any): {
        $anchor: any;
        $head: any;
        ranges: any;
        /**
        The selection's anchor, as an unresolved position.
        */
        readonly anchor: any;
        /**
        The selection's head.
        */
        readonly head: any;
        /**
        The lower bound of the selection's main range.
        */
        readonly from: any;
        /**
        The upper bound of the selection's main range.
        */
        readonly to: any;
        /**
        The resolved lower  bound of the selection's main range.
        */
        readonly $from: any;
        /**
        The resolved upper bound of the selection's main range.
        */
        readonly $to: any;
        /**
        Indicates whether the selection contains any content.
        */
        readonly empty: boolean;
        /**
        Get the content of this selection as a slice.
        */
        content(): any;
        /**
        Replace the selection with a slice or, if no slice is given,
        delete the selection. Will append to the given transaction.
        */
        replace(tr: any, content?: {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        }): void;
        /**
        Replace the selection with the given node, appending the changes
        to the given transaction.
        */
        replaceWith(tr: any, node: any): void;
        /**
        Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
        which is a value that can be mapped without having access to a
        current document, and later resolved to a real selection for a
        given document again. (This is used mostly by the history to
        track and restore old selections.) The default implementation of
        this method just converts the selection to a text selection and
        returns the bookmark for that.
        */
        getBookmark(): any;
        visible: boolean;
    };
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    findFrom($pos: any, dir: any, textOnly?: boolean): any;
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    near($pos: any, bias?: number): any;
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    atStart(doc: any): any;
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    atEnd(doc: any): any;
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    fromJSON(doc: any, json: any): any;
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    jsonID(id: any, selectionClass: any): any;
};
/**
A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document).
*/
export class AllSelection extends AllSelection_base {
    /**
    @internal
    */
    static fromJSON(doc: any): {
        replace(tr: any, content?: {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        }): void;
        toJSON(): {
            type: string;
        };
        map(doc: any): any;
        eq(other: any): boolean;
        getBookmark(): {
            map(): any;
            resolve(doc: any): any;
        };
        $anchor: any;
        $head: any;
        ranges: any;
        /**
        The selection's anchor, as an unresolved position.
        */
        readonly anchor: any;
        /**
        The selection's head.
        */
        readonly head: any;
        /**
        The lower bound of the selection's main range.
        */
        readonly from: any;
        /**
        The upper bound of the selection's main range.
        */
        readonly to: any;
        /**
        The resolved lower  bound of the selection's main range.
        */
        readonly $from: any;
        /**
        The resolved upper bound of the selection's main range.
        */
        readonly $to: any;
        /**
        Indicates whether the selection contains any content.
        */
        readonly empty: boolean;
        /**
        Get the content of this selection as a slice.
        */
        content(): any;
        /**
        Replace the selection with the given node, appending the changes
        to the given transaction.
        */
        replaceWith(tr: any, node: any): void;
        visible: boolean;
    };
    /**
    Create an all-selection over the given document.
    */
    constructor(doc: any);
    toJSON(): {
        type: string;
    };
    map(doc: any): {
        replace(tr: any, content?: {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        }): void;
        toJSON(): {
            type: string;
        };
        map(doc: any): any;
        eq(other: any): boolean;
        getBookmark(): {
            map(): any;
            resolve(doc: any): any;
        };
        $anchor: any;
        $head: any;
        ranges: any;
        /**
        The selection's anchor, as an unresolved position.
        */
        readonly anchor: any;
        /**
        The selection's head.
        */
        readonly head: any;
        /**
        The lower bound of the selection's main range.
        */
        readonly from: any;
        /**
        The upper bound of the selection's main range.
        */
        readonly to: any;
        /**
        The resolved lower  bound of the selection's main range.
        */
        readonly $from: any;
        /**
        The resolved upper bound of the selection's main range.
        */
        readonly $to: any;
        /**
        Indicates whether the selection contains any content.
        */
        readonly empty: boolean;
        /**
        Get the content of this selection as a slice.
        */
        content(): any;
        /**
        Replace the selection with the given node, appending the changes
        to the given transaction.
        */
        replaceWith(tr: any, node: any): void;
        visible: boolean;
    };
    eq(other: any): boolean;
    getBookmark(): {
        map(): any;
        resolve(doc: any): {
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            toJSON(): {
                type: string;
            };
            map(doc: any): any;
            eq(other: any): boolean;
            getBookmark(): any;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Get the content of this selection as a slice.
            */
            content(): any;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
            visible: boolean;
        };
    };
}
declare const DOMParser_base: {
    new (schema: any, rules: any): {
        schema: any;
        rules: any;
        /**
        @internal
        */
        tags: any[];
        /**
        @internal
        */
        styles: any[];
        normalizeLists: boolean;
        /**
        Parse a document from the content of a DOM node.
        */
        parse(dom: any, options?: {}): any;
        /**
        Parses the content of the given DOM node, like
        [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
        options. But unlike that method, which produces a whole node,
        this one returns a slice that is open at the sides, meaning that
        the schema constraints aren't applied to the start of nodes to
        the left of the input and the end of nodes at the end.
        */
        parseSlice(dom: any, options?: {}): {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        };
        /**
        @internal
        */
        matchTag(dom: any, context: any, after: any): any;
        /**
        @internal
        */
        matchStyle(prop: any, value: any, context: any, after: any): any;
    };
    /**
    @internal
    */
    schemaRules(schema: any): any[];
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    fromSchema(schema: any): any;
};
export class DOMParser extends DOMParser_base {
    /** @inheritdoc */
    parse(dom: any, options: any): any;
    #private;
}
/**
A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes.
*/
export class DOMSerializer {
    /**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */
    static renderSpec(doc: any, structure: any, xmlNS?: any): any;
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
    static fromSchema(schema: any): any;
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
    static nodesFromSchema(schema: any): {};
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
    static marksFromSchema(schema: any): {};
    /**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
    constructor(nodes: any, marks: any);
    nodes: any;
    marks: any;
    /**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */
    serializeFragment(fragment: any, options: {}, target: any): any;
    /**
    @internal
    */
    serializeNodeInner(node: any, options: any): any;
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
    serializeNode(node: any, options?: {}): any;
    /**
    @internal
    */
    serializeMark(mark: any, inline: any, options?: {}): any;
}
/**
The state of a ProseMirror editor is represented by an object of
this type. A state is a persistent data structureâ€”it isn't
updated, but rather a new state value is computed from an old one
using the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.

A state holds a number of built-in fields, and plugins can
[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.
*/
export class EditorState {
    /**
    Create a new state.
    */
    static create(config: any): {
        config: any;
        /**
        The schema of the state's document.
        */
        readonly schema: any;
        /**
        The plugins that are active in this state.
        */
        readonly plugins: any;
        /**
        Apply the given transaction to produce a new state.
        */
        apply(tr: any): any;
        /**
        @internal
        */
        filterTransaction(tr: any, ignore?: number): boolean;
        /**
        Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
        returns the precise transactions that were applied (which might
        be influenced by the [transaction
        hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
        plugins) along with the new state.
        */
        applyTransaction(rootTr: any): {
            state: any;
            transactions: any[];
        };
        /**
        @internal
        */
        applyInner(tr: any): any;
        /**
        Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
        */
        readonly tr: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        };
        /**
        Create a new state based on this one, but with an adjusted set
        of active plugins. State fields that exist in both sets of
        plugins are kept unchanged. Those that no longer exist are
        dropped, and those that are new are initialized using their
        [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
        configuration object..
        */
        reconfigure(config: any): any;
        /**
        Serialize this state to JSON. If you want to serialize the state
        of plugins, pass an object mapping property names to use in the
        resulting JSON object to plugin objects. The argument may also be
        a string or number, in which case it is ignored, to support the
        way `JSON.stringify` calls `toString` methods.
        */
        toJSON(pluginFields: any): {
            doc: any;
            selection: any;
        };
    };
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
    static fromJSON(config: any, json: any, pluginFields: any): {
        config: any;
        /**
        The schema of the state's document.
        */
        readonly schema: any;
        /**
        The plugins that are active in this state.
        */
        readonly plugins: any;
        /**
        Apply the given transaction to produce a new state.
        */
        apply(tr: any): any;
        /**
        @internal
        */
        filterTransaction(tr: any, ignore?: number): boolean;
        /**
        Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
        returns the precise transactions that were applied (which might
        be influenced by the [transaction
        hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
        plugins) along with the new state.
        */
        applyTransaction(rootTr: any): {
            state: any;
            transactions: any[];
        };
        /**
        @internal
        */
        applyInner(tr: any): any;
        /**
        Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
        */
        readonly tr: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        };
        /**
        Create a new state based on this one, but with an adjusted set
        of active plugins. State fields that exist in both sets of
        plugins are kept unchanged. Those that no longer exist are
        dropped, and those that are new are initialized using their
        [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
        configuration object..
        */
        reconfigure(config: any): any;
        /**
        Serialize this state to JSON. If you want to serialize the state
        of plugins, pass an object mapping property names to use in the
        resulting JSON object to plugin objects. The argument may also be
        a string or number, in which case it is ignored, to support the
        way `JSON.stringify` calls `toString` methods.
        */
        toJSON(pluginFields: any): {
            doc: any;
            selection: any;
        };
    };
    /**
    @internal
    */
    constructor(config: any);
    config: any;
    /**
    The schema of the state's document.
    */
    get schema(): any;
    /**
    The plugins that are active in this state.
    */
    get plugins(): any;
    /**
    Apply the given transaction to produce a new state.
    */
    apply(tr: any): {
        config: any;
        /**
        The schema of the state's document.
        */
        readonly schema: any;
        /**
        The plugins that are active in this state.
        */
        readonly plugins: any;
        apply(tr: any): any;
        /**
        @internal
        */
        filterTransaction(tr: any, ignore?: number): boolean;
        /**
        Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
        returns the precise transactions that were applied (which might
        be influenced by the [transaction
        hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
        plugins) along with the new state.
        */
        applyTransaction(rootTr: any): {
            state: any;
            transactions: any[];
        };
        /**
        @internal
        */
        applyInner(tr: any): any;
        /**
        Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
        */
        readonly tr: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        };
        /**
        Create a new state based on this one, but with an adjusted set
        of active plugins. State fields that exist in both sets of
        plugins are kept unchanged. Those that no longer exist are
        dropped, and those that are new are initialized using their
        [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
        configuration object..
        */
        reconfigure(config: any): any;
        /**
        Serialize this state to JSON. If you want to serialize the state
        of plugins, pass an object mapping property names to use in the
        resulting JSON object to plugin objects. The argument may also be
        a string or number, in which case it is ignored, to support the
        way `JSON.stringify` calls `toString` methods.
        */
        toJSON(pluginFields: any): {
            doc: any;
            selection: any;
        };
    };
    /**
    @internal
    */
    filterTransaction(tr: any, ignore?: number): boolean;
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
    applyTransaction(rootTr: any): {
        state: {
            config: any;
            /**
            The schema of the state's document.
            */
            readonly schema: any;
            /**
            The plugins that are active in this state.
            */
            readonly plugins: any;
            /**
            Apply the given transaction to produce a new state.
            */
            apply(tr: any): any;
            /**
            @internal
            */
            filterTransaction(tr: any, ignore?: number): boolean;
            /**
            Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
            returns the precise transactions that were applied (which might
            be influenced by the [transaction
            hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
            plugins) along with the new state.
            */
            applyTransaction(rootTr: any): {
                state: any;
                transactions: any[];
            };
            /**
            @internal
            */
            applyInner(tr: any): any;
            /**
            Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
            */
            readonly tr: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            };
            /**
            Create a new state based on this one, but with an adjusted set
            of active plugins. State fields that exist in both sets of
            plugins are kept unchanged. Those that no longer exist are
            dropped, and those that are new are initialized using their
            [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
            configuration object..
            */
            reconfigure(config: any): any;
            /**
            Serialize this state to JSON. If you want to serialize the state
            of plugins, pass an object mapping property names to use in the
            resulting JSON object to plugin objects. The argument may also be
            a string or number, in which case it is ignored, to support the
            way `JSON.stringify` calls `toString` methods.
            */
            toJSON(pluginFields: any): {
                doc: any;
                selection: any;
            };
        };
        transactions: any[];
    };
    /**
    @internal
    */
    applyInner(tr: any): {
        config: any;
        /**
        The schema of the state's document.
        */
        readonly schema: any;
        /**
        The plugins that are active in this state.
        */
        readonly plugins: any;
        /**
        Apply the given transaction to produce a new state.
        */
        apply(tr: any): any;
        /**
        @internal
        */
        filterTransaction(tr: any, ignore?: number): boolean;
        /**
        Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
        returns the precise transactions that were applied (which might
        be influenced by the [transaction
        hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
        plugins) along with the new state.
        */
        applyTransaction(rootTr: any): {
            state: any;
            transactions: any[];
        };
        applyInner(tr: any): any;
        /**
        Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
        */
        readonly tr: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        };
        /**
        Create a new state based on this one, but with an adjusted set
        of active plugins. State fields that exist in both sets of
        plugins are kept unchanged. Those that no longer exist are
        dropped, and those that are new are initialized using their
        [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
        configuration object..
        */
        reconfigure(config: any): any;
        /**
        Serialize this state to JSON. If you want to serialize the state
        of plugins, pass an object mapping property names to use in the
        resulting JSON object to plugin objects. The argument may also be
        a string or number, in which case it is ignored, to support the
        way `JSON.stringify` calls `toString` methods.
        */
        toJSON(pluginFields: any): {
            doc: any;
            selection: any;
        };
    };
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
    get tr(): {
        curSelectionFor: number;
        updated: number;
        meta: any;
        time: number;
        curSelection: any;
        storedMarks: any;
        /**
        The transaction's current selection. This defaults to the editor
        selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
        transaction, but can be overwritten with
        [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
        */
        readonly selection: any;
        /**
        Update the transaction's current selection. Will determine the
        selection that the editor gets when the transaction is applied.
        */
        setSelection(selection: any): any;
        /**
        Whether the selection was explicitly updated by this transaction.
        */
        readonly selectionSet: boolean;
        /**
        Set the current stored marks.
        */
        setStoredMarks(marks: any): any;
        /**
        Make sure the current stored marks or, if that is null, the marks
        at the selection, match the given set of marks. Does nothing if
        this is already the case.
        */
        ensureMarks(marks: any): any;
        /**
        Add a mark to the set of stored marks.
        */
        addStoredMark(mark: any): any;
        /**
        Remove a mark or mark type from the set of stored marks.
        */
        removeStoredMark(mark: any): any;
        /**
        Whether the stored marks were explicitly set for this transaction.
        */
        readonly storedMarksSet: boolean;
        /**
        @internal
        */
        addStep(step: any, doc: any): void;
        /**
        Update the timestamp for the transaction.
        */
        setTime(time: any): any;
        /**
        Replace the current selection with the given slice.
        */
        replaceSelection(slice: any): any;
        /**
        Replace the selection with the given node. When `inheritMarks` is
        true and the content is inline, it inherits the marks from the
        place where it is inserted.
        */
        replaceSelectionWith(node: any, inheritMarks?: boolean): any;
        /**
        Delete the selection.
        */
        deleteSelection(): any;
        /**
        Replace the given range, or the selection if no range is given,
        with a text node containing the given string.
        */
        insertText(text: any, from: any, to: any): any;
        /**
        Store a metadata property in this transaction, keyed either by
        name or by plugin.
        */
        setMeta(key: any, value: any): any;
        /**
        Retrieve a metadata property for a given name or plugin.
        */
        getMeta(key: any): any;
        /**
        Returns true if this transaction doesn't contain any metadata,
        and can thus safely be extended.
        */
        readonly isGeneric: boolean;
        /**
        Indicate that the editor should scroll the selection into view
        when updated to the state produced by this transaction.
        */
        scrollIntoView(): any;
        /**
        True when this transaction has had `scrollIntoView` called on it.
        */
        readonly scrolledIntoView: boolean;
        doc: any;
        /**
        The steps in this transform.
        */
        steps: any[];
        /**
        The documents before each of the steps.
        */
        docs: any[];
        /**
        A mapping with the maps for each of the steps in this transform.
        */
        mapping: {
            maps: any[];
            mirror: any;
            from: number;
            to: number;
            /**
            Create a mapping that maps only through a part of this one.
            */
            slice(from?: number, to?: number): any;
            /**
            @internal
            */
            copy(): any;
            /**
            Add a step map to the end of this mapping. If `mirrors` is
            given, it should be the index of the step map that is the mirror
            image of this one.
            */
            appendMap(map: any, mirrors: any): void;
            /**
            Add all the step maps in a given mapping to this one (preserving
            mirroring information).
            */
            appendMapping(mapping: any): void;
            /**
            Finds the offset of the step map that mirrors the map at the
            given offset, in this mapping (as per the second argument to
            `appendMap`).
            */
            getMirror(n: any): any;
            /**
            @internal
            */
            setMirror(n: any, m: any): void;
            /**
            Append the inverse of the given mapping to this one.
            */
            appendMappingInverted(mapping: any): void;
            /**
            Create an inverted version of this mapping.
            */
            invert(): any;
            /**
            Map a position through this mapping.
            */
            map(pos: any, assoc?: number): any;
            /**
            Map a position through this mapping, returning a mapping
            result.
            */
            mapResult(pos: any, assoc?: number): any;
            /**
            @internal
            */
            _map(pos: any, assoc: any, simple: any): any;
        };
        /**
        The starting document.
        */
        readonly before: any;
        /**
        Apply a new step in this transform, saving the result. Throws an
        error when the step fails.
        */
        step(step: any): any;
        /**
        Try to apply a step in this transformation, ignoring it if it
        fails. Returns the step result.
        */
        maybeStep(step: any): any;
        /**
        True when the document has been changed (when there are any
        steps).
        */
        readonly docChanged: boolean;
        /**
        Replace the part of the document between `from` and `to` with the
        given `slice`.
        */
        replace(from: any, to?: any, slice?: {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        }): any;
        /**
        Replace the given range with the given content, which may be a
        fragment, node, or array of nodes.
        */
        replaceWith(from: any, to: any, content: any): any;
        /**
        Delete the content between the given positions.
        */
        delete(from: any, to: any): any;
        /**
        Insert the given content at the given position.
        */
        insert(pos: any, content: any): any;
        /**
        Replace a range of the document with a given slice, using
        `from`, `to`, and the slice's
        [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
        than fixed start and end points. This method may grow the
        replaced area or close open nodes in the slice in order to get a
        fit that is more in line with WYSIWYG expectations, by dropping
        fully covered parent nodes of the replaced region when they are
        marked [non-defining as
        context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
        open parent node from the slice that _is_ marked as [defining
        its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
        
        This is the method, for example, to handle paste. The similar
        [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
        primitive tool which will _not_ move the start and end of its given
        range, and is useful in situations where you need more precise
        control over what happens.
        */
        replaceRange(from: any, to: any, slice: any): any;
        /**
        Replace the given range with a node, but use `from` and `to` as
        hints, rather than precise positions. When from and to are the same
        and are at the start or end of a parent node in which the given
        node doesn't fit, this method may _move_ them out towards a parent
        that does allow the given node to be placed. When the given range
        completely covers a parent node, this method may completely replace
        that parent node.
        */
        replaceRangeWith(from: any, to: any, node: any): any;
        /**
        Delete the given range, expanding it to cover fully covered
        parent nodes until a valid replace is found.
        */
        deleteRange(from: any, to: any): any;
        /**
        Split the content in the given range off from its parent, if there
        is sibling content before or after it, and move it up the tree to
        the depth specified by `target`. You'll probably want to use
        [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
        sure the lift is valid.
        */
        lift(range: any, target: any): any;
        /**
        Join the blocks around the given position. If depth is 2, their
        last and first siblings are also joined, and so on.
        */
        join(pos: any, depth?: number): any;
        /**
        Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
        The wrappers are assumed to be valid in this position, and should
        probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
        */
        wrap(range: any, wrappers: any): any;
        /**
        Set the type of all textblocks (partly) between `from` and `to` to
        the given node type with the given attributes.
        */
        setBlockType(from: any, to: any, type: any, attrs?: any): any;
        /**
        Change the type, attributes, and/or marks of the node at `pos`.
        When `type` isn't given, the existing node type is preserved,
        */
        setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
        /**
        Set a single attribute on a given node to a new value.
        */
        setNodeAttribute(pos: any, attr: any, value: any): any;
        /**
        Add a mark to the node at position `pos`.
        */
        addNodeMark(pos: any, mark: any): any;
        /**
        Remove a mark (or a mark of the given type) from the node at
        position `pos`.
        */
        removeNodeMark(pos: any, mark: any): any;
        /**
        Split the node at the given position, and optionally, if `depth` is
        greater than one, any number of nodes above that. By default, the
        parts split off will inherit the node type of the original node.
        This can be changed by passing an array of types and attributes to
        use after the split.
        */
        split(pos: any, depth: number, typesAfter: any): any;
        /**
        Add the given mark to the inline content between `from` and `to`.
        */
        addMark(from: any, to: any, mark: any): any;
        /**
        Remove marks from inline nodes between `from` and `to`. When
        `mark` is a single mark, remove precisely that mark. When it is
        a mark type, remove all marks of that type. When it is null,
        remove all marks of any type.
        */
        removeMark(from: any, to: any, mark: any): any;
        /**
        Removes all marks and nodes from the content of the node at
        `pos` that don't match the given new parent node type. Accepts
        an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
        third argument.
        */
        clearIncompatible(pos: any, parentType: any, match: any): any;
    };
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    reconfigure(config: any): {
        config: any;
        /**
        The schema of the state's document.
        */
        readonly schema: any;
        /**
        The plugins that are active in this state.
        */
        readonly plugins: any;
        /**
        Apply the given transaction to produce a new state.
        */
        apply(tr: any): any;
        /**
        @internal
        */
        filterTransaction(tr: any, ignore?: number): boolean;
        /**
        Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
        returns the precise transactions that were applied (which might
        be influenced by the [transaction
        hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
        plugins) along with the new state.
        */
        applyTransaction(rootTr: any): {
            state: any;
            transactions: any[];
        };
        /**
        @internal
        */
        applyInner(tr: any): any;
        /**
        Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
        */
        readonly tr: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        };
        reconfigure(config: any): any;
        /**
        Serialize this state to JSON. If you want to serialize the state
        of plugins, pass an object mapping property names to use in the
        resulting JSON object to plugin objects. The argument may also be
        a string or number, in which case it is ignored, to support the
        way `JSON.stringify` calls `toString` methods.
        */
        toJSON(pluginFields: any): {
            doc: any;
            selection: any;
        };
    };
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
    toJSON(pluginFields: any): {
        doc: any;
        selection: any;
    };
}
/**
An editor view manages the DOM structure that represents an
editable document. Its state and behavior are determined by its
[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).
*/
export class EditorView {
    /**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
    constructor(place: any, props: any);
    _root: any;
    /**
    @internal
    */
    focused: boolean;
    /**
    Kludge used to work around a Chrome bug @internal
    */
    trackWrites: any;
    mounted: boolean;
    /**
    @internal
    */
    markCursor: any;
    /**
    @internal
    */
    cursorWrapper: any;
    /**
    @internal
    */
    lastSelectedViewDesc: any;
    /**
    @internal
    */
    input: {
        shiftKey: boolean;
        mouseDown: any;
        lastKeyCode: any;
        lastKeyCodeTime: number;
        lastClick: {
            time: number;
            x: number;
            y: number;
            type: string;
        };
        lastSelectionOrigin: any;
        lastSelectionTime: number;
        lastIOSEnter: number;
        lastIOSEnterFallbackTimeout: number;
        lastFocus: number;
        lastTouch: number;
        lastAndroidDelete: number;
        composing: boolean;
        composingTimeout: number;
        compositionNodes: any[];
        compositionEndedAt: number;
        domChangeCount: number;
        eventHandlers: any;
        hideSelectionGuard: any;
    };
    prevDirectPlugins: any[];
    pluginViews: any[];
    /**
    Holds `true` when a hack node is needed in Firefox to prevent the
    [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
    @internal
    */
    requiresGeckoHackNode: boolean;
    /**
    When editor content is being dragged, this object contains
    information about the dragged slice and whether it is being
    copied or moved. At any other time, it is null.
    */
    dragging: any;
    _props: any;
    state: any;
    directPlugins: any;
    /**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */
    dispatch(tr: any): void;
    dom: any;
    editable: boolean;
    nodeViews: any;
    docView: {
        node: any;
        outerDeco: any;
        innerDeco: any;
        nodeDOM: any;
        parseRule(): {
            node: any;
            attrs: any;
        };
        matchesNode(node: any, outerDeco: any, innerDeco: any): any;
        readonly size: any;
        readonly border: 0 | 1;
        updateChildren(view: any, pos: any): void;
        localCompositionInfo(view: any, pos: any): {
            node: any;
            pos: any;
            text: any;
        };
        protectLocalComposition(view: any, { node, pos, text }: {
            node: any;
            pos: any;
            text: any;
        }): void;
        children: any;
        update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
        updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
        dirty: number;
        updateOuterDeco(outerDeco: any): void;
        dom: any;
        selectNode(): void;
        deselectNode(): void;
        readonly domAtom: any;
        parent: any;
        contentDOM: any;
        matchesWidget(widget: any): boolean;
        matchesMark(mark: any): boolean;
        matchesHack(nodeName: any): boolean;
        stopEvent(event: any): boolean;
        destroy(): void;
        posBeforeChild(child: any): any;
        readonly posBefore: any;
        readonly posAtStart: any;
        readonly posAfter: any;
        readonly posAtEnd: number;
        localPosFromDOM(dom: any, offset: any, bias: any): any;
        nearestDesc(dom: any, onlyNodes?: boolean): any;
        getDesc(dom: any): any;
        posFromDOM(dom: any, offset: any, bias: any): any;
        descAt(pos: any): any;
        domFromPos(pos: any, side: any): any;
        parseRange(from: any, to: any, base?: number): any;
        emptyChildAt(side: any): any;
        domAfterPos(pos: any): any;
        setSelection(anchor: any, head: any, root: any, force?: boolean): any;
        ignoreMutation(mutation: any): boolean;
        readonly contentLost: boolean;
        markDirty(from: any, to: any): void;
        markParentsDirty(): void;
        readonly ignoreForCoords: boolean;
    };
    domObserver: {
        view: any;
        handleDOMChange: any;
        queue: any[];
        flushingSoon: number;
        observer: MutationObserver;
        currentSelection: {
            anchorNode: any;
            anchorOffset: number;
            focusNode: any;
            focusOffset: number;
            set(sel: any): void;
            clear(): void;
            eq(sel: any): boolean;
        };
        onCharData: (e: any) => void;
        suppressingSelectionUpdates: boolean;
        onSelectionChange(): void;
        flushSoon(): void;
        forceFlush(): void;
        start(): void;
        stop(): void;
        connectSelection(): void;
        disconnectSelection(): void;
        suppressSelectionUpdates(): void;
        setCurSelection(): void;
        ignoreSelectionChange(sel: any): boolean;
        flush(): void;
        registerMutation(mut: any, added: any): {
            from: any;
            to: any;
            typeOver?: undefined;
        } | {
            from: any;
            to: any;
            typeOver: boolean;
        };
    };
    /**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */
    get composing(): boolean;
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
    get props(): any;
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
    update(props: any): void;
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
    setProps(props: any): void;
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
    updateState(state: any): void;
    updateStateInner(state: any, prevProps: any): void;
    /**
    @internal
    */
    scrollToSelection(): void;
    destroyPluginViews(): void;
    updatePluginViews(prevState: any): void;
    someProp(propName: any, f: any): any;
    /**
    Query whether the view has focus.
    */
    hasFocus(): boolean;
    /**
    Focus the editor.
    */
    focus(): void;
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
    get root(): any;
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
    posAtCoords(coords: any): {
        pos: any;
        inside: number;
    };
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
    coordsAtPos(pos: any, side?: number): any;
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
    domAtPos(pos: any, side?: number): any;
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
    nodeDOM(pos: any): any;
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimesâ€”for example when interpreting an event
    targetâ€”you don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
    posAtDOM(node: any, offset: any, bias?: number): any;
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
    endOfTextblock(dir: any, state: any): any;
    /**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */
    pasteHTML(html: any, event: any): boolean;
    /**
    Run the editor's paste logic with the given plain-text input.
    */
    pasteText(text: any, event: any): boolean;
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
    destroy(): void;
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
    get isDestroyed(): boolean;
    /**
    Used for testing.
    */
    dispatchEvent(event: any): void;
    /**
    @internal
    */
    domSelectionRange(): any;
    /**
    @internal
    */
    domSelection(): any;
}
/**
Plugins bundle functionality that can be added to an editor.
They are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and
may influence that state and the view that contains it.
*/
export class Plugin {
    /**
    Create a plugin.
    */
    constructor(spec: any);
    spec: any;
    /**
    The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
    */
    props: {};
    key: any;
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state: any): any;
}
/**
A key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way
that makes it possible to find them, given an editor state.
Assigning a key does mean only one plugin of that type can be
active in a state.
*/
export class PluginKey {
    /**
    Create a plugin key.
    */
    constructor(name?: string);
    key: string;
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state: any): any;
    /**
    Get the plugin's state from an editor state.
    */
    getState(state: any): any;
}
declare const ProseMirrorClickHandler_base: {
    new (schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }): {};
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: any): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
};
/**
 * A class responsible for managing click events inside a ProseMirror editor.
 * @extends {ProseMirrorPlugin}
 */
export class ProseMirrorClickHandler extends ProseMirrorClickHandler_base {
    /** @override */
    static override build(schema: any, options?: {}): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    /**
     * Handle a click on the editor.
     * @param {EditorView} view     The ProseMirror editor view.
     * @param {number} pos          The position in the ProseMirror document that the click occurred at.
     * @param {Node} node           The current ProseMirror Node that the click has bubbled to.
     * @param {number} nodePos      The position of the click within this Node.
     * @param {PointerEvent} event  The click event.
     * @param {boolean} direct      Whether this Node is the one that was directly clicked on.
     * @returns {boolean|void}      A return value of true indicates the event has been handled, it will not propagate to
     *                              other plugins, and ProseMirror will call preventDefault on it.
     * @protected
     */
    protected _onClick(view: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }, pos: number, node: {
        type: any;
        attrs: any;
        marks: any[];
        content: any;
        /**
        The size of this node, as defined by the integer-based [indexing
        scheme](/docs/guide/#doc.indexing). For text nodes, this is the
        amount of characters. For other leaf nodes, it is one. For
        non-leaf nodes, it is the size of the content plus two (the
        start and end token).
        */
        readonly nodeSize: any;
        /**
        The number of children that the node has.
        */
        readonly childCount: any;
        /**
        Get the child node at the given index. Raises an error when the
        index is out of range.
        */
        child(index: any): any;
        /**
        Get the child node at the given index, if it exists.
        */
        maybeChild(index: any): any;
        /**
        Call `f` for every child node, passing the node, its offset
        into this parent node, and its index.
        */
        forEach(f: any): void;
        /**
        Invoke a callback for all descendant nodes recursively between
        the given two positions that are relative to start of this
        node's content. The callback is invoked with the node, its
        parent-relative position, its parent node, and its child index.
        When the callback returns false for a given node, that node's
        children will not be recursed over. The last parameter can be
        used to specify a starting position to count from.
        */
        nodesBetween(from: any, to: any, f: any, startPos?: number): void;
        /**
        Call the given callback for every descendant node. Doesn't
        descend into a node when the callback returns `false`.
        */
        descendants(f: any): void;
        /**
        Concatenates all the text nodes found in this fragment and its
        children.
        */
        readonly textContent: any;
        /**
        Get all text between positions `from` and `to`. When
        `blockSeparator` is given, it will be inserted to separate text
        from different block nodes. If `leafText` is given, it'll be
        inserted for every non-text leaf node encountered, otherwise
        [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
        */
        textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
        /**
        Returns this node's first child, or `null` if there are no
        children.
        */
        readonly firstChild: any;
        /**
        Returns this node's last child, or `null` if there are no
        children.
        */
        readonly lastChild: any;
        /**
        Test whether two nodes represent the same piece of document.
        */
        eq(other: any): any;
        /**
        Compare the markup (type, attributes, and marks) of this node to
        those of another. Returns `true` if both have the same markup.
        */
        sameMarkup(other: any): boolean;
        /**
        Check whether this node's markup correspond to the given type,
        attributes, and marks.
        */
        hasMarkup(type: any, attrs: any, marks: any): boolean;
        /**
        Create a new node with the same markup as this node, containing
        the given content (or empty, if no content is given).
        */
        copy(content?: any): any;
        /**
        Create a copy of this node, with the given set of marks instead
        of the node's own marks.
        */
        mark(marks: any): any;
        /**
        Create a copy of this node with only the content between the
        given positions. If `to` is not given, it defaults to the end of
        the node.
        */
        cut(from: any, to?: any): any;
        /**
        Cut out the part of the document between the given positions, and
        return it as a `Slice` object.
        */
        slice(from: any, to?: any, includeParents?: boolean): {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        };
        /**
        Replace the part of the document between the given positions with
        the given slice. The slice must 'fit', meaning its open sides
        must be able to connect to the surrounding content, and its
        content nodes must be valid children for the node they are placed
        into. If any of this is violated, an error of type
        [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
        */
        replace(from: any, to: any, slice: any): any;
        /**
        Find the node directly after the given position.
        */
        nodeAt(pos: any): any;
        /**
        Find the (direct) child node after the given offset, if any,
        and return it along with its index and offset relative to this
        node.
        */
        childAfter(pos: any): {
            node: any;
            index: any;
            offset: any;
        };
        /**
        Find the (direct) child node before the given offset, if any,
        and return it along with its index and offset relative to this
        node.
        */
        childBefore(pos: any): {
            node: any;
            index: any;
            offset: any;
        };
        /**
        Resolve the given position in the document, returning an
        [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
        */
        resolve(pos: any): any;
        /**
        @internal
        */
        resolveNoCache(pos: any): {
            pos: any;
            path: any;
            parentOffset: any;
            depth: number;
            /**
            @internal
            */
            resolveDepth(val: any): any;
            /**
            The parent node that the position points into. Note that even if
            a position points into a text node, that node is not considered
            the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
            */
            readonly parent: any;
            /**
            The root node in which the position was resolved.
            */
            readonly doc: any;
            /**
            The ancestor node at the given level. `p.node(p.depth)` is the
            same as `p.parent`.
            */
            node(depth: any): any;
            /**
            The index into the ancestor at the given level. If this points
            at the 3rd node in the 2nd paragraph on the top level, for
            example, `p.index(0)` is 1 and `p.index(1)` is 2.
            */
            index(depth: any): any;
            /**
            The index pointing after this position into the ancestor at the
            given level.
            */
            indexAfter(depth: any): any;
            /**
            The (absolute) position at the start of the node at the given
            level.
            */
            start(depth: any): any;
            /**
            The (absolute) position at the end of the node at the given
            level.
            */
            end(depth: any): any;
            /**
            The (absolute) position directly before the wrapping node at the
            given level, or, when `depth` is `this.depth + 1`, the original
            position.
            */
            before(depth: any): any;
            /**
            The (absolute) position directly after the wrapping node at the
            given level, or the original position when `depth` is `this.depth + 1`.
            */
            after(depth: any): any;
            /**
            When this position points into a text node, this returns the
            distance between the position and the start of the text node.
            Will be zero for positions that point between nodes.
            */
            readonly textOffset: number;
            /**
            Get the node directly after the position, if any. If the position
            points into a text node, only the part of that node after the
            position is returned.
            */
            readonly nodeAfter: any;
            /**
            Get the node directly before the position, if any. If the
            position points into a text node, only the part of that node
            before the position is returned.
            */
            readonly nodeBefore: any;
            /**
            Get the position at the given index in the parent node at the
            given depth (which defaults to `this.depth`).
            */
            posAtIndex(index: any, depth: any): any;
            /**
            Get the marks at this position, factoring in the surrounding
            marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
            position is at the start of a non-empty node, the marks of the
            node after it (if any) are returned.
            */
            marks(): any;
            /**
            Get the marks after the current position, if any, except those
            that are non-inclusive and not present at position `$end`. This
            is mostly useful for getting the set of marks to preserve after a
            deletion. Will return `null` if this position is at the end of
            its parent node or its parent node isn't a textblock (in which
            case no marks should be preserved).
            */
            marksAcross($end: any): any;
            /**
            The depth up to which this position and the given (non-resolved)
            position share the same parent nodes.
            */
            sharedDepth(pos: any): number;
            /**
            Returns a range based on the place where this position and the
            given position diverge around block content. If both point into
            the same textblock, for example, a range around that textblock
            will be returned. If they point into different blocks, the range
            around those blocks in their shared ancestor is returned. You can
            pass in an optional predicate that will be called with a parent
            node to see if a range into that parent is acceptable.
            */
            blockRange(other: any, pred: any): any;
            /**
            Query whether the given position shares the same parent node.
            */
            sameParent(other: any): boolean;
            /**
            Return the greater of this and the given position.
            */
            max(other: any): any;
            /**
            Return the smaller of this and the given position.
            */
            min(other: any): any;
            /**
            @internal
            */
            toString(): string;
            /**
             * Determine whether a given position has an ancestor node of the given type.
             * @param {NodeType} other  The other node type.
             * @param {object} [attrs]  An object of attributes that must also match, if provided.
             * @returns {boolean}
             */
            hasAncestor(other: {
                attrs: any;
                spec: any;
                map(mapping: any, span: any, offset: any, oldOffset: any): {
                    from: any;
                    to: any;
                    type: any;
                    /**
                    @internal
                    */
                    copy(from: any, to: any): any;
                    /**
                    @internal
                    */
                    eq(other: any, offset?: number): boolean;
                    /**
                    @internal
                    */
                    map(mapping: any, offset: any, oldOffset: any): any;
                    /**
                    The spec provided when creating this decoration. Can be useful
                    if you've stored extra information in that object.
                    */
                    readonly spec: any;
                    /**
                    @internal
                    */
                    readonly inline: boolean;
                };
                valid(node: any, span: any): boolean;
                eq(other: any): boolean;
                destroy(): void;
            }, attrs?: any): boolean;
        };
        /**
        Test whether a given mark or mark type occurs in this document
        between the two given positions.
        */
        rangeHasMark(from: any, to: any, type: any): boolean;
        /**
        True when this is a block (non-inline node)
        */
        readonly isBlock: any;
        /**
        True when this is a textblock node, a block node with inline
        content.
        */
        readonly isTextblock: any;
        /**
        True when this node allows inline content.
        */
        readonly inlineContent: any;
        /**
        True when this is an inline node (a text node or a node that can
        appear among text).
        */
        readonly isInline: any;
        /**
        True when this is a text node.
        */
        readonly isText: any;
        /**
        True when this is a leaf node.
        */
        readonly isLeaf: any;
        /**
        True when this is an atom, i.e. when it does not have directly
        editable content. This is usually the same as `isLeaf`, but can
        be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
        on a node's spec (typically used when the node is displayed as
        an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
        */
        readonly isAtom: any;
        /**
        Return a string representation of this node for debugging
        purposes.
        */
        toString(): any;
        /**
        Get the content match in this node at the given index.
        */
        contentMatchAt(index: any): any;
        /**
        Test whether replacing the range between `from` and `to` (by
        child index) with the given replacement fragment (which defaults
        to the empty fragment) would leave the node's content valid. You
        can optionally pass `start` and `end` indices into the
        replacement fragment.
        */
        canReplace(from: any, to: any, replacement?: {
            content: any;
            size: any;
            /**
            Invoke a callback for all descendant nodes between the given two
            positions (relative to start of this fragment). Doesn't descend
            into a node when the callback returns `false`.
            */
            nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
            /**
            Call the given callback for every descendant node. `pos` will be
            relative to the start of the fragment. The callback may return
            `false` to prevent traversal of a given node's children.
            */
            descendants(f: any): void;
            /**
            Extract the text between `from` and `to`. See the same method on
            [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
            */
            textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
            /**
            Create a new fragment containing the combined content of this
            fragment and the other.
            */
            append(other: any): any;
            /**
            Cut out the sub-fragment between the two given positions.
            */
            cut(from: any, to?: any): any;
            /**
            @internal
            */
            cutByIndex(from: any, to: any): any;
            /**
            Create a new fragment in which the node at the given index is
            replaced by the given node.
            */
            replaceChild(index: any, node: any): any;
            /**
            Create a new fragment by prepending the given node to this
            fragment.
            */
            addToStart(node: any): any;
            /**
            Create a new fragment by appending the given node to this
            fragment.
            */
            addToEnd(node: any): any;
            /**
            Compare this fragment to another one.
            */
            eq(other: any): boolean;
            /**
            The first child of the fragment, or `null` if it is empty.
            */
            readonly firstChild: any;
            /**
            The last child of the fragment, or `null` if it is empty.
            */
            readonly lastChild: any;
            /**
            The number of child nodes in this fragment.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raise an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Find the first position at which this fragment and another
            fragment differ, or `null` if they are the same.
            */
            findDiffStart(other: any, pos?: number): any;
            /**
            Find the first position, searching from the end, at which this
            fragment and the given fragment differ, or `null` if they are
            the same. Since this position will not be the same in both
            nodes, an object with two separate positions is returned.
            */
            findDiffEnd(other: any, pos?: any, otherPos?: any): any;
            /**
            Find the index and inner offset corresponding to a given relative
            position in this fragment. The result object will be reused
            (overwritten) the next time the function is called. (Not public.)
            */
            findIndex(pos: any, round?: number): {
                index: number;
                offset: number;
            };
            /**
            Return a debugging string that describes this fragment.
            */
            toString(): string;
            /**
            @internal
            */
            toStringInner(): any;
            /**
            Create a JSON-serializeable representation of this fragment.
            */
            toJSON(): any;
        }, start?: number, end?: any): boolean;
        /**
        Test whether replacing the range `from` to `to` (by index) with
        a node of the given type would leave the node's content valid.
        */
        canReplaceWith(from: any, to: any, type: any, marks: any): any;
        /**
        Test whether the given node's content could be appended to this
        node. If that node is empty, this will only return true if there
        is at least one node type that can appear in both nodes (to avoid
        merging completely incompatible nodes).
        */
        canAppend(other: any): any;
        /**
        Check whether this node and its descendants conform to the
        schema, and raise error when they do not.
        */
        check(): void;
        /**
        Return a JSON-serializeable representation of this node.
        */
        toJSON(): {
            type: any;
        };
        text: any;
    }, nodePos: number, event: PointerEvent, direct: boolean): boolean | void;
}
declare const ProseMirrorContentLinkPlugin_base: {
    new (schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }): {};
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: any): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
};
/**
 * A class responsible for handling the dropping of Documents onto the editor and creating content links for them.
 * @extends {ProseMirrorPlugin}
 */
export class ProseMirrorContentLinkPlugin extends ProseMirrorContentLinkPlugin_base {
    /** @inheritdoc */
    static build(schema: any, options?: {}): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    /**
     * @typedef {object} ProseMirrorContentLinkOptions
     * @property {ClientDocument} [document]      The parent document housing this editor.
     * @property {boolean} [relativeLinks=false]  Whether to generate links relative to the parent document.
     */
    /**
     * @param {Schema} schema                          The ProseMirror schema.
     * @param {ProseMirrorContentLinkOptions} options  Additional options to configure the plugin's behaviour.
     */
    constructor(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, { document, relativeLinks }?: {
        /**
         * The parent document housing this editor.
         */
        document?: ClientDocument;
        /**
         * Whether to generate links relative to the parent document.
         */
        relativeLinks?: boolean;
    });
    /**
     * Handle a drop onto the editor.
     * @param {EditorView} view  The ProseMirror editor view.
     * @param {DragEvent} event  The drop event.
     * @param {Slice} slice      A slice of editor content.
     * @param {boolean} moved    Whether the slice has been moved from a different part of the editor.
     * @protected
     */
    protected _onDrop(view: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }, event: DragEvent, slice: {
        content: any;
        openStart: any;
        openEnd: any;
        /**
        The size this slice would add when inserted into a document.
        */
        readonly size: number;
        /**
        @internal
        */
        insertAt(pos: any, fragment: any): any;
        /**
        @internal
        */
        removeBetween(from: any, to: any): any;
        /**
        Tests whether this slice is equal to another slice.
        */
        eq(other: any): boolean;
        /**
        @internal
        */
        toString(): string;
        /**
        Convert a slice to a JSON-serializable representation.
        */
        toJSON(): {
            content: any;
        };
    }, moved: boolean): boolean;
}
declare const ProseMirrorDirtyPlugin_base: {
    new (schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }): {};
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: any): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
};
/**
 * A simple plugin that records the dirty state of the editor.
 * @extends {ProseMirrorPlugin}
 */
export class ProseMirrorDirtyPlugin extends ProseMirrorDirtyPlugin_base {
    /** @inheritdoc */
    static build(schema: any, options?: {}): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
}
declare const ProseMirrorHighlightMatchesPlugin_base: {
    new (schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }): {};
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: any): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
};
/**
 * A ProseMirrorPlugin wrapper around the {@link PossibleMatchesTooltip} class.
 * @extends {ProseMirrorPlugin}
 */
export class ProseMirrorHighlightMatchesPlugin extends ProseMirrorHighlightMatchesPlugin_base {
    /** @inheritdoc */
    static build(schema: any, options?: {}): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    /**
     * @param {Schema} schema                     The ProseMirror schema.
     * @param {ProseMirrorMenuOptions} [options]  Additional options to configure the plugin's behaviour.
     */
    constructor(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: {
        /**
         * A function to call when the save button is pressed.
         */
        onSave?: Function;
        /**
         * Whether this editor instance is intended to be destroyed when saved.
         */
        destroyOnSave?: boolean;
        /**
         * Whether to display a more compact version of the menu.
         */
        compact?: boolean;
    });
    options: {
        /**
         * A function to call when the save button is pressed.
         */
        onSave?: Function;
        /**
         * Whether this editor instance is intended to be destroyed when saved.
         */
        destroyOnSave?: boolean;
        /**
         * Whether to display a more compact version of the menu.
         */
        compact?: boolean;
    };
}
declare const ProseMirrorImagePlugin_base: {
    new (schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }): {};
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: any): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
};
/**
 * A class responsible for handle drag-and-drop and pasting of image content. Ensuring no base64 data is injected
 * directly into the journal content and it is instead uploaded to the user's data directory.
 * @extends {ProseMirrorPlugin}
 */
export class ProseMirrorImagePlugin extends ProseMirrorImagePlugin_base {
    /** @inheritdoc */
    static build(schema: any, options?: {}): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    /**
     * Convert a base64 string into a File object.
     * @param {string} data      Base64 encoded data.
     * @param {string} filename  The filename.
     * @param {string} mimetype  The file's mimetype.
     * @returns {File}
     */
    static base64ToFile(data: string, filename: string, mimetype: string): File;
    /**
     * @param {Schema} schema                    The ProseMirror schema.
     * @param {object} options                   Additional options to configure the plugin's behaviour.
     * @param {ClientDocument} options.document  A related Document to store extract base64 images for.
     */
    constructor(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, { document }?: {
        document: ClientDocument;
    });
    /**
     * Handle a drop onto the editor.
     * @param {EditorView} view  The ProseMirror editor view.
     * @param {DragEvent} event  The drop event.
     * @param {Slice} slice      A slice of editor content.
     * @param {boolean} moved    Whether the slice has been moved from a different part of the editor.
     * @protected
     */
    protected _onDrop(view: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }, event: DragEvent, slice: {
        content: any;
        openStart: any;
        openEnd: any;
        /**
        The size this slice would add when inserted into a document.
        */
        readonly size: number;
        /**
        @internal
        */
        insertAt(pos: any, fragment: any): any;
        /**
        @internal
        */
        removeBetween(from: any, to: any): any;
        /**
        Tests whether this slice is equal to another slice.
        */
        eq(other: any): boolean;
        /**
        @internal
        */
        toString(): string;
        /**
        Convert a slice to a JSON-serializable representation.
        */
        toJSON(): {
            content: any;
        };
    }, moved: boolean): boolean;
    /**
     * Handle a paste into the editor.
     * @param {EditorView} view       The ProseMirror editor view.
     * @param {ClipboardEvent} event  The paste event.
     * @protected
     */
    protected _onPaste(view: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }, event: ClipboardEvent): boolean;
    /**
     * Upload any image files encountered in the drop.
     * @param {EditorView} view  The ProseMirror editor view.
     * @param {FileList} files   The files to upload.
     * @param {number} [pos]     The position in the document to insert at. If not provided, the current selection will be
     *                           replaced instead.
     * @protected
     */
    protected _uploadImages(view: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }, files: FileList, pos?: number): Promise<void>;
    /**
     * Capture any base64-encoded images embedded in the rich text paste and upload them.
     * @param {EditorView} view                                      The ProseMirror editor view.
     * @param {string} html                                          The HTML data as a string.
     * @param {[full: string, mime: string, data: string][]} images  An array of extracted base64 image data.
     * @protected
     */
    protected _replaceBase64Images(view: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }, html: string, images: [full: string, mime: string, data: string][]): Promise<void>;
    /**
     * Detect base64 image data embedded in an HTML string and extract it.
     * @param {string} html  The HTML data as a string.
     * @returns {[full: string, mime: string, data: string][]}
     * @protected
     */
    protected _extractBase64Images(html: string): [full: string, mime: string, data: string][];
}
declare const ProseMirrorInputRules_base: {
    new (schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }): {};
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: any): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
};
/**
 * A class responsible for building the input rules for the ProseMirror editor.
 * @extends {ProseMirrorPlugin}
 */
export class ProseMirrorInputRules extends ProseMirrorInputRules_base {
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @param {number} [options.minHeadingLevel=0]  The minimum heading level to start from when generating heading input
     *                                              rules. The resulting heading level for a heading rule is equal to the
     *                                              number of leading hashes minus this number.
     * */
    static build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, { minHeadingLevel }?: {
        minHeadingLevel?: number;
    }): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    /**
     * Turns a double dash anywhere into an em-dash. Does not match at the start of the line to avoid conflict with the
     * HR rule.
     * @returns {InputRule}
     * @protected
     */
    protected static "__#211@#emDashRule"(): {
        match: any;
        handler: any;
    };
    /**
     * Build input rules for node types present in the schema.
     * @returns {InputRule[]}
     */
    buildRules(): {
        match: any;
        handler: any;
    }[];
    #private;
}
declare const ProseMirrorKeyMaps_base: {
    new (schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }): {};
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: any): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
};
/**
 * A class responsible for building the keyboard commands for the ProseMirror editor.
 * @extends {ProseMirrorPlugin}
 */
export class ProseMirrorKeyMaps extends ProseMirrorKeyMaps_base {
    /** @inheritdoc */
    static build(schema: any, options?: {}): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    /**
     * @param {Schema} schema              The ProseMirror schema to build keymaps for.
     * @param {object} [options]           Additional options to configure the plugin's behaviour.
     * @param {Function} [options.onSave]  A function to call when Ctrl+S is pressed.
     */
    constructor(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, { onSave }?: {
        onSave?: Function;
    });
    /**
     * @callback ProseMirrorCommand
     * @param {EditorState} state               The current editor state.
     * @param {function(Transaction)} dispatch  A function to dispatch a transaction.
     * @param {EditorView} view                 Escape-hatch for when the command needs to interact directly with the UI.
     * @returns {boolean}                       Whether the command has performed any action and consumed the event.
     */
    /**
     * Build keyboard commands for nodes and marks present in the schema.
     * @returns {Object<ProseMirrorCommand>}  An object of keyboard shortcuts to editor functions.
     */
    buildMapping(): any;
    #private;
}
declare const ProseMirrorMenu_base: {
    new (schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }): {};
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: any): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
};
/**
 * A class responsible for building a menu for a ProseMirror instance.
 * @extends {ProseMirrorPlugin}
 */
export class ProseMirrorMenu extends ProseMirrorMenu_base {
    /**
     * An enumeration of editor scopes in which a menu item can appear
     * @enum {string}
     * @protected
     */
    protected static _MENU_ITEM_SCOPES: {
        BOTH: string;
        TEXT: string;
        HTML: string;
    };
    /** @inheritdoc */
    static build(schema: any, options?: {}): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    /**
     * @typedef {object} ProseMirrorMenuOptions
     * @property {Function} [onSave]        A function to call when the save button is pressed.
     * @property {boolean} [destroyOnSave]  Whether this editor instance is intended to be destroyed when saved.
     * @property {boolean} [compact]        Whether to display a more compact version of the menu.
     */
    /**
     * @param {Schema} schema                     The ProseMirror schema to build a menu for.
     * @param {EditorView} view                   The editor view.
     * @param {ProseMirrorMenuOptions} [options]  Additional options to configure the plugin's behaviour.
     */
    constructor(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, view: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }, options?: {
        /**
         * A function to call when the save button is pressed.
         */
        onSave?: Function;
        /**
         * Whether this editor instance is intended to be destroyed when saved.
         */
        destroyOnSave?: boolean;
        /**
         * Whether to display a more compact version of the menu.
         */
        compact?: boolean;
    });
    /**
     * Additional options to configure the plugin's behaviour.
     * @type {ProseMirrorMenuOptions}
     */
    options: {
        /**
         * A function to call when the save button is pressed.
         */
        onSave?: Function;
        /**
         * Whether this editor instance is intended to be destroyed when saved.
         */
        destroyOnSave?: boolean;
        /**
         * Whether to display a more compact version of the menu.
         */
        compact?: boolean;
    };
    get editingSource(): boolean;
    /**
     * Render the menu's HTML.
     * @returns {ProseMirrorMenu}
     */
    render(): {
        /**
         * Additional options to configure the plugin's behaviour.
         * @type {ProseMirrorMenuOptions}
         */
        options: {
            /**
             * A function to call when the save button is pressed.
             */
            onSave?: Function;
            /**
             * Whether this editor instance is intended to be destroyed when saved.
             */
            destroyOnSave?: boolean;
            /**
             * Whether to display a more compact version of the menu.
             */
            compact?: boolean;
        };
        /**
         * An HTML element that we write HTML to before injecting it into the DOM.
         * @type {HTMLTemplateElement}
         * @protected
         */
        "__#214@#renderTarget": HTMLTemplateElement;
        /**
         * Track whether we are currently in a state of editing the HTML source.
         * @type {boolean}
         */
        "__#214@#editingSource": boolean;
        readonly editingSource: boolean;
        render(): any;
        /**
         * Attach event listeners.
         * @param {HTMLMenuElement} html  The root menu element.
         */
        activateListeners(html: HTMLMenuElement): void;
        /**
         * Called whenever the view's state is updated.
         * @param {EditorView} view       The current editor state.
         * @param {EditorView} prevState  The previous editor state.
         */
        update(view: {
            _root: any;
            /**
            @internal
            */
            focused: boolean;
            /**
            Kludge used to work around a Chrome bug @internal
            */
            trackWrites: any;
            mounted: boolean;
            /**
            @internal
            */
            markCursor: any;
            /**
            @internal
            */
            cursorWrapper: any;
            /**
            @internal
            */
            lastSelectedViewDesc: any;
            /**
            @internal
            */
            input: {
                shiftKey: boolean;
                mouseDown: any;
                lastKeyCode: any;
                lastKeyCodeTime: number;
                lastClick: {
                    time: number;
                    x: number;
                    y: number;
                    type: string;
                };
                lastSelectionOrigin: any;
                lastSelectionTime: number;
                lastIOSEnter: number;
                lastIOSEnterFallbackTimeout: number;
                lastFocus: number;
                lastTouch: number;
                lastAndroidDelete: number;
                composing: boolean;
                composingTimeout: number;
                compositionNodes: any[];
                compositionEndedAt: number;
                domChangeCount: number;
                eventHandlers: any;
                hideSelectionGuard: any;
            };
            prevDirectPlugins: any[];
            pluginViews: any[];
            /**
            Holds `true` when a hack node is needed in Firefox to prevent the
            [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
            @internal
            */
            requiresGeckoHackNode: boolean;
            /**
            When editor content is being dragged, this object contains
            information about the dragged slice and whether it is being
            copied or moved. At any other time, it is null.
            */
            dragging: any;
            _props: any;
            state: any;
            directPlugins: any;
            /**
            Dispatch a transaction. Will call
            [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
            when given, and otherwise defaults to applying the transaction to
            the current state and calling
            [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
            This method is bound to the view instance, so that it can be
            easily passed around.
            */
            dispatch(tr: any): void;
            dom: any;
            editable: boolean;
            nodeViews: any;
            docView: {
                node: any;
                outerDeco: any;
                innerDeco: any;
                nodeDOM: any;
                parseRule(): {
                    node: any;
                    attrs: any;
                };
                matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                readonly size: any;
                readonly border: 0 | 1;
                updateChildren(view: any, pos: any): void;
                localCompositionInfo(view: any, pos: any): {
                    node: any;
                    pos: any;
                    text: any;
                };
                protectLocalComposition(view: any, { node, pos, text }: {
                    node: any;
                    pos: any;
                    text: any;
                }): void;
                children: any;
                update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                dirty: number;
                updateOuterDeco(outerDeco: any): void;
                dom: any;
                selectNode(): void;
                deselectNode(): void;
                readonly domAtom: any;
                parent: any;
                contentDOM: any;
                matchesWidget(widget: any): boolean;
                matchesMark(mark: any): boolean;
                matchesHack(nodeName: any): boolean;
                stopEvent(event: any): boolean;
                destroy(): void;
                posBeforeChild(child: any): any;
                readonly posBefore: any;
                readonly posAtStart: any;
                readonly posAfter: any;
                readonly posAtEnd: number;
                localPosFromDOM(dom: any, offset: any, bias: any): any;
                nearestDesc(dom: any, onlyNodes?: boolean): any;
                getDesc(dom: any): any;
                posFromDOM(dom: any, offset: any, bias: any): any;
                descAt(pos: any): any;
                domFromPos(pos: any, side: any): any;
                parseRange(from: any, to: any, base?: number): any;
                emptyChildAt(side: any): any;
                domAfterPos(pos: any): any;
                setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                ignoreMutation(mutation: any): boolean;
                readonly contentLost: boolean;
                markDirty(from: any, to: any): void;
                markParentsDirty(): void;
                readonly ignoreForCoords: boolean;
            };
            domObserver: {
                view: any;
                handleDOMChange: any;
                queue: any[];
                flushingSoon: number;
                observer: MutationObserver;
                currentSelection: {
                    anchorNode: any;
                    anchorOffset: number;
                    focusNode: any;
                    focusOffset: number;
                    set(sel: any): void;
                    clear(): void;
                    eq(sel: any): boolean;
                };
                onCharData: (e: any) => void;
                suppressingSelectionUpdates: boolean;
                onSelectionChange(): void;
                flushSoon(): void;
                forceFlush(): void;
                start(): void;
                stop(): void;
                connectSelection(): void;
                disconnectSelection(): void;
                suppressSelectionUpdates(): void;
                setCurSelection(): void;
                ignoreSelectionChange(sel: any): boolean;
                flush(): void;
                registerMutation(mut: any, added: any): {
                    from: any;
                    to: any;
                    typeOver?: undefined;
                } | {
                    from: any;
                    to: any;
                    typeOver: boolean;
                };
            };
            /**
            Holds `true` when a
            [composition](https://w3c.github.io/uievents/#events-compositionevents)
            is active.
            */
            readonly composing: boolean;
            /**
            The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
            */
            readonly props: any;
            /**
            Update the view's props. Will immediately cause an update to
            the DOM.
            */
            update(props: any): void;
            /**
            Update the view by updating existing props object with the object
            given as argument. Equivalent to `view.update(Object.assign({},
            view.props, props))`.
            */
            setProps(props: any): void;
            /**
            Update the editor's `state` prop, without touching any of the
            other props.
            */
            updateState(state: any): void;
            updateStateInner(state: any, prevProps: any): void;
            /**
            @internal
            */
            scrollToSelection(): void;
            destroyPluginViews(): void;
            updatePluginViews(prevState: any): void;
            someProp(propName: any, f: any): any;
            /**
            Query whether the view has focus.
            */
            hasFocus(): boolean;
            /**
            Focus the editor.
            */
            focus(): void;
            /**
            Get the document root in which the editor exists. This will
            usually be the top-level `document`, but might be a [shadow
            DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
            root if the editor is inside one.
            */
            readonly root: any;
            /**
            Given a pair of viewport coordinates, return the document
            position that corresponds to them. May return null if the given
            coordinates aren't inside of the editor. When an object is
            returned, its `pos` property is the position nearest to the
            coordinates, and its `inside` property holds the position of the
            inner node that the position falls inside of, or -1 if it is at
            the top level, not in any node.
            */
            posAtCoords(coords: any): {
                pos: any;
                inside: number;
            };
            /**
            Returns the viewport rectangle at a given document position.
            `left` and `right` will be the same number, as this returns a
            flat cursor-ish rectangle. If the position is between two things
            that aren't directly adjacent, `side` determines which element
            is used. When < 0, the element before the position is used,
            otherwise the element after.
            */
            coordsAtPos(pos: any, side?: number): any;
            /**
            Find the DOM position that corresponds to the given document
            position. When `side` is negative, find the position as close as
            possible to the content before the position. When positive,
            prefer positions close to the content after the position. When
            zero, prefer as shallow a position as possible.
            
            Note that you should **not** mutate the editor's internal DOM,
            only inspect it (and even that is usually not necessary).
            */
            domAtPos(pos: any, side?: number): any;
            /**
            Find the DOM node that represents the document node after the
            given position. May return `null` when the position doesn't point
            in front of a node or if the node is inside an opaque node view.
            
            This is intended to be able to call things like
            `getBoundingClientRect` on that DOM node. Do **not** mutate the
            editor DOM directly, or add styling this way, since that will be
            immediately overriden by the editor as it redraws the node.
            */
            nodeDOM(pos: any): any;
            /**
            Find the document position that corresponds to a given DOM
            position. (Whenever possible, it is preferable to inspect the
            document structure directly, rather than poking around in the
            DOM, but sometimesâ€”for example when interpreting an event
            targetâ€”you don't have a choice.)
            
            The `bias` parameter can be used to influence which side of a DOM
            node to use when the position is inside a leaf node.
            */
            posAtDOM(node: any, offset: any, bias?: number): any;
            /**
            Find out whether the selection is at the end of a textblock when
            moving in a given direction. When, for example, given `"left"`,
            it will return true if moving left from the current cursor
            position would leave that position's parent textblock. Will apply
            to the view's current state by default, but it is possible to
            pass a different state.
            */
            endOfTextblock(dir: any, state: any): any;
            /**
            Run the editor's paste logic with the given HTML string. The
            `event`, if given, will be passed to the
            [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
            */
            pasteHTML(html: any, event: any): boolean;
            /**
            Run the editor's paste logic with the given plain-text input.
            */
            pasteText(text: any, event: any): boolean;
            /**
            Removes the editor from the DOM and destroys all [node
            views](https://prosemirror.net/docs/ref/#view.NodeView).
            */
            destroy(): void;
            /**
            This is true when the view has been
            [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
            used anymore).
            */
            readonly isDestroyed: boolean;
            /**
            Used for testing.
            */
            dispatchEvent(event: any): void;
            /**
            @internal
            */
            domSelectionRange(): any;
            /**
            @internal
            */
            domSelection(): any;
        }, prevState: {
            _root: any;
            /**
            @internal
            */
            focused: boolean;
            /**
            Kludge used to work around a Chrome bug @internal
            */
            trackWrites: any;
            mounted: boolean;
            /**
            @internal
            */
            markCursor: any;
            /**
            @internal
            */
            cursorWrapper: any;
            /**
            @internal
            */
            lastSelectedViewDesc: any;
            /**
            @internal
            */
            input: {
                shiftKey: boolean;
                mouseDown: any;
                lastKeyCode: any;
                lastKeyCodeTime: number;
                lastClick: {
                    time: number;
                    x: number;
                    y: number;
                    type: string;
                };
                lastSelectionOrigin: any;
                lastSelectionTime: number;
                lastIOSEnter: number;
                lastIOSEnterFallbackTimeout: number;
                lastFocus: number;
                lastTouch: number;
                lastAndroidDelete: number;
                composing: boolean;
                composingTimeout: number;
                compositionNodes: any[];
                compositionEndedAt: number;
                domChangeCount: number;
                eventHandlers: any;
                hideSelectionGuard: any;
            };
            prevDirectPlugins: any[];
            pluginViews: any[];
            /**
            Holds `true` when a hack node is needed in Firefox to prevent the
            [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
            @internal
            */
            requiresGeckoHackNode: boolean;
            /**
            When editor content is being dragged, this object contains
            information about the dragged slice and whether it is being
            copied or moved. At any other time, it is null.
            */
            dragging: any;
            _props: any;
            state: any;
            directPlugins: any;
            /**
            Dispatch a transaction. Will call
            [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
            when given, and otherwise defaults to applying the transaction to
            the current state and calling
            [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
            This method is bound to the view instance, so that it can be
            easily passed around.
            */
            dispatch(tr: any): void;
            dom: any;
            editable: boolean;
            nodeViews: any;
            docView: {
                node: any;
                outerDeco: any;
                innerDeco: any;
                nodeDOM: any;
                parseRule(): {
                    node: any;
                    attrs: any;
                };
                matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                readonly size: any;
                readonly border: 0 | 1;
                updateChildren(view: any, pos: any): void;
                localCompositionInfo(view: any, pos: any): {
                    node: any;
                    pos: any;
                    text: any;
                };
                protectLocalComposition(view: any, { node, pos, text }: {
                    node: any;
                    pos: any;
                    text: any;
                }): void;
                children: any;
                update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                dirty: number;
                updateOuterDeco(outerDeco: any): void;
                dom: any;
                selectNode(): void;
                deselectNode(): void;
                readonly domAtom: any;
                parent: any;
                contentDOM: any;
                matchesWidget(widget: any): boolean;
                matchesMark(mark: any): boolean;
                matchesHack(nodeName: any): boolean;
                stopEvent(event: any): boolean;
                destroy(): void;
                posBeforeChild(child: any): any;
                readonly posBefore: any;
                readonly posAtStart: any;
                readonly posAfter: any;
                readonly posAtEnd: number;
                localPosFromDOM(dom: any, offset: any, bias: any): any;
                nearestDesc(dom: any, onlyNodes?: boolean): any;
                getDesc(dom: any): any;
                posFromDOM(dom: any, offset: any, bias: any): any;
                descAt(pos: any): any;
                domFromPos(pos: any, side: any): any;
                parseRange(from: any, to: any, base?: number): any;
                emptyChildAt(side: any): any;
                domAfterPos(pos: any): any;
                setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                ignoreMutation(mutation: any): boolean;
                readonly contentLost: boolean;
                markDirty(from: any, to: any): void;
                markParentsDirty(): void;
                readonly ignoreForCoords: boolean;
            };
            domObserver: {
                view: any;
                handleDOMChange: any;
                queue: any[];
                flushingSoon: number;
                observer: MutationObserver;
                currentSelection: {
                    anchorNode: any;
                    anchorOffset: number;
                    focusNode: any;
                    focusOffset: number;
                    set(sel: any): void;
                    clear(): void;
                    eq(sel: any): boolean;
                };
                onCharData: (e: any) => void;
                suppressingSelectionUpdates: boolean;
                onSelectionChange(): void;
                flushSoon(): void;
                forceFlush(): void;
                start(): void;
                stop(): void;
                connectSelection(): void;
                disconnectSelection(): void;
                suppressSelectionUpdates(): void;
                setCurSelection(): void;
                ignoreSelectionChange(sel: any): boolean;
                flush(): void;
                registerMutation(mut: any, added: any): {
                    from: any;
                    to: any;
                    typeOver?: undefined;
                } | {
                    from: any;
                    to: any;
                    typeOver: boolean;
                };
            };
            /**
            Holds `true` when a
            [composition](https://w3c.github.io/uievents/#events-compositionevents)
            is active.
            */
            readonly composing: boolean;
            /**
            The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
            */
            readonly props: any;
            /**
            Update the view's props. Will immediately cause an update to
            the DOM.
            */
            update(props: any): void;
            /**
            Update the view by updating existing props object with the object
            given as argument. Equivalent to `view.update(Object.assign({},
            view.props, props))`.
            */
            setProps(props: any): void;
            /**
            Update the editor's `state` prop, without touching any of the
            other props.
            */
            updateState(state: any): void;
            updateStateInner(state: any, prevProps: any): void;
            /**
            @internal
            */
            scrollToSelection(): void;
            destroyPluginViews(): void;
            updatePluginViews(prevState: any): void;
            someProp(propName: any, f: any): any;
            /**
            Query whether the view has focus.
            */
            hasFocus(): boolean;
            /**
            Focus the editor.
            */
            focus(): void;
            /**
            Get the document root in which the editor exists. This will
            usually be the top-level `document`, but might be a [shadow
            DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
            root if the editor is inside one.
            */
            readonly root: any;
            /**
            Given a pair of viewport coordinates, return the document
            position that corresponds to them. May return null if the given
            coordinates aren't inside of the editor. When an object is
            returned, its `pos` property is the position nearest to the
            coordinates, and its `inside` property holds the position of the
            inner node that the position falls inside of, or -1 if it is at
            the top level, not in any node.
            */
            posAtCoords(coords: any): {
                pos: any;
                inside: number;
            };
            /**
            Returns the viewport rectangle at a given document position.
            `left` and `right` will be the same number, as this returns a
            flat cursor-ish rectangle. If the position is between two things
            that aren't directly adjacent, `side` determines which element
            is used. When < 0, the element before the position is used,
            otherwise the element after.
            */
            coordsAtPos(pos: any, side?: number): any;
            /**
            Find the DOM position that corresponds to the given document
            position. When `side` is negative, find the position as close as
            possible to the content before the position. When positive,
            prefer positions close to the content after the position. When
            zero, prefer as shallow a position as possible.
            
            Note that you should **not** mutate the editor's internal DOM,
            only inspect it (and even that is usually not necessary).
            */
            domAtPos(pos: any, side?: number): any;
            /**
            Find the DOM node that represents the document node after the
            given position. May return `null` when the position doesn't point
            in front of a node or if the node is inside an opaque node view.
            
            This is intended to be able to call things like
            `getBoundingClientRect` on that DOM node. Do **not** mutate the
            editor DOM directly, or add styling this way, since that will be
            immediately overriden by the editor as it redraws the node.
            */
            nodeDOM(pos: any): any;
            /**
            Find the document position that corresponds to a given DOM
            position. (Whenever possible, it is preferable to inspect the
            document structure directly, rather than poking around in the
            DOM, but sometimesâ€”for example when interpreting an event
            targetâ€”you don't have a choice.)
            
            The `bias` parameter can be used to influence which side of a DOM
            node to use when the position is inside a leaf node.
            */
            posAtDOM(node: any, offset: any, bias?: number): any;
            /**
            Find out whether the selection is at the end of a textblock when
            moving in a given direction. When, for example, given `"left"`,
            it will return true if moving left from the current cursor
            position would leave that position's parent textblock. Will apply
            to the view's current state by default, but it is possible to
            pass a different state.
            */
            endOfTextblock(dir: any, state: any): any;
            /**
            Run the editor's paste logic with the given HTML string. The
            `event`, if given, will be passed to the
            [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
            */
            pasteHTML(html: any, event: any): boolean;
            /**
            Run the editor's paste logic with the given plain-text input.
            */
            pasteText(text: any, event: any): boolean;
            /**
            Removes the editor from the DOM and destroys all [node
            views](https://prosemirror.net/docs/ref/#view.NodeView).
            */
            destroy(): void;
            /**
            This is true when the view has been
            [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
            used anymore).
            */
            readonly isDestroyed: boolean;
            /**
            Used for testing.
            */
            dispatchEvent(event: any): void;
            /**
            @internal
            */
            domSelectionRange(): any;
            /**
            @internal
            */
            domSelection(): any;
        }): void;
        /**
         * Called when the view is destroyed or receives a state with different plugins.
         */
        destroy(): void;
        /**
         * Instantiate the ProseMirrorDropDown instances and configure them with the defined menu items.
         * @protected
         */
        _createDropDowns(): void;
        /**
         * @typedef {object} ProseMirrorMenuItem
         * @property {string} action             A string identifier for this menu item.
         * @property {string} title              The description of the menu item.
         * @property {string} [class]            An optional class to apply to the menu item.
         * @property {string} [style]            An optional style to apply to the title text.
         * @property {string} [icon]             The menu item's icon HTML.
         * @property {MarkType} [mark]           The mark to apply to the selected text.
         * @property {NodeType} [node]           The node to wrap the selected text in.
         * @property {object} [attrs]            An object of attributes for the node or mark.
         * @property {number} [group]            Entries with the same group number will be grouped together in the drop-down.
         *                                       Lower-numbered groups appear higher in the list.
         * @property {number} [priority]         A numeric priority which determines whether this item is displayed as the
         *                                       dropdown title. Lower priority takes precedence.
         * @property {ProseMirrorCommand} [cmd]  The command to run when the menu item is clicked.
         * @property {boolean} [active=false]    Whether the current item is active under the given selection or cursor.
         */
        /**
         * @typedef {ProseMirrorMenuItem} ProseMirrorDropDownEntry
         * @property {ProseMirrorDropDownEntry[]} [children]  Any child entries.
         */
        /**
         * @typedef {object} ProseMirrorDropDownConfig
         * @property {string} title                        The default title of the drop-down.
         * @property {string} cssClass                     The menu CSS class.
         * @property {string} [icon]                       An optional icon to use instead of a text label.
         * @property {ProseMirrorDropDownEntry[]} entries  The drop-down entries.
         */
        /**
         * Configure dropdowns for this menu. Each entry in the top-level array corresponds to a separate drop-down.
         * @returns {Object<ProseMirrorDropDownConfig>}
         * @protected
         */
        _getDropDownMenus(): any;
        /**
         * Configure the items for this menu.
         * @returns {ProseMirrorMenuItem[]}
         * @protected
         */
        _getMenuItems(): {
            /**
             * A string identifier for this menu item.
             */
            action: string;
            /**
             * The description of the menu item.
             */
            title: string;
            /**
             * An optional class to apply to the menu item.
             */
            class?: string;
            /**
             * An optional style to apply to the title text.
             */
            style?: string;
            /**
             * The menu item's icon HTML.
             */
            icon?: string;
            /**
             * The mark to apply to the selected text.
             */
            mark?: {
                name: any;
                rank: any;
                schema: any;
                spec: any;
                attrs: any;
                excluded: any;
                instance: {
                    type: any;
                    attrs: any;
                    /**
                    Given a set of marks, create a new set which contains this one as
                    well, in the right position. If this mark is already in the set,
                    the set itself is returned. If any marks that are set to be
                    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                    those are replaced by this one.
                    */
                    addToSet(set: any): any;
                    /**
                    Remove this mark from the given set, returning a new set. If this
                    mark is not in the set, the set itself is returned.
                    */
                    removeFromSet(set: any): any;
                    /**
                    Test whether this mark is in the given set of marks.
                    */
                    isInSet(set: any): boolean;
                    /**
                    Test whether this mark has the same type and attributes as
                    another mark.
                    */
                    eq(other: any): boolean;
                    /**
                    Convert this mark to a JSON-serializeable representation.
                    */
                    toJSON(): {
                        type: any;
                    };
                };
                /**
                Create a mark of this type. `attrs` may be `null` or an object
                containing only some of the mark's attributes. The others, if
                they have defaults, will be added.
                */
                create(attrs?: any): {
                    type: any;
                    attrs: any;
                    /**
                    Given a set of marks, create a new set which contains this one as
                    well, in the right position. If this mark is already in the set,
                    the set itself is returned. If any marks that are set to be
                    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                    those are replaced by this one.
                    */
                    addToSet(set: any): any;
                    /**
                    Remove this mark from the given set, returning a new set. If this
                    mark is not in the set, the set itself is returned.
                    */
                    removeFromSet(set: any): any;
                    /**
                    Test whether this mark is in the given set of marks.
                    */
                    isInSet(set: any): boolean;
                    /**
                    Test whether this mark has the same type and attributes as
                    another mark.
                    */
                    eq(other: any): boolean;
                    /**
                    Convert this mark to a JSON-serializeable representation.
                    */
                    toJSON(): {
                        type: any;
                    };
                };
                /**
                When there is a mark of this type in the given set, a new set
                without it is returned. Otherwise, the input set is returned.
                */
                removeFromSet(set: any): any;
                /**
                Tests whether there is a mark of this type in the given set.
                */
                isInSet(set: any): any;
                /**
                Queries whether a given mark type is
                [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
                */
                excludes(other: any): boolean;
            };
            /**
             * The node to wrap the selected text in.
             */
            node?: {
                attrs: any;
                spec: any;
                map(mapping: any, span: any, offset: any, oldOffset: any): {
                    from: any;
                    to: any;
                    type: any;
                    /**
                    @internal
                    */
                    copy(from: any, to: any): any;
                    /**
                    @internal
                    */
                    eq(other: any, offset?: number): boolean;
                    /**
                    @internal
                    */
                    map(mapping: any, offset: any, oldOffset: any): any;
                    /**
                    The spec provided when creating this decoration. Can be useful
                    if you've stored extra information in that object.
                    */
                    readonly spec: any;
                    /**
                    @internal
                    */
                    readonly inline: boolean;
                };
                valid(node: any, span: any): boolean;
                eq(other: any): boolean;
                destroy(): void;
            };
            /**
             * An object of attributes for the node or mark.
             */
            attrs?: object;
            /**
             * Entries with the same group number will be grouped together in the drop-down.
             *             Lower-numbered groups appear higher in the list.
             */
            group?: number;
            /**
             * A numeric priority which determines whether this item is displayed as the
             *          dropdown title. Lower priority takes precedence.
             */
            priority?: number;
            /**
             * The command to run when the menu item is clicked.
             */
            cmd?: (state: {
                config: any;
                /**
                The schema of the state's document.
                */
                readonly schema: any;
                /**
                The plugins that are active in this state.
                */
                readonly plugins: any;
                /**
                Apply the given transaction to produce a new state.
                */
                apply(tr: any): any;
                /**
                @internal
                */
                filterTransaction(tr: any, ignore?: number): boolean;
                /**
                Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
                returns the precise transactions that were applied (which might
                be influenced by the [transaction
                hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
                plugins) along with the new state.
                */
                applyTransaction(rootTr: any): {
                    state: any;
                    transactions: any[];
                };
                /**
                @internal
                */
                applyInner(tr: any): any;
                /**
                Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
                */
                readonly tr: {
                    curSelectionFor: number;
                    updated: number;
                    meta: any;
                    time: number;
                    curSelection: any;
                    storedMarks: any;
                    /**
                    The transaction's current selection. This defaults to the editor
                    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                    transaction, but can be overwritten with
                    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                    */
                    readonly selection: any;
                    /**
                    Update the transaction's current selection. Will determine the
                    selection that the editor gets when the transaction is applied.
                    */
                    setSelection(selection: any): any;
                    /**
                    Whether the selection was explicitly updated by this transaction.
                    */
                    readonly selectionSet: boolean;
                    /**
                    Set the current stored marks.
                    */
                    setStoredMarks(marks: any): any;
                    /**
                    Make sure the current stored marks or, if that is null, the marks
                    at the selection, match the given set of marks. Does nothing if
                    this is already the case.
                    */
                    ensureMarks(marks: any): any;
                    /**
                    Add a mark to the set of stored marks.
                    */
                    addStoredMark(mark: any): any;
                    /**
                    Remove a mark or mark type from the set of stored marks.
                    */
                    removeStoredMark(mark: any): any;
                    /**
                    Whether the stored marks were explicitly set for this transaction.
                    */
                    readonly storedMarksSet: boolean;
                    /**
                    @internal
                    */
                    addStep(step: any, doc: any): void;
                    /**
                    Update the timestamp for the transaction.
                    */
                    setTime(time: any): any;
                    /**
                    Replace the current selection with the given slice.
                    */
                    replaceSelection(slice: any): any;
                    /**
                    Replace the selection with the given node. When `inheritMarks` is
                    true and the content is inline, it inherits the marks from the
                    place where it is inserted.
                    */
                    replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                    /**
                    Delete the selection.
                    */
                    deleteSelection(): any;
                    /**
                    Replace the given range, or the selection if no range is given,
                    with a text node containing the given string.
                    */
                    insertText(text: any, from: any, to: any): any;
                    /**
                    Store a metadata property in this transaction, keyed either by
                    name or by plugin.
                    */
                    setMeta(key: any, value: any): any;
                    /**
                    Retrieve a metadata property for a given name or plugin.
                    */
                    getMeta(key: any): any;
                    /**
                    Returns true if this transaction doesn't contain any metadata,
                    and can thus safely be extended.
                    */
                    readonly isGeneric: boolean;
                    /**
                    Indicate that the editor should scroll the selection into view
                    when updated to the state produced by this transaction.
                    */
                    scrollIntoView(): any;
                    /**
                    True when this transaction has had `scrollIntoView` called on it.
                    */
                    readonly scrolledIntoView: boolean;
                    doc: any;
                    /**
                    The steps in this transform.
                    */
                    steps: any[];
                    /**
                    The documents before each of the steps.
                    */
                    docs: any[];
                    /**
                    A mapping with the maps for each of the steps in this transform.
                    */
                    mapping: {
                        maps: any[];
                        mirror: any;
                        from: number;
                        to: number;
                        /**
                        Create a mapping that maps only through a part of this one.
                        */
                        slice(from?: number, to?: number): any;
                        /**
                        @internal
                        */
                        copy(): any;
                        /**
                        Add a step map to the end of this mapping. If `mirrors` is
                        given, it should be the index of the step map that is the mirror
                        image of this one.
                        */
                        appendMap(map: any, mirrors: any): void;
                        /**
                        Add all the step maps in a given mapping to this one (preserving
                        mirroring information).
                        */
                        appendMapping(mapping: any): void;
                        /**
                        Finds the offset of the step map that mirrors the map at the
                        given offset, in this mapping (as per the second argument to
                        `appendMap`).
                        */
                        getMirror(n: any): any;
                        /**
                        @internal
                        */
                        setMirror(n: any, m: any): void;
                        /**
                        Append the inverse of the given mapping to this one.
                        */
                        appendMappingInverted(mapping: any): void;
                        /**
                        Create an inverted version of this mapping.
                        */
                        invert(): any;
                        /**
                        Map a position through this mapping.
                        */
                        map(pos: any, assoc?: number): any;
                        /**
                        Map a position through this mapping, returning a mapping
                        result.
                        */
                        mapResult(pos: any, assoc?: number): any;
                        /**
                        @internal
                        */
                        _map(pos: any, assoc: any, simple: any): any;
                    };
                    /**
                    The starting document.
                    */
                    readonly before: any;
                    /**
                    Apply a new step in this transform, saving the result. Throws an
                    error when the step fails.
                    */
                    step(step: any): any;
                    /**
                    Try to apply a step in this transformation, ignoring it if it
                    fails. Returns the step result.
                    */
                    maybeStep(step: any): any;
                    /**
                    True when the document has been changed (when there are any
                    steps).
                    */
                    readonly docChanged: boolean;
                    /**
                    Replace the part of the document between `from` and `to` with the
                    given `slice`.
                    */
                    replace(from: any, to?: any, slice?: {
                        content: any;
                        openStart: any;
                        openEnd: any;
                        /**
                        The size this slice would add when inserted into a document.
                        */
                        readonly size: number;
                        /**
                        @internal
                        */
                        insertAt(pos: any, fragment: any): any;
                        /**
                        @internal
                        */
                        removeBetween(from: any, to: any): any;
                        /**
                        Tests whether this slice is equal to another slice.
                        */
                        eq(other: any): boolean;
                        /**
                        @internal
                        */
                        toString(): string;
                        /**
                        Convert a slice to a JSON-serializable representation.
                        */
                        toJSON(): {
                            content: any;
                        };
                    }): any;
                    /**
                    Replace the given range with the given content, which may be a
                    fragment, node, or array of nodes.
                    */
                    replaceWith(from: any, to: any, content: any): any;
                    /**
                    Delete the content between the given positions.
                    */
                    delete(from: any, to: any): any;
                    /**
                    Insert the given content at the given position.
                    */
                    insert(pos: any, content: any): any;
                    /**
                    Replace a range of the document with a given slice, using
                    `from`, `to`, and the slice's
                    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                    than fixed start and end points. This method may grow the
                    replaced area or close open nodes in the slice in order to get a
                    fit that is more in line with WYSIWYG expectations, by dropping
                    fully covered parent nodes of the replaced region when they are
                    marked [non-defining as
                    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                    open parent node from the slice that _is_ marked as [defining
                    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                    
                    This is the method, for example, to handle paste. The similar
                    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                    primitive tool which will _not_ move the start and end of its given
                    range, and is useful in situations where you need more precise
                    control over what happens.
                    */
                    replaceRange(from: any, to: any, slice: any): any;
                    /**
                    Replace the given range with a node, but use `from` and `to` as
                    hints, rather than precise positions. When from and to are the same
                    and are at the start or end of a parent node in which the given
                    node doesn't fit, this method may _move_ them out towards a parent
                    that does allow the given node to be placed. When the given range
                    completely covers a parent node, this method may completely replace
                    that parent node.
                    */
                    replaceRangeWith(from: any, to: any, node: any): any;
                    /**
                    Delete the given range, expanding it to cover fully covered
                    parent nodes until a valid replace is found.
                    */
                    deleteRange(from: any, to: any): any;
                    /**
                    Split the content in the given range off from its parent, if there
                    is sibling content before or after it, and move it up the tree to
                    the depth specified by `target`. You'll probably want to use
                    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                    sure the lift is valid.
                    */
                    lift(range: any, target: any): any;
                    /**
                    Join the blocks around the given position. If depth is 2, their
                    last and first siblings are also joined, and so on.
                    */
                    join(pos: any, depth?: number): any;
                    /**
                    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                    The wrappers are assumed to be valid in this position, and should
                    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                    */
                    wrap(range: any, wrappers: any): any;
                    /**
                    Set the type of all textblocks (partly) between `from` and `to` to
                    the given node type with the given attributes.
                    */
                    setBlockType(from: any, to: any, type: any, attrs?: any): any;
                    /**
                    Change the type, attributes, and/or marks of the node at `pos`.
                    When `type` isn't given, the existing node type is preserved,
                    */
                    setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                    /**
                    Set a single attribute on a given node to a new value.
                    */
                    setNodeAttribute(pos: any, attr: any, value: any): any;
                    /**
                    Add a mark to the node at position `pos`.
                    */
                    addNodeMark(pos: any, mark: any): any;
                    /**
                    Remove a mark (or a mark of the given type) from the node at
                    position `pos`.
                    */
                    removeNodeMark(pos: any, mark: any): any;
                    /**
                    Split the node at the given position, and optionally, if `depth` is
                    greater than one, any number of nodes above that. By default, the
                    parts split off will inherit the node type of the original node.
                    This can be changed by passing an array of types and attributes to
                    use after the split.
                    */
                    split(pos: any, depth: number, typesAfter: any): any;
                    /**
                    Add the given mark to the inline content between `from` and `to`.
                    */
                    addMark(from: any, to: any, mark: any): any;
                    /**
                    Remove marks from inline nodes between `from` and `to`. When
                    `mark` is a single mark, remove precisely that mark. When it is
                    a mark type, remove all marks of that type. When it is null,
                    remove all marks of any type.
                    */
                    removeMark(from: any, to: any, mark: any): any;
                    /**
                    Removes all marks and nodes from the content of the node at
                    `pos` that don't match the given new parent node type. Accepts
                    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                    third argument.
                    */
                    clearIncompatible(pos: any, parentType: any, match: any): any;
                };
                /**
                Create a new state based on this one, but with an adjusted set
                of active plugins. State fields that exist in both sets of
                plugins are kept unchanged. Those that no longer exist are
                dropped, and those that are new are initialized using their
                [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
                configuration object..
                */
                reconfigure(config: any): any;
                /**
                Serialize this state to JSON. If you want to serialize the state
                of plugins, pass an object mapping property names to use in the
                resulting JSON object to plugin objects. The argument may also be
                a string or number, in which case it is ignored, to support the
                way `JSON.stringify` calls `toString` methods.
                */
                toJSON(pluginFields: any): {
                    doc: any;
                    selection: any;
                };
            }, dispatch: (arg0: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            }) => any, view: {
                _root: any;
                /**
                @internal
                */
                focused: boolean;
                /**
                Kludge used to work around a Chrome bug @internal
                */
                trackWrites: any;
                mounted: boolean;
                /**
                @internal
                */
                markCursor: any;
                /**
                @internal
                */
                cursorWrapper: any;
                /**
                @internal
                */
                lastSelectedViewDesc: any;
                /**
                @internal
                */
                input: {
                    shiftKey: boolean;
                    mouseDown: any;
                    lastKeyCode: any;
                    lastKeyCodeTime: number;
                    lastClick: {
                        time: number;
                        x: number;
                        y: number;
                        type: string;
                    };
                    lastSelectionOrigin: any;
                    lastSelectionTime: number;
                    lastIOSEnter: number;
                    lastIOSEnterFallbackTimeout: number;
                    lastFocus: number;
                    lastTouch: number;
                    lastAndroidDelete: number;
                    composing: boolean;
                    composingTimeout: number;
                    compositionNodes: any[];
                    compositionEndedAt: number;
                    domChangeCount: number;
                    eventHandlers: any;
                    hideSelectionGuard: any;
                };
                prevDirectPlugins: any[];
                pluginViews: any[];
                /**
                Holds `true` when a hack node is needed in Firefox to prevent the
                [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
                @internal
                */
                requiresGeckoHackNode: boolean;
                /**
                When editor content is being dragged, this object contains
                information about the dragged slice and whether it is being
                copied or moved. At any other time, it is null.
                */
                dragging: any;
                _props: any;
                state: any;
                directPlugins: any;
                /**
                Dispatch a transaction. Will call
                [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
                when given, and otherwise defaults to applying the transaction to
                the current state and calling
                [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
                This method is bound to the view instance, so that it can be
                easily passed around.
                */
                dispatch(tr: any): void;
                dom: any;
                editable: boolean;
                nodeViews: any;
                docView: {
                    node: any;
                    outerDeco: any;
                    innerDeco: any;
                    nodeDOM: any;
                    parseRule(): {
                        node: any;
                        attrs: any;
                    };
                    matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                    readonly size: any;
                    readonly border: 0 | 1;
                    updateChildren(view: any, pos: any): void;
                    localCompositionInfo(view: any, pos: any): {
                        node: any;
                        pos: any;
                        text: any;
                    };
                    protectLocalComposition(view: any, { node, pos, text }: {
                        node: any;
                        pos: any;
                        text: any;
                    }): void;
                    children: any;
                    update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                    updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                    dirty: number;
                    updateOuterDeco(outerDeco: any): void;
                    dom: any;
                    selectNode(): void;
                    deselectNode(): void;
                    readonly domAtom: any;
                    parent: any;
                    contentDOM: any;
                    matchesWidget(widget: any): boolean;
                    matchesMark(mark: any): boolean;
                    matchesHack(nodeName: any): boolean;
                    stopEvent(event: any): boolean;
                    destroy(): void;
                    posBeforeChild(child: any): any;
                    readonly posBefore: any;
                    readonly posAtStart: any;
                    readonly posAfter: any;
                    readonly posAtEnd: number;
                    localPosFromDOM(dom: any, offset: any, bias: any): any;
                    nearestDesc(dom: any, onlyNodes?: boolean): any;
                    getDesc(dom: any): any;
                    posFromDOM(dom: any, offset: any, bias: any): any;
                    descAt(pos: any): any;
                    domFromPos(pos: any, side: any): any;
                    parseRange(from: any, to: any, base?: number): any;
                    emptyChildAt(side: any): any;
                    domAfterPos(pos: any): any;
                    setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                    ignoreMutation(mutation: any): boolean;
                    readonly contentLost: boolean;
                    markDirty(from: any, to: any): void;
                    markParentsDirty(): void;
                    readonly ignoreForCoords: boolean;
                };
                domObserver: {
                    view: any;
                    handleDOMChange: any;
                    queue: any[];
                    flushingSoon: number;
                    observer: MutationObserver;
                    currentSelection: {
                        anchorNode: any;
                        anchorOffset: number;
                        focusNode: any;
                        focusOffset: number;
                        set(sel: any): void;
                        clear(): void;
                        eq(sel: any): boolean;
                    };
                    onCharData: (e: any) => void;
                    suppressingSelectionUpdates: boolean;
                    onSelectionChange(): void;
                    flushSoon(): void;
                    forceFlush(): void;
                    start(): void;
                    stop(): void;
                    connectSelection(): void;
                    disconnectSelection(): void;
                    suppressSelectionUpdates(): void;
                    setCurSelection(): void;
                    ignoreSelectionChange(sel: any): boolean;
                    flush(): void;
                    registerMutation(mut: any, added: any): {
                        from: any;
                        to: any;
                        typeOver?: undefined;
                    } | {
                        from: any;
                        to: any;
                        typeOver: boolean;
                    };
                };
                /**
                Holds `true` when a
                [composition](https://w3c.github.io/uievents/#events-compositionevents)
                is active.
                */
                readonly composing: boolean;
                /**
                The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
                */
                readonly props: any;
                /**
                Update the view's props. Will immediately cause an update to
                the DOM.
                */
                update(props: any): void;
                /**
                Update the view by updating existing props object with the object
                given as argument. Equivalent to `view.update(Object.assign({},
                view.props, props))`.
                */
                setProps(props: any): void;
                /**
                Update the editor's `state` prop, without touching any of the
                other props.
                */
                updateState(state: any): void;
                updateStateInner(state: any, prevProps: any): void;
                /**
                @internal
                */
                scrollToSelection(): void;
                destroyPluginViews(): void;
                updatePluginViews(prevState: any): void;
                someProp(propName: any, f: any): any;
                /**
                Query whether the view has focus.
                */
                hasFocus(): boolean;
                /**
                Focus the editor.
                */
                focus(): void;
                /**
                Get the document root in which the editor exists. This will
                usually be the top-level `document`, but might be a [shadow
                DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
                root if the editor is inside one.
                */
                readonly root: any;
                /**
                Given a pair of viewport coordinates, return the document
                position that corresponds to them. May return null if the given
                coordinates aren't inside of the editor. When an object is
                returned, its `pos` property is the position nearest to the
                coordinates, and its `inside` property holds the position of the
                inner node that the position falls inside of, or -1 if it is at
                the top level, not in any node.
                */
                posAtCoords(coords: any): {
                    pos: any;
                    inside: number;
                };
                /**
                Returns the viewport rectangle at a given document position.
                `left` and `right` will be the same number, as this returns a
                flat cursor-ish rectangle. If the position is between two things
                that aren't directly adjacent, `side` determines which element
                is used. When < 0, the element before the position is used,
                otherwise the element after.
                */
                coordsAtPos(pos: any, side?: number): any;
                /**
                Find the DOM position that corresponds to the given document
                position. When `side` is negative, find the position as close as
                possible to the content before the position. When positive,
                prefer positions close to the content after the position. When
                zero, prefer as shallow a position as possible.
                
                Note that you should **not** mutate the editor's internal DOM,
                only inspect it (and even that is usually not necessary).
                */
                domAtPos(pos: any, side?: number): any;
                /**
                Find the DOM node that represents the document node after the
                given position. May return `null` when the position doesn't point
                in front of a node or if the node is inside an opaque node view.
                
                This is intended to be able to call things like
                `getBoundingClientRect` on that DOM node. Do **not** mutate the
                editor DOM directly, or add styling this way, since that will be
                immediately overriden by the editor as it redraws the node.
                */
                nodeDOM(pos: any): any;
                /**
                Find the document position that corresponds to a given DOM
                position. (Whenever possible, it is preferable to inspect the
                document structure directly, rather than poking around in the
                DOM, but sometimesâ€”for example when interpreting an event
                targetâ€”you don't have a choice.)
                
                The `bias` parameter can be used to influence which side of a DOM
                node to use when the position is inside a leaf node.
                */
                posAtDOM(node: any, offset: any, bias?: number): any;
                /**
                Find out whether the selection is at the end of a textblock when
                moving in a given direction. When, for example, given `"left"`,
                it will return true if moving left from the current cursor
                position would leave that position's parent textblock. Will apply
                to the view's current state by default, but it is possible to
                pass a different state.
                */
                endOfTextblock(dir: any, state: any): any;
                /**
                Run the editor's paste logic with the given HTML string. The
                `event`, if given, will be passed to the
                [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
                */
                pasteHTML(html: any, event: any): boolean;
                /**
                Run the editor's paste logic with the given plain-text input.
                */
                pasteText(text: any, event: any): boolean;
                /**
                Removes the editor from the DOM and destroys all [node
                views](https://prosemirror.net/docs/ref/#view.NodeView).
                */
                destroy(): void;
                /**
                This is true when the view has been
                [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
                used anymore).
                */
                readonly isDestroyed: boolean;
                /**
                Used for testing.
                */
                dispatchEvent(event: any): void;
                /**
                @internal
                */
                domSelectionRange(): any;
                /**
                @internal
                */
                domSelection(): any;
            }) => boolean;
            /**
             * Whether the current item is active under the given selection or cursor.
             */
            active?: boolean;
        }[];
        /**
         * Determine whether the given menu item is currently active or not.
         * @param {ProseMirrorMenuItem} item  The menu item.
         * @returns {boolean}                 Whether the cursor or selection is in a state represented by the given menu
         *                                    item.
         * @protected
         */
        _isItemActive(item: {
            /**
             * A string identifier for this menu item.
             */
            action: string;
            /**
             * The description of the menu item.
             */
            title: string;
            /**
             * An optional class to apply to the menu item.
             */
            class?: string;
            /**
             * An optional style to apply to the title text.
             */
            style?: string;
            /**
             * The menu item's icon HTML.
             */
            icon?: string;
            /**
             * The mark to apply to the selected text.
             */
            mark?: {
                name: any;
                rank: any;
                schema: any;
                spec: any;
                attrs: any;
                excluded: any;
                instance: {
                    type: any;
                    attrs: any;
                    /**
                    Given a set of marks, create a new set which contains this one as
                    well, in the right position. If this mark is already in the set,
                    the set itself is returned. If any marks that are set to be
                    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                    those are replaced by this one.
                    */
                    addToSet(set: any): any;
                    /**
                    Remove this mark from the given set, returning a new set. If this
                    mark is not in the set, the set itself is returned.
                    */
                    removeFromSet(set: any): any;
                    /**
                    Test whether this mark is in the given set of marks.
                    */
                    isInSet(set: any): boolean;
                    /**
                    Test whether this mark has the same type and attributes as
                    another mark.
                    */
                    eq(other: any): boolean;
                    /**
                    Convert this mark to a JSON-serializeable representation.
                    */
                    toJSON(): {
                        type: any;
                    };
                };
                /**
                Create a mark of this type. `attrs` may be `null` or an object
                containing only some of the mark's attributes. The others, if
                they have defaults, will be added.
                */
                create(attrs?: any): {
                    type: any;
                    attrs: any;
                    /**
                    Given a set of marks, create a new set which contains this one as
                    well, in the right position. If this mark is already in the set,
                    the set itself is returned. If any marks that are set to be
                    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                    those are replaced by this one.
                    */
                    addToSet(set: any): any;
                    /**
                    Remove this mark from the given set, returning a new set. If this
                    mark is not in the set, the set itself is returned.
                    */
                    removeFromSet(set: any): any;
                    /**
                    Test whether this mark is in the given set of marks.
                    */
                    isInSet(set: any): boolean;
                    /**
                    Test whether this mark has the same type and attributes as
                    another mark.
                    */
                    eq(other: any): boolean;
                    /**
                    Convert this mark to a JSON-serializeable representation.
                    */
                    toJSON(): {
                        type: any;
                    };
                };
                /**
                When there is a mark of this type in the given set, a new set
                without it is returned. Otherwise, the input set is returned.
                */
                removeFromSet(set: any): any;
                /**
                Tests whether there is a mark of this type in the given set.
                */
                isInSet(set: any): any;
                /**
                Queries whether a given mark type is
                [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
                */
                excludes(other: any): boolean;
            };
            /**
             * The node to wrap the selected text in.
             */
            node?: {
                attrs: any;
                spec: any;
                map(mapping: any, span: any, offset: any, oldOffset: any): {
                    from: any;
                    to: any;
                    type: any;
                    /**
                    @internal
                    */
                    copy(from: any, to: any): any;
                    /**
                    @internal
                    */
                    eq(other: any, offset?: number): boolean;
                    /**
                    @internal
                    */
                    map(mapping: any, offset: any, oldOffset: any): any;
                    /**
                    The spec provided when creating this decoration. Can be useful
                    if you've stored extra information in that object.
                    */
                    readonly spec: any;
                    /**
                    @internal
                    */
                    readonly inline: boolean;
                };
                valid(node: any, span: any): boolean;
                eq(other: any): boolean;
                destroy(): void;
            };
            /**
             * An object of attributes for the node or mark.
             */
            attrs?: object;
            /**
             * Entries with the same group number will be grouped together in the drop-down.
             *             Lower-numbered groups appear higher in the list.
             */
            group?: number;
            /**
             * A numeric priority which determines whether this item is displayed as the
             *          dropdown title. Lower priority takes precedence.
             */
            priority?: number;
            /**
             * The command to run when the menu item is clicked.
             */
            cmd?: (state: {
                config: any;
                /**
                The schema of the state's document.
                */
                readonly schema: any;
                /**
                The plugins that are active in this state.
                */
                readonly plugins: any;
                /**
                Apply the given transaction to produce a new state.
                */
                apply(tr: any): any;
                /**
                @internal
                */
                filterTransaction(tr: any, ignore?: number): boolean;
                /**
                Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
                returns the precise transactions that were applied (which might
                be influenced by the [transaction
                hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
                plugins) along with the new state.
                */
                applyTransaction(rootTr: any): {
                    state: any;
                    transactions: any[];
                };
                /**
                @internal
                */
                applyInner(tr: any): any;
                /**
                Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
                */
                readonly tr: {
                    curSelectionFor: number;
                    updated: number;
                    meta: any;
                    time: number;
                    curSelection: any;
                    storedMarks: any;
                    /**
                    The transaction's current selection. This defaults to the editor
                    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                    transaction, but can be overwritten with
                    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                    */
                    readonly selection: any;
                    /**
                    Update the transaction's current selection. Will determine the
                    selection that the editor gets when the transaction is applied.
                    */
                    setSelection(selection: any): any;
                    /**
                    Whether the selection was explicitly updated by this transaction.
                    */
                    readonly selectionSet: boolean;
                    /**
                    Set the current stored marks.
                    */
                    setStoredMarks(marks: any): any;
                    /**
                    Make sure the current stored marks or, if that is null, the marks
                    at the selection, match the given set of marks. Does nothing if
                    this is already the case.
                    */
                    ensureMarks(marks: any): any;
                    /**
                    Add a mark to the set of stored marks.
                    */
                    addStoredMark(mark: any): any;
                    /**
                    Remove a mark or mark type from the set of stored marks.
                    */
                    removeStoredMark(mark: any): any;
                    /**
                    Whether the stored marks were explicitly set for this transaction.
                    */
                    readonly storedMarksSet: boolean;
                    /**
                    @internal
                    */
                    addStep(step: any, doc: any): void;
                    /**
                    Update the timestamp for the transaction.
                    */
                    setTime(time: any): any;
                    /**
                    Replace the current selection with the given slice.
                    */
                    replaceSelection(slice: any): any;
                    /**
                    Replace the selection with the given node. When `inheritMarks` is
                    true and the content is inline, it inherits the marks from the
                    place where it is inserted.
                    */
                    replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                    /**
                    Delete the selection.
                    */
                    deleteSelection(): any;
                    /**
                    Replace the given range, or the selection if no range is given,
                    with a text node containing the given string.
                    */
                    insertText(text: any, from: any, to: any): any;
                    /**
                    Store a metadata property in this transaction, keyed either by
                    name or by plugin.
                    */
                    setMeta(key: any, value: any): any;
                    /**
                    Retrieve a metadata property for a given name or plugin.
                    */
                    getMeta(key: any): any;
                    /**
                    Returns true if this transaction doesn't contain any metadata,
                    and can thus safely be extended.
                    */
                    readonly isGeneric: boolean;
                    /**
                    Indicate that the editor should scroll the selection into view
                    when updated to the state produced by this transaction.
                    */
                    scrollIntoView(): any;
                    /**
                    True when this transaction has had `scrollIntoView` called on it.
                    */
                    readonly scrolledIntoView: boolean;
                    doc: any;
                    /**
                    The steps in this transform.
                    */
                    steps: any[];
                    /**
                    The documents before each of the steps.
                    */
                    docs: any[];
                    /**
                    A mapping with the maps for each of the steps in this transform.
                    */
                    mapping: {
                        maps: any[];
                        mirror: any;
                        from: number;
                        to: number;
                        /**
                        Create a mapping that maps only through a part of this one.
                        */
                        slice(from?: number, to?: number): any;
                        /**
                        @internal
                        */
                        copy(): any;
                        /**
                        Add a step map to the end of this mapping. If `mirrors` is
                        given, it should be the index of the step map that is the mirror
                        image of this one.
                        */
                        appendMap(map: any, mirrors: any): void;
                        /**
                        Add all the step maps in a given mapping to this one (preserving
                        mirroring information).
                        */
                        appendMapping(mapping: any): void;
                        /**
                        Finds the offset of the step map that mirrors the map at the
                        given offset, in this mapping (as per the second argument to
                        `appendMap`).
                        */
                        getMirror(n: any): any;
                        /**
                        @internal
                        */
                        setMirror(n: any, m: any): void;
                        /**
                        Append the inverse of the given mapping to this one.
                        */
                        appendMappingInverted(mapping: any): void;
                        /**
                        Create an inverted version of this mapping.
                        */
                        invert(): any;
                        /**
                        Map a position through this mapping.
                        */
                        map(pos: any, assoc?: number): any;
                        /**
                        Map a position through this mapping, returning a mapping
                        result.
                        */
                        mapResult(pos: any, assoc?: number): any;
                        /**
                        @internal
                        */
                        _map(pos: any, assoc: any, simple: any): any;
                    };
                    /**
                    The starting document.
                    */
                    readonly before: any;
                    /**
                    Apply a new step in this transform, saving the result. Throws an
                    error when the step fails.
                    */
                    step(step: any): any;
                    /**
                    Try to apply a step in this transformation, ignoring it if it
                    fails. Returns the step result.
                    */
                    maybeStep(step: any): any;
                    /**
                    True when the document has been changed (when there are any
                    steps).
                    */
                    readonly docChanged: boolean;
                    /**
                    Replace the part of the document between `from` and `to` with the
                    given `slice`.
                    */
                    replace(from: any, to?: any, slice?: {
                        content: any;
                        openStart: any;
                        openEnd: any;
                        /**
                        The size this slice would add when inserted into a document.
                        */
                        readonly size: number;
                        /**
                        @internal
                        */
                        insertAt(pos: any, fragment: any): any;
                        /**
                        @internal
                        */
                        removeBetween(from: any, to: any): any;
                        /**
                        Tests whether this slice is equal to another slice.
                        */
                        eq(other: any): boolean;
                        /**
                        @internal
                        */
                        toString(): string;
                        /**
                        Convert a slice to a JSON-serializable representation.
                        */
                        toJSON(): {
                            content: any;
                        };
                    }): any;
                    /**
                    Replace the given range with the given content, which may be a
                    fragment, node, or array of nodes.
                    */
                    replaceWith(from: any, to: any, content: any): any;
                    /**
                    Delete the content between the given positions.
                    */
                    delete(from: any, to: any): any;
                    /**
                    Insert the given content at the given position.
                    */
                    insert(pos: any, content: any): any;
                    /**
                    Replace a range of the document with a given slice, using
                    `from`, `to`, and the slice's
                    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                    than fixed start and end points. This method may grow the
                    replaced area or close open nodes in the slice in order to get a
                    fit that is more in line with WYSIWYG expectations, by dropping
                    fully covered parent nodes of the replaced region when they are
                    marked [non-defining as
                    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                    open parent node from the slice that _is_ marked as [defining
                    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                    
                    This is the method, for example, to handle paste. The similar
                    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                    primitive tool which will _not_ move the start and end of its given
                    range, and is useful in situations where you need more precise
                    control over what happens.
                    */
                    replaceRange(from: any, to: any, slice: any): any;
                    /**
                    Replace the given range with a node, but use `from` and `to` as
                    hints, rather than precise positions. When from and to are the same
                    and are at the start or end of a parent node in which the given
                    node doesn't fit, this method may _move_ them out towards a parent
                    that does allow the given node to be placed. When the given range
                    completely covers a parent node, this method may completely replace
                    that parent node.
                    */
                    replaceRangeWith(from: any, to: any, node: any): any;
                    /**
                    Delete the given range, expanding it to cover fully covered
                    parent nodes until a valid replace is found.
                    */
                    deleteRange(from: any, to: any): any;
                    /**
                    Split the content in the given range off from its parent, if there
                    is sibling content before or after it, and move it up the tree to
                    the depth specified by `target`. You'll probably want to use
                    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                    sure the lift is valid.
                    */
                    lift(range: any, target: any): any;
                    /**
                    Join the blocks around the given position. If depth is 2, their
                    last and first siblings are also joined, and so on.
                    */
                    join(pos: any, depth?: number): any;
                    /**
                    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                    The wrappers are assumed to be valid in this position, and should
                    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                    */
                    wrap(range: any, wrappers: any): any;
                    /**
                    Set the type of all textblocks (partly) between `from` and `to` to
                    the given node type with the given attributes.
                    */
                    setBlockType(from: any, to: any, type: any, attrs?: any): any;
                    /**
                    Change the type, attributes, and/or marks of the node at `pos`.
                    When `type` isn't given, the existing node type is preserved,
                    */
                    setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                    /**
                    Set a single attribute on a given node to a new value.
                    */
                    setNodeAttribute(pos: any, attr: any, value: any): any;
                    /**
                    Add a mark to the node at position `pos`.
                    */
                    addNodeMark(pos: any, mark: any): any;
                    /**
                    Remove a mark (or a mark of the given type) from the node at
                    position `pos`.
                    */
                    removeNodeMark(pos: any, mark: any): any;
                    /**
                    Split the node at the given position, and optionally, if `depth` is
                    greater than one, any number of nodes above that. By default, the
                    parts split off will inherit the node type of the original node.
                    This can be changed by passing an array of types and attributes to
                    use after the split.
                    */
                    split(pos: any, depth: number, typesAfter: any): any;
                    /**
                    Add the given mark to the inline content between `from` and `to`.
                    */
                    addMark(from: any, to: any, mark: any): any;
                    /**
                    Remove marks from inline nodes between `from` and `to`. When
                    `mark` is a single mark, remove precisely that mark. When it is
                    a mark type, remove all marks of that type. When it is null,
                    remove all marks of any type.
                    */
                    removeMark(from: any, to: any, mark: any): any;
                    /**
                    Removes all marks and nodes from the content of the node at
                    `pos` that don't match the given new parent node type. Accepts
                    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                    third argument.
                    */
                    clearIncompatible(pos: any, parentType: any, match: any): any;
                };
                /**
                Create a new state based on this one, but with an adjusted set
                of active plugins. State fields that exist in both sets of
                plugins are kept unchanged. Those that no longer exist are
                dropped, and those that are new are initialized using their
                [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
                configuration object..
                */
                reconfigure(config: any): any;
                /**
                Serialize this state to JSON. If you want to serialize the state
                of plugins, pass an object mapping property names to use in the
                resulting JSON object to plugin objects. The argument may also be
                a string or number, in which case it is ignored, to support the
                way `JSON.stringify` calls `toString` methods.
                */
                toJSON(pluginFields: any): {
                    doc: any;
                    selection: any;
                };
            }, dispatch: (arg0: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            }) => any, view: {
                _root: any;
                /**
                @internal
                */
                focused: boolean;
                /**
                Kludge used to work around a Chrome bug @internal
                */
                trackWrites: any;
                mounted: boolean;
                /**
                @internal
                */
                markCursor: any;
                /**
                @internal
                */
                cursorWrapper: any;
                /**
                @internal
                */
                lastSelectedViewDesc: any;
                /**
                @internal
                */
                input: {
                    shiftKey: boolean;
                    mouseDown: any;
                    lastKeyCode: any;
                    lastKeyCodeTime: number;
                    lastClick: {
                        time: number;
                        x: number;
                        y: number;
                        type: string;
                    };
                    lastSelectionOrigin: any;
                    lastSelectionTime: number;
                    lastIOSEnter: number;
                    lastIOSEnterFallbackTimeout: number;
                    lastFocus: number;
                    lastTouch: number;
                    lastAndroidDelete: number;
                    composing: boolean;
                    composingTimeout: number;
                    compositionNodes: any[];
                    compositionEndedAt: number;
                    domChangeCount: number;
                    eventHandlers: any;
                    hideSelectionGuard: any;
                };
                prevDirectPlugins: any[];
                pluginViews: any[];
                /**
                Holds `true` when a hack node is needed in Firefox to prevent the
                [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
                @internal
                */
                requiresGeckoHackNode: boolean;
                /**
                When editor content is being dragged, this object contains
                information about the dragged slice and whether it is being
                copied or moved. At any other time, it is null.
                */
                dragging: any;
                _props: any;
                state: any;
                directPlugins: any;
                /**
                Dispatch a transaction. Will call
                [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
                when given, and otherwise defaults to applying the transaction to
                the current state and calling
                [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
                This method is bound to the view instance, so that it can be
                easily passed around.
                */
                dispatch(tr: any): void;
                dom: any;
                editable: boolean;
                nodeViews: any;
                docView: {
                    node: any;
                    outerDeco: any;
                    innerDeco: any;
                    nodeDOM: any;
                    parseRule(): {
                        node: any;
                        attrs: any;
                    };
                    matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                    readonly size: any;
                    readonly border: 0 | 1;
                    updateChildren(view: any, pos: any): void;
                    localCompositionInfo(view: any, pos: any): {
                        node: any;
                        pos: any;
                        text: any;
                    };
                    protectLocalComposition(view: any, { node, pos, text }: {
                        node: any;
                        pos: any;
                        text: any;
                    }): void;
                    children: any;
                    update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                    updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                    dirty: number;
                    updateOuterDeco(outerDeco: any): void;
                    dom: any;
                    selectNode(): void;
                    deselectNode(): void;
                    readonly domAtom: any;
                    parent: any;
                    contentDOM: any;
                    matchesWidget(widget: any): boolean;
                    matchesMark(mark: any): boolean;
                    matchesHack(nodeName: any): boolean;
                    stopEvent(event: any): boolean;
                    destroy(): void;
                    posBeforeChild(child: any): any;
                    readonly posBefore: any;
                    readonly posAtStart: any;
                    readonly posAfter: any;
                    readonly posAtEnd: number;
                    localPosFromDOM(dom: any, offset: any, bias: any): any;
                    nearestDesc(dom: any, onlyNodes?: boolean): any;
                    getDesc(dom: any): any;
                    posFromDOM(dom: any, offset: any, bias: any): any;
                    descAt(pos: any): any;
                    domFromPos(pos: any, side: any): any;
                    parseRange(from: any, to: any, base?: number): any;
                    emptyChildAt(side: any): any;
                    domAfterPos(pos: any): any;
                    setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                    ignoreMutation(mutation: any): boolean;
                    readonly contentLost: boolean;
                    markDirty(from: any, to: any): void;
                    markParentsDirty(): void;
                    readonly ignoreForCoords: boolean;
                };
                domObserver: {
                    view: any;
                    handleDOMChange: any;
                    queue: any[];
                    flushingSoon: number;
                    observer: MutationObserver;
                    currentSelection: {
                        anchorNode: any;
                        anchorOffset: number;
                        focusNode: any;
                        focusOffset: number;
                        set(sel: any): void;
                        clear(): void;
                        eq(sel: any): boolean;
                    };
                    onCharData: (e: any) => void;
                    suppressingSelectionUpdates: boolean;
                    onSelectionChange(): void;
                    flushSoon(): void;
                    forceFlush(): void;
                    start(): void;
                    stop(): void;
                    connectSelection(): void;
                    disconnectSelection(): void;
                    suppressSelectionUpdates(): void;
                    setCurSelection(): void;
                    ignoreSelectionChange(sel: any): boolean;
                    flush(): void;
                    registerMutation(mut: any, added: any): {
                        from: any;
                        to: any;
                        typeOver?: undefined;
                    } | {
                        from: any;
                        to: any;
                        typeOver: boolean;
                    };
                };
                /**
                Holds `true` when a
                [composition](https://w3c.github.io/uievents/#events-compositionevents)
                is active.
                */
                readonly composing: boolean;
                /**
                The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
                */
                readonly props: any;
                /**
                Update the view's props. Will immediately cause an update to
                the DOM.
                */
                update(props: any): void;
                /**
                Update the view by updating existing props object with the object
                given as argument. Equivalent to `view.update(Object.assign({},
                view.props, props))`.
                */
                setProps(props: any): void;
                /**
                Update the editor's `state` prop, without touching any of the
                other props.
                */
                updateState(state: any): void;
                updateStateInner(state: any, prevProps: any): void;
                /**
                @internal
                */
                scrollToSelection(): void;
                destroyPluginViews(): void;
                updatePluginViews(prevState: any): void;
                someProp(propName: any, f: any): any;
                /**
                Query whether the view has focus.
                */
                hasFocus(): boolean;
                /**
                Focus the editor.
                */
                focus(): void;
                /**
                Get the document root in which the editor exists. This will
                usually be the top-level `document`, but might be a [shadow
                DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
                root if the editor is inside one.
                */
                readonly root: any;
                /**
                Given a pair of viewport coordinates, return the document
                position that corresponds to them. May return null if the given
                coordinates aren't inside of the editor. When an object is
                returned, its `pos` property is the position nearest to the
                coordinates, and its `inside` property holds the position of the
                inner node that the position falls inside of, or -1 if it is at
                the top level, not in any node.
                */
                posAtCoords(coords: any): {
                    pos: any;
                    inside: number;
                };
                /**
                Returns the viewport rectangle at a given document position.
                `left` and `right` will be the same number, as this returns a
                flat cursor-ish rectangle. If the position is between two things
                that aren't directly adjacent, `side` determines which element
                is used. When < 0, the element before the position is used,
                otherwise the element after.
                */
                coordsAtPos(pos: any, side?: number): any;
                /**
                Find the DOM position that corresponds to the given document
                position. When `side` is negative, find the position as close as
                possible to the content before the position. When positive,
                prefer positions close to the content after the position. When
                zero, prefer as shallow a position as possible.
                
                Note that you should **not** mutate the editor's internal DOM,
                only inspect it (and even that is usually not necessary).
                */
                domAtPos(pos: any, side?: number): any;
                /**
                Find the DOM node that represents the document node after the
                given position. May return `null` when the position doesn't point
                in front of a node or if the node is inside an opaque node view.
                
                This is intended to be able to call things like
                `getBoundingClientRect` on that DOM node. Do **not** mutate the
                editor DOM directly, or add styling this way, since that will be
                immediately overriden by the editor as it redraws the node.
                */
                nodeDOM(pos: any): any;
                /**
                Find the document position that corresponds to a given DOM
                position. (Whenever possible, it is preferable to inspect the
                document structure directly, rather than poking around in the
                DOM, but sometimesâ€”for example when interpreting an event
                targetâ€”you don't have a choice.)
                
                The `bias` parameter can be used to influence which side of a DOM
                node to use when the position is inside a leaf node.
                */
                posAtDOM(node: any, offset: any, bias?: number): any;
                /**
                Find out whether the selection is at the end of a textblock when
                moving in a given direction. When, for example, given `"left"`,
                it will return true if moving left from the current cursor
                position would leave that position's parent textblock. Will apply
                to the view's current state by default, but it is possible to
                pass a different state.
                */
                endOfTextblock(dir: any, state: any): any;
                /**
                Run the editor's paste logic with the given HTML string. The
                `event`, if given, will be passed to the
                [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
                */
                pasteHTML(html: any, event: any): boolean;
                /**
                Run the editor's paste logic with the given plain-text input.
                */
                pasteText(text: any, event: any): boolean;
                /**
                Removes the editor from the DOM and destroys all [node
                views](https://prosemirror.net/docs/ref/#view.NodeView).
                */
                destroy(): void;
                /**
                This is true when the view has been
                [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
                used anymore).
                */
                readonly isDestroyed: boolean;
                /**
                Used for testing.
                */
                dispatchEvent(event: any): void;
                /**
                @internal
                */
                domSelectionRange(): any;
                /**
                @internal
                */
                domSelection(): any;
            }) => boolean;
            /**
             * Whether the current item is active under the given selection or cursor.
             */
            active?: boolean;
        }): boolean;
        /**
         * Determine whether the given menu item representing a mark is active or not.
         * @param {ProseMirrorMenuItem} item  The menu item representing a {@link MarkType}.
         * @returns {boolean}                 Whether the cursor or selection is in a state represented by the given mark.
         * @protected
         */
        _isMarkActive(item: {
            /**
             * A string identifier for this menu item.
             */
            action: string;
            /**
             * The description of the menu item.
             */
            title: string;
            /**
             * An optional class to apply to the menu item.
             */
            class?: string;
            /**
             * An optional style to apply to the title text.
             */
            style?: string;
            /**
             * The menu item's icon HTML.
             */
            icon?: string;
            /**
             * The mark to apply to the selected text.
             */
            mark?: {
                name: any;
                rank: any;
                schema: any;
                spec: any;
                attrs: any;
                excluded: any;
                instance: {
                    type: any;
                    attrs: any;
                    /**
                    Given a set of marks, create a new set which contains this one as
                    well, in the right position. If this mark is already in the set,
                    the set itself is returned. If any marks that are set to be
                    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                    those are replaced by this one.
                    */
                    addToSet(set: any): any;
                    /**
                    Remove this mark from the given set, returning a new set. If this
                    mark is not in the set, the set itself is returned.
                    */
                    removeFromSet(set: any): any;
                    /**
                    Test whether this mark is in the given set of marks.
                    */
                    isInSet(set: any): boolean;
                    /**
                    Test whether this mark has the same type and attributes as
                    another mark.
                    */
                    eq(other: any): boolean;
                    /**
                    Convert this mark to a JSON-serializeable representation.
                    */
                    toJSON(): {
                        type: any;
                    };
                };
                /**
                Create a mark of this type. `attrs` may be `null` or an object
                containing only some of the mark's attributes. The others, if
                they have defaults, will be added.
                */
                create(attrs?: any): {
                    type: any;
                    attrs: any;
                    /**
                    Given a set of marks, create a new set which contains this one as
                    well, in the right position. If this mark is already in the set,
                    the set itself is returned. If any marks that are set to be
                    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                    those are replaced by this one.
                    */
                    addToSet(set: any): any;
                    /**
                    Remove this mark from the given set, returning a new set. If this
                    mark is not in the set, the set itself is returned.
                    */
                    removeFromSet(set: any): any;
                    /**
                    Test whether this mark is in the given set of marks.
                    */
                    isInSet(set: any): boolean;
                    /**
                    Test whether this mark has the same type and attributes as
                    another mark.
                    */
                    eq(other: any): boolean;
                    /**
                    Convert this mark to a JSON-serializeable representation.
                    */
                    toJSON(): {
                        type: any;
                    };
                };
                /**
                When there is a mark of this type in the given set, a new set
                without it is returned. Otherwise, the input set is returned.
                */
                removeFromSet(set: any): any;
                /**
                Tests whether there is a mark of this type in the given set.
                */
                isInSet(set: any): any;
                /**
                Queries whether a given mark type is
                [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
                */
                excludes(other: any): boolean;
            };
            /**
             * The node to wrap the selected text in.
             */
            node?: {
                attrs: any;
                spec: any;
                map(mapping: any, span: any, offset: any, oldOffset: any): {
                    from: any;
                    to: any;
                    type: any;
                    /**
                    @internal
                    */
                    copy(from: any, to: any): any;
                    /**
                    @internal
                    */
                    eq(other: any, offset?: number): boolean;
                    /**
                    @internal
                    */
                    map(mapping: any, offset: any, oldOffset: any): any;
                    /**
                    The spec provided when creating this decoration. Can be useful
                    if you've stored extra information in that object.
                    */
                    readonly spec: any;
                    /**
                    @internal
                    */
                    readonly inline: boolean;
                };
                valid(node: any, span: any): boolean;
                eq(other: any): boolean;
                destroy(): void;
            };
            /**
             * An object of attributes for the node or mark.
             */
            attrs?: object;
            /**
             * Entries with the same group number will be grouped together in the drop-down.
             *             Lower-numbered groups appear higher in the list.
             */
            group?: number;
            /**
             * A numeric priority which determines whether this item is displayed as the
             *          dropdown title. Lower priority takes precedence.
             */
            priority?: number;
            /**
             * The command to run when the menu item is clicked.
             */
            cmd?: (state: {
                config: any;
                /**
                The schema of the state's document.
                */
                readonly schema: any;
                /**
                The plugins that are active in this state.
                */
                readonly plugins: any;
                /**
                Apply the given transaction to produce a new state.
                */
                apply(tr: any): any;
                /**
                @internal
                */
                filterTransaction(tr: any, ignore?: number): boolean;
                /**
                Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
                returns the precise transactions that were applied (which might
                be influenced by the [transaction
                hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
                plugins) along with the new state.
                */
                applyTransaction(rootTr: any): {
                    state: any;
                    transactions: any[];
                };
                /**
                @internal
                */
                applyInner(tr: any): any;
                /**
                Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
                */
                readonly tr: {
                    curSelectionFor: number;
                    updated: number;
                    meta: any;
                    time: number;
                    curSelection: any;
                    storedMarks: any;
                    /**
                    The transaction's current selection. This defaults to the editor
                    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                    transaction, but can be overwritten with
                    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                    */
                    readonly selection: any;
                    /**
                    Update the transaction's current selection. Will determine the
                    selection that the editor gets when the transaction is applied.
                    */
                    setSelection(selection: any): any;
                    /**
                    Whether the selection was explicitly updated by this transaction.
                    */
                    readonly selectionSet: boolean;
                    /**
                    Set the current stored marks.
                    */
                    setStoredMarks(marks: any): any;
                    /**
                    Make sure the current stored marks or, if that is null, the marks
                    at the selection, match the given set of marks. Does nothing if
                    this is already the case.
                    */
                    ensureMarks(marks: any): any;
                    /**
                    Add a mark to the set of stored marks.
                    */
                    addStoredMark(mark: any): any;
                    /**
                    Remove a mark or mark type from the set of stored marks.
                    */
                    removeStoredMark(mark: any): any;
                    /**
                    Whether the stored marks were explicitly set for this transaction.
                    */
                    readonly storedMarksSet: boolean;
                    /**
                    @internal
                    */
                    addStep(step: any, doc: any): void;
                    /**
                    Update the timestamp for the transaction.
                    */
                    setTime(time: any): any;
                    /**
                    Replace the current selection with the given slice.
                    */
                    replaceSelection(slice: any): any;
                    /**
                    Replace the selection with the given node. When `inheritMarks` is
                    true and the content is inline, it inherits the marks from the
                    place where it is inserted.
                    */
                    replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                    /**
                    Delete the selection.
                    */
                    deleteSelection(): any;
                    /**
                    Replace the given range, or the selection if no range is given,
                    with a text node containing the given string.
                    */
                    insertText(text: any, from: any, to: any): any;
                    /**
                    Store a metadata property in this transaction, keyed either by
                    name or by plugin.
                    */
                    setMeta(key: any, value: any): any;
                    /**
                    Retrieve a metadata property for a given name or plugin.
                    */
                    getMeta(key: any): any;
                    /**
                    Returns true if this transaction doesn't contain any metadata,
                    and can thus safely be extended.
                    */
                    readonly isGeneric: boolean;
                    /**
                    Indicate that the editor should scroll the selection into view
                    when updated to the state produced by this transaction.
                    */
                    scrollIntoView(): any;
                    /**
                    True when this transaction has had `scrollIntoView` called on it.
                    */
                    readonly scrolledIntoView: boolean;
                    doc: any;
                    /**
                    The steps in this transform.
                    */
                    steps: any[];
                    /**
                    The documents before each of the steps.
                    */
                    docs: any[];
                    /**
                    A mapping with the maps for each of the steps in this transform.
                    */
                    mapping: {
                        maps: any[];
                        mirror: any;
                        from: number;
                        to: number;
                        /**
                        Create a mapping that maps only through a part of this one.
                        */
                        slice(from?: number, to?: number): any;
                        /**
                        @internal
                        */
                        copy(): any;
                        /**
                        Add a step map to the end of this mapping. If `mirrors` is
                        given, it should be the index of the step map that is the mirror
                        image of this one.
                        */
                        appendMap(map: any, mirrors: any): void;
                        /**
                        Add all the step maps in a given mapping to this one (preserving
                        mirroring information).
                        */
                        appendMapping(mapping: any): void;
                        /**
                        Finds the offset of the step map that mirrors the map at the
                        given offset, in this mapping (as per the second argument to
                        `appendMap`).
                        */
                        getMirror(n: any): any;
                        /**
                        @internal
                        */
                        setMirror(n: any, m: any): void;
                        /**
                        Append the inverse of the given mapping to this one.
                        */
                        appendMappingInverted(mapping: any): void;
                        /**
                        Create an inverted version of this mapping.
                        */
                        invert(): any;
                        /**
                        Map a position through this mapping.
                        */
                        map(pos: any, assoc?: number): any;
                        /**
                        Map a position through this mapping, returning a mapping
                        result.
                        */
                        mapResult(pos: any, assoc?: number): any;
                        /**
                        @internal
                        */
                        _map(pos: any, assoc: any, simple: any): any;
                    };
                    /**
                    The starting document.
                    */
                    readonly before: any;
                    /**
                    Apply a new step in this transform, saving the result. Throws an
                    error when the step fails.
                    */
                    step(step: any): any;
                    /**
                    Try to apply a step in this transformation, ignoring it if it
                    fails. Returns the step result.
                    */
                    maybeStep(step: any): any;
                    /**
                    True when the document has been changed (when there are any
                    steps).
                    */
                    readonly docChanged: boolean;
                    /**
                    Replace the part of the document between `from` and `to` with the
                    given `slice`.
                    */
                    replace(from: any, to?: any, slice?: {
                        content: any;
                        openStart: any;
                        openEnd: any;
                        /**
                        The size this slice would add when inserted into a document.
                        */
                        readonly size: number;
                        /**
                        @internal
                        */
                        insertAt(pos: any, fragment: any): any;
                        /**
                        @internal
                        */
                        removeBetween(from: any, to: any): any;
                        /**
                        Tests whether this slice is equal to another slice.
                        */
                        eq(other: any): boolean;
                        /**
                        @internal
                        */
                        toString(): string;
                        /**
                        Convert a slice to a JSON-serializable representation.
                        */
                        toJSON(): {
                            content: any;
                        };
                    }): any;
                    /**
                    Replace the given range with the given content, which may be a
                    fragment, node, or array of nodes.
                    */
                    replaceWith(from: any, to: any, content: any): any;
                    /**
                    Delete the content between the given positions.
                    */
                    delete(from: any, to: any): any;
                    /**
                    Insert the given content at the given position.
                    */
                    insert(pos: any, content: any): any;
                    /**
                    Replace a range of the document with a given slice, using
                    `from`, `to`, and the slice's
                    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                    than fixed start and end points. This method may grow the
                    replaced area or close open nodes in the slice in order to get a
                    fit that is more in line with WYSIWYG expectations, by dropping
                    fully covered parent nodes of the replaced region when they are
                    marked [non-defining as
                    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                    open parent node from the slice that _is_ marked as [defining
                    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                    
                    This is the method, for example, to handle paste. The similar
                    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                    primitive tool which will _not_ move the start and end of its given
                    range, and is useful in situations where you need more precise
                    control over what happens.
                    */
                    replaceRange(from: any, to: any, slice: any): any;
                    /**
                    Replace the given range with a node, but use `from` and `to` as
                    hints, rather than precise positions. When from and to are the same
                    and are at the start or end of a parent node in which the given
                    node doesn't fit, this method may _move_ them out towards a parent
                    that does allow the given node to be placed. When the given range
                    completely covers a parent node, this method may completely replace
                    that parent node.
                    */
                    replaceRangeWith(from: any, to: any, node: any): any;
                    /**
                    Delete the given range, expanding it to cover fully covered
                    parent nodes until a valid replace is found.
                    */
                    deleteRange(from: any, to: any): any;
                    /**
                    Split the content in the given range off from its parent, if there
                    is sibling content before or after it, and move it up the tree to
                    the depth specified by `target`. You'll probably want to use
                    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                    sure the lift is valid.
                    */
                    lift(range: any, target: any): any;
                    /**
                    Join the blocks around the given position. If depth is 2, their
                    last and first siblings are also joined, and so on.
                    */
                    join(pos: any, depth?: number): any;
                    /**
                    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                    The wrappers are assumed to be valid in this position, and should
                    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                    */
                    wrap(range: any, wrappers: any): any;
                    /**
                    Set the type of all textblocks (partly) between `from` and `to` to
                    the given node type with the given attributes.
                    */
                    setBlockType(from: any, to: any, type: any, attrs?: any): any;
                    /**
                    Change the type, attributes, and/or marks of the node at `pos`.
                    When `type` isn't given, the existing node type is preserved,
                    */
                    setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                    /**
                    Set a single attribute on a given node to a new value.
                    */
                    setNodeAttribute(pos: any, attr: any, value: any): any;
                    /**
                    Add a mark to the node at position `pos`.
                    */
                    addNodeMark(pos: any, mark: any): any;
                    /**
                    Remove a mark (or a mark of the given type) from the node at
                    position `pos`.
                    */
                    removeNodeMark(pos: any, mark: any): any;
                    /**
                    Split the node at the given position, and optionally, if `depth` is
                    greater than one, any number of nodes above that. By default, the
                    parts split off will inherit the node type of the original node.
                    This can be changed by passing an array of types and attributes to
                    use after the split.
                    */
                    split(pos: any, depth: number, typesAfter: any): any;
                    /**
                    Add the given mark to the inline content between `from` and `to`.
                    */
                    addMark(from: any, to: any, mark: any): any;
                    /**
                    Remove marks from inline nodes between `from` and `to`. When
                    `mark` is a single mark, remove precisely that mark. When it is
                    a mark type, remove all marks of that type. When it is null,
                    remove all marks of any type.
                    */
                    removeMark(from: any, to: any, mark: any): any;
                    /**
                    Removes all marks and nodes from the content of the node at
                    `pos` that don't match the given new parent node type. Accepts
                    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                    third argument.
                    */
                    clearIncompatible(pos: any, parentType: any, match: any): any;
                };
                /**
                Create a new state based on this one, but with an adjusted set
                of active plugins. State fields that exist in both sets of
                plugins are kept unchanged. Those that no longer exist are
                dropped, and those that are new are initialized using their
                [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
                configuration object..
                */
                reconfigure(config: any): any;
                /**
                Serialize this state to JSON. If you want to serialize the state
                of plugins, pass an object mapping property names to use in the
                resulting JSON object to plugin objects. The argument may also be
                a string or number, in which case it is ignored, to support the
                way `JSON.stringify` calls `toString` methods.
                */
                toJSON(pluginFields: any): {
                    doc: any;
                    selection: any;
                };
            }, dispatch: (arg0: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            }) => any, view: {
                _root: any;
                /**
                @internal
                */
                focused: boolean;
                /**
                Kludge used to work around a Chrome bug @internal
                */
                trackWrites: any;
                mounted: boolean;
                /**
                @internal
                */
                markCursor: any;
                /**
                @internal
                */
                cursorWrapper: any;
                /**
                @internal
                */
                lastSelectedViewDesc: any;
                /**
                @internal
                */
                input: {
                    shiftKey: boolean;
                    mouseDown: any;
                    lastKeyCode: any;
                    lastKeyCodeTime: number;
                    lastClick: {
                        time: number;
                        x: number;
                        y: number;
                        type: string;
                    };
                    lastSelectionOrigin: any;
                    lastSelectionTime: number;
                    lastIOSEnter: number;
                    lastIOSEnterFallbackTimeout: number;
                    lastFocus: number;
                    lastTouch: number;
                    lastAndroidDelete: number;
                    composing: boolean;
                    composingTimeout: number;
                    compositionNodes: any[];
                    compositionEndedAt: number;
                    domChangeCount: number;
                    eventHandlers: any;
                    hideSelectionGuard: any;
                };
                prevDirectPlugins: any[];
                pluginViews: any[];
                /**
                Holds `true` when a hack node is needed in Firefox to prevent the
                [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
                @internal
                */
                requiresGeckoHackNode: boolean;
                /**
                When editor content is being dragged, this object contains
                information about the dragged slice and whether it is being
                copied or moved. At any other time, it is null.
                */
                dragging: any;
                _props: any;
                state: any;
                directPlugins: any;
                /**
                Dispatch a transaction. Will call
                [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
                when given, and otherwise defaults to applying the transaction to
                the current state and calling
                [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
                This method is bound to the view instance, so that it can be
                easily passed around.
                */
                dispatch(tr: any): void;
                dom: any;
                editable: boolean;
                nodeViews: any;
                docView: {
                    node: any;
                    outerDeco: any;
                    innerDeco: any;
                    nodeDOM: any;
                    parseRule(): {
                        node: any;
                        attrs: any;
                    };
                    matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                    readonly size: any;
                    readonly border: 0 | 1;
                    updateChildren(view: any, pos: any): void;
                    localCompositionInfo(view: any, pos: any): {
                        node: any;
                        pos: any;
                        text: any;
                    };
                    protectLocalComposition(view: any, { node, pos, text }: {
                        node: any;
                        pos: any;
                        text: any;
                    }): void;
                    children: any;
                    update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                    updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                    dirty: number;
                    updateOuterDeco(outerDeco: any): void;
                    dom: any;
                    selectNode(): void;
                    deselectNode(): void;
                    readonly domAtom: any;
                    parent: any;
                    contentDOM: any;
                    matchesWidget(widget: any): boolean;
                    matchesMark(mark: any): boolean;
                    matchesHack(nodeName: any): boolean;
                    stopEvent(event: any): boolean;
                    destroy(): void;
                    posBeforeChild(child: any): any;
                    readonly posBefore: any;
                    readonly posAtStart: any;
                    readonly posAfter: any;
                    readonly posAtEnd: number;
                    localPosFromDOM(dom: any, offset: any, bias: any): any;
                    nearestDesc(dom: any, onlyNodes?: boolean): any;
                    getDesc(dom: any): any;
                    posFromDOM(dom: any, offset: any, bias: any): any;
                    descAt(pos: any): any;
                    domFromPos(pos: any, side: any): any;
                    parseRange(from: any, to: any, base?: number): any;
                    emptyChildAt(side: any): any;
                    domAfterPos(pos: any): any;
                    setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                    ignoreMutation(mutation: any): boolean;
                    readonly contentLost: boolean;
                    markDirty(from: any, to: any): void;
                    markParentsDirty(): void;
                    readonly ignoreForCoords: boolean;
                };
                domObserver: {
                    view: any;
                    handleDOMChange: any;
                    queue: any[];
                    flushingSoon: number;
                    observer: MutationObserver;
                    currentSelection: {
                        anchorNode: any;
                        anchorOffset: number;
                        focusNode: any;
                        focusOffset: number;
                        set(sel: any): void;
                        clear(): void;
                        eq(sel: any): boolean;
                    };
                    onCharData: (e: any) => void;
                    suppressingSelectionUpdates: boolean;
                    onSelectionChange(): void;
                    flushSoon(): void;
                    forceFlush(): void;
                    start(): void;
                    stop(): void;
                    connectSelection(): void;
                    disconnectSelection(): void;
                    suppressSelectionUpdates(): void;
                    setCurSelection(): void;
                    ignoreSelectionChange(sel: any): boolean;
                    flush(): void;
                    registerMutation(mut: any, added: any): {
                        from: any;
                        to: any;
                        typeOver?: undefined;
                    } | {
                        from: any;
                        to: any;
                        typeOver: boolean;
                    };
                };
                /**
                Holds `true` when a
                [composition](https://w3c.github.io/uievents/#events-compositionevents)
                is active.
                */
                readonly composing: boolean;
                /**
                The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
                */
                readonly props: any;
                /**
                Update the view's props. Will immediately cause an update to
                the DOM.
                */
                update(props: any): void;
                /**
                Update the view by updating existing props object with the object
                given as argument. Equivalent to `view.update(Object.assign({},
                view.props, props))`.
                */
                setProps(props: any): void;
                /**
                Update the editor's `state` prop, without touching any of the
                other props.
                */
                updateState(state: any): void;
                updateStateInner(state: any, prevProps: any): void;
                /**
                @internal
                */
                scrollToSelection(): void;
                destroyPluginViews(): void;
                updatePluginViews(prevState: any): void;
                someProp(propName: any, f: any): any;
                /**
                Query whether the view has focus.
                */
                hasFocus(): boolean;
                /**
                Focus the editor.
                */
                focus(): void;
                /**
                Get the document root in which the editor exists. This will
                usually be the top-level `document`, but might be a [shadow
                DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
                root if the editor is inside one.
                */
                readonly root: any;
                /**
                Given a pair of viewport coordinates, return the document
                position that corresponds to them. May return null if the given
                coordinates aren't inside of the editor. When an object is
                returned, its `pos` property is the position nearest to the
                coordinates, and its `inside` property holds the position of the
                inner node that the position falls inside of, or -1 if it is at
                the top level, not in any node.
                */
                posAtCoords(coords: any): {
                    pos: any;
                    inside: number;
                };
                /**
                Returns the viewport rectangle at a given document position.
                `left` and `right` will be the same number, as this returns a
                flat cursor-ish rectangle. If the position is between two things
                that aren't directly adjacent, `side` determines which element
                is used. When < 0, the element before the position is used,
                otherwise the element after.
                */
                coordsAtPos(pos: any, side?: number): any;
                /**
                Find the DOM position that corresponds to the given document
                position. When `side` is negative, find the position as close as
                possible to the content before the position. When positive,
                prefer positions close to the content after the position. When
                zero, prefer as shallow a position as possible.
                
                Note that you should **not** mutate the editor's internal DOM,
                only inspect it (and even that is usually not necessary).
                */
                domAtPos(pos: any, side?: number): any;
                /**
                Find the DOM node that represents the document node after the
                given position. May return `null` when the position doesn't point
                in front of a node or if the node is inside an opaque node view.
                
                This is intended to be able to call things like
                `getBoundingClientRect` on that DOM node. Do **not** mutate the
                editor DOM directly, or add styling this way, since that will be
                immediately overriden by the editor as it redraws the node.
                */
                nodeDOM(pos: any): any;
                /**
                Find the document position that corresponds to a given DOM
                position. (Whenever possible, it is preferable to inspect the
                document structure directly, rather than poking around in the
                DOM, but sometimesâ€”for example when interpreting an event
                targetâ€”you don't have a choice.)
                
                The `bias` parameter can be used to influence which side of a DOM
                node to use when the position is inside a leaf node.
                */
                posAtDOM(node: any, offset: any, bias?: number): any;
                /**
                Find out whether the selection is at the end of a textblock when
                moving in a given direction. When, for example, given `"left"`,
                it will return true if moving left from the current cursor
                position would leave that position's parent textblock. Will apply
                to the view's current state by default, but it is possible to
                pass a different state.
                */
                endOfTextblock(dir: any, state: any): any;
                /**
                Run the editor's paste logic with the given HTML string. The
                `event`, if given, will be passed to the
                [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
                */
                pasteHTML(html: any, event: any): boolean;
                /**
                Run the editor's paste logic with the given plain-text input.
                */
                pasteText(text: any, event: any): boolean;
                /**
                Removes the editor from the DOM and destroys all [node
                views](https://prosemirror.net/docs/ref/#view.NodeView).
                */
                destroy(): void;
                /**
                This is true when the view has been
                [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
                used anymore).
                */
                readonly isDestroyed: boolean;
                /**
                Used for testing.
                */
                dispatchEvent(event: any): void;
                /**
                @internal
                */
                domSelectionRange(): any;
                /**
                @internal
                */
                domSelection(): any;
            }) => boolean;
            /**
             * Whether the current item is active under the given selection or cursor.
             */
            active?: boolean;
        }): boolean;
        /**
         * Determine whether the given menu item representing a node is active or not.
         * @param {ProseMirrorMenuItem} item  The menu item representing a {@link NodeType}.
         * @returns {boolean}                 Whether the cursor or selection is currently within a block of this menu item's
         *                                    node type.
         * @protected
         */
        _isNodeActive(item: {
            /**
             * A string identifier for this menu item.
             */
            action: string;
            /**
             * The description of the menu item.
             */
            title: string;
            /**
             * An optional class to apply to the menu item.
             */
            class?: string;
            /**
             * An optional style to apply to the title text.
             */
            style?: string;
            /**
             * The menu item's icon HTML.
             */
            icon?: string;
            /**
             * The mark to apply to the selected text.
             */
            mark?: {
                name: any;
                rank: any;
                schema: any;
                spec: any;
                attrs: any;
                excluded: any;
                instance: {
                    type: any;
                    attrs: any;
                    /**
                    Given a set of marks, create a new set which contains this one as
                    well, in the right position. If this mark is already in the set,
                    the set itself is returned. If any marks that are set to be
                    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                    those are replaced by this one.
                    */
                    addToSet(set: any): any;
                    /**
                    Remove this mark from the given set, returning a new set. If this
                    mark is not in the set, the set itself is returned.
                    */
                    removeFromSet(set: any): any;
                    /**
                    Test whether this mark is in the given set of marks.
                    */
                    isInSet(set: any): boolean;
                    /**
                    Test whether this mark has the same type and attributes as
                    another mark.
                    */
                    eq(other: any): boolean;
                    /**
                    Convert this mark to a JSON-serializeable representation.
                    */
                    toJSON(): {
                        type: any;
                    };
                };
                /**
                Create a mark of this type. `attrs` may be `null` or an object
                containing only some of the mark's attributes. The others, if
                they have defaults, will be added.
                */
                create(attrs?: any): {
                    type: any;
                    attrs: any;
                    /**
                    Given a set of marks, create a new set which contains this one as
                    well, in the right position. If this mark is already in the set,
                    the set itself is returned. If any marks that are set to be
                    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                    those are replaced by this one.
                    */
                    addToSet(set: any): any;
                    /**
                    Remove this mark from the given set, returning a new set. If this
                    mark is not in the set, the set itself is returned.
                    */
                    removeFromSet(set: any): any;
                    /**
                    Test whether this mark is in the given set of marks.
                    */
                    isInSet(set: any): boolean;
                    /**
                    Test whether this mark has the same type and attributes as
                    another mark.
                    */
                    eq(other: any): boolean;
                    /**
                    Convert this mark to a JSON-serializeable representation.
                    */
                    toJSON(): {
                        type: any;
                    };
                };
                /**
                When there is a mark of this type in the given set, a new set
                without it is returned. Otherwise, the input set is returned.
                */
                removeFromSet(set: any): any;
                /**
                Tests whether there is a mark of this type in the given set.
                */
                isInSet(set: any): any;
                /**
                Queries whether a given mark type is
                [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
                */
                excludes(other: any): boolean;
            };
            /**
             * The node to wrap the selected text in.
             */
            node?: {
                attrs: any;
                spec: any;
                map(mapping: any, span: any, offset: any, oldOffset: any): {
                    from: any;
                    to: any;
                    type: any;
                    /**
                    @internal
                    */
                    copy(from: any, to: any): any;
                    /**
                    @internal
                    */
                    eq(other: any, offset?: number): boolean;
                    /**
                    @internal
                    */
                    map(mapping: any, offset: any, oldOffset: any): any;
                    /**
                    The spec provided when creating this decoration. Can be useful
                    if you've stored extra information in that object.
                    */
                    readonly spec: any;
                    /**
                    @internal
                    */
                    readonly inline: boolean;
                };
                valid(node: any, span: any): boolean;
                eq(other: any): boolean;
                destroy(): void;
            };
            /**
             * An object of attributes for the node or mark.
             */
            attrs?: object;
            /**
             * Entries with the same group number will be grouped together in the drop-down.
             *             Lower-numbered groups appear higher in the list.
             */
            group?: number;
            /**
             * A numeric priority which determines whether this item is displayed as the
             *          dropdown title. Lower priority takes precedence.
             */
            priority?: number;
            /**
             * The command to run when the menu item is clicked.
             */
            cmd?: (state: {
                config: any;
                /**
                The schema of the state's document.
                */
                readonly schema: any;
                /**
                The plugins that are active in this state.
                */
                readonly plugins: any;
                /**
                Apply the given transaction to produce a new state.
                */
                apply(tr: any): any;
                /**
                @internal
                */
                filterTransaction(tr: any, ignore?: number): boolean;
                /**
                Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
                returns the precise transactions that were applied (which might
                be influenced by the [transaction
                hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
                plugins) along with the new state.
                */
                applyTransaction(rootTr: any): {
                    state: any;
                    transactions: any[];
                };
                /**
                @internal
                */
                applyInner(tr: any): any;
                /**
                Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
                */
                readonly tr: {
                    curSelectionFor: number;
                    updated: number;
                    meta: any;
                    time: number;
                    curSelection: any;
                    storedMarks: any;
                    /**
                    The transaction's current selection. This defaults to the editor
                    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                    transaction, but can be overwritten with
                    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                    */
                    readonly selection: any;
                    /**
                    Update the transaction's current selection. Will determine the
                    selection that the editor gets when the transaction is applied.
                    */
                    setSelection(selection: any): any;
                    /**
                    Whether the selection was explicitly updated by this transaction.
                    */
                    readonly selectionSet: boolean;
                    /**
                    Set the current stored marks.
                    */
                    setStoredMarks(marks: any): any;
                    /**
                    Make sure the current stored marks or, if that is null, the marks
                    at the selection, match the given set of marks. Does nothing if
                    this is already the case.
                    */
                    ensureMarks(marks: any): any;
                    /**
                    Add a mark to the set of stored marks.
                    */
                    addStoredMark(mark: any): any;
                    /**
                    Remove a mark or mark type from the set of stored marks.
                    */
                    removeStoredMark(mark: any): any;
                    /**
                    Whether the stored marks were explicitly set for this transaction.
                    */
                    readonly storedMarksSet: boolean;
                    /**
                    @internal
                    */
                    addStep(step: any, doc: any): void;
                    /**
                    Update the timestamp for the transaction.
                    */
                    setTime(time: any): any;
                    /**
                    Replace the current selection with the given slice.
                    */
                    replaceSelection(slice: any): any;
                    /**
                    Replace the selection with the given node. When `inheritMarks` is
                    true and the content is inline, it inherits the marks from the
                    place where it is inserted.
                    */
                    replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                    /**
                    Delete the selection.
                    */
                    deleteSelection(): any;
                    /**
                    Replace the given range, or the selection if no range is given,
                    with a text node containing the given string.
                    */
                    insertText(text: any, from: any, to: any): any;
                    /**
                    Store a metadata property in this transaction, keyed either by
                    name or by plugin.
                    */
                    setMeta(key: any, value: any): any;
                    /**
                    Retrieve a metadata property for a given name or plugin.
                    */
                    getMeta(key: any): any;
                    /**
                    Returns true if this transaction doesn't contain any metadata,
                    and can thus safely be extended.
                    */
                    readonly isGeneric: boolean;
                    /**
                    Indicate that the editor should scroll the selection into view
                    when updated to the state produced by this transaction.
                    */
                    scrollIntoView(): any;
                    /**
                    True when this transaction has had `scrollIntoView` called on it.
                    */
                    readonly scrolledIntoView: boolean;
                    doc: any;
                    /**
                    The steps in this transform.
                    */
                    steps: any[];
                    /**
                    The documents before each of the steps.
                    */
                    docs: any[];
                    /**
                    A mapping with the maps for each of the steps in this transform.
                    */
                    mapping: {
                        maps: any[];
                        mirror: any;
                        from: number;
                        to: number;
                        /**
                        Create a mapping that maps only through a part of this one.
                        */
                        slice(from?: number, to?: number): any;
                        /**
                        @internal
                        */
                        copy(): any;
                        /**
                        Add a step map to the end of this mapping. If `mirrors` is
                        given, it should be the index of the step map that is the mirror
                        image of this one.
                        */
                        appendMap(map: any, mirrors: any): void;
                        /**
                        Add all the step maps in a given mapping to this one (preserving
                        mirroring information).
                        */
                        appendMapping(mapping: any): void;
                        /**
                        Finds the offset of the step map that mirrors the map at the
                        given offset, in this mapping (as per the second argument to
                        `appendMap`).
                        */
                        getMirror(n: any): any;
                        /**
                        @internal
                        */
                        setMirror(n: any, m: any): void;
                        /**
                        Append the inverse of the given mapping to this one.
                        */
                        appendMappingInverted(mapping: any): void;
                        /**
                        Create an inverted version of this mapping.
                        */
                        invert(): any;
                        /**
                        Map a position through this mapping.
                        */
                        map(pos: any, assoc?: number): any;
                        /**
                        Map a position through this mapping, returning a mapping
                        result.
                        */
                        mapResult(pos: any, assoc?: number): any;
                        /**
                        @internal
                        */
                        _map(pos: any, assoc: any, simple: any): any;
                    };
                    /**
                    The starting document.
                    */
                    readonly before: any;
                    /**
                    Apply a new step in this transform, saving the result. Throws an
                    error when the step fails.
                    */
                    step(step: any): any;
                    /**
                    Try to apply a step in this transformation, ignoring it if it
                    fails. Returns the step result.
                    */
                    maybeStep(step: any): any;
                    /**
                    True when the document has been changed (when there are any
                    steps).
                    */
                    readonly docChanged: boolean;
                    /**
                    Replace the part of the document between `from` and `to` with the
                    given `slice`.
                    */
                    replace(from: any, to?: any, slice?: {
                        content: any;
                        openStart: any;
                        openEnd: any;
                        /**
                        The size this slice would add when inserted into a document.
                        */
                        readonly size: number;
                        /**
                        @internal
                        */
                        insertAt(pos: any, fragment: any): any;
                        /**
                        @internal
                        */
                        removeBetween(from: any, to: any): any;
                        /**
                        Tests whether this slice is equal to another slice.
                        */
                        eq(other: any): boolean;
                        /**
                        @internal
                        */
                        toString(): string;
                        /**
                        Convert a slice to a JSON-serializable representation.
                        */
                        toJSON(): {
                            content: any;
                        };
                    }): any;
                    /**
                    Replace the given range with the given content, which may be a
                    fragment, node, or array of nodes.
                    */
                    replaceWith(from: any, to: any, content: any): any;
                    /**
                    Delete the content between the given positions.
                    */
                    delete(from: any, to: any): any;
                    /**
                    Insert the given content at the given position.
                    */
                    insert(pos: any, content: any): any;
                    /**
                    Replace a range of the document with a given slice, using
                    `from`, `to`, and the slice's
                    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                    than fixed start and end points. This method may grow the
                    replaced area or close open nodes in the slice in order to get a
                    fit that is more in line with WYSIWYG expectations, by dropping
                    fully covered parent nodes of the replaced region when they are
                    marked [non-defining as
                    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                    open parent node from the slice that _is_ marked as [defining
                    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                    
                    This is the method, for example, to handle paste. The similar
                    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                    primitive tool which will _not_ move the start and end of its given
                    range, and is useful in situations where you need more precise
                    control over what happens.
                    */
                    replaceRange(from: any, to: any, slice: any): any;
                    /**
                    Replace the given range with a node, but use `from` and `to` as
                    hints, rather than precise positions. When from and to are the same
                    and are at the start or end of a parent node in which the given
                    node doesn't fit, this method may _move_ them out towards a parent
                    that does allow the given node to be placed. When the given range
                    completely covers a parent node, this method may completely replace
                    that parent node.
                    */
                    replaceRangeWith(from: any, to: any, node: any): any;
                    /**
                    Delete the given range, expanding it to cover fully covered
                    parent nodes until a valid replace is found.
                    */
                    deleteRange(from: any, to: any): any;
                    /**
                    Split the content in the given range off from its parent, if there
                    is sibling content before or after it, and move it up the tree to
                    the depth specified by `target`. You'll probably want to use
                    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                    sure the lift is valid.
                    */
                    lift(range: any, target: any): any;
                    /**
                    Join the blocks around the given position. If depth is 2, their
                    last and first siblings are also joined, and so on.
                    */
                    join(pos: any, depth?: number): any;
                    /**
                    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                    The wrappers are assumed to be valid in this position, and should
                    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                    */
                    wrap(range: any, wrappers: any): any;
                    /**
                    Set the type of all textblocks (partly) between `from` and `to` to
                    the given node type with the given attributes.
                    */
                    setBlockType(from: any, to: any, type: any, attrs?: any): any;
                    /**
                    Change the type, attributes, and/or marks of the node at `pos`.
                    When `type` isn't given, the existing node type is preserved,
                    */
                    setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                    /**
                    Set a single attribute on a given node to a new value.
                    */
                    setNodeAttribute(pos: any, attr: any, value: any): any;
                    /**
                    Add a mark to the node at position `pos`.
                    */
                    addNodeMark(pos: any, mark: any): any;
                    /**
                    Remove a mark (or a mark of the given type) from the node at
                    position `pos`.
                    */
                    removeNodeMark(pos: any, mark: any): any;
                    /**
                    Split the node at the given position, and optionally, if `depth` is
                    greater than one, any number of nodes above that. By default, the
                    parts split off will inherit the node type of the original node.
                    This can be changed by passing an array of types and attributes to
                    use after the split.
                    */
                    split(pos: any, depth: number, typesAfter: any): any;
                    /**
                    Add the given mark to the inline content between `from` and `to`.
                    */
                    addMark(from: any, to: any, mark: any): any;
                    /**
                    Remove marks from inline nodes between `from` and `to`. When
                    `mark` is a single mark, remove precisely that mark. When it is
                    a mark type, remove all marks of that type. When it is null,
                    remove all marks of any type.
                    */
                    removeMark(from: any, to: any, mark: any): any;
                    /**
                    Removes all marks and nodes from the content of the node at
                    `pos` that don't match the given new parent node type. Accepts
                    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                    third argument.
                    */
                    clearIncompatible(pos: any, parentType: any, match: any): any;
                };
                /**
                Create a new state based on this one, but with an adjusted set
                of active plugins. State fields that exist in both sets of
                plugins are kept unchanged. Those that no longer exist are
                dropped, and those that are new are initialized using their
                [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
                configuration object..
                */
                reconfigure(config: any): any;
                /**
                Serialize this state to JSON. If you want to serialize the state
                of plugins, pass an object mapping property names to use in the
                resulting JSON object to plugin objects. The argument may also be
                a string or number, in which case it is ignored, to support the
                way `JSON.stringify` calls `toString` methods.
                */
                toJSON(pluginFields: any): {
                    doc: any;
                    selection: any;
                };
            }, dispatch: (arg0: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            }) => any, view: {
                _root: any;
                /**
                @internal
                */
                focused: boolean;
                /**
                Kludge used to work around a Chrome bug @internal
                */
                trackWrites: any;
                mounted: boolean;
                /**
                @internal
                */
                markCursor: any;
                /**
                @internal
                */
                cursorWrapper: any;
                /**
                @internal
                */
                lastSelectedViewDesc: any;
                /**
                @internal
                */
                input: {
                    shiftKey: boolean;
                    mouseDown: any;
                    lastKeyCode: any;
                    lastKeyCodeTime: number;
                    lastClick: {
                        time: number;
                        x: number;
                        y: number;
                        type: string;
                    };
                    lastSelectionOrigin: any;
                    lastSelectionTime: number;
                    lastIOSEnter: number;
                    lastIOSEnterFallbackTimeout: number;
                    lastFocus: number;
                    lastTouch: number;
                    lastAndroidDelete: number;
                    composing: boolean;
                    composingTimeout: number;
                    compositionNodes: any[];
                    compositionEndedAt: number;
                    domChangeCount: number;
                    eventHandlers: any;
                    hideSelectionGuard: any;
                };
                prevDirectPlugins: any[];
                pluginViews: any[];
                /**
                Holds `true` when a hack node is needed in Firefox to prevent the
                [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
                @internal
                */
                requiresGeckoHackNode: boolean;
                /**
                When editor content is being dragged, this object contains
                information about the dragged slice and whether it is being
                copied or moved. At any other time, it is null.
                */
                dragging: any;
                _props: any;
                state: any;
                directPlugins: any;
                /**
                Dispatch a transaction. Will call
                [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
                when given, and otherwise defaults to applying the transaction to
                the current state and calling
                [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
                This method is bound to the view instance, so that it can be
                easily passed around.
                */
                dispatch(tr: any): void;
                dom: any;
                editable: boolean;
                nodeViews: any;
                docView: {
                    node: any;
                    outerDeco: any;
                    innerDeco: any;
                    nodeDOM: any;
                    parseRule(): {
                        node: any;
                        attrs: any;
                    };
                    matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                    readonly size: any;
                    readonly border: 0 | 1;
                    updateChildren(view: any, pos: any): void;
                    localCompositionInfo(view: any, pos: any): {
                        node: any;
                        pos: any;
                        text: any;
                    };
                    protectLocalComposition(view: any, { node, pos, text }: {
                        node: any;
                        pos: any;
                        text: any;
                    }): void;
                    children: any;
                    update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                    updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                    dirty: number;
                    updateOuterDeco(outerDeco: any): void;
                    dom: any;
                    selectNode(): void;
                    deselectNode(): void;
                    readonly domAtom: any;
                    parent: any;
                    contentDOM: any;
                    matchesWidget(widget: any): boolean;
                    matchesMark(mark: any): boolean;
                    matchesHack(nodeName: any): boolean;
                    stopEvent(event: any): boolean;
                    destroy(): void;
                    posBeforeChild(child: any): any;
                    readonly posBefore: any;
                    readonly posAtStart: any;
                    readonly posAfter: any;
                    readonly posAtEnd: number;
                    localPosFromDOM(dom: any, offset: any, bias: any): any;
                    nearestDesc(dom: any, onlyNodes?: boolean): any;
                    getDesc(dom: any): any;
                    posFromDOM(dom: any, offset: any, bias: any): any;
                    descAt(pos: any): any;
                    domFromPos(pos: any, side: any): any;
                    parseRange(from: any, to: any, base?: number): any;
                    emptyChildAt(side: any): any;
                    domAfterPos(pos: any): any;
                    setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                    ignoreMutation(mutation: any): boolean;
                    readonly contentLost: boolean;
                    markDirty(from: any, to: any): void;
                    markParentsDirty(): void;
                    readonly ignoreForCoords: boolean;
                };
                domObserver: {
                    view: any;
                    handleDOMChange: any;
                    queue: any[];
                    flushingSoon: number;
                    observer: MutationObserver;
                    currentSelection: {
                        anchorNode: any;
                        anchorOffset: number;
                        focusNode: any;
                        focusOffset: number;
                        set(sel: any): void;
                        clear(): void;
                        eq(sel: any): boolean;
                    };
                    onCharData: (e: any) => void;
                    suppressingSelectionUpdates: boolean;
                    onSelectionChange(): void;
                    flushSoon(): void;
                    forceFlush(): void;
                    start(): void;
                    stop(): void;
                    connectSelection(): void;
                    disconnectSelection(): void;
                    suppressSelectionUpdates(): void;
                    setCurSelection(): void;
                    ignoreSelectionChange(sel: any): boolean;
                    flush(): void;
                    registerMutation(mut: any, added: any): {
                        from: any;
                        to: any;
                        typeOver?: undefined;
                    } | {
                        from: any;
                        to: any;
                        typeOver: boolean;
                    };
                };
                /**
                Holds `true` when a
                [composition](https://w3c.github.io/uievents/#events-compositionevents)
                is active.
                */
                readonly composing: boolean;
                /**
                The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
                */
                readonly props: any;
                /**
                Update the view's props. Will immediately cause an update to
                the DOM.
                */
                update(props: any): void;
                /**
                Update the view by updating existing props object with the object
                given as argument. Equivalent to `view.update(Object.assign({},
                view.props, props))`.
                */
                setProps(props: any): void;
                /**
                Update the editor's `state` prop, without touching any of the
                other props.
                */
                updateState(state: any): void;
                updateStateInner(state: any, prevProps: any): void;
                /**
                @internal
                */
                scrollToSelection(): void;
                destroyPluginViews(): void;
                updatePluginViews(prevState: any): void;
                someProp(propName: any, f: any): any;
                /**
                Query whether the view has focus.
                */
                hasFocus(): boolean;
                /**
                Focus the editor.
                */
                focus(): void;
                /**
                Get the document root in which the editor exists. This will
                usually be the top-level `document`, but might be a [shadow
                DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
                root if the editor is inside one.
                */
                readonly root: any;
                /**
                Given a pair of viewport coordinates, return the document
                position that corresponds to them. May return null if the given
                coordinates aren't inside of the editor. When an object is
                returned, its `pos` property is the position nearest to the
                coordinates, and its `inside` property holds the position of the
                inner node that the position falls inside of, or -1 if it is at
                the top level, not in any node.
                */
                posAtCoords(coords: any): {
                    pos: any;
                    inside: number;
                };
                /**
                Returns the viewport rectangle at a given document position.
                `left` and `right` will be the same number, as this returns a
                flat cursor-ish rectangle. If the position is between two things
                that aren't directly adjacent, `side` determines which element
                is used. When < 0, the element before the position is used,
                otherwise the element after.
                */
                coordsAtPos(pos: any, side?: number): any;
                /**
                Find the DOM position that corresponds to the given document
                position. When `side` is negative, find the position as close as
                possible to the content before the position. When positive,
                prefer positions close to the content after the position. When
                zero, prefer as shallow a position as possible.
                
                Note that you should **not** mutate the editor's internal DOM,
                only inspect it (and even that is usually not necessary).
                */
                domAtPos(pos: any, side?: number): any;
                /**
                Find the DOM node that represents the document node after the
                given position. May return `null` when the position doesn't point
                in front of a node or if the node is inside an opaque node view.
                
                This is intended to be able to call things like
                `getBoundingClientRect` on that DOM node. Do **not** mutate the
                editor DOM directly, or add styling this way, since that will be
                immediately overriden by the editor as it redraws the node.
                */
                nodeDOM(pos: any): any;
                /**
                Find the document position that corresponds to a given DOM
                position. (Whenever possible, it is preferable to inspect the
                document structure directly, rather than poking around in the
                DOM, but sometimesâ€”for example when interpreting an event
                targetâ€”you don't have a choice.)
                
                The `bias` parameter can be used to influence which side of a DOM
                node to use when the position is inside a leaf node.
                */
                posAtDOM(node: any, offset: any, bias?: number): any;
                /**
                Find out whether the selection is at the end of a textblock when
                moving in a given direction. When, for example, given `"left"`,
                it will return true if moving left from the current cursor
                position would leave that position's parent textblock. Will apply
                to the view's current state by default, but it is possible to
                pass a different state.
                */
                endOfTextblock(dir: any, state: any): any;
                /**
                Run the editor's paste logic with the given HTML string. The
                `event`, if given, will be passed to the
                [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
                */
                pasteHTML(html: any, event: any): boolean;
                /**
                Run the editor's paste logic with the given plain-text input.
                */
                pasteText(text: any, event: any): boolean;
                /**
                Removes the editor from the DOM and destroys all [node
                views](https://prosemirror.net/docs/ref/#view.NodeView).
                */
                destroy(): void;
                /**
                This is true when the view has been
                [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
                used anymore).
                */
                readonly isDestroyed: boolean;
                /**
                Used for testing.
                */
                dispatchEvent(event: any): void;
                /**
                @internal
                */
                domSelectionRange(): any;
                /**
                @internal
                */
                domSelection(): any;
            }) => boolean;
            /**
             * Whether the current item is active under the given selection or cursor.
             */
            active?: boolean;
        }): boolean;
        /**
         * Handle a button press.
         * @param {MouseEvent} event  The click event.
         * @protected
         */
        _onAction(event: MouseEvent): void;
        /**
         * Wrap the editor view element and inject our template ready to be rendered into.
         * @protected
         */
        _wrapEditor(): void;
        /**
         * Handle requests to save the editor contents
         * @protected
         */
        _handleSave(): any;
        /**
         * Handle a request to edit the source HTML directly.
         * @protected
         */
        "__#214@#toggleSource"(): void;
        /**
         * Conclude editing the source HTML textarea. Clear its contents and return the HTML which was contained.
         * @returns {string}      The HTML text contained within the textarea before it was cleared
         */
        "__#214@#clearSourceTextarea"(): string;
        /**
         * Create and activate the source code editing textarea
         */
        "__#214@#activateSourceTextarea"(): void;
        /**
         * Commit changes from the source textarea to the view.
         */
        "__#214@#commitSourceTextarea"(): void;
        /**
         * Display the insert image prompt.
         * @protected
         */
        _insertImagePrompt(): Promise<void>;
        /**
         * Display the insert link prompt.
         * @protected
         */
        _insertLinkPrompt(): Promise<void>;
        /**
         * Display the insert table prompt.
         * @protected
         */
        _insertTablePrompt(): Promise<void>;
        /**
         * Create a dialog for a menu button.
         * @param {string} action                      The unique menu button action.
         * @param {string} template                    The dialog's template.
         * @param {object} [options]                   Additional options to configure the dialog's behaviour.
         * @param {object} [options.data={}]           Data to pass to the template.
         * @returns {HTMLDialogElement}
         * @protected
         */
        _showDialog(action: string, template: string, { data }?: {
            data?: object;
        }): HTMLDialogElement;
        /**
         * Clear any marks from the current selection.
         * @protected
         */
        _clearFormatting(): void;
        /**
         * Toggle link recommendations
         * @protected
         */
        _toggleMatches(): Promise<void>;
        /**
         * Inserts a horizontal rule at the cursor.
         */
        "__#214@#insertHorizontalRule"(): void;
        /**
         * Toggle a particular alignment for the given selection.
         * @param {string} alignment  The text alignment to toggle.
         */
        "__#214@#toggleAlignment"(alignment: string): void;
        /**
         * @callback MenuToggleBlockWrapCommand
         * @param {NodeType} node   The node to wrap the selection in.
         * @param {object} [attrs]  Attributes for the node.
         * @returns ProseMirrorCommand
         */
        /**
         * Toggle the given selection by wrapping it in a given block or lifting it out of one.
         * @param {NodeType} node                    The type of node being interacted with.
         * @param {MenuToggleBlockWrapCommand} wrap  The wrap command specific to the given node.
         * @param {object} [options]                 Additional options to configure behaviour.
         * @param {object} [options.attrs]           Attributes for the node.
         * @protected
         */
        _toggleBlock(node: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        }, wrap: (node: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        }, attrs?: object) => any, { attrs }?: {
            attrs?: object;
        }): void;
        /**
         * Toggle the given selection by wrapping it in a given text block, or reverting to a paragraph block.
         * @param {NodeType} node           The type of node being interacted with.
         * @param {object} [options]        Additional options to configure behaviour.
         * @param {object} [options.attrs]  Attributes for the node.
         * @protected
         */
        _toggleTextBlock(node: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        }, { attrs }?: {
            attrs?: object;
        }): void;
    };
    /**
     * Attach event listeners.
     * @param {HTMLMenuElement} html  The root menu element.
     */
    activateListeners(html: HTMLMenuElement): void;
    /**
     * Called whenever the view's state is updated.
     * @param {EditorView} view       The current editor state.
     * @param {EditorView} prevState  The previous editor state.
     */
    update(view: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }, prevState: {
        _root: any;
        /**
        @internal
        */
        focused: boolean;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        trackWrites: any;
        mounted: boolean;
        /**
        @internal
        */
        markCursor: any;
        /**
        @internal
        */
        cursorWrapper: any;
        /**
        @internal
        */
        lastSelectedViewDesc: any;
        /**
        @internal
        */
        input: {
            shiftKey: boolean;
            mouseDown: any;
            lastKeyCode: any;
            lastKeyCodeTime: number;
            lastClick: {
                time: number;
                x: number;
                y: number;
                type: string;
            };
            lastSelectionOrigin: any;
            lastSelectionTime: number;
            lastIOSEnter: number;
            lastIOSEnterFallbackTimeout: number;
            lastFocus: number;
            lastTouch: number;
            lastAndroidDelete: number;
            composing: boolean;
            composingTimeout: number;
            compositionNodes: any[];
            compositionEndedAt: number;
            domChangeCount: number;
            eventHandlers: any;
            hideSelectionGuard: any;
        };
        prevDirectPlugins: any[];
        pluginViews: any[];
        /**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
        requiresGeckoHackNode: boolean;
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        dragging: any;
        _props: any;
        state: any;
        directPlugins: any;
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr: any): void;
        dom: any;
        editable: boolean;
        nodeViews: any;
        docView: {
            node: any;
            outerDeco: any;
            innerDeco: any;
            nodeDOM: any;
            parseRule(): {
                node: any;
                attrs: any;
            };
            matchesNode(node: any, outerDeco: any, innerDeco: any): any;
            readonly size: any;
            readonly border: 0 | 1;
            updateChildren(view: any, pos: any): void;
            localCompositionInfo(view: any, pos: any): {
                node: any;
                pos: any;
                text: any;
            };
            protectLocalComposition(view: any, { node, pos, text }: {
                node: any;
                pos: any;
                text: any;
            }): void;
            children: any;
            update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
            updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
            dirty: number;
            updateOuterDeco(outerDeco: any): void;
            dom: any;
            selectNode(): void;
            deselectNode(): void;
            readonly domAtom: any;
            parent: any;
            contentDOM: any;
            matchesWidget(widget: any): boolean;
            matchesMark(mark: any): boolean;
            matchesHack(nodeName: any): boolean;
            stopEvent(event: any): boolean;
            destroy(): void;
            posBeforeChild(child: any): any;
            readonly posBefore: any;
            readonly posAtStart: any;
            readonly posAfter: any;
            readonly posAtEnd: number;
            localPosFromDOM(dom: any, offset: any, bias: any): any;
            nearestDesc(dom: any, onlyNodes?: boolean): any;
            getDesc(dom: any): any;
            posFromDOM(dom: any, offset: any, bias: any): any;
            descAt(pos: any): any;
            domFromPos(pos: any, side: any): any;
            parseRange(from: any, to: any, base?: number): any;
            emptyChildAt(side: any): any;
            domAfterPos(pos: any): any;
            setSelection(anchor: any, head: any, root: any, force?: boolean): any;
            ignoreMutation(mutation: any): boolean;
            readonly contentLost: boolean;
            markDirty(from: any, to: any): void;
            markParentsDirty(): void;
            readonly ignoreForCoords: boolean;
        };
        domObserver: {
            view: any;
            handleDOMChange: any;
            queue: any[];
            flushingSoon: number;
            observer: MutationObserver;
            currentSelection: {
                anchorNode: any;
                anchorOffset: number;
                focusNode: any;
                focusOffset: number;
                set(sel: any): void;
                clear(): void;
                eq(sel: any): boolean;
            };
            onCharData: (e: any) => void;
            suppressingSelectionUpdates: boolean;
            onSelectionChange(): void;
            flushSoon(): void;
            forceFlush(): void;
            start(): void;
            stop(): void;
            connectSelection(): void;
            disconnectSelection(): void;
            suppressSelectionUpdates(): void;
            setCurSelection(): void;
            ignoreSelectionChange(sel: any): boolean;
            flush(): void;
            registerMutation(mut: any, added: any): {
                from: any;
                to: any;
                typeOver?: undefined;
            } | {
                from: any;
                to: any;
                typeOver: boolean;
            };
        };
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        readonly composing: boolean;
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        readonly props: any;
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props: any): void;
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props: any): void;
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state: any): void;
        updateStateInner(state: any, prevProps: any): void;
        /**
        @internal
        */
        scrollToSelection(): void;
        destroyPluginViews(): void;
        updatePluginViews(prevState: any): void;
        someProp(propName: any, f: any): any;
        /**
        Query whether the view has focus.
        */
        hasFocus(): boolean;
        /**
        Focus the editor.
        */
        focus(): void;
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        readonly root: any;
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords: any): {
            pos: any;
            inside: number;
        };
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos: any, side?: number): any;
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos: any, side?: number): any;
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos: any): any;
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesâ€”for example when interpreting an event
        targetâ€”you don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node: any, offset: any, bias?: number): any;
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir: any, state: any): any;
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html: any, event: any): boolean;
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text: any, event: any): boolean;
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy(): void;
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        readonly isDestroyed: boolean;
        /**
        Used for testing.
        */
        dispatchEvent(event: any): void;
        /**
        @internal
        */
        domSelectionRange(): any;
        /**
        @internal
        */
        domSelection(): any;
    }): void;
    /**
     * Called when the view is destroyed or receives a state with different plugins.
     */
    destroy(): void;
    /**
     * Instantiate the ProseMirrorDropDown instances and configure them with the defined menu items.
     * @protected
     */
    protected _createDropDowns(): void;
    /**
     * @typedef {object} ProseMirrorMenuItem
     * @property {string} action             A string identifier for this menu item.
     * @property {string} title              The description of the menu item.
     * @property {string} [class]            An optional class to apply to the menu item.
     * @property {string} [style]            An optional style to apply to the title text.
     * @property {string} [icon]             The menu item's icon HTML.
     * @property {MarkType} [mark]           The mark to apply to the selected text.
     * @property {NodeType} [node]           The node to wrap the selected text in.
     * @property {object} [attrs]            An object of attributes for the node or mark.
     * @property {number} [group]            Entries with the same group number will be grouped together in the drop-down.
     *                                       Lower-numbered groups appear higher in the list.
     * @property {number} [priority]         A numeric priority which determines whether this item is displayed as the
     *                                       dropdown title. Lower priority takes precedence.
     * @property {ProseMirrorCommand} [cmd]  The command to run when the menu item is clicked.
     * @property {boolean} [active=false]    Whether the current item is active under the given selection or cursor.
     */
    /**
     * @typedef {ProseMirrorMenuItem} ProseMirrorDropDownEntry
     * @property {ProseMirrorDropDownEntry[]} [children]  Any child entries.
     */
    /**
     * @typedef {object} ProseMirrorDropDownConfig
     * @property {string} title                        The default title of the drop-down.
     * @property {string} cssClass                     The menu CSS class.
     * @property {string} [icon]                       An optional icon to use instead of a text label.
     * @property {ProseMirrorDropDownEntry[]} entries  The drop-down entries.
     */
    /**
     * Configure dropdowns for this menu. Each entry in the top-level array corresponds to a separate drop-down.
     * @returns {Object<ProseMirrorDropDownConfig>}
     * @protected
     */
    protected _getDropDownMenus(): any;
    /**
     * Configure the items for this menu.
     * @returns {ProseMirrorMenuItem[]}
     * @protected
     */
    protected _getMenuItems(): {
        /**
         * A string identifier for this menu item.
         */
        action: string;
        /**
         * The description of the menu item.
         */
        title: string;
        /**
         * An optional class to apply to the menu item.
         */
        class?: string;
        /**
         * An optional style to apply to the title text.
         */
        style?: string;
        /**
         * The menu item's icon HTML.
         */
        icon?: string;
        /**
         * The mark to apply to the selected text.
         */
        mark?: {
            name: any;
            rank: any;
            schema: any;
            spec: any;
            attrs: any;
            excluded: any;
            instance: {
                type: any;
                attrs: any;
                /**
                Given a set of marks, create a new set which contains this one as
                well, in the right position. If this mark is already in the set,
                the set itself is returned. If any marks that are set to be
                [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                those are replaced by this one.
                */
                addToSet(set: any): any;
                /**
                Remove this mark from the given set, returning a new set. If this
                mark is not in the set, the set itself is returned.
                */
                removeFromSet(set: any): any;
                /**
                Test whether this mark is in the given set of marks.
                */
                isInSet(set: any): boolean;
                /**
                Test whether this mark has the same type and attributes as
                another mark.
                */
                eq(other: any): boolean;
                /**
                Convert this mark to a JSON-serializeable representation.
                */
                toJSON(): {
                    type: any;
                };
            };
            /**
            Create a mark of this type. `attrs` may be `null` or an object
            containing only some of the mark's attributes. The others, if
            they have defaults, will be added.
            */
            create(attrs?: any): {
                type: any;
                attrs: any;
                /**
                Given a set of marks, create a new set which contains this one as
                well, in the right position. If this mark is already in the set,
                the set itself is returned. If any marks that are set to be
                [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                those are replaced by this one.
                */
                addToSet(set: any): any;
                /**
                Remove this mark from the given set, returning a new set. If this
                mark is not in the set, the set itself is returned.
                */
                removeFromSet(set: any): any;
                /**
                Test whether this mark is in the given set of marks.
                */
                isInSet(set: any): boolean;
                /**
                Test whether this mark has the same type and attributes as
                another mark.
                */
                eq(other: any): boolean;
                /**
                Convert this mark to a JSON-serializeable representation.
                */
                toJSON(): {
                    type: any;
                };
            };
            /**
            When there is a mark of this type in the given set, a new set
            without it is returned. Otherwise, the input set is returned.
            */
            removeFromSet(set: any): any;
            /**
            Tests whether there is a mark of this type in the given set.
            */
            isInSet(set: any): any;
            /**
            Queries whether a given mark type is
            [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
            */
            excludes(other: any): boolean;
        };
        /**
         * The node to wrap the selected text in.
         */
        node?: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        };
        /**
         * An object of attributes for the node or mark.
         */
        attrs?: object;
        /**
         * Entries with the same group number will be grouped together in the drop-down.
         *             Lower-numbered groups appear higher in the list.
         */
        group?: number;
        /**
         * A numeric priority which determines whether this item is displayed as the
         *          dropdown title. Lower priority takes precedence.
         */
        priority?: number;
        /**
         * The command to run when the menu item is clicked.
         */
        cmd?: (state: {
            config: any;
            /**
            The schema of the state's document.
            */
            readonly schema: any;
            /**
            The plugins that are active in this state.
            */
            readonly plugins: any;
            /**
            Apply the given transaction to produce a new state.
            */
            apply(tr: any): any;
            /**
            @internal
            */
            filterTransaction(tr: any, ignore?: number): boolean;
            /**
            Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
            returns the precise transactions that were applied (which might
            be influenced by the [transaction
            hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
            plugins) along with the new state.
            */
            applyTransaction(rootTr: any): {
                state: any;
                transactions: any[];
            };
            /**
            @internal
            */
            applyInner(tr: any): any;
            /**
            Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
            */
            readonly tr: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            };
            /**
            Create a new state based on this one, but with an adjusted set
            of active plugins. State fields that exist in both sets of
            plugins are kept unchanged. Those that no longer exist are
            dropped, and those that are new are initialized using their
            [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
            configuration object..
            */
            reconfigure(config: any): any;
            /**
            Serialize this state to JSON. If you want to serialize the state
            of plugins, pass an object mapping property names to use in the
            resulting JSON object to plugin objects. The argument may also be
            a string or number, in which case it is ignored, to support the
            way `JSON.stringify` calls `toString` methods.
            */
            toJSON(pluginFields: any): {
                doc: any;
                selection: any;
            };
        }, dispatch: (arg0: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        }) => any, view: {
            _root: any;
            /**
            @internal
            */
            focused: boolean;
            /**
            Kludge used to work around a Chrome bug @internal
            */
            trackWrites: any;
            mounted: boolean;
            /**
            @internal
            */
            markCursor: any;
            /**
            @internal
            */
            cursorWrapper: any;
            /**
            @internal
            */
            lastSelectedViewDesc: any;
            /**
            @internal
            */
            input: {
                shiftKey: boolean;
                mouseDown: any;
                lastKeyCode: any;
                lastKeyCodeTime: number;
                lastClick: {
                    time: number;
                    x: number;
                    y: number;
                    type: string;
                };
                lastSelectionOrigin: any;
                lastSelectionTime: number;
                lastIOSEnter: number;
                lastIOSEnterFallbackTimeout: number;
                lastFocus: number;
                lastTouch: number;
                lastAndroidDelete: number;
                composing: boolean;
                composingTimeout: number;
                compositionNodes: any[];
                compositionEndedAt: number;
                domChangeCount: number;
                eventHandlers: any;
                hideSelectionGuard: any;
            };
            prevDirectPlugins: any[];
            pluginViews: any[];
            /**
            Holds `true` when a hack node is needed in Firefox to prevent the
            [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
            @internal
            */
            requiresGeckoHackNode: boolean;
            /**
            When editor content is being dragged, this object contains
            information about the dragged slice and whether it is being
            copied or moved. At any other time, it is null.
            */
            dragging: any;
            _props: any;
            state: any;
            directPlugins: any;
            /**
            Dispatch a transaction. Will call
            [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
            when given, and otherwise defaults to applying the transaction to
            the current state and calling
            [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
            This method is bound to the view instance, so that it can be
            easily passed around.
            */
            dispatch(tr: any): void;
            dom: any;
            editable: boolean;
            nodeViews: any;
            docView: {
                node: any;
                outerDeco: any;
                innerDeco: any;
                nodeDOM: any;
                parseRule(): {
                    node: any;
                    attrs: any;
                };
                matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                readonly size: any;
                readonly border: 0 | 1;
                updateChildren(view: any, pos: any): void;
                localCompositionInfo(view: any, pos: any): {
                    node: any;
                    pos: any;
                    text: any;
                };
                protectLocalComposition(view: any, { node, pos, text }: {
                    node: any;
                    pos: any;
                    text: any;
                }): void;
                children: any;
                update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                dirty: number;
                updateOuterDeco(outerDeco: any): void;
                dom: any;
                selectNode(): void;
                deselectNode(): void;
                readonly domAtom: any;
                parent: any;
                contentDOM: any;
                matchesWidget(widget: any): boolean;
                matchesMark(mark: any): boolean;
                matchesHack(nodeName: any): boolean;
                stopEvent(event: any): boolean;
                destroy(): void;
                posBeforeChild(child: any): any;
                readonly posBefore: any;
                readonly posAtStart: any;
                readonly posAfter: any;
                readonly posAtEnd: number;
                localPosFromDOM(dom: any, offset: any, bias: any): any;
                nearestDesc(dom: any, onlyNodes?: boolean): any;
                getDesc(dom: any): any;
                posFromDOM(dom: any, offset: any, bias: any): any;
                descAt(pos: any): any;
                domFromPos(pos: any, side: any): any;
                parseRange(from: any, to: any, base?: number): any;
                emptyChildAt(side: any): any;
                domAfterPos(pos: any): any;
                setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                ignoreMutation(mutation: any): boolean;
                readonly contentLost: boolean;
                markDirty(from: any, to: any): void;
                markParentsDirty(): void;
                readonly ignoreForCoords: boolean;
            };
            domObserver: {
                view: any;
                handleDOMChange: any;
                queue: any[];
                flushingSoon: number;
                observer: MutationObserver;
                currentSelection: {
                    anchorNode: any;
                    anchorOffset: number;
                    focusNode: any;
                    focusOffset: number;
                    set(sel: any): void;
                    clear(): void;
                    eq(sel: any): boolean;
                };
                onCharData: (e: any) => void;
                suppressingSelectionUpdates: boolean;
                onSelectionChange(): void;
                flushSoon(): void;
                forceFlush(): void;
                start(): void;
                stop(): void;
                connectSelection(): void;
                disconnectSelection(): void;
                suppressSelectionUpdates(): void;
                setCurSelection(): void;
                ignoreSelectionChange(sel: any): boolean;
                flush(): void;
                registerMutation(mut: any, added: any): {
                    from: any;
                    to: any;
                    typeOver?: undefined;
                } | {
                    from: any;
                    to: any;
                    typeOver: boolean;
                };
            };
            /**
            Holds `true` when a
            [composition](https://w3c.github.io/uievents/#events-compositionevents)
            is active.
            */
            readonly composing: boolean;
            /**
            The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
            */
            readonly props: any;
            /**
            Update the view's props. Will immediately cause an update to
            the DOM.
            */
            update(props: any): void;
            /**
            Update the view by updating existing props object with the object
            given as argument. Equivalent to `view.update(Object.assign({},
            view.props, props))`.
            */
            setProps(props: any): void;
            /**
            Update the editor's `state` prop, without touching any of the
            other props.
            */
            updateState(state: any): void;
            updateStateInner(state: any, prevProps: any): void;
            /**
            @internal
            */
            scrollToSelection(): void;
            destroyPluginViews(): void;
            updatePluginViews(prevState: any): void;
            someProp(propName: any, f: any): any;
            /**
            Query whether the view has focus.
            */
            hasFocus(): boolean;
            /**
            Focus the editor.
            */
            focus(): void;
            /**
            Get the document root in which the editor exists. This will
            usually be the top-level `document`, but might be a [shadow
            DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
            root if the editor is inside one.
            */
            readonly root: any;
            /**
            Given a pair of viewport coordinates, return the document
            position that corresponds to them. May return null if the given
            coordinates aren't inside of the editor. When an object is
            returned, its `pos` property is the position nearest to the
            coordinates, and its `inside` property holds the position of the
            inner node that the position falls inside of, or -1 if it is at
            the top level, not in any node.
            */
            posAtCoords(coords: any): {
                pos: any;
                inside: number;
            };
            /**
            Returns the viewport rectangle at a given document position.
            `left` and `right` will be the same number, as this returns a
            flat cursor-ish rectangle. If the position is between two things
            that aren't directly adjacent, `side` determines which element
            is used. When < 0, the element before the position is used,
            otherwise the element after.
            */
            coordsAtPos(pos: any, side?: number): any;
            /**
            Find the DOM position that corresponds to the given document
            position. When `side` is negative, find the position as close as
            possible to the content before the position. When positive,
            prefer positions close to the content after the position. When
            zero, prefer as shallow a position as possible.
            
            Note that you should **not** mutate the editor's internal DOM,
            only inspect it (and even that is usually not necessary).
            */
            domAtPos(pos: any, side?: number): any;
            /**
            Find the DOM node that represents the document node after the
            given position. May return `null` when the position doesn't point
            in front of a node or if the node is inside an opaque node view.
            
            This is intended to be able to call things like
            `getBoundingClientRect` on that DOM node. Do **not** mutate the
            editor DOM directly, or add styling this way, since that will be
            immediately overriden by the editor as it redraws the node.
            */
            nodeDOM(pos: any): any;
            /**
            Find the document position that corresponds to a given DOM
            position. (Whenever possible, it is preferable to inspect the
            document structure directly, rather than poking around in the
            DOM, but sometimesâ€”for example when interpreting an event
            targetâ€”you don't have a choice.)
            
            The `bias` parameter can be used to influence which side of a DOM
            node to use when the position is inside a leaf node.
            */
            posAtDOM(node: any, offset: any, bias?: number): any;
            /**
            Find out whether the selection is at the end of a textblock when
            moving in a given direction. When, for example, given `"left"`,
            it will return true if moving left from the current cursor
            position would leave that position's parent textblock. Will apply
            to the view's current state by default, but it is possible to
            pass a different state.
            */
            endOfTextblock(dir: any, state: any): any;
            /**
            Run the editor's paste logic with the given HTML string. The
            `event`, if given, will be passed to the
            [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
            */
            pasteHTML(html: any, event: any): boolean;
            /**
            Run the editor's paste logic with the given plain-text input.
            */
            pasteText(text: any, event: any): boolean;
            /**
            Removes the editor from the DOM and destroys all [node
            views](https://prosemirror.net/docs/ref/#view.NodeView).
            */
            destroy(): void;
            /**
            This is true when the view has been
            [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
            used anymore).
            */
            readonly isDestroyed: boolean;
            /**
            Used for testing.
            */
            dispatchEvent(event: any): void;
            /**
            @internal
            */
            domSelectionRange(): any;
            /**
            @internal
            */
            domSelection(): any;
        }) => boolean;
        /**
         * Whether the current item is active under the given selection or cursor.
         */
        active?: boolean;
    }[];
    /**
     * Determine whether the given menu item is currently active or not.
     * @param {ProseMirrorMenuItem} item  The menu item.
     * @returns {boolean}                 Whether the cursor or selection is in a state represented by the given menu
     *                                    item.
     * @protected
     */
    protected _isItemActive(item: {
        /**
         * A string identifier for this menu item.
         */
        action: string;
        /**
         * The description of the menu item.
         */
        title: string;
        /**
         * An optional class to apply to the menu item.
         */
        class?: string;
        /**
         * An optional style to apply to the title text.
         */
        style?: string;
        /**
         * The menu item's icon HTML.
         */
        icon?: string;
        /**
         * The mark to apply to the selected text.
         */
        mark?: {
            name: any;
            rank: any;
            schema: any;
            spec: any;
            attrs: any;
            excluded: any;
            instance: {
                type: any;
                attrs: any;
                /**
                Given a set of marks, create a new set which contains this one as
                well, in the right position. If this mark is already in the set,
                the set itself is returned. If any marks that are set to be
                [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                those are replaced by this one.
                */
                addToSet(set: any): any;
                /**
                Remove this mark from the given set, returning a new set. If this
                mark is not in the set, the set itself is returned.
                */
                removeFromSet(set: any): any;
                /**
                Test whether this mark is in the given set of marks.
                */
                isInSet(set: any): boolean;
                /**
                Test whether this mark has the same type and attributes as
                another mark.
                */
                eq(other: any): boolean;
                /**
                Convert this mark to a JSON-serializeable representation.
                */
                toJSON(): {
                    type: any;
                };
            };
            /**
            Create a mark of this type. `attrs` may be `null` or an object
            containing only some of the mark's attributes. The others, if
            they have defaults, will be added.
            */
            create(attrs?: any): {
                type: any;
                attrs: any;
                /**
                Given a set of marks, create a new set which contains this one as
                well, in the right position. If this mark is already in the set,
                the set itself is returned. If any marks that are set to be
                [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                those are replaced by this one.
                */
                addToSet(set: any): any;
                /**
                Remove this mark from the given set, returning a new set. If this
                mark is not in the set, the set itself is returned.
                */
                removeFromSet(set: any): any;
                /**
                Test whether this mark is in the given set of marks.
                */
                isInSet(set: any): boolean;
                /**
                Test whether this mark has the same type and attributes as
                another mark.
                */
                eq(other: any): boolean;
                /**
                Convert this mark to a JSON-serializeable representation.
                */
                toJSON(): {
                    type: any;
                };
            };
            /**
            When there is a mark of this type in the given set, a new set
            without it is returned. Otherwise, the input set is returned.
            */
            removeFromSet(set: any): any;
            /**
            Tests whether there is a mark of this type in the given set.
            */
            isInSet(set: any): any;
            /**
            Queries whether a given mark type is
            [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
            */
            excludes(other: any): boolean;
        };
        /**
         * The node to wrap the selected text in.
         */
        node?: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        };
        /**
         * An object of attributes for the node or mark.
         */
        attrs?: object;
        /**
         * Entries with the same group number will be grouped together in the drop-down.
         *             Lower-numbered groups appear higher in the list.
         */
        group?: number;
        /**
         * A numeric priority which determines whether this item is displayed as the
         *          dropdown title. Lower priority takes precedence.
         */
        priority?: number;
        /**
         * The command to run when the menu item is clicked.
         */
        cmd?: (state: {
            config: any;
            /**
            The schema of the state's document.
            */
            readonly schema: any;
            /**
            The plugins that are active in this state.
            */
            readonly plugins: any;
            /**
            Apply the given transaction to produce a new state.
            */
            apply(tr: any): any;
            /**
            @internal
            */
            filterTransaction(tr: any, ignore?: number): boolean;
            /**
            Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
            returns the precise transactions that were applied (which might
            be influenced by the [transaction
            hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
            plugins) along with the new state.
            */
            applyTransaction(rootTr: any): {
                state: any;
                transactions: any[];
            };
            /**
            @internal
            */
            applyInner(tr: any): any;
            /**
            Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
            */
            readonly tr: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            };
            /**
            Create a new state based on this one, but with an adjusted set
            of active plugins. State fields that exist in both sets of
            plugins are kept unchanged. Those that no longer exist are
            dropped, and those that are new are initialized using their
            [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
            configuration object..
            */
            reconfigure(config: any): any;
            /**
            Serialize this state to JSON. If you want to serialize the state
            of plugins, pass an object mapping property names to use in the
            resulting JSON object to plugin objects. The argument may also be
            a string or number, in which case it is ignored, to support the
            way `JSON.stringify` calls `toString` methods.
            */
            toJSON(pluginFields: any): {
                doc: any;
                selection: any;
            };
        }, dispatch: (arg0: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        }) => any, view: {
            _root: any;
            /**
            @internal
            */
            focused: boolean;
            /**
            Kludge used to work around a Chrome bug @internal
            */
            trackWrites: any;
            mounted: boolean;
            /**
            @internal
            */
            markCursor: any;
            /**
            @internal
            */
            cursorWrapper: any;
            /**
            @internal
            */
            lastSelectedViewDesc: any;
            /**
            @internal
            */
            input: {
                shiftKey: boolean;
                mouseDown: any;
                lastKeyCode: any;
                lastKeyCodeTime: number;
                lastClick: {
                    time: number;
                    x: number;
                    y: number;
                    type: string;
                };
                lastSelectionOrigin: any;
                lastSelectionTime: number;
                lastIOSEnter: number;
                lastIOSEnterFallbackTimeout: number;
                lastFocus: number;
                lastTouch: number;
                lastAndroidDelete: number;
                composing: boolean;
                composingTimeout: number;
                compositionNodes: any[];
                compositionEndedAt: number;
                domChangeCount: number;
                eventHandlers: any;
                hideSelectionGuard: any;
            };
            prevDirectPlugins: any[];
            pluginViews: any[];
            /**
            Holds `true` when a hack node is needed in Firefox to prevent the
            [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
            @internal
            */
            requiresGeckoHackNode: boolean;
            /**
            When editor content is being dragged, this object contains
            information about the dragged slice and whether it is being
            copied or moved. At any other time, it is null.
            */
            dragging: any;
            _props: any;
            state: any;
            directPlugins: any;
            /**
            Dispatch a transaction. Will call
            [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
            when given, and otherwise defaults to applying the transaction to
            the current state and calling
            [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
            This method is bound to the view instance, so that it can be
            easily passed around.
            */
            dispatch(tr: any): void;
            dom: any;
            editable: boolean;
            nodeViews: any;
            docView: {
                node: any;
                outerDeco: any;
                innerDeco: any;
                nodeDOM: any;
                parseRule(): {
                    node: any;
                    attrs: any;
                };
                matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                readonly size: any;
                readonly border: 0 | 1;
                updateChildren(view: any, pos: any): void;
                localCompositionInfo(view: any, pos: any): {
                    node: any;
                    pos: any;
                    text: any;
                };
                protectLocalComposition(view: any, { node, pos, text }: {
                    node: any;
                    pos: any;
                    text: any;
                }): void;
                children: any;
                update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                dirty: number;
                updateOuterDeco(outerDeco: any): void;
                dom: any;
                selectNode(): void;
                deselectNode(): void;
                readonly domAtom: any;
                parent: any;
                contentDOM: any;
                matchesWidget(widget: any): boolean;
                matchesMark(mark: any): boolean;
                matchesHack(nodeName: any): boolean;
                stopEvent(event: any): boolean;
                destroy(): void;
                posBeforeChild(child: any): any;
                readonly posBefore: any;
                readonly posAtStart: any;
                readonly posAfter: any;
                readonly posAtEnd: number;
                localPosFromDOM(dom: any, offset: any, bias: any): any;
                nearestDesc(dom: any, onlyNodes?: boolean): any;
                getDesc(dom: any): any;
                posFromDOM(dom: any, offset: any, bias: any): any;
                descAt(pos: any): any;
                domFromPos(pos: any, side: any): any;
                parseRange(from: any, to: any, base?: number): any;
                emptyChildAt(side: any): any;
                domAfterPos(pos: any): any;
                setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                ignoreMutation(mutation: any): boolean;
                readonly contentLost: boolean;
                markDirty(from: any, to: any): void;
                markParentsDirty(): void;
                readonly ignoreForCoords: boolean;
            };
            domObserver: {
                view: any;
                handleDOMChange: any;
                queue: any[];
                flushingSoon: number;
                observer: MutationObserver;
                currentSelection: {
                    anchorNode: any;
                    anchorOffset: number;
                    focusNode: any;
                    focusOffset: number;
                    set(sel: any): void;
                    clear(): void;
                    eq(sel: any): boolean;
                };
                onCharData: (e: any) => void;
                suppressingSelectionUpdates: boolean;
                onSelectionChange(): void;
                flushSoon(): void;
                forceFlush(): void;
                start(): void;
                stop(): void;
                connectSelection(): void;
                disconnectSelection(): void;
                suppressSelectionUpdates(): void;
                setCurSelection(): void;
                ignoreSelectionChange(sel: any): boolean;
                flush(): void;
                registerMutation(mut: any, added: any): {
                    from: any;
                    to: any;
                    typeOver?: undefined;
                } | {
                    from: any;
                    to: any;
                    typeOver: boolean;
                };
            };
            /**
            Holds `true` when a
            [composition](https://w3c.github.io/uievents/#events-compositionevents)
            is active.
            */
            readonly composing: boolean;
            /**
            The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
            */
            readonly props: any;
            /**
            Update the view's props. Will immediately cause an update to
            the DOM.
            */
            update(props: any): void;
            /**
            Update the view by updating existing props object with the object
            given as argument. Equivalent to `view.update(Object.assign({},
            view.props, props))`.
            */
            setProps(props: any): void;
            /**
            Update the editor's `state` prop, without touching any of the
            other props.
            */
            updateState(state: any): void;
            updateStateInner(state: any, prevProps: any): void;
            /**
            @internal
            */
            scrollToSelection(): void;
            destroyPluginViews(): void;
            updatePluginViews(prevState: any): void;
            someProp(propName: any, f: any): any;
            /**
            Query whether the view has focus.
            */
            hasFocus(): boolean;
            /**
            Focus the editor.
            */
            focus(): void;
            /**
            Get the document root in which the editor exists. This will
            usually be the top-level `document`, but might be a [shadow
            DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
            root if the editor is inside one.
            */
            readonly root: any;
            /**
            Given a pair of viewport coordinates, return the document
            position that corresponds to them. May return null if the given
            coordinates aren't inside of the editor. When an object is
            returned, its `pos` property is the position nearest to the
            coordinates, and its `inside` property holds the position of the
            inner node that the position falls inside of, or -1 if it is at
            the top level, not in any node.
            */
            posAtCoords(coords: any): {
                pos: any;
                inside: number;
            };
            /**
            Returns the viewport rectangle at a given document position.
            `left` and `right` will be the same number, as this returns a
            flat cursor-ish rectangle. If the position is between two things
            that aren't directly adjacent, `side` determines which element
            is used. When < 0, the element before the position is used,
            otherwise the element after.
            */
            coordsAtPos(pos: any, side?: number): any;
            /**
            Find the DOM position that corresponds to the given document
            position. When `side` is negative, find the position as close as
            possible to the content before the position. When positive,
            prefer positions close to the content after the position. When
            zero, prefer as shallow a position as possible.
            
            Note that you should **not** mutate the editor's internal DOM,
            only inspect it (and even that is usually not necessary).
            */
            domAtPos(pos: any, side?: number): any;
            /**
            Find the DOM node that represents the document node after the
            given position. May return `null` when the position doesn't point
            in front of a node or if the node is inside an opaque node view.
            
            This is intended to be able to call things like
            `getBoundingClientRect` on that DOM node. Do **not** mutate the
            editor DOM directly, or add styling this way, since that will be
            immediately overriden by the editor as it redraws the node.
            */
            nodeDOM(pos: any): any;
            /**
            Find the document position that corresponds to a given DOM
            position. (Whenever possible, it is preferable to inspect the
            document structure directly, rather than poking around in the
            DOM, but sometimesâ€”for example when interpreting an event
            targetâ€”you don't have a choice.)
            
            The `bias` parameter can be used to influence which side of a DOM
            node to use when the position is inside a leaf node.
            */
            posAtDOM(node: any, offset: any, bias?: number): any;
            /**
            Find out whether the selection is at the end of a textblock when
            moving in a given direction. When, for example, given `"left"`,
            it will return true if moving left from the current cursor
            position would leave that position's parent textblock. Will apply
            to the view's current state by default, but it is possible to
            pass a different state.
            */
            endOfTextblock(dir: any, state: any): any;
            /**
            Run the editor's paste logic with the given HTML string. The
            `event`, if given, will be passed to the
            [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
            */
            pasteHTML(html: any, event: any): boolean;
            /**
            Run the editor's paste logic with the given plain-text input.
            */
            pasteText(text: any, event: any): boolean;
            /**
            Removes the editor from the DOM and destroys all [node
            views](https://prosemirror.net/docs/ref/#view.NodeView).
            */
            destroy(): void;
            /**
            This is true when the view has been
            [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
            used anymore).
            */
            readonly isDestroyed: boolean;
            /**
            Used for testing.
            */
            dispatchEvent(event: any): void;
            /**
            @internal
            */
            domSelectionRange(): any;
            /**
            @internal
            */
            domSelection(): any;
        }) => boolean;
        /**
         * Whether the current item is active under the given selection or cursor.
         */
        active?: boolean;
    }): boolean;
    /**
     * Determine whether the given menu item representing a mark is active or not.
     * @param {ProseMirrorMenuItem} item  The menu item representing a {@link MarkType}.
     * @returns {boolean}                 Whether the cursor or selection is in a state represented by the given mark.
     * @protected
     */
    protected _isMarkActive(item: {
        /**
         * A string identifier for this menu item.
         */
        action: string;
        /**
         * The description of the menu item.
         */
        title: string;
        /**
         * An optional class to apply to the menu item.
         */
        class?: string;
        /**
         * An optional style to apply to the title text.
         */
        style?: string;
        /**
         * The menu item's icon HTML.
         */
        icon?: string;
        /**
         * The mark to apply to the selected text.
         */
        mark?: {
            name: any;
            rank: any;
            schema: any;
            spec: any;
            attrs: any;
            excluded: any;
            instance: {
                type: any;
                attrs: any;
                /**
                Given a set of marks, create a new set which contains this one as
                well, in the right position. If this mark is already in the set,
                the set itself is returned. If any marks that are set to be
                [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                those are replaced by this one.
                */
                addToSet(set: any): any;
                /**
                Remove this mark from the given set, returning a new set. If this
                mark is not in the set, the set itself is returned.
                */
                removeFromSet(set: any): any;
                /**
                Test whether this mark is in the given set of marks.
                */
                isInSet(set: any): boolean;
                /**
                Test whether this mark has the same type and attributes as
                another mark.
                */
                eq(other: any): boolean;
                /**
                Convert this mark to a JSON-serializeable representation.
                */
                toJSON(): {
                    type: any;
                };
            };
            /**
            Create a mark of this type. `attrs` may be `null` or an object
            containing only some of the mark's attributes. The others, if
            they have defaults, will be added.
            */
            create(attrs?: any): {
                type: any;
                attrs: any;
                /**
                Given a set of marks, create a new set which contains this one as
                well, in the right position. If this mark is already in the set,
                the set itself is returned. If any marks that are set to be
                [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                those are replaced by this one.
                */
                addToSet(set: any): any;
                /**
                Remove this mark from the given set, returning a new set. If this
                mark is not in the set, the set itself is returned.
                */
                removeFromSet(set: any): any;
                /**
                Test whether this mark is in the given set of marks.
                */
                isInSet(set: any): boolean;
                /**
                Test whether this mark has the same type and attributes as
                another mark.
                */
                eq(other: any): boolean;
                /**
                Convert this mark to a JSON-serializeable representation.
                */
                toJSON(): {
                    type: any;
                };
            };
            /**
            When there is a mark of this type in the given set, a new set
            without it is returned. Otherwise, the input set is returned.
            */
            removeFromSet(set: any): any;
            /**
            Tests whether there is a mark of this type in the given set.
            */
            isInSet(set: any): any;
            /**
            Queries whether a given mark type is
            [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
            */
            excludes(other: any): boolean;
        };
        /**
         * The node to wrap the selected text in.
         */
        node?: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        };
        /**
         * An object of attributes for the node or mark.
         */
        attrs?: object;
        /**
         * Entries with the same group number will be grouped together in the drop-down.
         *             Lower-numbered groups appear higher in the list.
         */
        group?: number;
        /**
         * A numeric priority which determines whether this item is displayed as the
         *          dropdown title. Lower priority takes precedence.
         */
        priority?: number;
        /**
         * The command to run when the menu item is clicked.
         */
        cmd?: (state: {
            config: any;
            /**
            The schema of the state's document.
            */
            readonly schema: any;
            /**
            The plugins that are active in this state.
            */
            readonly plugins: any;
            /**
            Apply the given transaction to produce a new state.
            */
            apply(tr: any): any;
            /**
            @internal
            */
            filterTransaction(tr: any, ignore?: number): boolean;
            /**
            Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
            returns the precise transactions that were applied (which might
            be influenced by the [transaction
            hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
            plugins) along with the new state.
            */
            applyTransaction(rootTr: any): {
                state: any;
                transactions: any[];
            };
            /**
            @internal
            */
            applyInner(tr: any): any;
            /**
            Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
            */
            readonly tr: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            };
            /**
            Create a new state based on this one, but with an adjusted set
            of active plugins. State fields that exist in both sets of
            plugins are kept unchanged. Those that no longer exist are
            dropped, and those that are new are initialized using their
            [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
            configuration object..
            */
            reconfigure(config: any): any;
            /**
            Serialize this state to JSON. If you want to serialize the state
            of plugins, pass an object mapping property names to use in the
            resulting JSON object to plugin objects. The argument may also be
            a string or number, in which case it is ignored, to support the
            way `JSON.stringify` calls `toString` methods.
            */
            toJSON(pluginFields: any): {
                doc: any;
                selection: any;
            };
        }, dispatch: (arg0: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        }) => any, view: {
            _root: any;
            /**
            @internal
            */
            focused: boolean;
            /**
            Kludge used to work around a Chrome bug @internal
            */
            trackWrites: any;
            mounted: boolean;
            /**
            @internal
            */
            markCursor: any;
            /**
            @internal
            */
            cursorWrapper: any;
            /**
            @internal
            */
            lastSelectedViewDesc: any;
            /**
            @internal
            */
            input: {
                shiftKey: boolean;
                mouseDown: any;
                lastKeyCode: any;
                lastKeyCodeTime: number;
                lastClick: {
                    time: number;
                    x: number;
                    y: number;
                    type: string;
                };
                lastSelectionOrigin: any;
                lastSelectionTime: number;
                lastIOSEnter: number;
                lastIOSEnterFallbackTimeout: number;
                lastFocus: number;
                lastTouch: number;
                lastAndroidDelete: number;
                composing: boolean;
                composingTimeout: number;
                compositionNodes: any[];
                compositionEndedAt: number;
                domChangeCount: number;
                eventHandlers: any;
                hideSelectionGuard: any;
            };
            prevDirectPlugins: any[];
            pluginViews: any[];
            /**
            Holds `true` when a hack node is needed in Firefox to prevent the
            [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
            @internal
            */
            requiresGeckoHackNode: boolean;
            /**
            When editor content is being dragged, this object contains
            information about the dragged slice and whether it is being
            copied or moved. At any other time, it is null.
            */
            dragging: any;
            _props: any;
            state: any;
            directPlugins: any;
            /**
            Dispatch a transaction. Will call
            [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
            when given, and otherwise defaults to applying the transaction to
            the current state and calling
            [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
            This method is bound to the view instance, so that it can be
            easily passed around.
            */
            dispatch(tr: any): void;
            dom: any;
            editable: boolean;
            nodeViews: any;
            docView: {
                node: any;
                outerDeco: any;
                innerDeco: any;
                nodeDOM: any;
                parseRule(): {
                    node: any;
                    attrs: any;
                };
                matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                readonly size: any;
                readonly border: 0 | 1;
                updateChildren(view: any, pos: any): void;
                localCompositionInfo(view: any, pos: any): {
                    node: any;
                    pos: any;
                    text: any;
                };
                protectLocalComposition(view: any, { node, pos, text }: {
                    node: any;
                    pos: any;
                    text: any;
                }): void;
                children: any;
                update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                dirty: number;
                updateOuterDeco(outerDeco: any): void;
                dom: any;
                selectNode(): void;
                deselectNode(): void;
                readonly domAtom: any;
                parent: any;
                contentDOM: any;
                matchesWidget(widget: any): boolean;
                matchesMark(mark: any): boolean;
                matchesHack(nodeName: any): boolean;
                stopEvent(event: any): boolean;
                destroy(): void;
                posBeforeChild(child: any): any;
                readonly posBefore: any;
                readonly posAtStart: any;
                readonly posAfter: any;
                readonly posAtEnd: number;
                localPosFromDOM(dom: any, offset: any, bias: any): any;
                nearestDesc(dom: any, onlyNodes?: boolean): any;
                getDesc(dom: any): any;
                posFromDOM(dom: any, offset: any, bias: any): any;
                descAt(pos: any): any;
                domFromPos(pos: any, side: any): any;
                parseRange(from: any, to: any, base?: number): any;
                emptyChildAt(side: any): any;
                domAfterPos(pos: any): any;
                setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                ignoreMutation(mutation: any): boolean;
                readonly contentLost: boolean;
                markDirty(from: any, to: any): void;
                markParentsDirty(): void;
                readonly ignoreForCoords: boolean;
            };
            domObserver: {
                view: any;
                handleDOMChange: any;
                queue: any[];
                flushingSoon: number;
                observer: MutationObserver;
                currentSelection: {
                    anchorNode: any;
                    anchorOffset: number;
                    focusNode: any;
                    focusOffset: number;
                    set(sel: any): void;
                    clear(): void;
                    eq(sel: any): boolean;
                };
                onCharData: (e: any) => void;
                suppressingSelectionUpdates: boolean;
                onSelectionChange(): void;
                flushSoon(): void;
                forceFlush(): void;
                start(): void;
                stop(): void;
                connectSelection(): void;
                disconnectSelection(): void;
                suppressSelectionUpdates(): void;
                setCurSelection(): void;
                ignoreSelectionChange(sel: any): boolean;
                flush(): void;
                registerMutation(mut: any, added: any): {
                    from: any;
                    to: any;
                    typeOver?: undefined;
                } | {
                    from: any;
                    to: any;
                    typeOver: boolean;
                };
            };
            /**
            Holds `true` when a
            [composition](https://w3c.github.io/uievents/#events-compositionevents)
            is active.
            */
            readonly composing: boolean;
            /**
            The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
            */
            readonly props: any;
            /**
            Update the view's props. Will immediately cause an update to
            the DOM.
            */
            update(props: any): void;
            /**
            Update the view by updating existing props object with the object
            given as argument. Equivalent to `view.update(Object.assign({},
            view.props, props))`.
            */
            setProps(props: any): void;
            /**
            Update the editor's `state` prop, without touching any of the
            other props.
            */
            updateState(state: any): void;
            updateStateInner(state: any, prevProps: any): void;
            /**
            @internal
            */
            scrollToSelection(): void;
            destroyPluginViews(): void;
            updatePluginViews(prevState: any): void;
            someProp(propName: any, f: any): any;
            /**
            Query whether the view has focus.
            */
            hasFocus(): boolean;
            /**
            Focus the editor.
            */
            focus(): void;
            /**
            Get the document root in which the editor exists. This will
            usually be the top-level `document`, but might be a [shadow
            DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
            root if the editor is inside one.
            */
            readonly root: any;
            /**
            Given a pair of viewport coordinates, return the document
            position that corresponds to them. May return null if the given
            coordinates aren't inside of the editor. When an object is
            returned, its `pos` property is the position nearest to the
            coordinates, and its `inside` property holds the position of the
            inner node that the position falls inside of, or -1 if it is at
            the top level, not in any node.
            */
            posAtCoords(coords: any): {
                pos: any;
                inside: number;
            };
            /**
            Returns the viewport rectangle at a given document position.
            `left` and `right` will be the same number, as this returns a
            flat cursor-ish rectangle. If the position is between two things
            that aren't directly adjacent, `side` determines which element
            is used. When < 0, the element before the position is used,
            otherwise the element after.
            */
            coordsAtPos(pos: any, side?: number): any;
            /**
            Find the DOM position that corresponds to the given document
            position. When `side` is negative, find the position as close as
            possible to the content before the position. When positive,
            prefer positions close to the content after the position. When
            zero, prefer as shallow a position as possible.
            
            Note that you should **not** mutate the editor's internal DOM,
            only inspect it (and even that is usually not necessary).
            */
            domAtPos(pos: any, side?: number): any;
            /**
            Find the DOM node that represents the document node after the
            given position. May return `null` when the position doesn't point
            in front of a node or if the node is inside an opaque node view.
            
            This is intended to be able to call things like
            `getBoundingClientRect` on that DOM node. Do **not** mutate the
            editor DOM directly, or add styling this way, since that will be
            immediately overriden by the editor as it redraws the node.
            */
            nodeDOM(pos: any): any;
            /**
            Find the document position that corresponds to a given DOM
            position. (Whenever possible, it is preferable to inspect the
            document structure directly, rather than poking around in the
            DOM, but sometimesâ€”for example when interpreting an event
            targetâ€”you don't have a choice.)
            
            The `bias` parameter can be used to influence which side of a DOM
            node to use when the position is inside a leaf node.
            */
            posAtDOM(node: any, offset: any, bias?: number): any;
            /**
            Find out whether the selection is at the end of a textblock when
            moving in a given direction. When, for example, given `"left"`,
            it will return true if moving left from the current cursor
            position would leave that position's parent textblock. Will apply
            to the view's current state by default, but it is possible to
            pass a different state.
            */
            endOfTextblock(dir: any, state: any): any;
            /**
            Run the editor's paste logic with the given HTML string. The
            `event`, if given, will be passed to the
            [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
            */
            pasteHTML(html: any, event: any): boolean;
            /**
            Run the editor's paste logic with the given plain-text input.
            */
            pasteText(text: any, event: any): boolean;
            /**
            Removes the editor from the DOM and destroys all [node
            views](https://prosemirror.net/docs/ref/#view.NodeView).
            */
            destroy(): void;
            /**
            This is true when the view has been
            [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
            used anymore).
            */
            readonly isDestroyed: boolean;
            /**
            Used for testing.
            */
            dispatchEvent(event: any): void;
            /**
            @internal
            */
            domSelectionRange(): any;
            /**
            @internal
            */
            domSelection(): any;
        }) => boolean;
        /**
         * Whether the current item is active under the given selection or cursor.
         */
        active?: boolean;
    }): boolean;
    /**
     * Determine whether the given menu item representing a node is active or not.
     * @param {ProseMirrorMenuItem} item  The menu item representing a {@link NodeType}.
     * @returns {boolean}                 Whether the cursor or selection is currently within a block of this menu item's
     *                                    node type.
     * @protected
     */
    protected _isNodeActive(item: {
        /**
         * A string identifier for this menu item.
         */
        action: string;
        /**
         * The description of the menu item.
         */
        title: string;
        /**
         * An optional class to apply to the menu item.
         */
        class?: string;
        /**
         * An optional style to apply to the title text.
         */
        style?: string;
        /**
         * The menu item's icon HTML.
         */
        icon?: string;
        /**
         * The mark to apply to the selected text.
         */
        mark?: {
            name: any;
            rank: any;
            schema: any;
            spec: any;
            attrs: any;
            excluded: any;
            instance: {
                type: any;
                attrs: any;
                /**
                Given a set of marks, create a new set which contains this one as
                well, in the right position. If this mark is already in the set,
                the set itself is returned. If any marks that are set to be
                [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                those are replaced by this one.
                */
                addToSet(set: any): any;
                /**
                Remove this mark from the given set, returning a new set. If this
                mark is not in the set, the set itself is returned.
                */
                removeFromSet(set: any): any;
                /**
                Test whether this mark is in the given set of marks.
                */
                isInSet(set: any): boolean;
                /**
                Test whether this mark has the same type and attributes as
                another mark.
                */
                eq(other: any): boolean;
                /**
                Convert this mark to a JSON-serializeable representation.
                */
                toJSON(): {
                    type: any;
                };
            };
            /**
            Create a mark of this type. `attrs` may be `null` or an object
            containing only some of the mark's attributes. The others, if
            they have defaults, will be added.
            */
            create(attrs?: any): {
                type: any;
                attrs: any;
                /**
                Given a set of marks, create a new set which contains this one as
                well, in the right position. If this mark is already in the set,
                the set itself is returned. If any marks that are set to be
                [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
                those are replaced by this one.
                */
                addToSet(set: any): any;
                /**
                Remove this mark from the given set, returning a new set. If this
                mark is not in the set, the set itself is returned.
                */
                removeFromSet(set: any): any;
                /**
                Test whether this mark is in the given set of marks.
                */
                isInSet(set: any): boolean;
                /**
                Test whether this mark has the same type and attributes as
                another mark.
                */
                eq(other: any): boolean;
                /**
                Convert this mark to a JSON-serializeable representation.
                */
                toJSON(): {
                    type: any;
                };
            };
            /**
            When there is a mark of this type in the given set, a new set
            without it is returned. Otherwise, the input set is returned.
            */
            removeFromSet(set: any): any;
            /**
            Tests whether there is a mark of this type in the given set.
            */
            isInSet(set: any): any;
            /**
            Queries whether a given mark type is
            [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
            */
            excludes(other: any): boolean;
        };
        /**
         * The node to wrap the selected text in.
         */
        node?: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        };
        /**
         * An object of attributes for the node or mark.
         */
        attrs?: object;
        /**
         * Entries with the same group number will be grouped together in the drop-down.
         *             Lower-numbered groups appear higher in the list.
         */
        group?: number;
        /**
         * A numeric priority which determines whether this item is displayed as the
         *          dropdown title. Lower priority takes precedence.
         */
        priority?: number;
        /**
         * The command to run when the menu item is clicked.
         */
        cmd?: (state: {
            config: any;
            /**
            The schema of the state's document.
            */
            readonly schema: any;
            /**
            The plugins that are active in this state.
            */
            readonly plugins: any;
            /**
            Apply the given transaction to produce a new state.
            */
            apply(tr: any): any;
            /**
            @internal
            */
            filterTransaction(tr: any, ignore?: number): boolean;
            /**
            Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
            returns the precise transactions that were applied (which might
            be influenced by the [transaction
            hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
            plugins) along with the new state.
            */
            applyTransaction(rootTr: any): {
                state: any;
                transactions: any[];
            };
            /**
            @internal
            */
            applyInner(tr: any): any;
            /**
            Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
            */
            readonly tr: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            };
            /**
            Create a new state based on this one, but with an adjusted set
            of active plugins. State fields that exist in both sets of
            plugins are kept unchanged. Those that no longer exist are
            dropped, and those that are new are initialized using their
            [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
            configuration object..
            */
            reconfigure(config: any): any;
            /**
            Serialize this state to JSON. If you want to serialize the state
            of plugins, pass an object mapping property names to use in the
            resulting JSON object to plugin objects. The argument may also be
            a string or number, in which case it is ignored, to support the
            way `JSON.stringify` calls `toString` methods.
            */
            toJSON(pluginFields: any): {
                doc: any;
                selection: any;
            };
        }, dispatch: (arg0: {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        }) => any, view: {
            _root: any;
            /**
            @internal
            */
            focused: boolean;
            /**
            Kludge used to work around a Chrome bug @internal
            */
            trackWrites: any;
            mounted: boolean;
            /**
            @internal
            */
            markCursor: any;
            /**
            @internal
            */
            cursorWrapper: any;
            /**
            @internal
            */
            lastSelectedViewDesc: any;
            /**
            @internal
            */
            input: {
                shiftKey: boolean;
                mouseDown: any;
                lastKeyCode: any;
                lastKeyCodeTime: number;
                lastClick: {
                    time: number;
                    x: number;
                    y: number;
                    type: string;
                };
                lastSelectionOrigin: any;
                lastSelectionTime: number;
                lastIOSEnter: number;
                lastIOSEnterFallbackTimeout: number;
                lastFocus: number;
                lastTouch: number;
                lastAndroidDelete: number;
                composing: boolean;
                composingTimeout: number;
                compositionNodes: any[];
                compositionEndedAt: number;
                domChangeCount: number;
                eventHandlers: any;
                hideSelectionGuard: any;
            };
            prevDirectPlugins: any[];
            pluginViews: any[];
            /**
            Holds `true` when a hack node is needed in Firefox to prevent the
            [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
            @internal
            */
            requiresGeckoHackNode: boolean;
            /**
            When editor content is being dragged, this object contains
            information about the dragged slice and whether it is being
            copied or moved. At any other time, it is null.
            */
            dragging: any;
            _props: any;
            state: any;
            directPlugins: any;
            /**
            Dispatch a transaction. Will call
            [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
            when given, and otherwise defaults to applying the transaction to
            the current state and calling
            [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
            This method is bound to the view instance, so that it can be
            easily passed around.
            */
            dispatch(tr: any): void;
            dom: any;
            editable: boolean;
            nodeViews: any;
            docView: {
                node: any;
                outerDeco: any;
                innerDeco: any;
                nodeDOM: any;
                parseRule(): {
                    node: any;
                    attrs: any;
                };
                matchesNode(node: any, outerDeco: any, innerDeco: any): any;
                readonly size: any;
                readonly border: 0 | 1;
                updateChildren(view: any, pos: any): void;
                localCompositionInfo(view: any, pos: any): {
                    node: any;
                    pos: any;
                    text: any;
                };
                protectLocalComposition(view: any, { node, pos, text }: {
                    node: any;
                    pos: any;
                    text: any;
                }): void;
                children: any;
                update(node: any, outerDeco: any, innerDeco: any, view: any): boolean;
                updateInner(node: any, outerDeco: any, innerDeco: any, view: any): void;
                dirty: number;
                updateOuterDeco(outerDeco: any): void;
                dom: any;
                selectNode(): void;
                deselectNode(): void;
                readonly domAtom: any;
                parent: any;
                contentDOM: any;
                matchesWidget(widget: any): boolean;
                matchesMark(mark: any): boolean;
                matchesHack(nodeName: any): boolean;
                stopEvent(event: any): boolean;
                destroy(): void;
                posBeforeChild(child: any): any;
                readonly posBefore: any;
                readonly posAtStart: any;
                readonly posAfter: any;
                readonly posAtEnd: number;
                localPosFromDOM(dom: any, offset: any, bias: any): any;
                nearestDesc(dom: any, onlyNodes?: boolean): any;
                getDesc(dom: any): any;
                posFromDOM(dom: any, offset: any, bias: any): any;
                descAt(pos: any): any;
                domFromPos(pos: any, side: any): any;
                parseRange(from: any, to: any, base?: number): any;
                emptyChildAt(side: any): any;
                domAfterPos(pos: any): any;
                setSelection(anchor: any, head: any, root: any, force?: boolean): any;
                ignoreMutation(mutation: any): boolean;
                readonly contentLost: boolean;
                markDirty(from: any, to: any): void;
                markParentsDirty(): void;
                readonly ignoreForCoords: boolean;
            };
            domObserver: {
                view: any;
                handleDOMChange: any;
                queue: any[];
                flushingSoon: number;
                observer: MutationObserver;
                currentSelection: {
                    anchorNode: any;
                    anchorOffset: number;
                    focusNode: any;
                    focusOffset: number;
                    set(sel: any): void;
                    clear(): void;
                    eq(sel: any): boolean;
                };
                onCharData: (e: any) => void;
                suppressingSelectionUpdates: boolean;
                onSelectionChange(): void;
                flushSoon(): void;
                forceFlush(): void;
                start(): void;
                stop(): void;
                connectSelection(): void;
                disconnectSelection(): void;
                suppressSelectionUpdates(): void;
                setCurSelection(): void;
                ignoreSelectionChange(sel: any): boolean;
                flush(): void;
                registerMutation(mut: any, added: any): {
                    from: any;
                    to: any;
                    typeOver?: undefined;
                } | {
                    from: any;
                    to: any;
                    typeOver: boolean;
                };
            };
            /**
            Holds `true` when a
            [composition](https://w3c.github.io/uievents/#events-compositionevents)
            is active.
            */
            readonly composing: boolean;
            /**
            The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
            */
            readonly props: any;
            /**
            Update the view's props. Will immediately cause an update to
            the DOM.
            */
            update(props: any): void;
            /**
            Update the view by updating existing props object with the object
            given as argument. Equivalent to `view.update(Object.assign({},
            view.props, props))`.
            */
            setProps(props: any): void;
            /**
            Update the editor's `state` prop, without touching any of the
            other props.
            */
            updateState(state: any): void;
            updateStateInner(state: any, prevProps: any): void;
            /**
            @internal
            */
            scrollToSelection(): void;
            destroyPluginViews(): void;
            updatePluginViews(prevState: any): void;
            someProp(propName: any, f: any): any;
            /**
            Query whether the view has focus.
            */
            hasFocus(): boolean;
            /**
            Focus the editor.
            */
            focus(): void;
            /**
            Get the document root in which the editor exists. This will
            usually be the top-level `document`, but might be a [shadow
            DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
            root if the editor is inside one.
            */
            readonly root: any;
            /**
            Given a pair of viewport coordinates, return the document
            position that corresponds to them. May return null if the given
            coordinates aren't inside of the editor. When an object is
            returned, its `pos` property is the position nearest to the
            coordinates, and its `inside` property holds the position of the
            inner node that the position falls inside of, or -1 if it is at
            the top level, not in any node.
            */
            posAtCoords(coords: any): {
                pos: any;
                inside: number;
            };
            /**
            Returns the viewport rectangle at a given document position.
            `left` and `right` will be the same number, as this returns a
            flat cursor-ish rectangle. If the position is between two things
            that aren't directly adjacent, `side` determines which element
            is used. When < 0, the element before the position is used,
            otherwise the element after.
            */
            coordsAtPos(pos: any, side?: number): any;
            /**
            Find the DOM position that corresponds to the given document
            position. When `side` is negative, find the position as close as
            possible to the content before the position. When positive,
            prefer positions close to the content after the position. When
            zero, prefer as shallow a position as possible.
            
            Note that you should **not** mutate the editor's internal DOM,
            only inspect it (and even that is usually not necessary).
            */
            domAtPos(pos: any, side?: number): any;
            /**
            Find the DOM node that represents the document node after the
            given position. May return `null` when the position doesn't point
            in front of a node or if the node is inside an opaque node view.
            
            This is intended to be able to call things like
            `getBoundingClientRect` on that DOM node. Do **not** mutate the
            editor DOM directly, or add styling this way, since that will be
            immediately overriden by the editor as it redraws the node.
            */
            nodeDOM(pos: any): any;
            /**
            Find the document position that corresponds to a given DOM
            position. (Whenever possible, it is preferable to inspect the
            document structure directly, rather than poking around in the
            DOM, but sometimesâ€”for example when interpreting an event
            targetâ€”you don't have a choice.)
            
            The `bias` parameter can be used to influence which side of a DOM
            node to use when the position is inside a leaf node.
            */
            posAtDOM(node: any, offset: any, bias?: number): any;
            /**
            Find out whether the selection is at the end of a textblock when
            moving in a given direction. When, for example, given `"left"`,
            it will return true if moving left from the current cursor
            position would leave that position's parent textblock. Will apply
            to the view's current state by default, but it is possible to
            pass a different state.
            */
            endOfTextblock(dir: any, state: any): any;
            /**
            Run the editor's paste logic with the given HTML string. The
            `event`, if given, will be passed to the
            [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
            */
            pasteHTML(html: any, event: any): boolean;
            /**
            Run the editor's paste logic with the given plain-text input.
            */
            pasteText(text: any, event: any): boolean;
            /**
            Removes the editor from the DOM and destroys all [node
            views](https://prosemirror.net/docs/ref/#view.NodeView).
            */
            destroy(): void;
            /**
            This is true when the view has been
            [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
            used anymore).
            */
            readonly isDestroyed: boolean;
            /**
            Used for testing.
            */
            dispatchEvent(event: any): void;
            /**
            @internal
            */
            domSelectionRange(): any;
            /**
            @internal
            */
            domSelection(): any;
        }) => boolean;
        /**
         * Whether the current item is active under the given selection or cursor.
         */
        active?: boolean;
    }): boolean;
    /**
     * Handle a button press.
     * @param {MouseEvent} event  The click event.
     * @protected
     */
    protected _onAction(event: MouseEvent): void;
    /**
     * Wrap the editor view element and inject our template ready to be rendered into.
     * @protected
     */
    protected _wrapEditor(): void;
    /**
     * Handle requests to save the editor contents
     * @protected
     */
    protected _handleSave(): any;
    /**
     * Display the insert image prompt.
     * @protected
     */
    protected _insertImagePrompt(): Promise<void>;
    /**
     * Display the insert link prompt.
     * @protected
     */
    protected _insertLinkPrompt(): Promise<void>;
    /**
     * Display the insert table prompt.
     * @protected
     */
    protected _insertTablePrompt(): Promise<void>;
    /**
     * Create a dialog for a menu button.
     * @param {string} action                      The unique menu button action.
     * @param {string} template                    The dialog's template.
     * @param {object} [options]                   Additional options to configure the dialog's behaviour.
     * @param {object} [options.data={}]           Data to pass to the template.
     * @returns {HTMLDialogElement}
     * @protected
     */
    protected _showDialog(action: string, template: string, { data }?: {
        data?: object;
    }): HTMLDialogElement;
    /**
     * Clear any marks from the current selection.
     * @protected
     */
    protected _clearFormatting(): void;
    /**
     * Toggle link recommendations
     * @protected
     */
    protected _toggleMatches(): Promise<void>;
    /**
     * @callback MenuToggleBlockWrapCommand
     * @param {NodeType} node   The node to wrap the selection in.
     * @param {object} [attrs]  Attributes for the node.
     * @returns ProseMirrorCommand
     */
    /**
     * Toggle the given selection by wrapping it in a given block or lifting it out of one.
     * @param {NodeType} node                    The type of node being interacted with.
     * @param {MenuToggleBlockWrapCommand} wrap  The wrap command specific to the given node.
     * @param {object} [options]                 Additional options to configure behaviour.
     * @param {object} [options.attrs]           Attributes for the node.
     * @protected
     */
    protected _toggleBlock(node: {
        attrs: any;
        spec: any;
        map(mapping: any, span: any, offset: any, oldOffset: any): {
            from: any;
            to: any;
            type: any;
            /**
            @internal
            */
            copy(from: any, to: any): any;
            /**
            @internal
            */
            eq(other: any, offset?: number): boolean;
            /**
            @internal
            */
            map(mapping: any, offset: any, oldOffset: any): any;
            /**
            The spec provided when creating this decoration. Can be useful
            if you've stored extra information in that object.
            */
            readonly spec: any;
            /**
            @internal
            */
            readonly inline: boolean;
        };
        valid(node: any, span: any): boolean;
        eq(other: any): boolean;
        destroy(): void;
    }, wrap: (node: {
        attrs: any;
        spec: any;
        map(mapping: any, span: any, offset: any, oldOffset: any): {
            from: any;
            to: any;
            type: any;
            /**
            @internal
            */
            copy(from: any, to: any): any;
            /**
            @internal
            */
            eq(other: any, offset?: number): boolean;
            /**
            @internal
            */
            map(mapping: any, offset: any, oldOffset: any): any;
            /**
            The spec provided when creating this decoration. Can be useful
            if you've stored extra information in that object.
            */
            readonly spec: any;
            /**
            @internal
            */
            readonly inline: boolean;
        };
        valid(node: any, span: any): boolean;
        eq(other: any): boolean;
        destroy(): void;
    }, attrs?: object) => any, { attrs }?: {
        attrs?: object;
    }): void;
    /**
     * Toggle the given selection by wrapping it in a given text block, or reverting to a paragraph block.
     * @param {NodeType} node           The type of node being interacted with.
     * @param {object} [options]        Additional options to configure behaviour.
     * @param {object} [options.attrs]  Attributes for the node.
     * @protected
     */
    protected _toggleTextBlock(node: {
        attrs: any;
        spec: any;
        map(mapping: any, span: any, offset: any, oldOffset: any): {
            from: any;
            to: any;
            type: any;
            /**
            @internal
            */
            copy(from: any, to: any): any;
            /**
            @internal
            */
            eq(other: any, offset?: number): boolean;
            /**
            @internal
            */
            map(mapping: any, offset: any, oldOffset: any): any;
            /**
            The spec provided when creating this decoration. Can be useful
            if you've stored extra information in that object.
            */
            readonly spec: any;
            /**
            @internal
            */
            readonly inline: boolean;
        };
        valid(node: any, span: any): boolean;
        eq(other: any): boolean;
        destroy(): void;
    }, { attrs }?: {
        attrs?: object;
    }): void;
    #private;
}
/**
 * @abstract
 */
export class ProseMirrorPlugin {
    /**
     * Build the plugin.
     * @param {Schema} schema     The ProseMirror schema to build the plugin against.
     * @param {object} [options]  Additional options to pass to the plugin.
     * @returns {Plugin}
     * @abstract
     */
    static build(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    }, options?: object): {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    /**
     * An abstract class for building a ProseMirror Plugin.
     * @see {Plugin}
     * @param {Schema} schema  The schema to build the plugin against.
     */
    constructor(schema: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: any): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    });
}
/**
A document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark
type](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may
occur in conforming documents, and provides functionality for
creating and deserializing such documents.

When given, the type parameters provide the names of the nodes and
marks in this schema.
*/
export class Schema {
    /**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
    constructor(spec: any);
    /**
    An object for storing whatever values modules may want to
    compute and cache per schema. (If you want to store something
    in it, try to use property names unlikely to clash.)
    */
    cached: any;
    spec: {};
    nodes: any;
    marks: any;
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
    nodeFromJSON(json: any): any;
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
    markFromJSON(json: any): any;
    topNodeType: any;
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(type: any, attrs: any, content: any, marks: any): any;
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(text: any, marks: any): {
        text: any;
        toString(): any;
        readonly textContent: any;
        textBetween(from: any, to: any): any;
        readonly nodeSize: any;
        mark(marks: any): any;
        withText(text: any): any;
        cut(from?: number, to?: any): any;
        eq(other: any): boolean;
        toJSON(): {
            type: any;
        };
        type: any;
        attrs: any;
        marks: any[];
        content: any;
        /**
        The number of children that the node has.
        */
        readonly childCount: any;
        /**
        Get the child node at the given index. Raises an error when the
        index is out of range.
        */
        child(index: any): any;
        /**
        Get the child node at the given index, if it exists.
        */
        maybeChild(index: any): any;
        /**
        Call `f` for every child node, passing the node, its offset
        into this parent node, and its index.
        */
        forEach(f: any): void;
        /**
        Invoke a callback for all descendant nodes recursively between
        the given two positions that are relative to start of this
        node's content. The callback is invoked with the node, its
        parent-relative position, its parent node, and its child index.
        When the callback returns false for a given node, that node's
        children will not be recursed over. The last parameter can be
        used to specify a starting position to count from.
        */
        nodesBetween(from: any, to: any, f: any, startPos?: number): void;
        /**
        Call the given callback for every descendant node. Doesn't
        descend into a node when the callback returns `false`.
        */
        descendants(f: any): void;
        /**
        Returns this node's first child, or `null` if there are no
        children.
        */
        readonly firstChild: any;
        /**
        Returns this node's last child, or `null` if there are no
        children.
        */
        readonly lastChild: any;
        /**
        Compare the markup (type, attributes, and marks) of this node to
        those of another. Returns `true` if both have the same markup.
        */
        sameMarkup(other: any): boolean;
        /**
        Check whether this node's markup correspond to the given type,
        attributes, and marks.
        */
        hasMarkup(type: any, attrs: any, marks: any): boolean;
        /**
        Create a new node with the same markup as this node, containing
        the given content (or empty, if no content is given).
        */
        copy(content?: any): {
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The size of this node, as defined by the integer-based [indexing
            scheme](/docs/guide/#doc.indexing). For text nodes, this is the
            amount of characters. For other leaf nodes, it is one. For
            non-leaf nodes, it is the size of the content plus two (the
            start and end token).
            */
            readonly nodeSize: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Concatenates all the text nodes found in this fragment and its
            children.
            */
            readonly textContent: any;
            /**
            Get all text between positions `from` and `to`. When
            `blockSeparator` is given, it will be inserted to separate text
            from different block nodes. If `leafText` is given, it'll be
            inserted for every non-text leaf node encountered, otherwise
            [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
            */
            textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Test whether two nodes represent the same piece of document.
            */
            eq(other: any): any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            copy(content?: any): any;
            /**
            Create a copy of this node, with the given set of marks instead
            of the node's own marks.
            */
            mark(marks: any): any;
            /**
            Create a copy of this node with only the content between the
            given positions. If `to` is not given, it defaults to the end of
            the node.
            */
            cut(from: any, to?: any): any;
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: any): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Return a string representation of this node for debugging
            purposes.
            */
            toString(): any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
            /**
            Return a JSON-serializeable representation of this node.
            */
            toJSON(): {
                type: any;
            };
            text: any;
        };
        /**
        Cut out the part of the document between the given positions, and
        return it as a `Slice` object.
        */
        slice(from: any, to?: any, includeParents?: boolean): {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        };
        /**
        Replace the part of the document between the given positions with
        the given slice. The slice must 'fit', meaning its open sides
        must be able to connect to the surrounding content, and its
        content nodes must be valid children for the node they are placed
        into. If any of this is violated, an error of type
        [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
        */
        replace(from: any, to: any, slice: any): any;
        /**
        Find the node directly after the given position.
        */
        nodeAt(pos: any): any;
        /**
        Find the (direct) child node after the given offset, if any,
        and return it along with its index and offset relative to this
        node.
        */
        childAfter(pos: any): {
            node: any;
            index: any;
            offset: any;
        };
        /**
        Find the (direct) child node before the given offset, if any,
        and return it along with its index and offset relative to this
        node.
        */
        childBefore(pos: any): {
            node: any;
            index: any;
            offset: any;
        };
        /**
        Resolve the given position in the document, returning an
        [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
        */
        resolve(pos: any): any;
        /**
        @internal
        */
        resolveNoCache(pos: any): {
            pos: any;
            path: any;
            parentOffset: any;
            depth: number;
            /**
            @internal
            */
            resolveDepth(val: any): any;
            /**
            The parent node that the position points into. Note that even if
            a position points into a text node, that node is not considered
            the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
            */
            readonly parent: any;
            /**
            The root node in which the position was resolved.
            */
            readonly doc: any;
            /**
            The ancestor node at the given level. `p.node(p.depth)` is the
            same as `p.parent`.
            */
            node(depth: any): any;
            /**
            The index into the ancestor at the given level. If this points
            at the 3rd node in the 2nd paragraph on the top level, for
            example, `p.index(0)` is 1 and `p.index(1)` is 2.
            */
            index(depth: any): any;
            /**
            The index pointing after this position into the ancestor at the
            given level.
            */
            indexAfter(depth: any): any;
            /**
            The (absolute) position at the start of the node at the given
            level.
            */
            start(depth: any): any;
            /**
            The (absolute) position at the end of the node at the given
            level.
            */
            end(depth: any): any;
            /**
            The (absolute) position directly before the wrapping node at the
            given level, or, when `depth` is `this.depth + 1`, the original
            position.
            */
            before(depth: any): any;
            /**
            The (absolute) position directly after the wrapping node at the
            given level, or the original position when `depth` is `this.depth + 1`.
            */
            after(depth: any): any;
            /**
            When this position points into a text node, this returns the
            distance between the position and the start of the text node.
            Will be zero for positions that point between nodes.
            */
            readonly textOffset: number;
            /**
            Get the node directly after the position, if any. If the position
            points into a text node, only the part of that node after the
            position is returned.
            */
            readonly nodeAfter: any;
            /**
            Get the node directly before the position, if any. If the
            position points into a text node, only the part of that node
            before the position is returned.
            */
            readonly nodeBefore: any;
            /**
            Get the position at the given index in the parent node at the
            given depth (which defaults to `this.depth`).
            */
            posAtIndex(index: any, depth: any): any;
            /**
            Get the marks at this position, factoring in the surrounding
            marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
            position is at the start of a non-empty node, the marks of the
            node after it (if any) are returned.
            */
            marks(): any;
            /**
            Get the marks after the current position, if any, except those
            that are non-inclusive and not present at position `$end`. This
            is mostly useful for getting the set of marks to preserve after a
            deletion. Will return `null` if this position is at the end of
            its parent node or its parent node isn't a textblock (in which
            case no marks should be preserved).
            */
            marksAcross($end: any): any;
            /**
            The depth up to which this position and the given (non-resolved)
            position share the same parent nodes.
            */
            sharedDepth(pos: any): number;
            /**
            Returns a range based on the place where this position and the
            given position diverge around block content. If both point into
            the same textblock, for example, a range around that textblock
            will be returned. If they point into different blocks, the range
            around those blocks in their shared ancestor is returned. You can
            pass in an optional predicate that will be called with a parent
            node to see if a range into that parent is acceptable.
            */
            blockRange(other: any, pred: any): any;
            /**
            Query whether the given position shares the same parent node.
            */
            sameParent(other: any): boolean;
            /**
            Return the greater of this and the given position.
            */
            max(other: any): any;
            /**
            Return the smaller of this and the given position.
            */
            min(other: any): any;
            /**
            @internal
            */
            toString(): string;
            /**
             * Determine whether a given position has an ancestor node of the given type.
             * @param {NodeType} other  The other node type.
             * @param {object} [attrs]  An object of attributes that must also match, if provided.
             * @returns {boolean}
             */
            hasAncestor(other: {
                attrs: any;
                spec: any;
                map(mapping: any, span: any, offset: any, oldOffset: any): {
                    from: any;
                    to: any;
                    type: any;
                    /**
                    @internal
                    */
                    copy(from: any, to: any): any;
                    /**
                    @internal
                    */
                    eq(other: any, offset?: number): boolean;
                    /**
                    @internal
                    */
                    map(mapping: any, offset: any, oldOffset: any): any;
                    /**
                    The spec provided when creating this decoration. Can be useful
                    if you've stored extra information in that object.
                    */
                    readonly spec: any;
                    /**
                    @internal
                    */
                    readonly inline: boolean;
                };
                valid(node: any, span: any): boolean;
                eq(other: any): boolean;
                destroy(): void;
            }, attrs?: any): boolean;
        };
        /**
        Test whether a given mark or mark type occurs in this document
        between the two given positions.
        */
        rangeHasMark(from: any, to: any, type: any): boolean;
        /**
        True when this is a block (non-inline node)
        */
        readonly isBlock: any;
        /**
        True when this is a textblock node, a block node with inline
        content.
        */
        readonly isTextblock: any;
        /**
        True when this node allows inline content.
        */
        readonly inlineContent: any;
        /**
        True when this is an inline node (a text node or a node that can
        appear among text).
        */
        readonly isInline: any;
        /**
        True when this is a text node.
        */
        readonly isText: any;
        /**
        True when this is a leaf node.
        */
        readonly isLeaf: any;
        /**
        True when this is an atom, i.e. when it does not have directly
        editable content. This is usually the same as `isLeaf`, but can
        be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
        on a node's spec (typically used when the node is displayed as
        an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
        */
        readonly isAtom: any;
        /**
        Get the content match in this node at the given index.
        */
        contentMatchAt(index: any): any;
        /**
        Test whether replacing the range between `from` and `to` (by
        child index) with the given replacement fragment (which defaults
        to the empty fragment) would leave the node's content valid. You
        can optionally pass `start` and `end` indices into the
        replacement fragment.
        */
        canReplace(from: any, to: any, replacement?: {
            content: any;
            size: any;
            /**
            Invoke a callback for all descendant nodes between the given two
            positions (relative to start of this fragment). Doesn't descend
            into a node when the callback returns `false`.
            */
            nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
            /**
            Call the given callback for every descendant node. `pos` will be
            relative to the start of the fragment. The callback may return
            `false` to prevent traversal of a given node's children.
            */
            descendants(f: any): void;
            /**
            Extract the text between `from` and `to`. See the same method on
            [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
            */
            textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
            /**
            Create a new fragment containing the combined content of this
            fragment and the other.
            */
            append(other: any): any;
            /**
            Cut out the sub-fragment between the two given positions.
            */
            cut(from: any, to?: any): any;
            /**
            @internal
            */
            cutByIndex(from: any, to: any): any;
            /**
            Create a new fragment in which the node at the given index is
            replaced by the given node.
            */
            replaceChild(index: any, node: any): any;
            /**
            Create a new fragment by prepending the given node to this
            fragment.
            */
            addToStart(node: any): any;
            /**
            Create a new fragment by appending the given node to this
            fragment.
            */
            addToEnd(node: any): any;
            /**
            Compare this fragment to another one.
            */
            eq(other: any): boolean;
            /**
            The first child of the fragment, or `null` if it is empty.
            */
            readonly firstChild: any;
            /**
            The last child of the fragment, or `null` if it is empty.
            */
            readonly lastChild: any;
            /**
            The number of child nodes in this fragment.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raise an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Find the first position at which this fragment and another
            fragment differ, or `null` if they are the same.
            */
            findDiffStart(other: any, pos?: number): any;
            /**
            Find the first position, searching from the end, at which this
            fragment and the given fragment differ, or `null` if they are
            the same. Since this position will not be the same in both
            nodes, an object with two separate positions is returned.
            */
            findDiffEnd(other: any, pos?: any, otherPos?: any): any;
            /**
            Find the index and inner offset corresponding to a given relative
            position in this fragment. The result object will be reused
            (overwritten) the next time the function is called. (Not public.)
            */
            findIndex(pos: any, round?: number): {
                index: number;
                offset: number;
            };
            /**
            Return a debugging string that describes this fragment.
            */
            toString(): string;
            /**
            @internal
            */
            toStringInner(): any;
            /**
            Create a JSON-serializeable representation of this fragment.
            */
            toJSON(): any;
        }, start?: number, end?: any): boolean;
        /**
        Test whether replacing the range `from` to `to` (by index) with
        a node of the given type would leave the node's content valid.
        */
        canReplaceWith(from: any, to: any, type: any, marks: any): any;
        /**
        Test whether the given node's content could be appended to this
        node. If that node is empty, this will only return true if there
        is at least one node type that can appear in both nodes (to avoid
        merging completely incompatible nodes).
        */
        canAppend(other: any): any;
        /**
        Check whether this node and its descendants conform to the
        schema, and raise error when they do not.
        */
        check(): void;
    };
    /**
    Create a mark with the given type and attributes.
    */
    mark(type: any, attrs: any): any;
    /**
    @internal
    */
    nodeType(name: any): any;
}
/**
A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document.

New steps are defined by creating classes that extend `Step`,
overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
methods, and registering your class with a unique
JSON-serialization identifier using
[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).
*/
export class Step {
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema: any, json: any): any;
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id: any, stepClass: any): any;
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap(): {
        ranges: any;
        inverted: boolean;
        /**
        @internal
        */
        recover(value: any): any;
        mapResult(pos: any, assoc?: number): any;
        map(pos: any, assoc?: number): any;
        /**
        @internal
        */
        _map(pos: any, assoc: any, simple: any): any;
        /**
        @internal
        */
        touches(pos: any, recover: any): boolean;
        /**
        Calls the given function on each of the changed ranges included in
        this map.
        */
        forEach(f: any): void;
        /**
        Create an inverted version of this map. The result can be used to
        map positions in the post-step document to the pre-step document.
        */
        invert(): any;
        /**
        @internal
        */
        toString(): string;
    };
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other: any): any;
}
declare const TextSelection_base: {
    new ($anchor: any, $head: any, ranges: any): {
        $anchor: any;
        $head: any;
        ranges: any;
        /**
        The selection's anchor, as an unresolved position.
        */
        readonly anchor: any;
        /**
        The selection's head.
        */
        readonly head: any;
        /**
        The lower bound of the selection's main range.
        */
        readonly from: any;
        /**
        The upper bound of the selection's main range.
        */
        readonly to: any;
        /**
        The resolved lower  bound of the selection's main range.
        */
        readonly $from: any;
        /**
        The resolved upper bound of the selection's main range.
        */
        readonly $to: any;
        /**
        Indicates whether the selection contains any content.
        */
        readonly empty: boolean;
        /**
        Get the content of this selection as a slice.
        */
        content(): any;
        /**
        Replace the selection with a slice or, if no slice is given,
        delete the selection. Will append to the given transaction.
        */
        replace(tr: any, content?: {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        }): void;
        /**
        Replace the selection with the given node, appending the changes
        to the given transaction.
        */
        replaceWith(tr: any, node: any): void;
        /**
        Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
        which is a value that can be mapped without having access to a
        current document, and later resolved to a real selection for a
        given document again. (This is used mostly by the history to
        track and restore old selections.) The default implementation of
        this method just converts the selection to a text selection and
        returns the bookmark for that.
        */
        getBookmark(): any;
        visible: boolean;
    };
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    findFrom($pos: any, dir: any, textOnly?: boolean): any;
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    near($pos: any, bias?: number): any;
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    atStart(doc: any): any;
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    atEnd(doc: any): any;
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    fromJSON(doc: any, json: any): any;
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    jsonID(id: any, selectionClass: any): any;
};
/**
A text selection represents a classical editor selection, with a
head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position).
*/
export class TextSelection extends TextSelection_base {
    /**
    @internal
    */
    static fromJSON(doc: any, json: any): {
        /**
        Returns a resolved position if this is a cursor selection (an
        empty text selection), and null otherwise.
        */
        readonly $cursor: any;
        map(doc: any, mapping: any): any;
        replace(tr: any, content?: {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        }): void;
        eq(other: any): boolean;
        getBookmark(): {
            anchor: any;
            head: any;
            map(mapping: any): any;
            resolve(doc: any): any;
        };
        toJSON(): {
            type: string;
            anchor: any;
            head: any;
        };
        $anchor: any;
        $head: any;
        ranges: any;
        /**
        The selection's anchor, as an unresolved position.
        */
        readonly anchor: any;
        /**
        The selection's head.
        */
        readonly head: any;
        /**
        The lower bound of the selection's main range.
        */
        readonly from: any;
        /**
        The upper bound of the selection's main range.
        */
        readonly to: any;
        /**
        The resolved lower  bound of the selection's main range.
        */
        readonly $from: any;
        /**
        The resolved upper bound of the selection's main range.
        */
        readonly $to: any;
        /**
        Indicates whether the selection contains any content.
        */
        readonly empty: boolean;
        /**
        Get the content of this selection as a slice.
        */
        content(): any;
        /**
        Replace the selection with the given node, appending the changes
        to the given transaction.
        */
        replaceWith(tr: any, node: any): void;
        visible: boolean;
    };
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc: any, anchor: any, head?: any): {
        /**
        Returns a resolved position if this is a cursor selection (an
        empty text selection), and null otherwise.
        */
        readonly $cursor: any;
        map(doc: any, mapping: any): any;
        replace(tr: any, content?: {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        }): void;
        eq(other: any): boolean;
        getBookmark(): {
            anchor: any;
            head: any;
            map(mapping: any): any;
            resolve(doc: any): any;
        };
        toJSON(): {
            type: string;
            anchor: any;
            head: any;
        };
        $anchor: any;
        $head: any;
        ranges: any;
        /**
        The selection's anchor, as an unresolved position.
        */
        readonly anchor: any;
        /**
        The selection's head.
        */
        readonly head: any;
        /**
        The lower bound of the selection's main range.
        */
        readonly from: any;
        /**
        The upper bound of the selection's main range.
        */
        readonly to: any;
        /**
        The resolved lower  bound of the selection's main range.
        */
        readonly $from: any;
        /**
        The resolved upper bound of the selection's main range.
        */
        readonly $to: any;
        /**
        Indicates whether the selection contains any content.
        */
        readonly empty: boolean;
        /**
        Get the content of this selection as a slice.
        */
        content(): any;
        /**
        Replace the selection with the given node, appending the changes
        to the given transaction.
        */
        replaceWith(tr: any, node: any): void;
        visible: boolean;
    };
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor: any, $head: any, bias: any): any;
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor: any, $head?: any);
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor(): any;
    map(doc: any, mapping: any): any;
    eq(other: any): boolean;
    getBookmark(): {
        anchor: any;
        head: any;
        map(mapping: any): any;
        resolve(doc: any): any;
    };
    toJSON(): {
        type: string;
        anchor: any;
        head: any;
    };
}
declare var index: Readonly<{
    __proto__: any;
    collab: (config?: {}) => {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    getVersion: (state: any) => any;
    rebaseSteps: (steps: any, over: any, transform: any) => {
        step: any;
        inverted: any;
        origin: any;
    }[];
    receiveTransaction: (state: any, steps: any, clientIDs: any, options?: {}) => any;
    sendableSteps: (state: any) => {
        version: any;
        steps: any;
        clientID: any;
        readonly origins: any;
    };
}>;
declare var index$3: Readonly<{
    __proto__: any;
    autoJoin: (command: any, isJoinable: any) => (state: any, dispatch: any, view: any) => any;
    baseKeymap: {
        Enter: (state: any, dispatch: any, view: any) => boolean;
        "Mod-Enter": (state: any, dispatch: any) => boolean;
        Backspace: (state: any, dispatch: any, view: any) => boolean;
        "Mod-Backspace": (state: any, dispatch: any, view: any) => boolean;
        "Shift-Backspace": (state: any, dispatch: any, view: any) => boolean;
        Delete: (state: any, dispatch: any, view: any) => boolean;
        "Mod-Delete": (state: any, dispatch: any, view: any) => boolean;
        "Mod-a": (state: any, dispatch: any) => boolean;
    } | {
        "Ctrl-h": (state: any, dispatch: any, view: any) => boolean;
        "Alt-Backspace": (state: any, dispatch: any, view: any) => boolean;
        "Ctrl-d": (state: any, dispatch: any, view: any) => boolean;
        "Ctrl-Alt-Backspace": (state: any, dispatch: any, view: any) => boolean;
        "Alt-Delete": (state: any, dispatch: any, view: any) => boolean;
        "Alt-d": (state: any, dispatch: any, view: any) => boolean;
        "Ctrl-a": (state: any, dispatch: any) => boolean;
        "Ctrl-e": (state: any, dispatch: any) => boolean;
    };
    chainCommands: (...commands: any[]) => (state: any, dispatch: any, view: any) => boolean;
    createParagraphNear: (state: any, dispatch: any) => boolean;
    deleteSelection: (state: any, dispatch: any) => boolean;
    exitCode: (state: any, dispatch: any) => boolean;
    joinBackward: (state: any, dispatch: any, view: any) => boolean;
    joinDown: (state: any, dispatch: any) => boolean;
    joinForward: (state: any, dispatch: any, view: any) => boolean;
    joinTextblockBackward: (state: any, dispatch: any, view: any) => boolean;
    joinTextblockForward: (state: any, dispatch: any, view: any) => boolean;
    joinUp: (state: any, dispatch: any) => boolean;
    lift: (state: any, dispatch: any) => boolean;
    liftEmptyBlock: (state: any, dispatch: any) => boolean;
    macBaseKeymap: {
        "Ctrl-h": (state: any, dispatch: any, view: any) => boolean;
        "Alt-Backspace": (state: any, dispatch: any, view: any) => boolean;
        "Ctrl-d": (state: any, dispatch: any, view: any) => boolean;
        "Ctrl-Alt-Backspace": (state: any, dispatch: any, view: any) => boolean;
        "Alt-Delete": (state: any, dispatch: any, view: any) => boolean;
        "Alt-d": (state: any, dispatch: any, view: any) => boolean;
        "Ctrl-a": (state: any, dispatch: any) => boolean;
        "Ctrl-e": (state: any, dispatch: any) => boolean;
    };
    newlineInCode: (state: any, dispatch: any) => boolean;
    pcBaseKeymap: {
        Enter: (state: any, dispatch: any, view: any) => boolean;
        "Mod-Enter": (state: any, dispatch: any) => boolean;
        Backspace: (state: any, dispatch: any, view: any) => boolean;
        "Mod-Backspace": (state: any, dispatch: any, view: any) => boolean;
        "Shift-Backspace": (state: any, dispatch: any, view: any) => boolean;
        Delete: (state: any, dispatch: any, view: any) => boolean;
        "Mod-Delete": (state: any, dispatch: any, view: any) => boolean;
        "Mod-a": (state: any, dispatch: any) => boolean;
    };
    selectAll: (state: any, dispatch: any) => boolean;
    selectNodeBackward: (state: any, dispatch: any, view: any) => boolean;
    selectNodeForward: (state: any, dispatch: any, view: any) => boolean;
    selectParentNode: (state: any, dispatch: any) => boolean;
    selectTextblockEnd: (state: any, dispatch: any) => boolean;
    selectTextblockStart: (state: any, dispatch: any) => boolean;
    setBlockType: (nodeType: any, attrs?: any) => (state: any, dispatch: any) => boolean;
    splitBlock: (state: any, dispatch: any) => boolean;
    splitBlockAs: (splitNode: any) => (state: any, dispatch: any) => boolean;
    splitBlockKeepMarks: (state: any, dispatch: any) => boolean;
    toggleMark: (markType: any, attrs?: any) => (state: any, dispatch: any) => boolean;
    wrapIn: (nodeType: any, attrs?: any) => (state: any, dispatch: any) => boolean;
}>;
export namespace defaultPlugins {
    let inputRules: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let keyMaps: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let menu: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let isDirty: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let clickHandler: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let pasteTransformer: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let baseKeyMap: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let dropCursor: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let gapCursor: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let history: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let columnResizing: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    let tables: {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
}
declare const schema: {
    /**
    An object for storing whatever values modules may want to
    compute and cache per schema. (If you want to store something
    in it, try to use property names unlikely to clash.)
    */
    cached: any;
    spec: {};
    nodes: any;
    marks: any;
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
    nodeFromJSON(json: any): any;
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
    markFromJSON(json: any): any;
    topNodeType: any;
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(type: any, attrs: any, content: any, marks: any): any;
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(text: any, marks: any): {
        text: any;
        toString(): any;
        readonly textContent: any;
        textBetween(from: any, to: any): any;
        readonly nodeSize: any;
        mark(marks: any): any;
        withText(text: any): any;
        cut(from?: number, to?: any): any;
        eq(other: any): boolean;
        toJSON(): {
            type: any;
        };
        type: any;
        attrs: any;
        marks: any[];
        content: any;
        /**
        The number of children that the node has.
        */
        readonly childCount: any;
        /**
        Get the child node at the given index. Raises an error when the
        index is out of range.
        */
        child(index: any): any;
        /**
        Get the child node at the given index, if it exists.
        */
        maybeChild(index: any): any;
        /**
        Call `f` for every child node, passing the node, its offset
        into this parent node, and its index.
        */
        forEach(f: any): void;
        /**
        Invoke a callback for all descendant nodes recursively between
        the given two positions that are relative to start of this
        node's content. The callback is invoked with the node, its
        parent-relative position, its parent node, and its child index.
        When the callback returns false for a given node, that node's
        children will not be recursed over. The last parameter can be
        used to specify a starting position to count from.
        */
        nodesBetween(from: any, to: any, f: any, startPos?: number): void;
        /**
        Call the given callback for every descendant node. Doesn't
        descend into a node when the callback returns `false`.
        */
        descendants(f: any): void;
        /**
        Returns this node's first child, or `null` if there are no
        children.
        */
        readonly firstChild: any;
        /**
        Returns this node's last child, or `null` if there are no
        children.
        */
        readonly lastChild: any;
        /**
        Compare the markup (type, attributes, and marks) of this node to
        those of another. Returns `true` if both have the same markup.
        */
        sameMarkup(other: any): boolean;
        /**
        Check whether this node's markup correspond to the given type,
        attributes, and marks.
        */
        hasMarkup(type: any, attrs: any, marks: any): boolean;
        /**
        Create a new node with the same markup as this node, containing
        the given content (or empty, if no content is given).
        */
        copy(content?: any): {
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The size of this node, as defined by the integer-based [indexing
            scheme](/docs/guide/#doc.indexing). For text nodes, this is the
            amount of characters. For other leaf nodes, it is one. For
            non-leaf nodes, it is the size of the content plus two (the
            start and end token).
            */
            readonly nodeSize: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Concatenates all the text nodes found in this fragment and its
            children.
            */
            readonly textContent: any;
            /**
            Get all text between positions `from` and `to`. When
            `blockSeparator` is given, it will be inserted to separate text
            from different block nodes. If `leafText` is given, it'll be
            inserted for every non-text leaf node encountered, otherwise
            [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
            */
            textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Test whether two nodes represent the same piece of document.
            */
            eq(other: any): any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            copy(content?: any): any;
            /**
            Create a copy of this node, with the given set of marks instead
            of the node's own marks.
            */
            mark(marks: any): any;
            /**
            Create a copy of this node with only the content between the
            given positions. If `to` is not given, it defaults to the end of
            the node.
            */
            cut(from: any, to?: any): any;
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: object): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Return a string representation of this node for debugging
            purposes.
            */
            toString(): any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
            /**
            Return a JSON-serializeable representation of this node.
            */
            toJSON(): {
                type: any;
            };
            text: any;
        };
        /**
        Cut out the part of the document between the given positions, and
        return it as a `Slice` object.
        */
        slice(from: any, to?: any, includeParents?: boolean): {
            content: any;
            openStart: any;
            openEnd: any;
            /**
            The size this slice would add when inserted into a document.
            */
            readonly size: number;
            /**
            @internal
            */
            insertAt(pos: any, fragment: any): any;
            /**
            @internal
            */
            removeBetween(from: any, to: any): any;
            /**
            Tests whether this slice is equal to another slice.
            */
            eq(other: any): boolean;
            /**
            @internal
            */
            toString(): string;
            /**
            Convert a slice to a JSON-serializable representation.
            */
            toJSON(): {
                content: any;
            };
        };
        /**
        Replace the part of the document between the given positions with
        the given slice. The slice must 'fit', meaning its open sides
        must be able to connect to the surrounding content, and its
        content nodes must be valid children for the node they are placed
        into. If any of this is violated, an error of type
        [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
        */
        replace(from: any, to: any, slice: any): any;
        /**
        Find the node directly after the given position.
        */
        nodeAt(pos: any): any;
        /**
        Find the (direct) child node after the given offset, if any,
        and return it along with its index and offset relative to this
        node.
        */
        childAfter(pos: any): {
            node: any;
            index: any;
            offset: any;
        };
        /**
        Find the (direct) child node before the given offset, if any,
        and return it along with its index and offset relative to this
        node.
        */
        childBefore(pos: any): {
            node: any;
            index: any;
            offset: any;
        };
        /**
        Resolve the given position in the document, returning an
        [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
        */
        resolve(pos: any): any;
        /**
        @internal
        */
        resolveNoCache(pos: any): {
            pos: any;
            path: any;
            parentOffset: any;
            depth: number;
            /**
            @internal
            */
            resolveDepth(val: any): any;
            /**
            The parent node that the position points into. Note that even if
            a position points into a text node, that node is not considered
            the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
            */
            readonly parent: any;
            /**
            The root node in which the position was resolved.
            */
            readonly doc: any;
            /**
            The ancestor node at the given level. `p.node(p.depth)` is the
            same as `p.parent`.
            */
            node(depth: any): any;
            /**
            The index into the ancestor at the given level. If this points
            at the 3rd node in the 2nd paragraph on the top level, for
            example, `p.index(0)` is 1 and `p.index(1)` is 2.
            */
            index(depth: any): any;
            /**
            The index pointing after this position into the ancestor at the
            given level.
            */
            indexAfter(depth: any): any;
            /**
            The (absolute) position at the start of the node at the given
            level.
            */
            start(depth: any): any;
            /**
            The (absolute) position at the end of the node at the given
            level.
            */
            end(depth: any): any;
            /**
            The (absolute) position directly before the wrapping node at the
            given level, or, when `depth` is `this.depth + 1`, the original
            position.
            */
            before(depth: any): any;
            /**
            The (absolute) position directly after the wrapping node at the
            given level, or the original position when `depth` is `this.depth + 1`.
            */
            after(depth: any): any;
            /**
            When this position points into a text node, this returns the
            distance between the position and the start of the text node.
            Will be zero for positions that point between nodes.
            */
            readonly textOffset: number;
            /**
            Get the node directly after the position, if any. If the position
            points into a text node, only the part of that node after the
            position is returned.
            */
            readonly nodeAfter: any;
            /**
            Get the node directly before the position, if any. If the
            position points into a text node, only the part of that node
            before the position is returned.
            */
            readonly nodeBefore: any;
            /**
            Get the position at the given index in the parent node at the
            given depth (which defaults to `this.depth`).
            */
            posAtIndex(index: any, depth: any): any;
            /**
            Get the marks at this position, factoring in the surrounding
            marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
            position is at the start of a non-empty node, the marks of the
            node after it (if any) are returned.
            */
            marks(): any;
            /**
            Get the marks after the current position, if any, except those
            that are non-inclusive and not present at position `$end`. This
            is mostly useful for getting the set of marks to preserve after a
            deletion. Will return `null` if this position is at the end of
            its parent node or its parent node isn't a textblock (in which
            case no marks should be preserved).
            */
            marksAcross($end: any): any;
            /**
            The depth up to which this position and the given (non-resolved)
            position share the same parent nodes.
            */
            sharedDepth(pos: any): number;
            /**
            Returns a range based on the place where this position and the
            given position diverge around block content. If both point into
            the same textblock, for example, a range around that textblock
            will be returned. If they point into different blocks, the range
            around those blocks in their shared ancestor is returned. You can
            pass in an optional predicate that will be called with a parent
            node to see if a range into that parent is acceptable.
            */
            blockRange(other: any, pred: any): any;
            /**
            Query whether the given position shares the same parent node.
            */
            sameParent(other: any): boolean;
            /**
            Return the greater of this and the given position.
            */
            max(other: any): any;
            /**
            Return the smaller of this and the given position.
            */
            min(other: any): any;
            /**
            @internal
            */
            toString(): string;
            /**
             * Determine whether a given position has an ancestor node of the given type.
             * @param {NodeType} other  The other node type.
             * @param {object} [attrs]  An object of attributes that must also match, if provided.
             * @returns {boolean}
             */
            hasAncestor(other: {
                attrs: any;
                spec: any;
                map(mapping: any, span: any, offset: any, oldOffset: any): {
                    from: any;
                    to: any;
                    type: any;
                    /**
                    @internal
                    */
                    copy(from: any, to: any): any;
                    /**
                    @internal
                    */
                    eq(other: any, offset?: number): boolean;
                    /**
                    @internal
                    */
                    map(mapping: any, offset: any, oldOffset: any): any;
                    /**
                    The spec provided when creating this decoration. Can be useful
                    if you've stored extra information in that object.
                    */
                    readonly spec: any;
                    /**
                    @internal
                    */
                    readonly inline: boolean;
                };
                valid(node: any, span: any): boolean;
                eq(other: any): boolean;
                destroy(): void;
            }, attrs?: object): boolean;
        };
        /**
        Test whether a given mark or mark type occurs in this document
        between the two given positions.
        */
        rangeHasMark(from: any, to: any, type: any): boolean;
        /**
        True when this is a block (non-inline node)
        */
        readonly isBlock: any;
        /**
        True when this is a textblock node, a block node with inline
        content.
        */
        readonly isTextblock: any;
        /**
        True when this node allows inline content.
        */
        readonly inlineContent: any;
        /**
        True when this is an inline node (a text node or a node that can
        appear among text).
        */
        readonly isInline: any;
        /**
        True when this is a text node.
        */
        readonly isText: any;
        /**
        True when this is a leaf node.
        */
        readonly isLeaf: any;
        /**
        True when this is an atom, i.e. when it does not have directly
        editable content. This is usually the same as `isLeaf`, but can
        be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
        on a node's spec (typically used when the node is displayed as
        an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
        */
        readonly isAtom: any;
        /**
        Get the content match in this node at the given index.
        */
        contentMatchAt(index: any): any;
        /**
        Test whether replacing the range between `from` and `to` (by
        child index) with the given replacement fragment (which defaults
        to the empty fragment) would leave the node's content valid. You
        can optionally pass `start` and `end` indices into the
        replacement fragment.
        */
        canReplace(from: any, to: any, replacement?: {
            content: any;
            size: any;
            /**
            Invoke a callback for all descendant nodes between the given two
            positions (relative to start of this fragment). Doesn't descend
            into a node when the callback returns `false`.
            */
            nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
            /**
            Call the given callback for every descendant node. `pos` will be
            relative to the start of the fragment. The callback may return
            `false` to prevent traversal of a given node's children.
            */
            descendants(f: any): void;
            /**
            Extract the text between `from` and `to`. See the same method on
            [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
            */
            textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
            /**
            Create a new fragment containing the combined content of this
            fragment and the other.
            */
            append(other: any): any;
            /**
            Cut out the sub-fragment between the two given positions.
            */
            cut(from: any, to?: any): any;
            /**
            @internal
            */
            cutByIndex(from: any, to: any): any;
            /**
            Create a new fragment in which the node at the given index is
            replaced by the given node.
            */
            replaceChild(index: any, node: any): any;
            /**
            Create a new fragment by prepending the given node to this
            fragment.
            */
            addToStart(node: any): any;
            /**
            Create a new fragment by appending the given node to this
            fragment.
            */
            addToEnd(node: any): any;
            /**
            Compare this fragment to another one.
            */
            eq(other: any): boolean;
            /**
            The first child of the fragment, or `null` if it is empty.
            */
            readonly firstChild: any;
            /**
            The last child of the fragment, or `null` if it is empty.
            */
            readonly lastChild: any;
            /**
            The number of child nodes in this fragment.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raise an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Find the first position at which this fragment and another
            fragment differ, or `null` if they are the same.
            */
            findDiffStart(other: any, pos?: number): any;
            /**
            Find the first position, searching from the end, at which this
            fragment and the given fragment differ, or `null` if they are
            the same. Since this position will not be the same in both
            nodes, an object with two separate positions is returned.
            */
            findDiffEnd(other: any, pos?: any, otherPos?: any): any;
            /**
            Find the index and inner offset corresponding to a given relative
            position in this fragment. The result object will be reused
            (overwritten) the next time the function is called. (Not public.)
            */
            findIndex(pos: any, round?: number): {
                index: number;
                offset: number;
            };
            /**
            Return a debugging string that describes this fragment.
            */
            toString(): string;
            /**
            @internal
            */
            toStringInner(): any;
            /**
            Create a JSON-serializeable representation of this fragment.
            */
            toJSON(): any;
        }, start?: number, end?: any): boolean;
        /**
        Test whether replacing the range `from` to `to` (by index) with
        a node of the given type would leave the node's content valid.
        */
        canReplaceWith(from: any, to: any, type: any, marks: any): any;
        /**
        Test whether the given node's content could be appended to this
        node. If that node is empty, this will only return true if there
        is at least one node type that can appear in both nodes (to avoid
        merging completely incompatible nodes).
        */
        canAppend(other: any): any;
        /**
        Check whether this node and its descendants conform to the
        schema, and raise error when they do not.
        */
        check(): void;
    };
    /**
    Create a mark with the given type and attributes.
    */
    mark(type: any, attrs: any): any;
    /**
    @internal
    */
    nodeType(name: any): any;
};
export namespace dom {
    export let parser: any;
    export let serializer: any;
    export { parseHTMLString as parseString };
    export { serializeHTMLString as serializeString };
}
declare var index$4: Readonly<{
    __proto__: any;
    InputRule: {
        new (match: any, handler: any): {
            match: any;
            handler: any;
        };
    };
    closeDoubleQuote: {
        match: any;
        handler: any;
    };
    closeSingleQuote: {
        match: any;
        handler: any;
    };
    ellipsis: {
        match: any;
        handler: any;
    };
    emDash: {
        match: any;
        handler: any;
    };
    inputRules: ({ rules }: {
        rules: any;
    }) => {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    openDoubleQuote: {
        match: any;
        handler: any;
    };
    openSingleQuote: {
        match: any;
        handler: any;
    };
    smartQuotes: {
        match: any;
        handler: any;
    }[];
    textblockTypeInputRule: (regexp: any, nodeType: any, getAttrs?: any) => {
        match: any;
        handler: any;
    };
    undoInputRule: (state: any, dispatch: any) => boolean;
    wrappingInputRule: (regexp: any, nodeType: any, getAttrs: any, joinPredicate: any) => {
        match: any;
        handler: any;
    };
}>;
/**
Create a keymap plugin for the given set of bindings.

Bindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style
functions, which will be called with `(EditorState, dispatch,
EditorView)` arguments, and should return true when they've handled
the key. Note that the view argument isn't part of the command
protocol, but can be used as an escape hatch if a binding needs to
directly interact with the UI.

Key names may be strings like `"Shift-Ctrl-Enter"`â€”a key
identifier prefixed with zero or more modifiers. Key identifiers
are based on the strings that can appear in
[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
Use lowercase letters to refer to letter keys (or uppercase letters
if you want shift to be held). You may use `"Space"` as an alias
for the `" "` name.

Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
`Meta-`) are recognized. For characters that are created by holding
shift, the `Shift-` prefix is implied, and should not be added
explicitly.

You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
other platforms.

You can add multiple keymap plugins to an editor. The order in
which they appear determines their precedence (the ones early in
the array get to dispatch first).
*/
export function keymap(bindings: any): {
    spec: any;
    /**
    The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
    */
    props: {};
    key: any;
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state: any): any;
};
declare var index$2: Readonly<{
    __proto__: any;
    addListNodes: (nodes: any, itemContent: any, listGroup: any) => any;
    bulletList: {
        parseDOM: {
            tag: string;
        }[];
        toDOM(): (string | number)[];
    };
    liftListItem: (itemType: any) => (state: any, dispatch: any) => boolean;
    listItem: {
        parseDOM: {
            tag: string;
        }[];
        toDOM(): (string | number)[];
        defining: boolean;
    };
    orderedList: {
        attrs: {
            order: {
                default: number;
            };
        };
        parseDOM: {
            tag: string;
            getAttrs(dom: any): {
                order: number;
            };
        }[];
        toDOM(node: any): (string | number | {
            start: any;
        })[];
    };
    sinkListItem: (itemType: any) => (state: any, dispatch: any) => boolean;
    splitListItem: (itemType: any) => (state: any, dispatch: any) => boolean;
    wrapInList: (listType: any, attrs?: any) => (state: any, dispatch: any) => boolean;
}>;
declare var index$5: Readonly<{
    __proto__: any;
    AllSelection: {
        new (doc: any): {
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            toJSON(): {
                type: string;
            };
            map(doc: any): any;
            eq(other: any): boolean;
            getBookmark(): {
                map(): any;
                resolve(doc: any): any;
            };
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Get the content of this selection as a slice.
            */
            content(): any;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
            visible: boolean;
        };
        /**
        @internal
        */
        fromJSON(doc: any): {
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            toJSON(): {
                type: string;
            };
            map(doc: any): any;
            eq(other: any): boolean;
            getBookmark(): {
                map(): any;
                resolve(doc: any): any;
            };
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Get the content of this selection as a slice.
            */
            content(): any;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
            visible: boolean;
        };
        /**
        Find a valid cursor or leaf node selection starting at the given
        position and searching back if `dir` is negative, and forward if
        positive. When `textOnly` is true, only consider cursor
        selections. Will return null when no valid selection position is
        found.
        */
        findFrom($pos: any, dir: any, textOnly?: boolean): any;
        /**
        Find a valid cursor or leaf node selection near the given
        position. Searches forward first by default, but if `bias` is
        negative, it will search backwards first.
        */
        near($pos: any, bias?: number): any;
        /**
        Find the cursor or leaf node selection closest to the start of
        the given document. Will return an
        [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
        exists.
        */
        atStart(doc: any): any;
        /**
        Find the cursor or leaf node selection closest to the end of the
        given document.
        */
        atEnd(doc: any): any;
        /**
        To be able to deserialize selections from JSON, custom selection
        classes must register themselves with an ID string, so that they
        can be disambiguated. Try to pick something that's unlikely to
        clash with classes from other modules.
        */
        jsonID(id: any, selectionClass: any): any;
    };
    EditorState: {
        new (config: any): {
            config: any;
            /**
            The schema of the state's document.
            */
            readonly schema: any;
            /**
            The plugins that are active in this state.
            */
            readonly plugins: any;
            /**
            Apply the given transaction to produce a new state.
            */
            apply(tr: any): any;
            /**
            @internal
            */
            filterTransaction(tr: any, ignore?: number): boolean;
            /**
            Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
            returns the precise transactions that were applied (which might
            be influenced by the [transaction
            hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
            plugins) along with the new state.
            */
            applyTransaction(rootTr: any): {
                state: any;
                transactions: any[];
            };
            /**
            @internal
            */
            applyInner(tr: any): any;
            /**
            Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
            */
            readonly tr: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            };
            /**
            Create a new state based on this one, but with an adjusted set
            of active plugins. State fields that exist in both sets of
            plugins are kept unchanged. Those that no longer exist are
            dropped, and those that are new are initialized using their
            [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
            configuration object..
            */
            reconfigure(config: any): any;
            /**
            Serialize this state to JSON. If you want to serialize the state
            of plugins, pass an object mapping property names to use in the
            resulting JSON object to plugin objects. The argument may also be
            a string or number, in which case it is ignored, to support the
            way `JSON.stringify` calls `toString` methods.
            */
            toJSON(pluginFields: any): {
                doc: any;
                selection: any;
            };
        };
        /**
        Create a new state.
        */
        create(config: any): {
            config: any;
            /**
            The schema of the state's document.
            */
            readonly schema: any;
            /**
            The plugins that are active in this state.
            */
            readonly plugins: any;
            /**
            Apply the given transaction to produce a new state.
            */
            apply(tr: any): any;
            /**
            @internal
            */
            filterTransaction(tr: any, ignore?: number): boolean;
            /**
            Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
            returns the precise transactions that were applied (which might
            be influenced by the [transaction
            hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
            plugins) along with the new state.
            */
            applyTransaction(rootTr: any): {
                state: any;
                transactions: any[];
            };
            /**
            @internal
            */
            applyInner(tr: any): any;
            /**
            Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
            */
            readonly tr: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            };
            /**
            Create a new state based on this one, but with an adjusted set
            of active plugins. State fields that exist in both sets of
            plugins are kept unchanged. Those that no longer exist are
            dropped, and those that are new are initialized using their
            [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
            configuration object..
            */
            reconfigure(config: any): any;
            /**
            Serialize this state to JSON. If you want to serialize the state
            of plugins, pass an object mapping property names to use in the
            resulting JSON object to plugin objects. The argument may also be
            a string or number, in which case it is ignored, to support the
            way `JSON.stringify` calls `toString` methods.
            */
            toJSON(pluginFields: any): {
                doc: any;
                selection: any;
            };
        };
        /**
        Deserialize a JSON representation of a state. `config` should
        have at least a `schema` field, and should contain array of
        plugins to initialize the state with. `pluginFields` can be used
        to deserialize the state of plugins, by associating plugin
        instances with the property names they use in the JSON object.
        */
        fromJSON(config: any, json: any, pluginFields: any): {
            config: any;
            /**
            The schema of the state's document.
            */
            readonly schema: any;
            /**
            The plugins that are active in this state.
            */
            readonly plugins: any;
            /**
            Apply the given transaction to produce a new state.
            */
            apply(tr: any): any;
            /**
            @internal
            */
            filterTransaction(tr: any, ignore?: number): boolean;
            /**
            Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
            returns the precise transactions that were applied (which might
            be influenced by the [transaction
            hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
            plugins) along with the new state.
            */
            applyTransaction(rootTr: any): {
                state: any;
                transactions: any[];
            };
            /**
            @internal
            */
            applyInner(tr: any): any;
            /**
            Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
            */
            readonly tr: {
                curSelectionFor: number;
                updated: number;
                meta: any;
                time: number;
                curSelection: any;
                storedMarks: any;
                /**
                The transaction's current selection. This defaults to the editor
                selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
                transaction, but can be overwritten with
                [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
                */
                readonly selection: any;
                /**
                Update the transaction's current selection. Will determine the
                selection that the editor gets when the transaction is applied.
                */
                setSelection(selection: any): any;
                /**
                Whether the selection was explicitly updated by this transaction.
                */
                readonly selectionSet: boolean;
                /**
                Set the current stored marks.
                */
                setStoredMarks(marks: any): any;
                /**
                Make sure the current stored marks or, if that is null, the marks
                at the selection, match the given set of marks. Does nothing if
                this is already the case.
                */
                ensureMarks(marks: any): any;
                /**
                Add a mark to the set of stored marks.
                */
                addStoredMark(mark: any): any;
                /**
                Remove a mark or mark type from the set of stored marks.
                */
                removeStoredMark(mark: any): any;
                /**
                Whether the stored marks were explicitly set for this transaction.
                */
                readonly storedMarksSet: boolean;
                /**
                @internal
                */
                addStep(step: any, doc: any): void;
                /**
                Update the timestamp for the transaction.
                */
                setTime(time: any): any;
                /**
                Replace the current selection with the given slice.
                */
                replaceSelection(slice: any): any;
                /**
                Replace the selection with the given node. When `inheritMarks` is
                true and the content is inline, it inherits the marks from the
                place where it is inserted.
                */
                replaceSelectionWith(node: any, inheritMarks?: boolean): any;
                /**
                Delete the selection.
                */
                deleteSelection(): any;
                /**
                Replace the given range, or the selection if no range is given,
                with a text node containing the given string.
                */
                insertText(text: any, from: any, to: any): any;
                /**
                Store a metadata property in this transaction, keyed either by
                name or by plugin.
                */
                setMeta(key: any, value: any): any;
                /**
                Retrieve a metadata property for a given name or plugin.
                */
                getMeta(key: any): any;
                /**
                Returns true if this transaction doesn't contain any metadata,
                and can thus safely be extended.
                */
                readonly isGeneric: boolean;
                /**
                Indicate that the editor should scroll the selection into view
                when updated to the state produced by this transaction.
                */
                scrollIntoView(): any;
                /**
                True when this transaction has had `scrollIntoView` called on it.
                */
                readonly scrolledIntoView: boolean;
                doc: any;
                /**
                The steps in this transform.
                */
                steps: any[];
                /**
                The documents before each of the steps.
                */
                docs: any[];
                /**
                A mapping with the maps for each of the steps in this transform.
                */
                mapping: {
                    maps: any[];
                    mirror: any;
                    from: number;
                    to: number;
                    /**
                    Create a mapping that maps only through a part of this one.
                    */
                    slice(from?: number, to?: number): any;
                    /**
                    @internal
                    */
                    copy(): any;
                    /**
                    Add a step map to the end of this mapping. If `mirrors` is
                    given, it should be the index of the step map that is the mirror
                    image of this one.
                    */
                    appendMap(map: any, mirrors: any): void;
                    /**
                    Add all the step maps in a given mapping to this one (preserving
                    mirroring information).
                    */
                    appendMapping(mapping: any): void;
                    /**
                    Finds the offset of the step map that mirrors the map at the
                    given offset, in this mapping (as per the second argument to
                    `appendMap`).
                    */
                    getMirror(n: any): any;
                    /**
                    @internal
                    */
                    setMirror(n: any, m: any): void;
                    /**
                    Append the inverse of the given mapping to this one.
                    */
                    appendMappingInverted(mapping: any): void;
                    /**
                    Create an inverted version of this mapping.
                    */
                    invert(): any;
                    /**
                    Map a position through this mapping.
                    */
                    map(pos: any, assoc?: number): any;
                    /**
                    Map a position through this mapping, returning a mapping
                    result.
                    */
                    mapResult(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                };
                /**
                The starting document.
                */
                readonly before: any;
                /**
                Apply a new step in this transform, saving the result. Throws an
                error when the step fails.
                */
                step(step: any): any;
                /**
                Try to apply a step in this transformation, ignoring it if it
                fails. Returns the step result.
                */
                maybeStep(step: any): any;
                /**
                True when the document has been changed (when there are any
                steps).
                */
                readonly docChanged: boolean;
                /**
                Replace the part of the document between `from` and `to` with the
                given `slice`.
                */
                replace(from: any, to?: any, slice?: {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                }): any;
                /**
                Replace the given range with the given content, which may be a
                fragment, node, or array of nodes.
                */
                replaceWith(from: any, to: any, content: any): any;
                /**
                Delete the content between the given positions.
                */
                delete(from: any, to: any): any;
                /**
                Insert the given content at the given position.
                */
                insert(pos: any, content: any): any;
                /**
                Replace a range of the document with a given slice, using
                `from`, `to`, and the slice's
                [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
                than fixed start and end points. This method may grow the
                replaced area or close open nodes in the slice in order to get a
                fit that is more in line with WYSIWYG expectations, by dropping
                fully covered parent nodes of the replaced region when they are
                marked [non-defining as
                context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
                open parent node from the slice that _is_ marked as [defining
                its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
                
                This is the method, for example, to handle paste. The similar
                [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
                primitive tool which will _not_ move the start and end of its given
                range, and is useful in situations where you need more precise
                control over what happens.
                */
                replaceRange(from: any, to: any, slice: any): any;
                /**
                Replace the given range with a node, but use `from` and `to` as
                hints, rather than precise positions. When from and to are the same
                and are at the start or end of a parent node in which the given
                node doesn't fit, this method may _move_ them out towards a parent
                that does allow the given node to be placed. When the given range
                completely covers a parent node, this method may completely replace
                that parent node.
                */
                replaceRangeWith(from: any, to: any, node: any): any;
                /**
                Delete the given range, expanding it to cover fully covered
                parent nodes until a valid replace is found.
                */
                deleteRange(from: any, to: any): any;
                /**
                Split the content in the given range off from its parent, if there
                is sibling content before or after it, and move it up the tree to
                the depth specified by `target`. You'll probably want to use
                [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
                sure the lift is valid.
                */
                lift(range: any, target: any): any;
                /**
                Join the blocks around the given position. If depth is 2, their
                last and first siblings are also joined, and so on.
                */
                join(pos: any, depth?: number): any;
                /**
                Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
                The wrappers are assumed to be valid in this position, and should
                probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
                */
                wrap(range: any, wrappers: any): any;
                /**
                Set the type of all textblocks (partly) between `from` and `to` to
                the given node type with the given attributes.
                */
                setBlockType(from: any, to: any, type: any, attrs?: any): any;
                /**
                Change the type, attributes, and/or marks of the node at `pos`.
                When `type` isn't given, the existing node type is preserved,
                */
                setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
                /**
                Set a single attribute on a given node to a new value.
                */
                setNodeAttribute(pos: any, attr: any, value: any): any;
                /**
                Add a mark to the node at position `pos`.
                */
                addNodeMark(pos: any, mark: any): any;
                /**
                Remove a mark (or a mark of the given type) from the node at
                position `pos`.
                */
                removeNodeMark(pos: any, mark: any): any;
                /**
                Split the node at the given position, and optionally, if `depth` is
                greater than one, any number of nodes above that. By default, the
                parts split off will inherit the node type of the original node.
                This can be changed by passing an array of types and attributes to
                use after the split.
                */
                split(pos: any, depth: number, typesAfter: any): any;
                /**
                Add the given mark to the inline content between `from` and `to`.
                */
                addMark(from: any, to: any, mark: any): any;
                /**
                Remove marks from inline nodes between `from` and `to`. When
                `mark` is a single mark, remove precisely that mark. When it is
                a mark type, remove all marks of that type. When it is null,
                remove all marks of any type.
                */
                removeMark(from: any, to: any, mark: any): any;
                /**
                Removes all marks and nodes from the content of the node at
                `pos` that don't match the given new parent node type. Accepts
                an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
                third argument.
                */
                clearIncompatible(pos: any, parentType: any, match: any): any;
            };
            /**
            Create a new state based on this one, but with an adjusted set
            of active plugins. State fields that exist in both sets of
            plugins are kept unchanged. Those that no longer exist are
            dropped, and those that are new are initialized using their
            [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
            configuration object..
            */
            reconfigure(config: any): any;
            /**
            Serialize this state to JSON. If you want to serialize the state
            of plugins, pass an object mapping property names to use in the
            resulting JSON object to plugin objects. The argument may also be
            a string or number, in which case it is ignored, to support the
            way `JSON.stringify` calls `toString` methods.
            */
            toJSON(pluginFields: any): {
                doc: any;
                selection: any;
            };
        };
    };
    NodeSelection: {
        new ($pos: any): {
            node: any;
            map(doc: any, mapping: any): any;
            content(): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            eq(other: any): boolean;
            toJSON(): {
                type: string;
                anchor: any;
            };
            getBookmark(): {
                anchor: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            visible: boolean;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Replace the selection with a slice or, if no slice is given,
            delete the selection. Will append to the given transaction.
            */
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
        };
        /**
        @internal
        */
        fromJSON(doc: any, json: any): {
            node: any;
            map(doc: any, mapping: any): any;
            content(): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            eq(other: any): boolean;
            toJSON(): {
                type: string;
                anchor: any;
            };
            getBookmark(): {
                anchor: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            visible: boolean;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Replace the selection with a slice or, if no slice is given,
            delete the selection. Will append to the given transaction.
            */
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
        };
        /**
        Create a node selection from non-resolved positions.
        */
        create(doc: any, from: any): {
            node: any;
            map(doc: any, mapping: any): any;
            content(): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            eq(other: any): boolean;
            toJSON(): {
                type: string;
                anchor: any;
            };
            getBookmark(): {
                anchor: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            visible: boolean;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Replace the selection with a slice or, if no slice is given,
            delete the selection. Will append to the given transaction.
            */
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
        };
        /**
        Determines whether the given node may be selected as a node
        selection.
        */
        isSelectable(node: any): boolean;
        /**
        Find a valid cursor or leaf node selection starting at the given
        position and searching back if `dir` is negative, and forward if
        positive. When `textOnly` is true, only consider cursor
        selections. Will return null when no valid selection position is
        found.
        */
        findFrom($pos: any, dir: any, textOnly?: boolean): any;
        /**
        Find a valid cursor or leaf node selection near the given
        position. Searches forward first by default, but if `bias` is
        negative, it will search backwards first.
        */
        near($pos: any, bias?: number): any;
        /**
        Find the cursor or leaf node selection closest to the start of
        the given document. Will return an
        [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
        exists.
        */
        atStart(doc: any): any;
        /**
        Find the cursor or leaf node selection closest to the end of the
        given document.
        */
        atEnd(doc: any): any;
        /**
        To be able to deserialize selections from JSON, custom selection
        classes must register themselves with an ID string, so that they
        can be disambiguated. Try to pick something that's unlikely to
        clash with classes from other modules.
        */
        jsonID(id: any, selectionClass: any): any;
    };
    Plugin: {
        new (spec: any): {
            spec: any;
            /**
            The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
            */
            props: {};
            key: any;
            /**
            Extract the plugin's state field from an editor state.
            */
            getState(state: any): any;
        };
    };
    PluginKey: {
        new (name?: string): {
            key: string;
            /**
            Get the active plugin with this key, if any, from an editor
            state.
            */
            get(state: any): any;
            /**
            Get the plugin's state from an editor state.
            */
            getState(state: any): any;
        };
    };
    Selection: {
        new ($anchor: any, $head: any, ranges: any): {
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Get the content of this selection as a slice.
            */
            content(): any;
            /**
            Replace the selection with a slice or, if no slice is given,
            delete the selection. Will append to the given transaction.
            */
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
            /**
            Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
            which is a value that can be mapped without having access to a
            current document, and later resolved to a real selection for a
            given document again. (This is used mostly by the history to
            track and restore old selections.) The default implementation of
            this method just converts the selection to a text selection and
            returns the bookmark for that.
            */
            getBookmark(): any;
            visible: boolean;
        };
        /**
        Find a valid cursor or leaf node selection starting at the given
        position and searching back if `dir` is negative, and forward if
        positive. When `textOnly` is true, only consider cursor
        selections. Will return null when no valid selection position is
        found.
        */
        findFrom($pos: any, dir: any, textOnly?: boolean): any;
        /**
        Find a valid cursor or leaf node selection near the given
        position. Searches forward first by default, but if `bias` is
        negative, it will search backwards first.
        */
        near($pos: any, bias?: number): any;
        /**
        Find the cursor or leaf node selection closest to the start of
        the given document. Will return an
        [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
        exists.
        */
        atStart(doc: any): any;
        /**
        Find the cursor or leaf node selection closest to the end of the
        given document.
        */
        atEnd(doc: any): any;
        /**
        Deserialize the JSON representation of a selection. Must be
        implemented for custom classes (as a static class method).
        */
        fromJSON(doc: any, json: any): any;
        /**
        To be able to deserialize selections from JSON, custom selection
        classes must register themselves with an ID string, so that they
        can be disambiguated. Try to pick something that's unlikely to
        clash with classes from other modules.
        */
        jsonID(id: any, selectionClass: any): any;
    };
    SelectionRange: {
        new ($from: any, $to: any): {
            $from: any;
            $to: any;
        };
    };
    TextSelection: {
        new ($anchor: any, $head?: any): {
            /**
            Returns a resolved position if this is a cursor selection (an
            empty text selection), and null otherwise.
            */
            readonly $cursor: any;
            map(doc: any, mapping: any): any;
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            eq(other: any): boolean;
            getBookmark(): {
                anchor: any;
                head: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            toJSON(): {
                type: string;
                anchor: any;
                head: any;
            };
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Get the content of this selection as a slice.
            */
            content(): any;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
            visible: boolean;
        };
        /**
        @internal
        */
        fromJSON(doc: any, json: any): {
            /**
            Returns a resolved position if this is a cursor selection (an
            empty text selection), and null otherwise.
            */
            readonly $cursor: any;
            map(doc: any, mapping: any): any;
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            eq(other: any): boolean;
            getBookmark(): {
                anchor: any;
                head: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            toJSON(): {
                type: string;
                anchor: any;
                head: any;
            };
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Get the content of this selection as a slice.
            */
            content(): any;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
            visible: boolean;
        };
        /**
        Create a text selection from non-resolved positions.
        */
        create(doc: any, anchor: any, head?: any): {
            /**
            Returns a resolved position if this is a cursor selection (an
            empty text selection), and null otherwise.
            */
            readonly $cursor: any;
            map(doc: any, mapping: any): any;
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            eq(other: any): boolean;
            getBookmark(): {
                anchor: any;
                head: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            toJSON(): {
                type: string;
                anchor: any;
                head: any;
            };
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
            /**
            Get the content of this selection as a slice.
            */
            content(): any;
            /**
            Replace the selection with the given node, appending the changes
            to the given transaction.
            */
            replaceWith(tr: any, node: any): void;
            visible: boolean;
        };
        /**
        Return a text selection that spans the given positions or, if
        they aren't text positions, find a text selection near them.
        `bias` determines whether the method searches forward (default)
        or backwards (negative number) first. Will fall back to calling
        [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
        doesn't contain a valid text position.
        */
        between($anchor: any, $head: any, bias: any): any;
        /**
        Find a valid cursor or leaf node selection starting at the given
        position and searching back if `dir` is negative, and forward if
        positive. When `textOnly` is true, only consider cursor
        selections. Will return null when no valid selection position is
        found.
        */
        findFrom($pos: any, dir: any, textOnly?: boolean): any;
        /**
        Find a valid cursor or leaf node selection near the given
        position. Searches forward first by default, but if `bias` is
        negative, it will search backwards first.
        */
        near($pos: any, bias?: number): any;
        /**
        Find the cursor or leaf node selection closest to the start of
        the given document. Will return an
        [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
        exists.
        */
        atStart(doc: any): any;
        /**
        Find the cursor or leaf node selection closest to the end of the
        given document.
        */
        atEnd(doc: any): any;
        /**
        To be able to deserialize selections from JSON, custom selection
        classes must register themselves with an ID string, so that they
        can be disambiguated. Try to pick something that's unlikely to
        clash with classes from other modules.
        */
        jsonID(id: any, selectionClass: any): any;
    };
    Transaction: {
        new (state: any): {
            curSelectionFor: number;
            updated: number;
            meta: any;
            time: number;
            curSelection: any;
            storedMarks: any;
            /**
            The transaction's current selection. This defaults to the editor
            selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
            transaction, but can be overwritten with
            [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
            */
            readonly selection: any;
            /**
            Update the transaction's current selection. Will determine the
            selection that the editor gets when the transaction is applied.
            */
            setSelection(selection: any): any;
            /**
            Whether the selection was explicitly updated by this transaction.
            */
            readonly selectionSet: boolean;
            /**
            Set the current stored marks.
            */
            setStoredMarks(marks: any): any;
            /**
            Make sure the current stored marks or, if that is null, the marks
            at the selection, match the given set of marks. Does nothing if
            this is already the case.
            */
            ensureMarks(marks: any): any;
            /**
            Add a mark to the set of stored marks.
            */
            addStoredMark(mark: any): any;
            /**
            Remove a mark or mark type from the set of stored marks.
            */
            removeStoredMark(mark: any): any;
            /**
            Whether the stored marks were explicitly set for this transaction.
            */
            readonly storedMarksSet: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Update the timestamp for the transaction.
            */
            setTime(time: any): any;
            /**
            Replace the current selection with the given slice.
            */
            replaceSelection(slice: any): any;
            /**
            Replace the selection with the given node. When `inheritMarks` is
            true and the content is inline, it inherits the marks from the
            place where it is inserted.
            */
            replaceSelectionWith(node: any, inheritMarks?: boolean): any;
            /**
            Delete the selection.
            */
            deleteSelection(): any;
            /**
            Replace the given range, or the selection if no range is given,
            with a text node containing the given string.
            */
            insertText(text: any, from: any, to: any): any;
            /**
            Store a metadata property in this transaction, keyed either by
            name or by plugin.
            */
            setMeta(key: any, value: any): any;
            /**
            Retrieve a metadata property for a given name or plugin.
            */
            getMeta(key: any): any;
            /**
            Returns true if this transaction doesn't contain any metadata,
            and can thus safely be extended.
            */
            readonly isGeneric: boolean;
            /**
            Indicate that the editor should scroll the selection into view
            when updated to the state produced by this transaction.
            */
            scrollIntoView(): any;
            /**
            True when this transaction has had `scrollIntoView` called on it.
            */
            readonly scrolledIntoView: boolean;
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        };
    };
}>;
declare var index$1: Readonly<{
    __proto__: any;
    CellBookmark: {
        new (anchor: any, head: any): {
            anchor: any;
            head: any;
            map(mapping: any): any;
            resolve(doc: any): any;
        };
    };
    CellSelection: {
        new ($anchorCell: any, $headCell?: any): {
            $anchorCell: any;
            $headCell: any;
            map(doc: any, mapping: any): any;
            content(): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            replaceWith(tr: any, node: any): void;
            forEachCell(f: any): void;
            isColSelection(): boolean;
            isRowSelection(): boolean;
            eq(other: any): boolean;
            toJSON(): {
                type: string;
                anchor: any;
                head: any;
            };
            getBookmark(): {
                anchor: any;
                head: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            visible: boolean;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
        };
        colSelection($anchorCell: any, $headCell?: any): {
            $anchorCell: any;
            $headCell: any;
            map(doc: any, mapping: any): any;
            content(): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            replaceWith(tr: any, node: any): void;
            forEachCell(f: any): void;
            isColSelection(): boolean;
            isRowSelection(): boolean;
            eq(other: any): boolean;
            toJSON(): {
                type: string;
                anchor: any;
                head: any;
            };
            getBookmark(): {
                anchor: any;
                head: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            visible: boolean;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
        };
        rowSelection($anchorCell: any, $headCell?: any): {
            $anchorCell: any;
            $headCell: any;
            map(doc: any, mapping: any): any;
            content(): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            replaceWith(tr: any, node: any): void;
            forEachCell(f: any): void;
            isColSelection(): boolean;
            isRowSelection(): boolean;
            eq(other: any): boolean;
            toJSON(): {
                type: string;
                anchor: any;
                head: any;
            };
            getBookmark(): {
                anchor: any;
                head: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            visible: boolean;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
        };
        fromJSON(doc: any, json: any): {
            $anchorCell: any;
            $headCell: any;
            map(doc: any, mapping: any): any;
            content(): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            replaceWith(tr: any, node: any): void;
            forEachCell(f: any): void;
            isColSelection(): boolean;
            isRowSelection(): boolean;
            eq(other: any): boolean;
            toJSON(): {
                type: string;
                anchor: any;
                head: any;
            };
            getBookmark(): {
                anchor: any;
                head: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            visible: boolean;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
        };
        create(doc: any, anchorCell: any, headCell?: any): {
            $anchorCell: any;
            $headCell: any;
            map(doc: any, mapping: any): any;
            content(): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            replace(tr: any, content?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): void;
            replaceWith(tr: any, node: any): void;
            forEachCell(f: any): void;
            isColSelection(): boolean;
            isRowSelection(): boolean;
            eq(other: any): boolean;
            toJSON(): {
                type: string;
                anchor: any;
                head: any;
            };
            getBookmark(): {
                anchor: any;
                head: any;
                map(mapping: any): any;
                resolve(doc: any): any;
            };
            visible: boolean;
            $anchor: any;
            $head: any;
            ranges: any;
            /**
            The selection's anchor, as an unresolved position.
            */
            readonly anchor: any;
            /**
            The selection's head.
            */
            readonly head: any;
            /**
            The lower bound of the selection's main range.
            */
            readonly from: any;
            /**
            The upper bound of the selection's main range.
            */
            readonly to: any;
            /**
            The resolved lower  bound of the selection's main range.
            */
            readonly $from: any;
            /**
            The resolved upper bound of the selection's main range.
            */
            readonly $to: any;
            /**
            Indicates whether the selection contains any content.
            */
            readonly empty: boolean;
        };
        /**
        Find a valid cursor or leaf node selection starting at the given
        position and searching back if `dir` is negative, and forward if
        positive. When `textOnly` is true, only consider cursor
        selections. Will return null when no valid selection position is
        found.
        */
        findFrom($pos: any, dir: any, textOnly?: boolean): any;
        /**
        Find a valid cursor or leaf node selection near the given
        position. Searches forward first by default, but if `bias` is
        negative, it will search backwards first.
        */
        near($pos: any, bias?: number): any;
        /**
        Find the cursor or leaf node selection closest to the start of
        the given document. Will return an
        [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
        exists.
        */
        atStart(doc: any): any;
        /**
        Find the cursor or leaf node selection closest to the end of the
        given document.
        */
        atEnd(doc: any): any;
        /**
        To be able to deserialize selections from JSON, custom selection
        classes must register themselves with an ID string, so that they
        can be disambiguated. Try to pick something that's unlikely to
        clash with classes from other modules.
        */
        jsonID(id: any, selectionClass: any): any;
    };
    ResizeState: {
        new (activeHandle: any, dragging: any): {
            activeHandle: any;
            dragging: any;
            apply(tr: any): any;
        };
    };
    TableMap: {
        new (width: any, height: any, map: any, problems: any): {
            width: any;
            height: any;
            map: any;
            problems: any;
            findCell(pos: any): {
                left: number;
                top: number;
                right: number;
                bottom: number;
            };
            colCount(pos: any): number;
            nextCell(pos: any, axis: any, dir: any): any;
            rectBetween(a: any, b: any): {
                left: number;
                top: number;
                right: number;
                bottom: number;
            };
            cellsInRect(rect: any): any[];
            positionAt(row: any, col: any, table: any): any;
        };
        get(table: any): any;
    };
    TableView: {
        new (node: any, cellMinWidth: any): {
            node: any;
            cellMinWidth: any;
            dom: HTMLDivElement;
            table: HTMLTableElement;
            colgroup: HTMLTableColElement;
            contentDOM: HTMLTableSectionElement;
            update(node: any): boolean;
            ignoreMutation(record: any): boolean;
        };
    };
    __clipCells: ({ width, height, rows }: {
        width: any;
        height: any;
        rows: any;
    }, newWidth: any, newHeight: any) => {
        width: any;
        height: any;
        rows: any;
    };
    __insertCells: (state: any, dispatch: any, tableStart: any, rect: any, cells: any) => void;
    __pastedCells: (slice: any) => {
        height: any;
        width: number;
        rows: any;
    };
    addColSpan: (attrs: any, pos: any, n?: number) => any;
    addColumn: (tr: any, { map, tableStart, table }: {
        map: any;
        tableStart: any;
        table: any;
    }, col: any) => any;
    addColumnAfter: (state: any, dispatch: any) => boolean;
    addColumnBefore: (state: any, dispatch: any) => boolean;
    addRow: (tr: any, { map, tableStart, table }: {
        map: any;
        tableStart: any;
        table: any;
    }, row: any) => any;
    addRowAfter: (state: any, dispatch: any) => boolean;
    addRowBefore: (state: any, dispatch: any) => boolean;
    cellAround: ($pos: any) => any;
    colCount: ($pos: any) => any;
    columnIsHeader: (map: any, table: any, col: any) => boolean;
    columnResizing: ({ handleWidth, cellMinWidth, View, lastColumnResizable }?: {
        handleWidth?: number;
        cellMinWidth?: number;
        View?: {
            new (node: any, cellMinWidth: any): {
                node: any;
                cellMinWidth: any;
                dom: HTMLDivElement;
                table: HTMLTableElement;
                colgroup: HTMLTableColElement;
                contentDOM: HTMLTableSectionElement;
                update(node: any): boolean;
                ignoreMutation(record: any): boolean;
            };
        };
        lastColumnResizable?: boolean;
    }) => {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    columnResizingPluginKey: {
        key: string;
        /**
        Get the active plugin with this key, if any, from an editor
        state.
        */
        get(state: any): any;
        /**
        Get the plugin's state from an editor state.
        */
        getState(state: any): any;
    };
    deleteColumn: (state: any, dispatch: any) => boolean;
    deleteRow: (state: any, dispatch: any) => boolean;
    deleteTable: (state: any, dispatch: any) => boolean;
    findCell: ($pos: any) => any;
    fixTables: (state: any, oldState: any) => undefined;
    fixTablesKey: {
        key: string;
        /**
        Get the active plugin with this key, if any, from an editor
        state.
        */
        get(state: any): any;
        /**
        Get the plugin's state from an editor state.
        */
        getState(state: any): any;
    };
    goToNextCell: (direction: any) => (state: any, dispatch: any) => boolean;
    handlePaste: (view: any, _: any, slice: any) => boolean;
    inSameTable: ($cellA: any, $cellB: any) => boolean;
    isInTable: (state: any) => boolean;
    mergeCells: (state: any, dispatch: any) => boolean;
    moveCellForward: ($pos: any) => any;
    nextCell: ($pos: any, axis: any, dir: any) => any;
    pointsAtCell: ($pos: any) => boolean;
    removeColSpan: (attrs: any, pos: any, n?: number) => any;
    removeColumn: (tr: any, { map, table, tableStart }: {
        map: any;
        table: any;
        tableStart: any;
    }, col: any) => void;
    removeRow: (tr: any, { map, table, tableStart }: {
        map: any;
        table: any;
        tableStart: any;
    }, row: any) => void;
    rowIsHeader: (map: any, table: any, row: any) => boolean;
    selectedRect: (state: any) => any;
    selectionCell: (state: any) => any;
    setCellAttr: (name: any, value: any) => (state: any, dispatch: any) => boolean;
    splitCell: (state: any, dispatch: any) => boolean;
    splitCellWithType: (getCellType: any) => (state: any, dispatch: any) => boolean;
    tableEditing: ({ allowTableNodeSelection }?: {
        allowTableNodeSelection?: boolean;
    }) => {
        spec: any;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        props: {};
        key: any;
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state: any): any;
    };
    tableEditingKey: {
        key: string;
        /**
        Get the active plugin with this key, if any, from an editor
        state.
        */
        get(state: any): any;
        /**
        Get the plugin's state from an editor state.
        */
        getState(state: any): any;
    };
    tableNodeTypes: (schema: any) => any;
    tableNodes: (options: any) => {
        table: {
            content: string;
            tableRole: string;
            isolating: boolean;
            group: any;
            parseDOM: {
                tag: string;
            }[];
            toDOM(): (string | (string | number)[])[];
        };
        table_row: {
            content: string;
            tableRole: string;
            parseDOM: {
                tag: string;
            }[];
            toDOM(): (string | number)[];
        };
        table_cell: {
            content: any;
            attrs: {
                colspan: {
                    default: number;
                };
                rowspan: {
                    default: number;
                };
                colwidth: {
                    default: any;
                };
            };
            tableRole: string;
            isolating: boolean;
            parseDOM: {
                tag: string;
                getAttrs: (dom: any) => {};
            }[];
            toDOM(node: any): (string | number | {
                colspan: any;
                rowspan: any;
                "data-colwidth": any;
            })[];
        };
        table_header: {
            content: any;
            attrs: {
                colspan: {
                    default: number;
                };
                rowspan: {
                    default: number;
                };
                colwidth: {
                    default: any;
                };
            };
            tableRole: string;
            isolating: boolean;
            parseDOM: {
                tag: string;
                getAttrs: (dom: any) => {};
            }[];
            toDOM(node: any): (string | number | {
                colspan: any;
                rowspan: any;
                "data-colwidth": any;
            })[];
        };
    };
    toggleHeader: (type: any, options: any) => (state: any, dispatch: any) => boolean;
    toggleHeaderCell: (state: any, dispatch: any) => boolean;
    toggleHeaderColumn: (state: any, dispatch: any) => boolean;
    toggleHeaderRow: (state: any, dispatch: any) => boolean;
    updateColumnsOnResize: (node: any, colgroup: any, table: any, cellMinWidth: any, overrideCol: any, overrideValue: any) => void;
}>;
declare var index$6: Readonly<{
    __proto__: any;
    AddMarkStep: {
        new (from: any, to: any, mark: any): {
            from: any;
            to: any;
            mark: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            invert(): {
                from: any;
                to: any;
                mark: any;
                apply(doc: any): {
                    doc: any;
                    failed: any;
                };
                invert(): any;
                map(mapping: any): any;
                merge(other: any): any;
                toJSON(): {
                    stepType: string;
                    mark: any;
                    from: any;
                    to: any;
                };
                /**
                Get the step map that represents the changes made by this step,
                and which can be used to transform between positions in the old
                and the new document.
                */
                getMap(): {
                    ranges: any;
                    inverted: boolean;
                    /**
                    @internal
                    */
                    recover(value: any): any;
                    mapResult(pos: any, assoc?: number): any;
                    map(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                    /**
                    @internal
                    */
                    touches(pos: any, recover: any): boolean;
                    /**
                    Calls the given function on each of the changed ranges included in
                    this map.
                    */
                    forEach(f: any): void;
                    /**
                    Create an inverted version of this map. The result can be used to
                    map positions in the post-step document to the pre-step document.
                    */
                    invert(): any;
                    /**
                    @internal
                    */
                    toString(): string;
                };
            };
            map(mapping: any): any;
            merge(other: any): any;
            toJSON(): {
                stepType: string;
                mark: any;
                from: any;
                to: any;
            };
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
        };
        /**
        @internal
        */
        fromJSON(schema: any, json: any): {
            from: any;
            to: any;
            mark: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            invert(): {
                from: any;
                to: any;
                mark: any;
                apply(doc: any): {
                    doc: any;
                    failed: any;
                };
                invert(): any;
                map(mapping: any): any;
                merge(other: any): any;
                toJSON(): {
                    stepType: string;
                    mark: any;
                    from: any;
                    to: any;
                };
                /**
                Get the step map that represents the changes made by this step,
                and which can be used to transform between positions in the old
                and the new document.
                */
                getMap(): {
                    ranges: any;
                    inverted: boolean;
                    /**
                    @internal
                    */
                    recover(value: any): any;
                    mapResult(pos: any, assoc?: number): any;
                    map(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                    /**
                    @internal
                    */
                    touches(pos: any, recover: any): boolean;
                    /**
                    Calls the given function on each of the changed ranges included in
                    this map.
                    */
                    forEach(f: any): void;
                    /**
                    Create an inverted version of this map. The result can be used to
                    map positions in the post-step document to the pre-step document.
                    */
                    invert(): any;
                    /**
                    @internal
                    */
                    toString(): string;
                };
            };
            map(mapping: any): any;
            merge(other: any): any;
            toJSON(): {
                stepType: string;
                mark: any;
                from: any;
                to: any;
            };
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
        };
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        jsonID(id: any, stepClass: any): any;
    };
    AddNodeMarkStep: {
        new (pos: any, mark: any): {
            pos: any;
            mark: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            invert(doc: any): any;
            map(mapping: any): any;
            toJSON(): {
                stepType: string;
                pos: any;
                mark: any;
            };
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        /**
        @internal
        */
        fromJSON(schema: any, json: any): {
            pos: any;
            mark: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            invert(doc: any): any;
            map(mapping: any): any;
            toJSON(): {
                stepType: string;
                pos: any;
                mark: any;
            };
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        jsonID(id: any, stepClass: any): any;
    };
    AttrStep: {
        new (pos: any, attr: any, value: any): {
            pos: any;
            attr: any;
            value: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            invert(doc: any): any;
            map(mapping: any): any;
            toJSON(): {
                stepType: string;
                pos: any;
                attr: any;
                value: any;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        fromJSON(schema: any, json: any): {
            pos: any;
            attr: any;
            value: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            invert(doc: any): any;
            map(mapping: any): any;
            toJSON(): {
                stepType: string;
                pos: any;
                attr: any;
                value: any;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        jsonID(id: any, stepClass: any): any;
    };
    MapResult: {
        new (pos: any, delInfo: any, recover: any): {
            pos: any;
            delInfo: any;
            recover: any;
            /**
            Tells you whether the position was deleted, that is, whether the
            step removed the token on the side queried (via the `assoc`)
            argument from the document.
            */
            readonly deleted: boolean;
            /**
            Tells you whether the token before the mapped position was deleted.
            */
            readonly deletedBefore: boolean;
            /**
            True when the token after the mapped position was deleted.
            */
            readonly deletedAfter: boolean;
            /**
            Tells whether any of the steps mapped through deletes across the
            position (including both the token before and after the
            position).
            */
            readonly deletedAcross: boolean;
        };
    };
    Mapping: {
        new (maps: any[], mirror: any, from?: number, to?: number): {
            maps: any[];
            mirror: any;
            from: number;
            to: number;
            /**
            Create a mapping that maps only through a part of this one.
            */
            slice(from?: number, to?: number): any;
            /**
            @internal
            */
            copy(): any;
            /**
            Add a step map to the end of this mapping. If `mirrors` is
            given, it should be the index of the step map that is the mirror
            image of this one.
            */
            appendMap(map: any, mirrors: any): void;
            /**
            Add all the step maps in a given mapping to this one (preserving
            mirroring information).
            */
            appendMapping(mapping: any): void;
            /**
            Finds the offset of the step map that mirrors the map at the
            given offset, in this mapping (as per the second argument to
            `appendMap`).
            */
            getMirror(n: any): any;
            /**
            @internal
            */
            setMirror(n: any, m: any): void;
            /**
            Append the inverse of the given mapping to this one.
            */
            appendMappingInverted(mapping: any): void;
            /**
            Create an inverted version of this mapping.
            */
            invert(): any;
            /**
            Map a position through this mapping.
            */
            map(pos: any, assoc?: number): any;
            /**
            Map a position through this mapping, returning a mapping
            result.
            */
            mapResult(pos: any, assoc?: number): any;
            /**
            @internal
            */
            _map(pos: any, assoc: any, simple: any): any;
        };
    };
    RemoveMarkStep: {
        new (from: any, to: any, mark: any): {
            from: any;
            to: any;
            mark: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            invert(): any;
            map(mapping: any): any;
            merge(other: any): any;
            toJSON(): {
                stepType: string;
                mark: any;
                from: any;
                to: any;
            };
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
        };
        /**
        @internal
        */
        fromJSON(schema: any, json: any): {
            from: any;
            to: any;
            mark: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            invert(): any;
            map(mapping: any): any;
            merge(other: any): any;
            toJSON(): {
                stepType: string;
                mark: any;
                from: any;
                to: any;
            };
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
        };
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        jsonID(id: any, stepClass: any): any;
    };
    RemoveNodeMarkStep: {
        new (pos: any, mark: any): {
            pos: any;
            mark: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            invert(doc: any): {
                pos: any;
                mark: any;
                apply(doc: any): {
                    doc: any;
                    failed: any;
                };
                invert(doc: any): any;
                map(mapping: any): any;
                toJSON(): {
                    stepType: string;
                    pos: any;
                    mark: any;
                };
                /**
                Get the step map that represents the changes made by this step,
                and which can be used to transform between positions in the old
                and the new document.
                */
                getMap(): {
                    ranges: any;
                    inverted: boolean;
                    /**
                    @internal
                    */
                    recover(value: any): any;
                    mapResult(pos: any, assoc?: number): any;
                    map(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                    /**
                    @internal
                    */
                    touches(pos: any, recover: any): boolean;
                    /**
                    Calls the given function on each of the changed ranges included in
                    this map.
                    */
                    forEach(f: any): void;
                    /**
                    Create an inverted version of this map. The result can be used to
                    map positions in the post-step document to the pre-step document.
                    */
                    invert(): any;
                    /**
                    @internal
                    */
                    toString(): string;
                };
                /**
                Try to merge this step with another one, to be applied directly
                after it. Returns the merged step when possible, null if the
                steps can't be merged.
                */
                merge(other: any): any;
            };
            map(mapping: any): any;
            toJSON(): {
                stepType: string;
                pos: any;
                mark: any;
            };
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        /**
        @internal
        */
        fromJSON(schema: any, json: any): {
            pos: any;
            mark: any;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            invert(doc: any): {
                pos: any;
                mark: any;
                apply(doc: any): {
                    doc: any;
                    failed: any;
                };
                invert(doc: any): any;
                map(mapping: any): any;
                toJSON(): {
                    stepType: string;
                    pos: any;
                    mark: any;
                };
                /**
                Get the step map that represents the changes made by this step,
                and which can be used to transform between positions in the old
                and the new document.
                */
                getMap(): {
                    ranges: any;
                    inverted: boolean;
                    /**
                    @internal
                    */
                    recover(value: any): any;
                    mapResult(pos: any, assoc?: number): any;
                    map(pos: any, assoc?: number): any;
                    /**
                    @internal
                    */
                    _map(pos: any, assoc: any, simple: any): any;
                    /**
                    @internal
                    */
                    touches(pos: any, recover: any): boolean;
                    /**
                    Calls the given function on each of the changed ranges included in
                    this map.
                    */
                    forEach(f: any): void;
                    /**
                    Create an inverted version of this map. The result can be used to
                    map positions in the post-step document to the pre-step document.
                    */
                    invert(): any;
                    /**
                    @internal
                    */
                    toString(): string;
                };
                /**
                Try to merge this step with another one, to be applied directly
                after it. Returns the merged step when possible, null if the
                steps can't be merged.
                */
                merge(other: any): any;
            };
            map(mapping: any): any;
            toJSON(): {
                stepType: string;
                pos: any;
                mark: any;
            };
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        jsonID(id: any, stepClass: any): any;
    };
    ReplaceAroundStep: {
        new (from: any, to: any, gapFrom: any, gapTo: any, slice: any, insert: any, structure?: boolean): {
            from: any;
            to: any;
            gapFrom: any;
            gapTo: any;
            slice: any;
            insert: any;
            structure: boolean;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            invert(doc: any): any;
            map(mapping: any): any;
            toJSON(): {
                stepType: string;
                from: any;
                to: any;
                gapFrom: any;
                gapTo: any;
                insert: any;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        /**
        @internal
        */
        fromJSON(schema: any, json: any): {
            from: any;
            to: any;
            gapFrom: any;
            gapTo: any;
            slice: any;
            insert: any;
            structure: boolean;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            invert(doc: any): any;
            map(mapping: any): any;
            toJSON(): {
                stepType: string;
                from: any;
                to: any;
                gapFrom: any;
                gapTo: any;
                insert: any;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        jsonID(id: any, stepClass: any): any;
    };
    ReplaceStep: {
        new (from: any, to: any, slice: any, structure?: boolean): {
            from: any;
            to: any;
            slice: any;
            structure: boolean;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            invert(doc: any): any;
            map(mapping: any): any;
            merge(other: any): any;
            toJSON(): {
                stepType: string;
                from: any;
                to: any;
            };
        };
        /**
        @internal
        */
        fromJSON(schema: any, json: any): {
            from: any;
            to: any;
            slice: any;
            structure: boolean;
            apply(doc: any): {
                doc: any;
                failed: any;
            };
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            invert(doc: any): any;
            map(mapping: any): any;
            merge(other: any): any;
            toJSON(): {
                stepType: string;
                from: any;
                to: any;
            };
        };
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        jsonID(id: any, stepClass: any): any;
    };
    Step: {
        new (): {
            /**
            Get the step map that represents the changes made by this step,
            and which can be used to transform between positions in the old
            and the new document.
            */
            getMap(): {
                ranges: any;
                inverted: boolean;
                /**
                @internal
                */
                recover(value: any): any;
                mapResult(pos: any, assoc?: number): any;
                map(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
                /**
                @internal
                */
                touches(pos: any, recover: any): boolean;
                /**
                Calls the given function on each of the changed ranges included in
                this map.
                */
                forEach(f: any): void;
                /**
                Create an inverted version of this map. The result can be used to
                map positions in the post-step document to the pre-step document.
                */
                invert(): any;
                /**
                @internal
                */
                toString(): string;
            };
            /**
            Try to merge this step with another one, to be applied directly
            after it. Returns the merged step when possible, null if the
            steps can't be merged.
            */
            merge(other: any): any;
        };
        /**
        Deserialize a step from its JSON representation. Will call
        through to the step class' own implementation of this method.
        */
        fromJSON(schema: any, json: any): any;
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        jsonID(id: any, stepClass: any): any;
    };
    StepMap: {
        new (ranges: any, inverted?: boolean): {
            ranges: any;
            inverted: boolean;
            /**
            @internal
            */
            recover(value: any): any;
            mapResult(pos: any, assoc?: number): any;
            map(pos: any, assoc?: number): any;
            /**
            @internal
            */
            _map(pos: any, assoc: any, simple: any): any;
            /**
            @internal
            */
            touches(pos: any, recover: any): boolean;
            /**
            Calls the given function on each of the changed ranges included in
            this map.
            */
            forEach(f: any): void;
            /**
            Create an inverted version of this map. The result can be used to
            map positions in the post-step document to the pre-step document.
            */
            invert(): any;
            /**
            @internal
            */
            toString(): string;
        };
        /**
        Create a map that moves all positions by offset `n` (which may be
        negative). This can be useful when applying steps meant for a
        sub-document to a larger document, or vice-versa.
        */
        offset(n: any): {
            ranges: any;
            inverted: boolean;
            /**
            @internal
            */
            recover(value: any): any;
            mapResult(pos: any, assoc?: number): any;
            map(pos: any, assoc?: number): any;
            /**
            @internal
            */
            _map(pos: any, assoc: any, simple: any): any;
            /**
            @internal
            */
            touches(pos: any, recover: any): boolean;
            /**
            Calls the given function on each of the changed ranges included in
            this map.
            */
            forEach(f: any): void;
            /**
            Create an inverted version of this map. The result can be used to
            map positions in the post-step document to the pre-step document.
            */
            invert(): any;
            /**
            @internal
            */
            toString(): string;
        };
        /**
        A StepMap that contains no changed ranges.
        */
        empty: {
            ranges: any;
            inverted: boolean;
            /**
            @internal
            */
            recover(value: any): any;
            mapResult(pos: any, assoc?: number): any;
            map(pos: any, assoc?: number): any;
            /**
            @internal
            */
            _map(pos: any, assoc: any, simple: any): any;
            /**
            @internal
            */
            touches(pos: any, recover: any): boolean;
            /**
            Calls the given function on each of the changed ranges included in
            this map.
            */
            forEach(f: any): void;
            /**
            Create an inverted version of this map. The result can be used to
            map positions in the post-step document to the pre-step document.
            */
            invert(): any;
            /**
            @internal
            */
            toString(): string;
        };
    };
    StepResult: {
        new (doc: any, failed: any): {
            doc: any;
            failed: any;
        };
        /**
        Create a successful step result.
        */
        ok(doc: any): {
            doc: any;
            failed: any;
        };
        /**
        Create a failed step result.
        */
        fail(message: any): {
            doc: any;
            failed: any;
        };
        /**
        Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
        arguments. Create a successful result if it succeeds, and a
        failed one if it throws a `ReplaceError`.
        */
        fromReplace(doc: any, from: any, to: any, slice: any): {
            doc: any;
            failed: any;
        };
    };
    Transform: {
        new (doc: any): {
            doc: any;
            /**
            The steps in this transform.
            */
            steps: any[];
            /**
            The documents before each of the steps.
            */
            docs: any[];
            /**
            A mapping with the maps for each of the steps in this transform.
            */
            mapping: {
                maps: any[];
                mirror: any;
                from: number;
                to: number;
                /**
                Create a mapping that maps only through a part of this one.
                */
                slice(from?: number, to?: number): any;
                /**
                @internal
                */
                copy(): any;
                /**
                Add a step map to the end of this mapping. If `mirrors` is
                given, it should be the index of the step map that is the mirror
                image of this one.
                */
                appendMap(map: any, mirrors: any): void;
                /**
                Add all the step maps in a given mapping to this one (preserving
                mirroring information).
                */
                appendMapping(mapping: any): void;
                /**
                Finds the offset of the step map that mirrors the map at the
                given offset, in this mapping (as per the second argument to
                `appendMap`).
                */
                getMirror(n: any): any;
                /**
                @internal
                */
                setMirror(n: any, m: any): void;
                /**
                Append the inverse of the given mapping to this one.
                */
                appendMappingInverted(mapping: any): void;
                /**
                Create an inverted version of this mapping.
                */
                invert(): any;
                /**
                Map a position through this mapping.
                */
                map(pos: any, assoc?: number): any;
                /**
                Map a position through this mapping, returning a mapping
                result.
                */
                mapResult(pos: any, assoc?: number): any;
                /**
                @internal
                */
                _map(pos: any, assoc: any, simple: any): any;
            };
            /**
            The starting document.
            */
            readonly before: any;
            /**
            Apply a new step in this transform, saving the result. Throws an
            error when the step fails.
            */
            step(step: any): any;
            /**
            Try to apply a step in this transformation, ignoring it if it
            fails. Returns the step result.
            */
            maybeStep(step: any): any;
            /**
            True when the document has been changed (when there are any
            steps).
            */
            readonly docChanged: boolean;
            /**
            @internal
            */
            addStep(step: any, doc: any): void;
            /**
            Replace the part of the document between `from` and `to` with the
            given `slice`.
            */
            replace(from: any, to?: any, slice?: {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            }): any;
            /**
            Replace the given range with the given content, which may be a
            fragment, node, or array of nodes.
            */
            replaceWith(from: any, to: any, content: any): any;
            /**
            Delete the content between the given positions.
            */
            delete(from: any, to: any): any;
            /**
            Insert the given content at the given position.
            */
            insert(pos: any, content: any): any;
            /**
            Replace a range of the document with a given slice, using
            `from`, `to`, and the slice's
            [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
            than fixed start and end points. This method may grow the
            replaced area or close open nodes in the slice in order to get a
            fit that is more in line with WYSIWYG expectations, by dropping
            fully covered parent nodes of the replaced region when they are
            marked [non-defining as
            context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
            open parent node from the slice that _is_ marked as [defining
            its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
            
            This is the method, for example, to handle paste. The similar
            [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
            primitive tool which will _not_ move the start and end of its given
            range, and is useful in situations where you need more precise
            control over what happens.
            */
            replaceRange(from: any, to: any, slice: any): any;
            /**
            Replace the given range with a node, but use `from` and `to` as
            hints, rather than precise positions. When from and to are the same
            and are at the start or end of a parent node in which the given
            node doesn't fit, this method may _move_ them out towards a parent
            that does allow the given node to be placed. When the given range
            completely covers a parent node, this method may completely replace
            that parent node.
            */
            replaceRangeWith(from: any, to: any, node: any): any;
            /**
            Delete the given range, expanding it to cover fully covered
            parent nodes until a valid replace is found.
            */
            deleteRange(from: any, to: any): any;
            /**
            Split the content in the given range off from its parent, if there
            is sibling content before or after it, and move it up the tree to
            the depth specified by `target`. You'll probably want to use
            [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
            sure the lift is valid.
            */
            lift(range: any, target: any): any;
            /**
            Join the blocks around the given position. If depth is 2, their
            last and first siblings are also joined, and so on.
            */
            join(pos: any, depth?: number): any;
            /**
            Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
            The wrappers are assumed to be valid in this position, and should
            probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
            */
            wrap(range: any, wrappers: any): any;
            /**
            Set the type of all textblocks (partly) between `from` and `to` to
            the given node type with the given attributes.
            */
            setBlockType(from: any, to: any, type: any, attrs?: any): any;
            /**
            Change the type, attributes, and/or marks of the node at `pos`.
            When `type` isn't given, the existing node type is preserved,
            */
            setNodeMarkup(pos: any, type: any, attrs: any, marks: any): any;
            /**
            Set a single attribute on a given node to a new value.
            */
            setNodeAttribute(pos: any, attr: any, value: any): any;
            /**
            Add a mark to the node at position `pos`.
            */
            addNodeMark(pos: any, mark: any): any;
            /**
            Remove a mark (or a mark of the given type) from the node at
            position `pos`.
            */
            removeNodeMark(pos: any, mark: any): any;
            /**
            Split the node at the given position, and optionally, if `depth` is
            greater than one, any number of nodes above that. By default, the
            parts split off will inherit the node type of the original node.
            This can be changed by passing an array of types and attributes to
            use after the split.
            */
            split(pos: any, depth: number, typesAfter: any): any;
            /**
            Add the given mark to the inline content between `from` and `to`.
            */
            addMark(from: any, to: any, mark: any): any;
            /**
            Remove marks from inline nodes between `from` and `to`. When
            `mark` is a single mark, remove precisely that mark. When it is
            a mark type, remove all marks of that type. When it is null,
            remove all marks of any type.
            */
            removeMark(from: any, to: any, mark: any): any;
            /**
            Removes all marks and nodes from the content of the node at
            `pos` that don't match the given new parent node type. Accepts
            an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
            third argument.
            */
            clearIncompatible(pos: any, parentType: any, match: any): any;
        };
    };
    readonly TransformError: {
        new (message?: string): {
            constructor: any;
            name: string;
            message: string;
            stack?: string;
        };
        captureStackTrace(targetObject: object, constructorOpt?: Function): void;
        prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
        stackTraceLimit: number;
    };
    canJoin: (doc: any, pos: any) => any;
    canSplit: (doc: any, pos: any, depth: number, typesAfter: any) => any;
    dropPoint: (doc: any, pos: any, slice: any) => any;
    findWrapping: (range: any, nodeType: any, attrs?: any, innerRange?: any) => any;
    insertPoint: (doc: any, pos: any, nodeType: any) => any;
    joinPoint: (doc: any, pos: any, dir?: number) => any;
    liftTarget: (range: any) => any;
    replaceStep: (doc: any, from: any, to?: any, slice?: {
        content: any;
        openStart: any;
        openEnd: any;
        /**
        The size this slice would add when inserted into a document.
        */
        readonly size: number;
        /**
        @internal
        */
        insertAt(pos: any, fragment: any): any;
        /**
        @internal
        */
        removeBetween(from: any, to: any): any;
        /**
        Tests whether this slice is equal to another slice.
        */
        eq(other: any): boolean;
        /**
        @internal
        */
        toString(): string;
        /**
        Convert a slice to a JSON-serializable representation.
        */
        toJSON(): {
            content: any;
        };
    }) => {
        from: any;
        to: any;
        slice: any;
        structure: boolean;
        apply(doc: any): {
            doc: any;
            failed: any;
        };
        getMap(): {
            ranges: any;
            inverted: boolean;
            /**
            @internal
            */
            recover(value: any): any;
            mapResult(pos: any, assoc?: number): any;
            map(pos: any, assoc?: number): any;
            /**
            @internal
            */
            _map(pos: any, assoc: any, simple: any): any;
            /**
            @internal
            */
            touches(pos: any, recover: any): boolean;
            /**
            Calls the given function on each of the changed ranges included in
            this map.
            */
            forEach(f: any): void;
            /**
            Create an inverted version of this map. The result can be used to
            map positions in the post-step document to the pre-step document.
            */
            invert(): any;
            /**
            @internal
            */
            toString(): string;
        };
        invert(doc: any): any;
        map(mapping: any): any;
        merge(other: any): any;
        toJSON(): {
            stepType: string;
            from: any;
            to: any;
        };
    } | {
        from: any;
        to: any;
        gapFrom: any;
        gapTo: any;
        slice: any;
        insert: any;
        structure: boolean;
        apply(doc: any): {
            doc: any;
            failed: any;
        };
        getMap(): {
            ranges: any;
            inverted: boolean;
            /**
            @internal
            */
            recover(value: any): any;
            mapResult(pos: any, assoc?: number): any;
            map(pos: any, assoc?: number): any;
            /**
            @internal
            */
            _map(pos: any, assoc: any, simple: any): any;
            /**
            @internal
            */
            touches(pos: any, recover: any): boolean;
            /**
            Calls the given function on each of the changed ranges included in
            this map.
            */
            forEach(f: any): void;
            /**
            Create an inverted version of this map. The result can be used to
            map positions in the post-step document to the pre-step document.
            */
            invert(): any;
            /**
            @internal
            */
            toString(): string;
        };
        invert(doc: any): any;
        map(mapping: any): any;
        toJSON(): {
            stepType: string;
            from: any;
            to: any;
            gapFrom: any;
            gapTo: any;
            insert: any;
        };
        /**
        Try to merge this step with another one, to be applied directly
        after it. Returns the merged step when possible, null if the
        steps can't be merged.
        */
        merge(other: any): any;
    };
}>;
/**
 * Use the DOM and ProseMirror's DOMParser to construct a ProseMirror document state from an HTML string. This cannot be
 * used server-side.
 * @param {string} htmlString  A string of HTML.
 * @param {Schema} [schema]    The ProseMirror schema to use instead of the default one.
 * @returns {Node}             The document node.
 */
declare function parseHTMLString(htmlString: string, schema$1: any): {
    type: any;
    attrs: any;
    marks: any[];
    content: any;
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    readonly nodeSize: any;
    /**
    The number of children that the node has.
    */
    readonly childCount: any;
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index: any): any;
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index: any): any;
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f: any): void;
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    parent-relative position, its parent node, and its child index.
    When the callback returns false for a given node, that node's
    children will not be recursed over. The last parameter can be
    used to specify a starting position to count from.
    */
    nodesBetween(from: any, to: any, f: any, startPos?: number): void;
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f: any): void;
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    readonly textContent: any;
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    readonly firstChild: any;
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    readonly lastChild: any;
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other: any): any;
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other: any): boolean;
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type: any, attrs: any, marks: any): boolean;
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content?: any): any;
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks: any): any;
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from: any, to?: any): any;
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from: any, to?: any, includeParents?: boolean): {
        content: any;
        openStart: any;
        openEnd: any;
        /**
        The size this slice would add when inserted into a document.
        */
        readonly size: number;
        /**
        @internal
        */
        insertAt(pos: any, fragment: any): any;
        /**
        @internal
        */
        removeBetween(from: any, to: any): any;
        /**
        Tests whether this slice is equal to another slice.
        */
        eq(other: any): boolean;
        /**
        @internal
        */
        toString(): string;
        /**
        Convert a slice to a JSON-serializable representation.
        */
        toJSON(): {
            content: any;
        };
    };
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from: any, to: any, slice: any): any;
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos: any): any;
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos: any): {
        node: any;
        index: any;
        offset: any;
    };
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos: any): {
        node: any;
        index: any;
        offset: any;
    };
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos: any): any;
    /**
    @internal
    */
    resolveNoCache(pos: any): {
        pos: any;
        path: any;
        parentOffset: any;
        depth: number;
        /**
        @internal
        */
        resolveDepth(val: any): any;
        /**
        The parent node that the position points into. Note that even if
        a position points into a text node, that node is not considered
        the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
        */
        readonly parent: any;
        /**
        The root node in which the position was resolved.
        */
        readonly doc: any;
        /**
        The ancestor node at the given level. `p.node(p.depth)` is the
        same as `p.parent`.
        */
        node(depth: any): any;
        /**
        The index into the ancestor at the given level. If this points
        at the 3rd node in the 2nd paragraph on the top level, for
        example, `p.index(0)` is 1 and `p.index(1)` is 2.
        */
        index(depth: any): any;
        /**
        The index pointing after this position into the ancestor at the
        given level.
        */
        indexAfter(depth: any): any;
        /**
        The (absolute) position at the start of the node at the given
        level.
        */
        start(depth: any): any;
        /**
        The (absolute) position at the end of the node at the given
        level.
        */
        end(depth: any): any;
        /**
        The (absolute) position directly before the wrapping node at the
        given level, or, when `depth` is `this.depth + 1`, the original
        position.
        */
        before(depth: any): any;
        /**
        The (absolute) position directly after the wrapping node at the
        given level, or the original position when `depth` is `this.depth + 1`.
        */
        after(depth: any): any;
        /**
        When this position points into a text node, this returns the
        distance between the position and the start of the text node.
        Will be zero for positions that point between nodes.
        */
        readonly textOffset: number;
        /**
        Get the node directly after the position, if any. If the position
        points into a text node, only the part of that node after the
        position is returned.
        */
        readonly nodeAfter: any;
        /**
        Get the node directly before the position, if any. If the
        position points into a text node, only the part of that node
        before the position is returned.
        */
        readonly nodeBefore: any;
        /**
        Get the position at the given index in the parent node at the
        given depth (which defaults to `this.depth`).
        */
        posAtIndex(index: any, depth: any): any;
        /**
        Get the marks at this position, factoring in the surrounding
        marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
        position is at the start of a non-empty node, the marks of the
        node after it (if any) are returned.
        */
        marks(): any;
        /**
        Get the marks after the current position, if any, except those
        that are non-inclusive and not present at position `$end`. This
        is mostly useful for getting the set of marks to preserve after a
        deletion. Will return `null` if this position is at the end of
        its parent node or its parent node isn't a textblock (in which
        case no marks should be preserved).
        */
        marksAcross($end: any): any;
        /**
        The depth up to which this position and the given (non-resolved)
        position share the same parent nodes.
        */
        sharedDepth(pos: any): number;
        /**
        Returns a range based on the place where this position and the
        given position diverge around block content. If both point into
        the same textblock, for example, a range around that textblock
        will be returned. If they point into different blocks, the range
        around those blocks in their shared ancestor is returned. You can
        pass in an optional predicate that will be called with a parent
        node to see if a range into that parent is acceptable.
        */
        blockRange(other: any, pred: any): any;
        /**
        Query whether the given position shares the same parent node.
        */
        sameParent(other: any): boolean;
        /**
        Return the greater of this and the given position.
        */
        max(other: any): any;
        /**
        Return the smaller of this and the given position.
        */
        min(other: any): any;
        /**
        @internal
        */
        toString(): string;
        /**
         * Determine whether a given position has an ancestor node of the given type.
         * @param {NodeType} other  The other node type.
         * @param {object} [attrs]  An object of attributes that must also match, if provided.
         * @returns {boolean}
         */
        hasAncestor(other: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        }, attrs?: object): boolean;
    };
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from: any, to: any, type: any): boolean;
    /**
    True when this is a block (non-inline node)
    */
    readonly isBlock: any;
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    readonly isTextblock: any;
    /**
    True when this node allows inline content.
    */
    readonly inlineContent: any;
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    readonly isInline: any;
    /**
    True when this is a text node.
    */
    readonly isText: any;
    /**
    True when this is a leaf node.
    */
    readonly isLeaf: any;
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    readonly isAtom: any;
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString(): any;
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index: any): any;
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from: any, to: any, replacement?: {
        content: any;
        size: any;
        /**
        Invoke a callback for all descendant nodes between the given two
        positions (relative to start of this fragment). Doesn't descend
        into a node when the callback returns `false`.
        */
        nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
        /**
        Call the given callback for every descendant node. `pos` will be
        relative to the start of the fragment. The callback may return
        `false` to prevent traversal of a given node's children.
        */
        descendants(f: any): void;
        /**
        Extract the text between `from` and `to`. See the same method on
        [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
        */
        textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
        /**
        Create a new fragment containing the combined content of this
        fragment and the other.
        */
        append(other: any): any;
        /**
        Cut out the sub-fragment between the two given positions.
        */
        cut(from: any, to?: any): any;
        /**
        @internal
        */
        cutByIndex(from: any, to: any): any;
        /**
        Create a new fragment in which the node at the given index is
        replaced by the given node.
        */
        replaceChild(index: any, node: any): any;
        /**
        Create a new fragment by prepending the given node to this
        fragment.
        */
        addToStart(node: any): any;
        /**
        Create a new fragment by appending the given node to this
        fragment.
        */
        addToEnd(node: any): any;
        /**
        Compare this fragment to another one.
        */
        eq(other: any): boolean;
        /**
        The first child of the fragment, or `null` if it is empty.
        */
        readonly firstChild: any;
        /**
        The last child of the fragment, or `null` if it is empty.
        */
        readonly lastChild: any;
        /**
        The number of child nodes in this fragment.
        */
        readonly childCount: any;
        /**
        Get the child node at the given index. Raise an error when the
        index is out of range.
        */
        child(index: any): any;
        /**
        Get the child node at the given index, if it exists.
        */
        maybeChild(index: any): any;
        /**
        Call `f` for every child node, passing the node, its offset
        into this parent node, and its index.
        */
        forEach(f: any): void;
        /**
        Find the first position at which this fragment and another
        fragment differ, or `null` if they are the same.
        */
        findDiffStart(other: any, pos?: number): any;
        /**
        Find the first position, searching from the end, at which this
        fragment and the given fragment differ, or `null` if they are
        the same. Since this position will not be the same in both
        nodes, an object with two separate positions is returned.
        */
        findDiffEnd(other: any, pos?: any, otherPos?: any): any;
        /**
        Find the index and inner offset corresponding to a given relative
        position in this fragment. The result object will be reused
        (overwritten) the next time the function is called. (Not public.)
        */
        findIndex(pos: any, round?: number): {
            index: number;
            offset: number;
        };
        /**
        Return a debugging string that describes this fragment.
        */
        toString(): string;
        /**
        @internal
        */
        toStringInner(): any;
        /**
        Create a JSON-serializeable representation of this fragment.
        */
        toJSON(): any;
    }, start?: number, end?: any): boolean;
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from: any, to: any, type: any, marks: any): any;
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other: any): any;
    /**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */
    check(): void;
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON(): {
        type: any;
    };
    text: any;
};
/**
 * Use the StringSerializer to convert a ProseMirror document into an HTML string. This can be used server-side.
 * @param {Node} doc                        The ProseMirror document.
 * @param {object} [options]                Additional options to configure serialization behavior.
 * @param {Schema} [options.schema]         The ProseMirror schema to use instead of the default one.
 * @param {string|number} [options.spaces]  The number of spaces to use for indentation. See {@link StringNode#toString}
 *                                          for details.
 * @returns {string}
 */
declare function serializeHTMLString(doc: {
    type: any;
    attrs: any;
    marks: any[];
    content: any;
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    readonly nodeSize: any;
    /**
    The number of children that the node has.
    */
    readonly childCount: any;
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index: any): any;
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index: any): any;
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f: any): void;
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    parent-relative position, its parent node, and its child index.
    When the callback returns false for a given node, that node's
    children will not be recursed over. The last parameter can be
    used to specify a starting position to count from.
    */
    nodesBetween(from: any, to: any, f: any, startPos?: number): void;
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f: any): void;
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    readonly textContent: any;
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    readonly firstChild: any;
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    readonly lastChild: any;
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other: any): any;
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other: any): boolean;
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type: any, attrs: any, marks: any): boolean;
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content?: any): any;
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks: any): any;
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from: any, to?: any): any;
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from: any, to?: any, includeParents?: boolean): {
        content: any;
        openStart: any;
        openEnd: any;
        /**
        The size this slice would add when inserted into a document.
        */
        readonly size: number;
        /**
        @internal
        */
        insertAt(pos: any, fragment: any): any;
        /**
        @internal
        */
        removeBetween(from: any, to: any): any;
        /**
        Tests whether this slice is equal to another slice.
        */
        eq(other: any): boolean;
        /**
        @internal
        */
        toString(): string;
        /**
        Convert a slice to a JSON-serializable representation.
        */
        toJSON(): {
            content: any;
        };
    };
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from: any, to: any, slice: any): any;
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos: any): any;
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos: any): {
        node: any;
        index: any;
        offset: any;
    };
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos: any): {
        node: any;
        index: any;
        offset: any;
    };
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos: any): any;
    /**
    @internal
    */
    resolveNoCache(pos: any): {
        pos: any;
        path: any;
        parentOffset: any;
        depth: number;
        /**
        @internal
        */
        resolveDepth(val: any): any;
        /**
        The parent node that the position points into. Note that even if
        a position points into a text node, that node is not considered
        the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
        */
        readonly parent: any;
        /**
        The root node in which the position was resolved.
        */
        readonly doc: any;
        /**
        The ancestor node at the given level. `p.node(p.depth)` is the
        same as `p.parent`.
        */
        node(depth: any): any;
        /**
        The index into the ancestor at the given level. If this points
        at the 3rd node in the 2nd paragraph on the top level, for
        example, `p.index(0)` is 1 and `p.index(1)` is 2.
        */
        index(depth: any): any;
        /**
        The index pointing after this position into the ancestor at the
        given level.
        */
        indexAfter(depth: any): any;
        /**
        The (absolute) position at the start of the node at the given
        level.
        */
        start(depth: any): any;
        /**
        The (absolute) position at the end of the node at the given
        level.
        */
        end(depth: any): any;
        /**
        The (absolute) position directly before the wrapping node at the
        given level, or, when `depth` is `this.depth + 1`, the original
        position.
        */
        before(depth: any): any;
        /**
        The (absolute) position directly after the wrapping node at the
        given level, or the original position when `depth` is `this.depth + 1`.
        */
        after(depth: any): any;
        /**
        When this position points into a text node, this returns the
        distance between the position and the start of the text node.
        Will be zero for positions that point between nodes.
        */
        readonly textOffset: number;
        /**
        Get the node directly after the position, if any. If the position
        points into a text node, only the part of that node after the
        position is returned.
        */
        readonly nodeAfter: any;
        /**
        Get the node directly before the position, if any. If the
        position points into a text node, only the part of that node
        before the position is returned.
        */
        readonly nodeBefore: any;
        /**
        Get the position at the given index in the parent node at the
        given depth (which defaults to `this.depth`).
        */
        posAtIndex(index: any, depth: any): any;
        /**
        Get the marks at this position, factoring in the surrounding
        marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
        position is at the start of a non-empty node, the marks of the
        node after it (if any) are returned.
        */
        marks(): any;
        /**
        Get the marks after the current position, if any, except those
        that are non-inclusive and not present at position `$end`. This
        is mostly useful for getting the set of marks to preserve after a
        deletion. Will return `null` if this position is at the end of
        its parent node or its parent node isn't a textblock (in which
        case no marks should be preserved).
        */
        marksAcross($end: any): any;
        /**
        The depth up to which this position and the given (non-resolved)
        position share the same parent nodes.
        */
        sharedDepth(pos: any): number;
        /**
        Returns a range based on the place where this position and the
        given position diverge around block content. If both point into
        the same textblock, for example, a range around that textblock
        will be returned. If they point into different blocks, the range
        around those blocks in their shared ancestor is returned. You can
        pass in an optional predicate that will be called with a parent
        node to see if a range into that parent is acceptable.
        */
        blockRange(other: any, pred: any): any;
        /**
        Query whether the given position shares the same parent node.
        */
        sameParent(other: any): boolean;
        /**
        Return the greater of this and the given position.
        */
        max(other: any): any;
        /**
        Return the smaller of this and the given position.
        */
        min(other: any): any;
        /**
        @internal
        */
        toString(): string;
        /**
         * Determine whether a given position has an ancestor node of the given type.
         * @param {NodeType} other  The other node type.
         * @param {object} [attrs]  An object of attributes that must also match, if provided.
         * @returns {boolean}
         */
        hasAncestor(other: {
            attrs: any;
            spec: any;
            map(mapping: any, span: any, offset: any, oldOffset: any): {
                from: any;
                to: any;
                type: any;
                /**
                @internal
                */
                copy(from: any, to: any): any;
                /**
                @internal
                */
                eq(other: any, offset?: number): boolean;
                /**
                @internal
                */
                map(mapping: any, offset: any, oldOffset: any): any;
                /**
                The spec provided when creating this decoration. Can be useful
                if you've stored extra information in that object.
                */
                readonly spec: any;
                /**
                @internal
                */
                readonly inline: boolean;
            };
            valid(node: any, span: any): boolean;
            eq(other: any): boolean;
            destroy(): void;
        }, attrs?: object): boolean;
    };
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from: any, to: any, type: any): boolean;
    /**
    True when this is a block (non-inline node)
    */
    readonly isBlock: any;
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    readonly isTextblock: any;
    /**
    True when this node allows inline content.
    */
    readonly inlineContent: any;
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    readonly isInline: any;
    /**
    True when this is a text node.
    */
    readonly isText: any;
    /**
    True when this is a leaf node.
    */
    readonly isLeaf: any;
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    readonly isAtom: any;
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString(): any;
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index: any): any;
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from: any, to: any, replacement?: {
        content: any;
        size: any;
        /**
        Invoke a callback for all descendant nodes between the given two
        positions (relative to start of this fragment). Doesn't descend
        into a node when the callback returns `false`.
        */
        nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
        /**
        Call the given callback for every descendant node. `pos` will be
        relative to the start of the fragment. The callback may return
        `false` to prevent traversal of a given node's children.
        */
        descendants(f: any): void;
        /**
        Extract the text between `from` and `to`. See the same method on
        [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
        */
        textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
        /**
        Create a new fragment containing the combined content of this
        fragment and the other.
        */
        append(other: any): any;
        /**
        Cut out the sub-fragment between the two given positions.
        */
        cut(from: any, to?: any): any;
        /**
        @internal
        */
        cutByIndex(from: any, to: any): any;
        /**
        Create a new fragment in which the node at the given index is
        replaced by the given node.
        */
        replaceChild(index: any, node: any): any;
        /**
        Create a new fragment by prepending the given node to this
        fragment.
        */
        addToStart(node: any): any;
        /**
        Create a new fragment by appending the given node to this
        fragment.
        */
        addToEnd(node: any): any;
        /**
        Compare this fragment to another one.
        */
        eq(other: any): boolean;
        /**
        The first child of the fragment, or `null` if it is empty.
        */
        readonly firstChild: any;
        /**
        The last child of the fragment, or `null` if it is empty.
        */
        readonly lastChild: any;
        /**
        The number of child nodes in this fragment.
        */
        readonly childCount: any;
        /**
        Get the child node at the given index. Raise an error when the
        index is out of range.
        */
        child(index: any): any;
        /**
        Get the child node at the given index, if it exists.
        */
        maybeChild(index: any): any;
        /**
        Call `f` for every child node, passing the node, its offset
        into this parent node, and its index.
        */
        forEach(f: any): void;
        /**
        Find the first position at which this fragment and another
        fragment differ, or `null` if they are the same.
        */
        findDiffStart(other: any, pos?: number): any;
        /**
        Find the first position, searching from the end, at which this
        fragment and the given fragment differ, or `null` if they are
        the same. Since this position will not be the same in both
        nodes, an object with two separate positions is returned.
        */
        findDiffEnd(other: any, pos?: any, otherPos?: any): any;
        /**
        Find the index and inner offset corresponding to a given relative
        position in this fragment. The result object will be reused
        (overwritten) the next time the function is called. (Not public.)
        */
        findIndex(pos: any, round?: number): {
            index: number;
            offset: number;
        };
        /**
        Return a debugging string that describes this fragment.
        */
        toString(): string;
        /**
        @internal
        */
        toStringInner(): any;
        /**
        Create a JSON-serializeable representation of this fragment.
        */
        toJSON(): any;
    }, start?: number, end?: any): boolean;
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from: any, to: any, type: any, marks: any): any;
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other: any): any;
    /**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */
    check(): void;
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON(): {
        type: any;
    };
    text: any;
}, { schema: schema$1, spaces }?: {
    schema?: {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        cached: any;
        spec: {};
        nodes: any;
        marks: any;
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json: any): any;
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json: any): any;
        topNodeType: any;
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type: any, attrs: any, content: any, marks: any): any;
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text: any, marks: any): {
            text: any;
            toString(): any;
            readonly textContent: any;
            textBetween(from: any, to: any): any;
            readonly nodeSize: any;
            mark(marks: any): any;
            withText(text: any): any;
            cut(from?: number, to?: any): any;
            eq(other: any): boolean;
            toJSON(): {
                type: any;
            };
            type: any;
            attrs: any;
            marks: any[];
            content: any;
            /**
            The number of children that the node has.
            */
            readonly childCount: any;
            /**
            Get the child node at the given index. Raises an error when the
            index is out of range.
            */
            child(index: any): any;
            /**
            Get the child node at the given index, if it exists.
            */
            maybeChild(index: any): any;
            /**
            Call `f` for every child node, passing the node, its offset
            into this parent node, and its index.
            */
            forEach(f: any): void;
            /**
            Invoke a callback for all descendant nodes recursively between
            the given two positions that are relative to start of this
            node's content. The callback is invoked with the node, its
            parent-relative position, its parent node, and its child index.
            When the callback returns false for a given node, that node's
            children will not be recursed over. The last parameter can be
            used to specify a starting position to count from.
            */
            nodesBetween(from: any, to: any, f: any, startPos?: number): void;
            /**
            Call the given callback for every descendant node. Doesn't
            descend into a node when the callback returns `false`.
            */
            descendants(f: any): void;
            /**
            Returns this node's first child, or `null` if there are no
            children.
            */
            readonly firstChild: any;
            /**
            Returns this node's last child, or `null` if there are no
            children.
            */
            readonly lastChild: any;
            /**
            Compare the markup (type, attributes, and marks) of this node to
            those of another. Returns `true` if both have the same markup.
            */
            sameMarkup(other: any): boolean;
            /**
            Check whether this node's markup correspond to the given type,
            attributes, and marks.
            */
            hasMarkup(type: any, attrs: any, marks: any): boolean;
            /**
            Create a new node with the same markup as this node, containing
            the given content (or empty, if no content is given).
            */
            copy(content?: any): {
                type: any;
                attrs: any;
                marks: any[];
                content: any;
                /**
                The size of this node, as defined by the integer-based [indexing
                scheme](/docs/guide/#doc.indexing). For text nodes, this is the
                amount of characters. For other leaf nodes, it is one. For
                non-leaf nodes, it is the size of the content plus two (the
                start and end token).
                */
                readonly nodeSize: any;
                /**
                The number of children that the node has.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raises an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Invoke a callback for all descendant nodes recursively between
                the given two positions that are relative to start of this
                node's content. The callback is invoked with the node, its
                parent-relative position, its parent node, and its child index.
                When the callback returns false for a given node, that node's
                children will not be recursed over. The last parameter can be
                used to specify a starting position to count from.
                */
                nodesBetween(from: any, to: any, f: any, startPos?: number): void;
                /**
                Call the given callback for every descendant node. Doesn't
                descend into a node when the callback returns `false`.
                */
                descendants(f: any): void;
                /**
                Concatenates all the text nodes found in this fragment and its
                children.
                */
                readonly textContent: any;
                /**
                Get all text between positions `from` and `to`. When
                `blockSeparator` is given, it will be inserted to separate text
                from different block nodes. If `leafText` is given, it'll be
                inserted for every non-text leaf node encountered, otherwise
                [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): any;
                /**
                Returns this node's first child, or `null` if there are no
                children.
                */
                readonly firstChild: any;
                /**
                Returns this node's last child, or `null` if there are no
                children.
                */
                readonly lastChild: any;
                /**
                Test whether two nodes represent the same piece of document.
                */
                eq(other: any): any;
                /**
                Compare the markup (type, attributes, and marks) of this node to
                those of another. Returns `true` if both have the same markup.
                */
                sameMarkup(other: any): boolean;
                /**
                Check whether this node's markup correspond to the given type,
                attributes, and marks.
                */
                hasMarkup(type: any, attrs: any, marks: any): boolean;
                copy(content?: any): any;
                /**
                Create a copy of this node, with the given set of marks instead
                of the node's own marks.
                */
                mark(marks: any): any;
                /**
                Create a copy of this node with only the content between the
                given positions. If `to` is not given, it defaults to the end of
                the node.
                */
                cut(from: any, to?: any): any;
                /**
                Cut out the part of the document between the given positions, and
                return it as a `Slice` object.
                */
                slice(from: any, to?: any, includeParents?: boolean): {
                    content: any;
                    openStart: any;
                    openEnd: any;
                    /**
                    The size this slice would add when inserted into a document.
                    */
                    readonly size: number;
                    /**
                    @internal
                    */
                    insertAt(pos: any, fragment: any): any;
                    /**
                    @internal
                    */
                    removeBetween(from: any, to: any): any;
                    /**
                    Tests whether this slice is equal to another slice.
                    */
                    eq(other: any): boolean;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                    Convert a slice to a JSON-serializable representation.
                    */
                    toJSON(): {
                        content: any;
                    };
                };
                /**
                Replace the part of the document between the given positions with
                the given slice. The slice must 'fit', meaning its open sides
                must be able to connect to the surrounding content, and its
                content nodes must be valid children for the node they are placed
                into. If any of this is violated, an error of type
                [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
                */
                replace(from: any, to: any, slice: any): any;
                /**
                Find the node directly after the given position.
                */
                nodeAt(pos: any): any;
                /**
                Find the (direct) child node after the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childAfter(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Find the (direct) child node before the given offset, if any,
                and return it along with its index and offset relative to this
                node.
                */
                childBefore(pos: any): {
                    node: any;
                    index: any;
                    offset: any;
                };
                /**
                Resolve the given position in the document, returning an
                [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
                */
                resolve(pos: any): any;
                /**
                @internal
                */
                resolveNoCache(pos: any): {
                    pos: any;
                    path: any;
                    parentOffset: any;
                    depth: number;
                    /**
                    @internal
                    */
                    resolveDepth(val: any): any;
                    /**
                    The parent node that the position points into. Note that even if
                    a position points into a text node, that node is not considered
                    the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                    */
                    readonly parent: any;
                    /**
                    The root node in which the position was resolved.
                    */
                    readonly doc: any;
                    /**
                    The ancestor node at the given level. `p.node(p.depth)` is the
                    same as `p.parent`.
                    */
                    node(depth: any): any;
                    /**
                    The index into the ancestor at the given level. If this points
                    at the 3rd node in the 2nd paragraph on the top level, for
                    example, `p.index(0)` is 1 and `p.index(1)` is 2.
                    */
                    index(depth: any): any;
                    /**
                    The index pointing after this position into the ancestor at the
                    given level.
                    */
                    indexAfter(depth: any): any;
                    /**
                    The (absolute) position at the start of the node at the given
                    level.
                    */
                    start(depth: any): any;
                    /**
                    The (absolute) position at the end of the node at the given
                    level.
                    */
                    end(depth: any): any;
                    /**
                    The (absolute) position directly before the wrapping node at the
                    given level, or, when `depth` is `this.depth + 1`, the original
                    position.
                    */
                    before(depth: any): any;
                    /**
                    The (absolute) position directly after the wrapping node at the
                    given level, or the original position when `depth` is `this.depth + 1`.
                    */
                    after(depth: any): any;
                    /**
                    When this position points into a text node, this returns the
                    distance between the position and the start of the text node.
                    Will be zero for positions that point between nodes.
                    */
                    readonly textOffset: number;
                    /**
                    Get the node directly after the position, if any. If the position
                    points into a text node, only the part of that node after the
                    position is returned.
                    */
                    readonly nodeAfter: any;
                    /**
                    Get the node directly before the position, if any. If the
                    position points into a text node, only the part of that node
                    before the position is returned.
                    */
                    readonly nodeBefore: any;
                    /**
                    Get the position at the given index in the parent node at the
                    given depth (which defaults to `this.depth`).
                    */
                    posAtIndex(index: any, depth: any): any;
                    /**
                    Get the marks at this position, factoring in the surrounding
                    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                    position is at the start of a non-empty node, the marks of the
                    node after it (if any) are returned.
                    */
                    marks(): any;
                    /**
                    Get the marks after the current position, if any, except those
                    that are non-inclusive and not present at position `$end`. This
                    is mostly useful for getting the set of marks to preserve after a
                    deletion. Will return `null` if this position is at the end of
                    its parent node or its parent node isn't a textblock (in which
                    case no marks should be preserved).
                    */
                    marksAcross($end: any): any;
                    /**
                    The depth up to which this position and the given (non-resolved)
                    position share the same parent nodes.
                    */
                    sharedDepth(pos: any): number;
                    /**
                    Returns a range based on the place where this position and the
                    given position diverge around block content. If both point into
                    the same textblock, for example, a range around that textblock
                    will be returned. If they point into different blocks, the range
                    around those blocks in their shared ancestor is returned. You can
                    pass in an optional predicate that will be called with a parent
                    node to see if a range into that parent is acceptable.
                    */
                    blockRange(other: any, pred: any): any;
                    /**
                    Query whether the given position shares the same parent node.
                    */
                    sameParent(other: any): boolean;
                    /**
                    Return the greater of this and the given position.
                    */
                    max(other: any): any;
                    /**
                    Return the smaller of this and the given position.
                    */
                    min(other: any): any;
                    /**
                    @internal
                    */
                    toString(): string;
                    /**
                     * Determine whether a given position has an ancestor node of the given type.
                     * @param {NodeType} other  The other node type.
                     * @param {object} [attrs]  An object of attributes that must also match, if provided.
                     * @returns {boolean}
                     */
                    hasAncestor(other: {
                        attrs: any;
                        spec: any;
                        map(mapping: any, span: any, offset: any, oldOffset: any): {
                            from: any;
                            to: any;
                            type: any;
                            /**
                            @internal
                            */
                            copy(from: any, to: any): any;
                            /**
                            @internal
                            */
                            eq(other: any, offset?: number): boolean;
                            /**
                            @internal
                            */
                            map(mapping: any, offset: any, oldOffset: any): any;
                            /**
                            The spec provided when creating this decoration. Can be useful
                            if you've stored extra information in that object.
                            */
                            readonly spec: any;
                            /**
                            @internal
                            */
                            readonly inline: boolean;
                        };
                        valid(node: any, span: any): boolean;
                        eq(other: any): boolean;
                        destroy(): void;
                    }, attrs?: object): boolean;
                };
                /**
                Test whether a given mark or mark type occurs in this document
                between the two given positions.
                */
                rangeHasMark(from: any, to: any, type: any): boolean;
                /**
                True when this is a block (non-inline node)
                */
                readonly isBlock: any;
                /**
                True when this is a textblock node, a block node with inline
                content.
                */
                readonly isTextblock: any;
                /**
                True when this node allows inline content.
                */
                readonly inlineContent: any;
                /**
                True when this is an inline node (a text node or a node that can
                appear among text).
                */
                readonly isInline: any;
                /**
                True when this is a text node.
                */
                readonly isText: any;
                /**
                True when this is a leaf node.
                */
                readonly isLeaf: any;
                /**
                True when this is an atom, i.e. when it does not have directly
                editable content. This is usually the same as `isLeaf`, but can
                be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
                on a node's spec (typically used when the node is displayed as
                an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
                */
                readonly isAtom: any;
                /**
                Return a string representation of this node for debugging
                purposes.
                */
                toString(): any;
                /**
                Get the content match in this node at the given index.
                */
                contentMatchAt(index: any): any;
                /**
                Test whether replacing the range between `from` and `to` (by
                child index) with the given replacement fragment (which defaults
                to the empty fragment) would leave the node's content valid. You
                can optionally pass `start` and `end` indices into the
                replacement fragment.
                */
                canReplace(from: any, to: any, replacement?: {
                    content: any;
                    size: any;
                    /**
                    Invoke a callback for all descendant nodes between the given two
                    positions (relative to start of this fragment). Doesn't descend
                    into a node when the callback returns `false`.
                    */
                    nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                    /**
                    Call the given callback for every descendant node. `pos` will be
                    relative to the start of the fragment. The callback may return
                    `false` to prevent traversal of a given node's children.
                    */
                    descendants(f: any): void;
                    /**
                    Extract the text between `from` and `to`. See the same method on
                    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                    */
                    textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                    /**
                    Create a new fragment containing the combined content of this
                    fragment and the other.
                    */
                    append(other: any): any;
                    /**
                    Cut out the sub-fragment between the two given positions.
                    */
                    cut(from: any, to?: any): any;
                    /**
                    @internal
                    */
                    cutByIndex(from: any, to: any): any;
                    /**
                    Create a new fragment in which the node at the given index is
                    replaced by the given node.
                    */
                    replaceChild(index: any, node: any): any;
                    /**
                    Create a new fragment by prepending the given node to this
                    fragment.
                    */
                    addToStart(node: any): any;
                    /**
                    Create a new fragment by appending the given node to this
                    fragment.
                    */
                    addToEnd(node: any): any;
                    /**
                    Compare this fragment to another one.
                    */
                    eq(other: any): boolean;
                    /**
                    The first child of the fragment, or `null` if it is empty.
                    */
                    readonly firstChild: any;
                    /**
                    The last child of the fragment, or `null` if it is empty.
                    */
                    readonly lastChild: any;
                    /**
                    The number of child nodes in this fragment.
                    */
                    readonly childCount: any;
                    /**
                    Get the child node at the given index. Raise an error when the
                    index is out of range.
                    */
                    child(index: any): any;
                    /**
                    Get the child node at the given index, if it exists.
                    */
                    maybeChild(index: any): any;
                    /**
                    Call `f` for every child node, passing the node, its offset
                    into this parent node, and its index.
                    */
                    forEach(f: any): void;
                    /**
                    Find the first position at which this fragment and another
                    fragment differ, or `null` if they are the same.
                    */
                    findDiffStart(other: any, pos?: number): any;
                    /**
                    Find the first position, searching from the end, at which this
                    fragment and the given fragment differ, or `null` if they are
                    the same. Since this position will not be the same in both
                    nodes, an object with two separate positions is returned.
                    */
                    findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                    /**
                    Find the index and inner offset corresponding to a given relative
                    position in this fragment. The result object will be reused
                    (overwritten) the next time the function is called. (Not public.)
                    */
                    findIndex(pos: any, round?: number): {
                        index: number;
                        offset: number;
                    };
                    /**
                    Return a debugging string that describes this fragment.
                    */
                    toString(): string;
                    /**
                    @internal
                    */
                    toStringInner(): any;
                    /**
                    Create a JSON-serializeable representation of this fragment.
                    */
                    toJSON(): any;
                }, start?: number, end?: any): boolean;
                /**
                Test whether replacing the range `from` to `to` (by index) with
                a node of the given type would leave the node's content valid.
                */
                canReplaceWith(from: any, to: any, type: any, marks: any): any;
                /**
                Test whether the given node's content could be appended to this
                node. If that node is empty, this will only return true if there
                is at least one node type that can appear in both nodes (to avoid
                merging completely incompatible nodes).
                */
                canAppend(other: any): any;
                /**
                Check whether this node and its descendants conform to the
                schema, and raise error when they do not.
                */
                check(): void;
                /**
                Return a JSON-serializeable representation of this node.
                */
                toJSON(): {
                    type: any;
                };
                text: any;
            };
            /**
            Cut out the part of the document between the given positions, and
            return it as a `Slice` object.
            */
            slice(from: any, to?: any, includeParents?: boolean): {
                content: any;
                openStart: any;
                openEnd: any;
                /**
                The size this slice would add when inserted into a document.
                */
                readonly size: number;
                /**
                @internal
                */
                insertAt(pos: any, fragment: any): any;
                /**
                @internal
                */
                removeBetween(from: any, to: any): any;
                /**
                Tests whether this slice is equal to another slice.
                */
                eq(other: any): boolean;
                /**
                @internal
                */
                toString(): string;
                /**
                Convert a slice to a JSON-serializable representation.
                */
                toJSON(): {
                    content: any;
                };
            };
            /**
            Replace the part of the document between the given positions with
            the given slice. The slice must 'fit', meaning its open sides
            must be able to connect to the surrounding content, and its
            content nodes must be valid children for the node they are placed
            into. If any of this is violated, an error of type
            [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
            */
            replace(from: any, to: any, slice: any): any;
            /**
            Find the node directly after the given position.
            */
            nodeAt(pos: any): any;
            /**
            Find the (direct) child node after the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childAfter(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Find the (direct) child node before the given offset, if any,
            and return it along with its index and offset relative to this
            node.
            */
            childBefore(pos: any): {
                node: any;
                index: any;
                offset: any;
            };
            /**
            Resolve the given position in the document, returning an
            [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
            */
            resolve(pos: any): any;
            /**
            @internal
            */
            resolveNoCache(pos: any): {
                pos: any;
                path: any;
                parentOffset: any;
                depth: number;
                /**
                @internal
                */
                resolveDepth(val: any): any;
                /**
                The parent node that the position points into. Note that even if
                a position points into a text node, that node is not considered
                the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
                */
                readonly parent: any;
                /**
                The root node in which the position was resolved.
                */
                readonly doc: any;
                /**
                The ancestor node at the given level. `p.node(p.depth)` is the
                same as `p.parent`.
                */
                node(depth: any): any;
                /**
                The index into the ancestor at the given level. If this points
                at the 3rd node in the 2nd paragraph on the top level, for
                example, `p.index(0)` is 1 and `p.index(1)` is 2.
                */
                index(depth: any): any;
                /**
                The index pointing after this position into the ancestor at the
                given level.
                */
                indexAfter(depth: any): any;
                /**
                The (absolute) position at the start of the node at the given
                level.
                */
                start(depth: any): any;
                /**
                The (absolute) position at the end of the node at the given
                level.
                */
                end(depth: any): any;
                /**
                The (absolute) position directly before the wrapping node at the
                given level, or, when `depth` is `this.depth + 1`, the original
                position.
                */
                before(depth: any): any;
                /**
                The (absolute) position directly after the wrapping node at the
                given level, or the original position when `depth` is `this.depth + 1`.
                */
                after(depth: any): any;
                /**
                When this position points into a text node, this returns the
                distance between the position and the start of the text node.
                Will be zero for positions that point between nodes.
                */
                readonly textOffset: number;
                /**
                Get the node directly after the position, if any. If the position
                points into a text node, only the part of that node after the
                position is returned.
                */
                readonly nodeAfter: any;
                /**
                Get the node directly before the position, if any. If the
                position points into a text node, only the part of that node
                before the position is returned.
                */
                readonly nodeBefore: any;
                /**
                Get the position at the given index in the parent node at the
                given depth (which defaults to `this.depth`).
                */
                posAtIndex(index: any, depth: any): any;
                /**
                Get the marks at this position, factoring in the surrounding
                marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
                position is at the start of a non-empty node, the marks of the
                node after it (if any) are returned.
                */
                marks(): any;
                /**
                Get the marks after the current position, if any, except those
                that are non-inclusive and not present at position `$end`. This
                is mostly useful for getting the set of marks to preserve after a
                deletion. Will return `null` if this position is at the end of
                its parent node or its parent node isn't a textblock (in which
                case no marks should be preserved).
                */
                marksAcross($end: any): any;
                /**
                The depth up to which this position and the given (non-resolved)
                position share the same parent nodes.
                */
                sharedDepth(pos: any): number;
                /**
                Returns a range based on the place where this position and the
                given position diverge around block content. If both point into
                the same textblock, for example, a range around that textblock
                will be returned. If they point into different blocks, the range
                around those blocks in their shared ancestor is returned. You can
                pass in an optional predicate that will be called with a parent
                node to see if a range into that parent is acceptable.
                */
                blockRange(other: any, pred: any): any;
                /**
                Query whether the given position shares the same parent node.
                */
                sameParent(other: any): boolean;
                /**
                Return the greater of this and the given position.
                */
                max(other: any): any;
                /**
                Return the smaller of this and the given position.
                */
                min(other: any): any;
                /**
                @internal
                */
                toString(): string;
                /**
                 * Determine whether a given position has an ancestor node of the given type.
                 * @param {NodeType} other  The other node type.
                 * @param {object} [attrs]  An object of attributes that must also match, if provided.
                 * @returns {boolean}
                 */
                hasAncestor(other: {
                    attrs: any;
                    spec: any;
                    map(mapping: any, span: any, offset: any, oldOffset: any): {
                        from: any;
                        to: any;
                        type: any;
                        /**
                        @internal
                        */
                        copy(from: any, to: any): any;
                        /**
                        @internal
                        */
                        eq(other: any, offset?: number): boolean;
                        /**
                        @internal
                        */
                        map(mapping: any, offset: any, oldOffset: any): any;
                        /**
                        The spec provided when creating this decoration. Can be useful
                        if you've stored extra information in that object.
                        */
                        readonly spec: any;
                        /**
                        @internal
                        */
                        readonly inline: boolean;
                    };
                    valid(node: any, span: any): boolean;
                    eq(other: any): boolean;
                    destroy(): void;
                }, attrs?: object): boolean;
            };
            /**
            Test whether a given mark or mark type occurs in this document
            between the two given positions.
            */
            rangeHasMark(from: any, to: any, type: any): boolean;
            /**
            True when this is a block (non-inline node)
            */
            readonly isBlock: any;
            /**
            True when this is a textblock node, a block node with inline
            content.
            */
            readonly isTextblock: any;
            /**
            True when this node allows inline content.
            */
            readonly inlineContent: any;
            /**
            True when this is an inline node (a text node or a node that can
            appear among text).
            */
            readonly isInline: any;
            /**
            True when this is a text node.
            */
            readonly isText: any;
            /**
            True when this is a leaf node.
            */
            readonly isLeaf: any;
            /**
            True when this is an atom, i.e. when it does not have directly
            editable content. This is usually the same as `isLeaf`, but can
            be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
            on a node's spec (typically used when the node is displayed as
            an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
            */
            readonly isAtom: any;
            /**
            Get the content match in this node at the given index.
            */
            contentMatchAt(index: any): any;
            /**
            Test whether replacing the range between `from` and `to` (by
            child index) with the given replacement fragment (which defaults
            to the empty fragment) would leave the node's content valid. You
            can optionally pass `start` and `end` indices into the
            replacement fragment.
            */
            canReplace(from: any, to: any, replacement?: {
                content: any;
                size: any;
                /**
                Invoke a callback for all descendant nodes between the given two
                positions (relative to start of this fragment). Doesn't descend
                into a node when the callback returns `false`.
                */
                nodesBetween(from: any, to: any, f: any, nodeStart: number, parent: any): void;
                /**
                Call the given callback for every descendant node. `pos` will be
                relative to the start of the fragment. The callback may return
                `false` to prevent traversal of a given node's children.
                */
                descendants(f: any): void;
                /**
                Extract the text between `from` and `to`. See the same method on
                [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
                */
                textBetween(from: any, to: any, blockSeparator: any, leafText: any): string;
                /**
                Create a new fragment containing the combined content of this
                fragment and the other.
                */
                append(other: any): any;
                /**
                Cut out the sub-fragment between the two given positions.
                */
                cut(from: any, to?: any): any;
                /**
                @internal
                */
                cutByIndex(from: any, to: any): any;
                /**
                Create a new fragment in which the node at the given index is
                replaced by the given node.
                */
                replaceChild(index: any, node: any): any;
                /**
                Create a new fragment by prepending the given node to this
                fragment.
                */
                addToStart(node: any): any;
                /**
                Create a new fragment by appending the given node to this
                fragment.
                */
                addToEnd(node: any): any;
                /**
                Compare this fragment to another one.
                */
                eq(other: any): boolean;
                /**
                The first child of the fragment, or `null` if it is empty.
                */
                readonly firstChild: any;
                /**
                The last child of the fragment, or `null` if it is empty.
                */
                readonly lastChild: any;
                /**
                The number of child nodes in this fragment.
                */
                readonly childCount: any;
                /**
                Get the child node at the given index. Raise an error when the
                index is out of range.
                */
                child(index: any): any;
                /**
                Get the child node at the given index, if it exists.
                */
                maybeChild(index: any): any;
                /**
                Call `f` for every child node, passing the node, its offset
                into this parent node, and its index.
                */
                forEach(f: any): void;
                /**
                Find the first position at which this fragment and another
                fragment differ, or `null` if they are the same.
                */
                findDiffStart(other: any, pos?: number): any;
                /**
                Find the first position, searching from the end, at which this
                fragment and the given fragment differ, or `null` if they are
                the same. Since this position will not be the same in both
                nodes, an object with two separate positions is returned.
                */
                findDiffEnd(other: any, pos?: any, otherPos?: any): any;
                /**
                Find the index and inner offset corresponding to a given relative
                position in this fragment. The result object will be reused
                (overwritten) the next time the function is called. (Not public.)
                */
                findIndex(pos: any, round?: number): {
                    index: number;
                    offset: number;
                };
                /**
                Return a debugging string that describes this fragment.
                */
                toString(): string;
                /**
                @internal
                */
                toStringInner(): any;
                /**
                Create a JSON-serializeable representation of this fragment.
                */
                toJSON(): any;
            }, start?: number, end?: any): boolean;
            /**
            Test whether replacing the range `from` to `to` (by index) with
            a node of the given type would leave the node's content valid.
            */
            canReplaceWith(from: any, to: any, type: any, marks: any): any;
            /**
            Test whether the given node's content could be appended to this
            node. If that node is empty, this will only return true if there
            is at least one node type that can appear in both nodes (to avoid
            merging completely incompatible nodes).
            */
            canAppend(other: any): any;
            /**
            Check whether this node and its descendants conform to the
            schema, and raise error when they do not.
            */
            check(): void;
        };
        /**
        Create a mark with the given type and attributes.
        */
        mark(type: any, attrs: any): any;
        /**
        @internal
        */
        nodeType(name: any): any;
    };
    spaces?: string | number;
}): string;
export { index as collab, index$3 as commands, schema as defaultSchema, index$4 as input, index$2 as list, index$5 as state, index$1 as tables, index$6 as transform };
